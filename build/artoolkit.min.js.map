{"version":3,"sources":["/Users/ryo/src/jsartoolkit5/emscripten/artoolkit5/lib/SRC/AR/arLabelingSub/arLabelingSub.h","/Users/ryo/src/emsdk/emscripten/1.37.22/system/include/libcxx/ios","/Users/ryo/src/jsartoolkit5/emscripten/artoolkit5/lib/SRC/KPM/FreakMatcher/detectors/interpolate.h","/Users/ryo/src/emsdk/emscripten/1.37.22/system/include/libcxx/ostream","/Users/ryo/src/emsdk/emscripten/1.37.22/system/include/libcxx/__locale","/Users/ryo/src/emsdk/emscripten/1.37.22/system/include/libcxx/vector","/Users/ryo/src/emsdk/emscripten/1.37.22/system/include/libcxx/algorithm","/Users/ryo/src/emsdk/emscripten/1.37.22/system/include/libcxx/memory","/Users/ryo/src/emsdk/emscripten/1.37.22/system/include/libcxx/__split_buffer","/Users/ryo/src/jsartoolkit5/emscripten/artoolkit5/lib/SRC/KPM/FreakMatcher/detectors/DoG_scale_invariant_detector.h","/Users/ryo/src/emsdk/emscripten/1.37.22/system/include/libcxx/math.h","/Users/ryo/src/jsartoolkit5/emscripten/artoolkit5/lib/SRC/KPM/FreakMatcher/math/math_utils.h","/Users/ryo/src/jsartoolkit5/emscripten/artoolkit5/lib/SRC/KPM/FreakMatcher/detectors/gaussian_scale_space_pyramid.cpp","/Users/ryo/src/jsartoolkit5/emscripten/artoolkit5/lib/SRC/KPM/FreakMatcher/detectors/gaussian_scale_space_pyramid.h","/Users/ryo/src/emsdk/emscripten/1.37.22/system/include/libcxx/stdexcept","/Users/ryo/src/emsdk/emscripten/1.37.22/system/include/libcxx/type_traits","/Users/ryo/src/emsdk/emscripten/1.37.22/system/include/libcxx/iterator","/Users/ryo/src/emsdk/emscripten/1.37.22/system/include/libcxx/utility","/Users/ryo/src/jsartoolkit5/emscripten/artoolkit5/lib/SRC/KPM/FreakMatcher/math/linear_algebra.h","/Users/ryo/src/jsartoolkit5/emscripten/artoolkit5/lib/SRC/KPM/FreakMatcher/math/matrix.h","/Users/ryo/src/jsartoolkit5/emscripten/artoolkit5/lib/SRC/AR/arPattGetID.c","/Users/ryo/src/jsartoolkit5/emscripten/artoolkit5/lib/SRC/AR/ar3DCreateHandle.c","/Users/ryo/src/jsartoolkit5/emscripten/artoolkit5/lib/SRC/AR/arCreateHandle.c","/Users/ryo/src/jsartoolkit5/emscripten/artoolkit5/lib/SRC/AR/arDetectMarker2.c","/Users/ryo/src/jsartoolkit5/emscripten/artoolkit5/lib/SRC/AR/arGetLine.c","/Users/ryo/src/jsartoolkit5/emscripten/artoolkit5/lib/SRC/AR/arGetMarkerInfo.c","/Users/ryo/src/jsartoolkit5/emscripten/artoolkit5/lib/SRC/AR/arGetTransMat.c","/Users/ryo/src/emsdk/emscripten/1.37.22/system/include/libcxx/new","/Users/ryo/src/jsartoolkit5/emscripten/artoolkit5/lib/SRC/KPM/FreakMatcher/matchers/kmedoids.h","/Users/ryo/src/jsartoolkit5/emscripten/artoolkit5/lib/SRC/KPM/FreakMatcher/matchers/feature_point.h","/Users/ryo/src/jsartoolkit5/emscripten/artoolkit5/lib/SRC/KPM/FreakMatcher/matchers/keyframe.h","/Users/ryo/src/jsartoolkit5/emscripten/artoolkit5/lib/SRC/ARMulti/arMultiGetTransMat.c","/Users/ryo/src/jsartoolkit5/emscripten/artoolkit5/lib/SRC/ARMulti/arMultiReadConfigFile.c","/Users/ryo/src/jsartoolkit5/emscripten/artoolkit5/lib/SRC/AR/arUtil.c","/Users/ryo/src/jsartoolkit5/emscripten/artoolkit5/lib/SRC/AR/mAlloc.c","/Users/ryo/src/jsartoolkit5/emscripten/artoolkit5/lib/SRC/AR/mAllocDup.c","/Users/ryo/src/jsartoolkit5/emscripten/artoolkit5/lib/SRC/AR/mAllocMul.c","/Users/ryo/src/jsartoolkit5/emscripten/artoolkit5/lib/SRC/AR/mAllocTrans.c","/Users/ryo/src/jsartoolkit5/emscripten/artoolkit5/lib/SRC/AR/mDup.c","/Users/ryo/src/jsartoolkit5/emscripten/artoolkit5/lib/SRC/AR/mFree.c","/Users/ryo/src/jsartoolkit5/emscripten/artoolkit5/lib/SRC/AR/mMul.c","/Users/ryo/src/jsartoolkit5/emscripten/artoolkit5/lib/SRC/AR/mPCA.c","/Users/ryo/src/jsartoolkit5/emscripten/artoolkit5/lib/SRC/KPM/FreakMatcher/detectors/orientation_assignment.cpp","/Users/ryo/src/jsartoolkit5/emscripten/artoolkit5/lib/SRC/KPM/FreakMatcher/math/indexing.h","/Users/ryo/src/jsartoolkit5/emscripten/artoolkit5/lib/SRC/KPM/FreakMatcher/detectors/orientation_assignment.h","/Users/ryo/src/jsartoolkit5/emscripten/artoolkit5/lib/SRC/KPM/FreakMatcher/matchers/visual_database.h","/Users/ryo/src/jsartoolkit5/emscripten/artoolkit5/lib/SRC/KPM/FreakMatcher/matchers/visual_database-inline.h","/Users/ryo/src/jsartoolkit5/emscripten/artoolkit5/lib/SRC/KPM/FreakMatcher/matchers/feature_matcher-inline.h","/Users/ryo/src/jsartoolkit5/emscripten/artoolkit5/lib/SRC/KPM/FreakMatcher/homography_estimation/robust_homography.h","/Users/ryo/src/jsartoolkit5/emscripten/artoolkit5/lib/SRC/KPM/FreakMatcher/detectors/DoG_scale_invariant_detector.cpp","/Users/ryo/src/jsartoolkit5/emscripten/artoolkit5/lib/SRC/ARICP/icpUtil.c","/Users/ryo/src/jsartoolkit5/emscripten/artoolkit5/lib/SRC/ARMulti/arMultiFreeConfig.c","/Users/ryo/src/jsartoolkit5/emscripten/artoolkit5/lib/SRC/KPM/kpmMatching.cpp","/Users/ryo/src/jsartoolkit5/emscripten/artoolkit5/lib/SRC/KPM/kpmUtil.cpp","/Users/ryo/src/jsartoolkit5/emscripten/artoolkit5/lib/SRC/KPM/kpmFopen.c","/Users/ryo/src/emsdk/emscripten/1.37.22/system/include/libcxx/__string","/Users/ryo/src/jsartoolkit5/emscripten/artoolkit5/lib/SRC/KPM/FreakMatcher/framework/exception.h","/Users/ryo/src/emsdk/emscripten/1.37.22/system/include/libcxx/string","/Users/ryo/src/jsartoolkit5/emscripten/artoolkit5/lib/SRC/KPM/FreakMatcher/detectors/gradients.cpp","/Users/ryo/src/jsartoolkit5/emscripten/artoolkit5/lib/SRC/AR/arImageProc.c","/Users/ryo/src/jsartoolkit5/emscripten/artoolkit5/lib/SRC/AR/arLabeling.c","/Users/ryo/src/jsartoolkit5/emscripten/artoolkit5/lib/SRC/AR2/marker.c","/Users/ryo/src/jsartoolkit5/emscripten/artoolkit5/lib/SRC/AR2/featureSet.c","/Users/ryo/src/jsartoolkit5/emscripten/artoolkit5/lib/SRC/Gl/gsub_lite.c","/Users/ryo/src/jsartoolkit5/emscripten/artoolkit5/lib/SRC/AR2/imageSet.c","/Users/ryo/src/jsartoolkit5/emscripten/artoolkit5/lib/SRC/AR2/jpeg.c","/Users/ryo/src/jsartoolkit5/emscripten/artoolkit5/lib/SRC/AR/paramDecomp.c","/Users/ryo/src/jsartoolkit5/emscripten/artoolkit5/lib/SRC/AR/paramDistortion.c","/Users/ryo/src/jsartoolkit5/emscripten/artoolkit5/lib/SRC/AR/mTrans.c","/Users/ryo/src/jsartoolkit5/emscripten/artoolkit5/lib/SRC/AR/paramChangeSize.c","/Users/ryo/src/jsartoolkit5/emscripten/artoolkit5/lib/SRC/AR2/surface.c","/Users/ryo/src/jsartoolkit5/emscripten/artoolkit5/lib/SRC/AR/paramFile.c","/Users/ryo/src/jsartoolkit5/emscripten/artoolkit5/lib/SRC/AR/paramLT.c","/Users/ryo/src/emsdk/emscripten/1.37.22/system/include/libcxx/locale","/Users/ryo/src/emsdk/emscripten/1.37.22/system/include/libcxx/streambuf","/Users/ryo/src/jsartoolkit5/emscripten/artoolkit5/lib/SRC/ARICP/icpPoint.c","/Users/ryo/src/jsartoolkit5/emscripten/artoolkit5/lib/SRC/ARICP/icpPointRobust.c","/Users/ryo/src/jsartoolkit5/emscripten/artoolkit5/lib/SRC/KPM/kpmRefDataSet.cpp","/Users/ryo/src/jsartoolkit5/emscripten/artoolkit5/lib/SRC/AR2/util.c","/Users/ryo/src/jsartoolkit5/emscripten/artoolkit5/lib/SRC/KPM/kpmHandle.cpp","/Users/ryo/src/jsartoolkit5/emscripten/artoolkit5/lib/SRC/ARICP/icpCore.c","/Users/ryo/src/jsartoolkit5/emscripten/artoolkit5/lib/SRC/ARICP/icpHandle.c","/Users/ryo/src/jsartoolkit5/emscripten/artoolkit5/lib/SRC/AR/vAlloc.c","/Users/ryo/src/jsartoolkit5/emscripten/artoolkit5/lib/SRC/AR/vFree.c","/Users/ryo/src/jsartoolkit5/emscripten/artoolkit5/lib/SRC/AR/vHouse.c","/Users/ryo/src/jsartoolkit5/emscripten/artoolkit5/lib/SRC/AR/vInnerP.c","/Users/ryo/src/jsartoolkit5/emscripten/artoolkit5/lib/SRC/AR/vTridiag.c","/Users/ryo/src/jsartoolkit5/emscripten/artoolkit5/lib/SRC/KPM/FreakMatcher/utils/point.h","/Users/ryo/src/jsartoolkit5/emscripten/artoolkit5/lib/SRC/AR/arDetectMarker.c","/Users/ryo/src/jsartoolkit5/emscripten/artoolkit5/lib/SRC/KPM/FreakMatcher/facade/visual_database_facade.cpp","/Users/ryo/src/jsartoolkit5/emscripten/artoolkit5/lib/SRC/KPM/FreakMatcher/framework/image.h","/Users/ryo/src/emsdk/emscripten/1.37.22/system/include/libcxx/__hash_table","/Users/ryo/src/emsdk/emscripten/1.37.22/system/include/libcxx/functional","/Users/ryo/src/jsartoolkit5/emscripten/artoolkit5/lib/SRC/KPM/FreakMatcher/math/polynomial.h","/Users/ryo/src/jsartoolkit5/emscripten/artoolkit5/lib/SRC/KPM/FreakMatcher/matchers/binary_hierarchical_clustering.h","/Users/ryo/src/emsdk/emscripten/1.37.22/system/include/libcxx/unordered_map","/Users/ryo/src/jsartoolkit5/emscripten/artoolkit5/lib/SRC/KPM/kpmResult.cpp","/Users/ryo/src/jsartoolkit5/emscripten/artoolkit5/lib/SRC/KPM/FreakMatcher/framework/logger.h","/Users/ryo/src/jsartoolkit5/emscripten/artoolkit5/lib/SRC/AR/arPattLoad.c","/Users/ryo/src/jsartoolkit5/emscripten/artoolkit5/lib/SRC/AR/arPattCreateHandle.c","/Users/ryo/src/jsartoolkit5/emscripten/artoolkit5/lib/SRC/AR/mSelfInv.c","/Users/ryo/src/jsartoolkit5/emscripten/artoolkit5/lib/SRC/KPM/FreakMatcher/framework/timers.h","/Users/ryo/src/jsartoolkit5/emscripten/artoolkit5/lib/SRC/AR/arPattAttach.c","/Users/ryo/src/jsartoolkit5/emscripten/artoolkit5/lib/SRC/KPM/FreakMatcher/matchers/feature_store.h","/Users/ryo/src/jsartoolkit5/emscripten/artoolkit5/lib/SRC/KPM/FreakMatcher/math/rand.h","/Users/ryo/src/jsartoolkit5/emscripten/artoolkit5/lib/SRC/KPM/FreakMatcher/math/hamming.h","/Users/ryo/src/emsdk/emscripten/1.37.22/system/include/libcxx/queue","/Users/ryo/src/emsdk/emscripten/1.37.22/system/include/libcxx/typeinfo"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;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","file":"/Users/ryo/src/jsartoolkit5/build/artoolkit.min.js","sourcesContent":["/*\n *  arLabeling.c\n *  ARToolKit5\n *\n *  This file is part of ARToolKit.\n *\n *  ARToolKit is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation, either version 3 of the License, or\n *  (at your option) any later version.\n *\n *  ARToolKit is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public License\n *  along with ARToolKit.  If not, see <http://www.gnu.org/licenses/>.\n *\n *  As a special exception, the copyright holders of this library give you\n *  permission to link this library with independent modules to produce an\n *  executable, regardless of the license terms of these independent modules, and to\n *  copy and distribute the resulting executable under terms of your choice,\n *  provided that you also meet, for each linked independent module, the terms and\n *  conditions of the license of that module. An independent module is a module\n *  which is neither derived from nor based on this library. If you modify this\n *  library, you may extend this exception to your version of the library, but you\n *  are not obligated to do so. If you do not wish to do so, delete this exception\n *  statement from your version.\n *\n *  Copyright 2015 Daqri, LLC.\n *  Copyright 2003-2015 ARToolworks, Inc.\n *\n *  Author(s): Hirokazu Kato, Philip Lamb\n *\n */\n/*******************************************************\n *\n * Author: Hirokazu Kato\n *\n *         kato@sys.im.hiroshima-cu.ac.jp\n *\n * Revision: 4.0\n * Date: 03/08/13\n *\n *******************************************************/\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h> // memset()\n#include <AR/ar.h>\n#include \"arLabelingPrivate.h\"\n\n#if defined(AR_PIXEL_FORMAT_CCC)\n#  define  AR_PIXEL_SIZE     3\n#elif defined(AR_PIXEL_FORMAT_CCCA) || defined(AR_PIXEL_FORMAT_ACCC)\n#  define  AR_PIXEL_SIZE     4\n#elif defined(AR_PIXEL_FORMAT_C) || defined(AR_LABELING_ADAPTIVE)\n#  define  AR_PIXEL_SIZE     1\n#elif defined(AR_PIXEL_FORMAT_YC) || defined(AR_PIXEL_FORMAT_CY) || defined(AR_PIXEL_FORMAT_CCC_565) || defined(AR_PIXEL_FORMAT_CCCA_5551) || defined(AR_PIXEL_FORMAT_CCCA_4444)\n#  define  AR_PIXEL_SIZE     2\n#else\n#  error\n#endif\n\n#ifdef AR_PIXEL_FORMAT_CCC\n#ifndef AR_LABELING_DEBUG_ENABLE_F\n#ifndef AR_LABELING_WHITE_REGION_F\n#ifndef AR_LABELING_FRAME_IMAGE_F\nint arLabelingSubDBI3C( ARUint8 *image, int xsize, int ysize, int labelingThresh, ARLabelInfo *labelInfo )\n#else\nint arLabelingSubDBR3C( ARUint8 *image, int xsize, int ysize, int labelingThresh, ARLabelInfo *labelInfo )\n#endif // !AR_LABELING_FRAME_IMAGE_F\n#else\n#ifndef AR_LABELING_FRAME_IMAGE_F\nint arLabelingSubDWI3C( ARUint8 *image, int xsize, int ysize, int labelingThresh, ARLabelInfo *labelInfo )\n#else\nint arLabelingSubDWR3C( ARUint8 *image, int xsize, int ysize, int labelingThresh, ARLabelInfo *labelInfo )\n#endif // !AR_LABELING_FRAME_IMAGE_F\n#endif // !AR_LABELING_WHITE_REGION_F\n#else\n#ifndef AR_LABELING_WHITE_REGION_F\n#ifndef AR_LABELING_FRAME_IMAGE_F\nint arLabelingSubEBI3C( ARUint8 *image, int xsize, int ysize, int labelingThresh, ARLabelInfo *labelInfo )\n#else\nint arLabelingSubEBR3C( ARUint8 *image, int xsize, int ysize, int labelingThresh, ARLabelInfo *labelInfo )\n#endif // !AR_LABELING_FRAME_IMAGE_F\n#else\n#ifndef AR_LABELING_FRAME_IMAGE_F\nint arLabelingSubEWI3C( ARUint8 *image, int xsize, int ysize, int labelingThresh, ARLabelInfo *labelInfo )\n#else\nint arLabelingSubEWR3C( ARUint8 *image, int xsize, int ysize, int labelingThresh, ARLabelInfo *labelInfo )\n#endif // !AR_LABELING_FRAME_IMAGE_F\n#endif // !AR_LABELING_WHITE_REGION_F\n#endif // !AR_LABELING_DEBUG_ENABLE_F\n#endif\n\n#ifdef AR_PIXEL_FORMAT_CCCA\n#ifndef AR_LABELING_DEBUG_ENABLE_F\n#ifndef AR_LABELING_WHITE_REGION_F\n#ifndef AR_LABELING_FRAME_IMAGE_F\nint arLabelingSubDBI3CA( ARUint8 *image, int xsize, int ysize, int labelingThresh, ARLabelInfo *labelInfo )\n#else\nint arLabelingSubDBR3CA( ARUint8 *image, int xsize, int ysize, int labelingThresh, ARLabelInfo *labelInfo )\n#endif // !AR_LABELING_FRAME_IMAGE_F\n#else\n#ifndef AR_LABELING_FRAME_IMAGE_F\nint arLabelingSubDWI3CA( ARUint8 *image, int xsize, int ysize, int labelingThresh, ARLabelInfo *labelInfo )\n#else\nint arLabelingSubDWR3CA( ARUint8 *image, int xsize, int ysize, int labelingThresh, ARLabelInfo *labelInfo )\n#endif // !AR_LABELING_FRAME_IMAGE_F\n#endif // !AR_LABELING_WHITE_REGION_F\n#else\n#ifndef AR_LABELING_WHITE_REGION_F\n#ifndef AR_LABELING_FRAME_IMAGE_F\nint arLabelingSubEBI3CA( ARUint8 *image, int xsize, int ysize, int labelingThresh, ARLabelInfo *labelInfo )\n#else\nint arLabelingSubEBR3CA( ARUint8 *image, int xsize, int ysize, int labelingThresh, ARLabelInfo *labelInfo )\n#endif // !AR_LABELING_FRAME_IMAGE_F\n#else\n#ifndef AR_LABELING_FRAME_IMAGE_F\nint arLabelingSubEWI3CA( ARUint8 *image, int xsize, int ysize, int labelingThresh, ARLabelInfo *labelInfo )\n#else\nint arLabelingSubEWR3CA( ARUint8 *image, int xsize, int ysize, int labelingThresh, ARLabelInfo *labelInfo )\n#endif // !AR_LABELING_FRAME_IMAGE_F\n#endif // !AR_LABELING_WHITE_REGION_F\n#endif // !AR_LABELING_DEBUG_ENABLE_F\n#endif\n\n#ifdef AR_PIXEL_FORMAT_ACCC\n#ifndef AR_LABELING_DEBUG_ENABLE_F\n#ifndef AR_LABELING_WHITE_REGION_F\n#ifndef AR_LABELING_FRAME_IMAGE_F\nint arLabelingSubDBIA3C( ARUint8 *image, int xsize, int ysize, int labelingThresh, ARLabelInfo *labelInfo )\n#else\nint arLabelingSubDBRA3C( ARUint8 *image, int xsize, int ysize, int labelingThresh, ARLabelInfo *labelInfo )\n#endif // !AR_LABELING_FRAME_IMAGE_F\n#else\n#ifndef AR_LABELING_FRAME_IMAGE_F\nint arLabelingSubDWIA3C( ARUint8 *image, int xsize, int ysize, int labelingThresh, ARLabelInfo *labelInfo )\n#else\nint arLabelingSubDWRA3C( ARUint8 *image, int xsize, int ysize, int labelingThresh, ARLabelInfo *labelInfo )\n#endif // !AR_LABELING_FRAME_IMAGE_F\n#endif // !AR_LABELING_WHITE_REGION_F\n#else\n#ifndef AR_LABELING_WHITE_REGION_F\n#ifndef AR_LABELING_FRAME_IMAGE_F\nint arLabelingSubEBIA3C( ARUint8 *image, int xsize, int ysize, int labelingThresh, ARLabelInfo *labelInfo )\n#else\nint arLabelingSubEBRA3C( ARUint8 *image, int xsize, int ysize, int labelingThresh, ARLabelInfo *labelInfo )\n#endif // !AR_LABELING_FRAME_IMAGE_F\n#else\n#ifndef AR_LABELING_FRAME_IMAGE_F\nint arLabelingSubEWIA3C( ARUint8 *image, int xsize, int ysize, int labelingThresh, ARLabelInfo *labelInfo )\n#else\nint arLabelingSubEWRA3C( ARUint8 *image, int xsize, int ysize, int labelingThresh, ARLabelInfo *labelInfo )\n#endif // !AR_LABELING_FRAME_IMAGE_F\n#endif // !AR_LABELING_WHITE_REGION_F\n#endif // !AR_LABELING_DEBUG_ENABLE_F\n#endif\n\n#ifdef AR_PIXEL_FORMAT_C\n#ifndef AR_LABELING_DEBUG_ENABLE_F\n#ifndef AR_LABELING_WHITE_REGION_F\n#ifndef AR_LABELING_FRAME_IMAGE_F\nint arLabelingSubDBIC( ARUint8 *image, int xsize, int ysize, int labelingThresh, ARLabelInfo *labelInfo )\n#else\nint arLabelingSubDBRC( ARUint8 *image, int xsize, int ysize, int labelingThresh, ARLabelInfo *labelInfo )\n#endif // !AR_LABELING_FRAME_IMAGE_F\n#else\n#ifndef AR_LABELING_FRAME_IMAGE_F\nint arLabelingSubDWIC( ARUint8 *image, int xsize, int ysize, int labelingThresh, ARLabelInfo *labelInfo )\n#else\nint arLabelingSubDWRC( ARUint8 *image, int xsize, int ysize, int labelingThresh, ARLabelInfo *labelInfo )\n#endif // !AR_LABELING_FRAME_IMAGE_F\n#endif // !AR_LABELING_WHITE_REGION_F\n#else\n#ifndef AR_LABELING_WHITE_REGION_F\n#ifndef AR_LABELING_FRAME_IMAGE_F\nint arLabelingSubEBIC( ARUint8 *image, int xsize, int ysize, int labelingThresh, ARLabelInfo *labelInfo )\n#else\nint arLabelingSubEBRC( ARUint8 *image, int xsize, int ysize, int labelingThresh, ARLabelInfo *labelInfo )\n#endif // !AR_LABELING_FRAME_IMAGE_F\n#else\n#ifndef AR_LABELING_FRAME_IMAGE_F\nint arLabelingSubEWIC( ARUint8 *image, int xsize, int ysize, int labelingThresh, ARLabelInfo *labelInfo )\n#else\nint arLabelingSubEWRC( ARUint8 *image, int xsize, int ysize, int labelingThresh, ARLabelInfo *labelInfo )\n#endif // !AR_LABELING_FRAME_IMAGE_F\n#endif // !AR_LABELING_WHITE_REGION_F\n#endif // !AR_LABELING_DEBUG_ENABLE_F\n#endif\n\n#ifdef AR_PIXEL_FORMAT_YC\n#ifndef AR_LABELING_DEBUG_ENABLE_F\n#ifndef AR_LABELING_WHITE_REGION_F\n#ifndef AR_LABELING_FRAME_IMAGE_F\nint arLabelingSubDBIYC( ARUint8 *image, int xsize, int ysize, int labelingThresh, ARLabelInfo *labelInfo )\n#else\nint arLabelingSubDBRYC( ARUint8 *image, int xsize, int ysize, int labelingThresh, ARLabelInfo *labelInfo )\n#endif // !AR_LABELING_FRAME_IMAGE_F\n#else\n#ifndef AR_LABELING_FRAME_IMAGE_F\nint arLabelingSubDWIYC( ARUint8 *image, int xsize, int ysize, int labelingThresh, ARLabelInfo *labelInfo )\n#else\nint arLabelingSubDWRYC( ARUint8 *image, int xsize, int ysize, int labelingThresh, ARLabelInfo *labelInfo )\n#endif // !AR_LABELING_FRAME_IMAGE_F\n#endif // !AR_LABELING_WHITE_REGION_F\n#else\n#ifndef AR_LABELING_WHITE_REGION_F\n#ifndef AR_LABELING_FRAME_IMAGE_F\nint arLabelingSubEBIYC( ARUint8 *image, int xsize, int ysize, int labelingThresh, ARLabelInfo *labelInfo )\n#else\nint arLabelingSubEBRYC( ARUint8 *image, int xsize, int ysize, int labelingThresh, ARLabelInfo *labelInfo )\n#endif // !AR_LABELING_FRAME_IMAGE_F\n#else\n#ifndef AR_LABELING_FRAME_IMAGE_F\nint arLabelingSubEWIYC( ARUint8 *image, int xsize, int ysize, int labelingThresh, ARLabelInfo *labelInfo )\n#else\nint arLabelingSubEWRYC( ARUint8 *image, int xsize, int ysize, int labelingThresh, ARLabelInfo *labelInfo )\n#endif // !AR_LABELING_FRAME_IMAGE_F\n#endif // !AR_LABELING_WHITE_REGION_F\n#endif // !AR_LABELING_DEBUG_ENABLE_F\n#endif\n\n#ifdef AR_PIXEL_FORMAT_CY\n#ifndef AR_LABELING_DEBUG_ENABLE_F\n#ifndef AR_LABELING_WHITE_REGION_F\n#ifndef AR_LABELING_FRAME_IMAGE_F\nint arLabelingSubDBICY( ARUint8 *image, int xsize, int ysize, int labelingThresh, ARLabelInfo *labelInfo )\n#else\nint arLabelingSubDBRCY( ARUint8 *image, int xsize, int ysize, int labelingThresh, ARLabelInfo *labelInfo )\n#endif // !AR_LABELING_FRAME_IMAGE_F\n#else\n#ifndef AR_LABELING_FRAME_IMAGE_F\nint arLabelingSubDWICY( ARUint8 *image, int xsize, int ysize, int labelingThresh, ARLabelInfo *labelInfo )\n#else\nint arLabelingSubDWRCY( ARUint8 *image, int xsize, int ysize, int labelingThresh, ARLabelInfo *labelInfo )\n#endif // !AR_LABELING_FRAME_IMAGE_F\n#endif // !AR_LABELING_WHITE_REGION_F\n#else\n#ifndef AR_LABELING_WHITE_REGION_F\n#ifndef AR_LABELING_FRAME_IMAGE_F\nint arLabelingSubEBICY( ARUint8 *image, int xsize, int ysize, int labelingThresh, ARLabelInfo *labelInfo )\n#else\nint arLabelingSubEBRCY( ARUint8 *image, int xsize, int ysize, int labelingThresh, ARLabelInfo *labelInfo )\n#endif // !AR_LABELING_FRAME_IMAGE_F\n#else\n#ifndef AR_LABELING_FRAME_IMAGE_F\nint arLabelingSubEWICY( ARUint8 *image, int xsize, int ysize, int labelingThresh, ARLabelInfo *labelInfo )\n#else\nint arLabelingSubEWRCY( ARUint8 *image, int xsize, int ysize, int labelingThresh, ARLabelInfo *labelInfo )\n#endif // !AR_LABELING_FRAME_IMAGE_F\n#endif // !AR_LABELING_WHITE_REGION_F\n#endif // !AR_LABELING_DEBUG_ENABLE_F\n#endif\n\n#ifdef AR_PIXEL_FORMAT_CCC_565\n#ifndef AR_LABELING_DEBUG_ENABLE_F\n#ifndef AR_LABELING_WHITE_REGION_F\n#ifndef AR_LABELING_FRAME_IMAGE_F\nint arLabelingSubDBI3C565( ARUint8 *image, int xsize, int ysize, int labelingThresh, ARLabelInfo *labelInfo )\n#else\nint arLabelingSubDBR3C565( ARUint8 *image, int xsize, int ysize, int labelingThresh, ARLabelInfo *labelInfo )\n#endif // !AR_LABELING_FRAME_IMAGE_F\n#else\n#ifndef AR_LABELING_FRAME_IMAGE_F\nint arLabelingSubDWI3C565( ARUint8 *image, int xsize, int ysize, int labelingThresh, ARLabelInfo *labelInfo )\n#else\nint arLabelingSubDWR3C565( ARUint8 *image, int xsize, int ysize, int labelingThresh, ARLabelInfo *labelInfo )\n#endif // !AR_LABELING_FRAME_IMAGE_F\n#endif // !AR_LABELING_WHITE_REGION_F\n#else\n#ifndef AR_LABELING_WHITE_REGION_F\n#ifndef AR_LABELING_FRAME_IMAGE_F\nint arLabelingSubEBI3C565( ARUint8 *image, int xsize, int ysize, int labelingThresh, ARLabelInfo *labelInfo )\n#else\nint arLabelingSubEBR3C565( ARUint8 *image, int xsize, int ysize, int labelingThresh, ARLabelInfo *labelInfo )\n#endif // !AR_LABELING_FRAME_IMAGE_F\n#else\n#ifndef AR_LABELING_FRAME_IMAGE_F\nint arLabelingSubEWI3C565( ARUint8 *image, int xsize, int ysize, int labelingThresh, ARLabelInfo *labelInfo )\n#else\nint arLabelingSubEWR3C565( ARUint8 *image, int xsize, int ysize, int labelingThresh, ARLabelInfo *labelInfo )\n#endif // !AR_LABELING_FRAME_IMAGE_F\n#endif // !AR_LABELING_WHITE_REGION_F\n#endif // !AR_LABELING_DEBUG_ENABLE_F\n#endif\n\n#ifdef AR_PIXEL_FORMAT_CCCA_5551\n#ifndef AR_LABELING_DEBUG_ENABLE_F\n#ifndef AR_LABELING_WHITE_REGION_F\n#ifndef AR_LABELING_FRAME_IMAGE_F\nint arLabelingSubDBI3CA5551( ARUint8 *image, int xsize, int ysize, int labelingThresh, ARLabelInfo *labelInfo )\n#else\nint arLabelingSubDBR3CA5551( ARUint8 *image, int xsize, int ysize, int labelingThresh, ARLabelInfo *labelInfo )\n#endif // !AR_LABELING_FRAME_IMAGE_F\n#else\n#ifndef AR_LABELING_FRAME_IMAGE_F\nint arLabelingSubDWI3CA5551( ARUint8 *image, int xsize, int ysize, int labelingThresh, ARLabelInfo *labelInfo )\n#else\nint arLabelingSubDWR3CA5551( ARUint8 *image, int xsize, int ysize, int labelingThresh, ARLabelInfo *labelInfo )\n#endif // !AR_LABELING_FRAME_IMAGE_F\n#endif // !AR_LABELING_WHITE_REGION_F\n#else\n#ifndef AR_LABELING_WHITE_REGION_F\n#ifndef AR_LABELING_FRAME_IMAGE_F\nint arLabelingSubEBI3CA5551( ARUint8 *image, int xsize, int ysize, int labelingThresh, ARLabelInfo *labelInfo )\n#else\nint arLabelingSubEBR3CA5551( ARUint8 *image, int xsize, int ysize, int labelingThresh, ARLabelInfo *labelInfo )\n#endif // !AR_LABELING_FRAME_IMAGE_F\n#else\n#ifndef AR_LABELING_FRAME_IMAGE_F\nint arLabelingSubEWI3CA5551( ARUint8 *image, int xsize, int ysize, int labelingThresh, ARLabelInfo *labelInfo )\n#else\nint arLabelingSubEWR3CA5551( ARUint8 *image, int xsize, int ysize, int labelingThresh, ARLabelInfo *labelInfo )\n#endif // !AR_LABELING_FRAME_IMAGE_F\n#endif // !AR_LABELING_WHITE_REGION_F\n#endif // !AR_LABELING_DEBUG_ENABLE_F\n#endif\n\n#ifdef AR_PIXEL_FORMAT_CCCA_4444\n#ifndef AR_LABELING_DEBUG_ENABLE_F\n#ifndef AR_LABELING_WHITE_REGION_F\n#ifndef AR_LABELING_FRAME_IMAGE_F\nint arLabelingSubDBI3CA4444( ARUint8 *image, int xsize, int ysize, int labelingThresh, ARLabelInfo *labelInfo )\n#else\nint arLabelingSubDBR3CA4444( ARUint8 *image, int xsize, int ysize, int labelingThresh, ARLabelInfo *labelInfo )\n#endif // !AR_LABELING_FRAME_IMAGE_F\n#else\n#ifndef AR_LABELING_FRAME_IMAGE_F\nint arLabelingSubDWI3CA4444( ARUint8 *image, int xsize, int ysize, int labelingThresh, ARLabelInfo *labelInfo )\n#else\nint arLabelingSubDWR3CA4444( ARUint8 *image, int xsize, int ysize, int labelingThresh, ARLabelInfo *labelInfo )\n#endif // !AR_LABELING_FRAME_IMAGE_F\n#endif // !AR_LABELING_WHITE_REGION_F\n#else\n#ifndef AR_LABELING_WHITE_REGION_F\n#ifndef AR_LABELING_FRAME_IMAGE_F\nint arLabelingSubEBI3CA4444( ARUint8 *image, int xsize, int ysize, int labelingThresh, ARLabelInfo *labelInfo )\n#else\nint arLabelingSubEBR3CA4444( ARUint8 *image, int xsize, int ysize, int labelingThresh, ARLabelInfo *labelInfo )\n#endif // !AR_LABELING_FRAME_IMAGE_F\n#else\n#ifndef AR_LABELING_FRAME_IMAGE_F\nint arLabelingSubEWI3CA4444( ARUint8 *image, int xsize, int ysize, int labelingThresh, ARLabelInfo *labelInfo )\n#else\nint arLabelingSubEWR3CA4444( ARUint8 *image, int xsize, int ysize, int labelingThresh, ARLabelInfo *labelInfo )\n#endif // !AR_LABELING_FRAME_IMAGE_F\n#endif // !AR_LABELING_WHITE_REGION_F\n#endif // !AR_LABELING_DEBUG_ENABLE_F\n#endif\n\n#ifdef AR_LABELING_ADAPTIVE\n#ifndef AR_LABELING_DEBUG_ENABLE_F\n#ifndef AR_LABELING_WHITE_REGION_F\nint arLabelingSubDBZ( ARUint8 *image, const int xsize, const int ysize, ARUint8* image_thresh, ARLabelInfo *labelInfo )\n#else\nint arLabelingSubDWZ( ARUint8 *image, const int xsize, const int ysize, ARUint8* image_thresh, ARLabelInfo *labelInfo )\n#endif // !AR_LABELING_WHITE_REGION_F\n#else\n#ifndef AR_LABELING_WHITE_REGION_F\nint arLabelingSubEBZ( ARUint8 *image, const int xsize, const int ysize, ARUint8* image_thresh, ARLabelInfo *labelInfo )\n#else\nint arLabelingSubEWZ( ARUint8 *image, const int xsize, const int ysize, ARUint8* image_thresh, ARLabelInfo *labelInfo )\n#endif // !AR_LABELING_WHITE_REGION_F\n#endif // !AR_LABELING_DEBUG_ENABLE_F\n#endif\n\n{\n    int       lxsize, lysize;\n    ARUint8  *pnt;                     /*  image pointer into source image  */\n#ifdef AR_LABELING_ADAPTIVE\n    ARUint8  *pnt_thresh;\n#endif\n    AR_LABELING_LABEL_TYPE  *pnt1, *pnt2;             /*  image pointer into destination (label) image  */\n#ifdef AR_LABELING_DEBUG_ENABLE_F\n    ARUint8   *dpnt;\n#endif\n    int      *work, *work2;\n    int       wk_max;                   /*  work                */\n    int       i,j,k,l;                  /*  for loop            */\n    int       *wk;                      /*  pointer for work    */\n    int       m,n;                      /*  work                */\n    int       *label_num;\n    int       *area;\n    int       *clip;\n    ARdouble  *pos;\n\n#ifndef AR_LABELING_ADAPTIVE\n    int        labelingThresh2;\n#  if defined(AR_PIXEL_FORMAT_C) || defined(AR_PIXEL_FORMAT_YC) || defined(AR_PIXEL_FORMAT_CY) \n    labelingThresh2 = labelingThresh;\n#  else\n    labelingThresh2 = labelingThresh * 3;\n#  endif\n#endif\n\n#ifdef AR_LABELING_FRAME_IMAGE_F\n    lxsize = xsize;\n    lysize = ysize;\n#else\n    lxsize = xsize / 2;\n    lysize = ysize / 2;\n#endif\n\n#ifdef AR_LABELING_DEBUG_ENABLE_F\n    //memset( labelInfo->bwImage, 0, lxsize*lysize );\n#endif\n\n\t// Set top and bottom rows of labelImage to 0.\n    pnt1 = &(labelInfo->labelImage[0]); // Leftmost pixel of top row of image.\n    pnt2 = &(labelInfo->labelImage[(lysize - 1)*lxsize]); // Leftmost pixel of bottom row of image.\n    for(i = 0; i < lxsize; i++) {\n        *(pnt1++) = *(pnt2++) = 0;\n    }\n\n\t// Set leftmost and rightmost columns of labelImage to 0.\n    pnt1 = &(labelInfo->labelImage[0]); // Leftmost pixel of top row of image.\n    pnt2 = &(labelInfo->labelImage[lxsize - 1]); // Rightmost pixel of top row of image.\n    for(i = 0; i < lysize; i++) {\n        *pnt1 = *pnt2 = 0;\n        pnt1 += lxsize;\n        pnt2 += lxsize;\n    }\n\n    wk_max = 0;\n    work = labelInfo->work;\n    work2 = labelInfo->work2;\n    pnt2 = &(labelInfo->labelImage[lxsize + 1]); // Start on 2nd pixel of 2nd row.\n#ifdef AR_LABELING_DEBUG_ENABLE_F\n    dpnt = &(labelInfo->bwImage[lxsize + 1]);\n#  ifdef AR_LABELING_FRAME_IMAGE_F\n    pnt = &(image[(xsize + 1)*AR_PIXEL_SIZE]); // Start on 2nd pixel of 2nd row.\n#    ifdef AR_LABELING_ADAPTIVE\n    pnt_thresh = &(image_thresh[(xsize + 1)*AR_PIXEL_SIZE]);\n    for(j = 1; j < lysize - 1; j++, pnt += AR_PIXEL_SIZE*2, pnt_thresh += AR_PIXEL_SIZE*2, pnt2 += 2, dpnt += 2) { // Process rows. At end of each row, skips last pixel of row and first pixel of next row.\n        for(i = 1; i < lxsize - 1; i++, pnt += AR_PIXEL_SIZE, pnt_thresh += AR_PIXEL_SIZE, pnt2++, dpnt++) { // Process columns.\n#    else\n    for(j = 1; j < lysize - 1; j++, pnt += AR_PIXEL_SIZE*2, pnt2 += 2, dpnt += 2) { // Process rows. At end of each row, skips last pixel of row and first pixel of next row.\n        for(i = 1; i < lxsize - 1; i++, pnt += AR_PIXEL_SIZE, pnt2++, dpnt++) { // Process columns.\n#    endif\n#  else\n    pnt = &(image[(xsize*2 + 2)*AR_PIXEL_SIZE]);\n    for(j = 1; j < lysize - 1; j++, pnt += AR_PIXEL_SIZE*4, pnt2 += 2, dpnt += 2) {\n        for(i = 1; i < lxsize - 1; i++, pnt += AR_PIXEL_SIZE*2, pnt2++, dpnt++) {\n#  endif\n#else\n#  ifdef AR_LABELING_FRAME_IMAGE_F\n    pnt = &(image[(xsize + 1)*AR_PIXEL_SIZE]); // Start on 2nd pixel of 2nd row.\n#    ifdef AR_LABELING_ADAPTIVE\n    pnt_thresh = &(image_thresh[(xsize + 1)*AR_PIXEL_SIZE]);\n    for(j = 1; j < lysize - 1; j++, pnt += AR_PIXEL_SIZE*2, pnt_thresh += AR_PIXEL_SIZE*2, pnt2 += 2) { // Process rows. At end of each row, skips last pixel of row and first pixel of next row.\n        for(i = 1; i < lxsize - 1; i++, pnt += AR_PIXEL_SIZE, pnt_thresh += AR_PIXEL_SIZE, pnt2++) { // Process columns.\n#    else\n    for(j = 1; j < lysize - 1; j++, pnt += AR_PIXEL_SIZE*2, pnt2 += 2) { // Process rows. At end of each row, skips last pixel of row and first pixel of next row.\n        for(i = 1; i < lxsize - 1; i++, pnt += AR_PIXEL_SIZE, pnt2++) { // Process columns.\n#    endif\n#  else\n    pnt = &(image[(xsize*2 + 2)*AR_PIXEL_SIZE]);\n    for(j = 1; j < lysize - 1; j++, pnt += AR_PIXEL_SIZE*4, pnt2 += 2) {\n        for(i = 1; i < lxsize - 1; i++, pnt += AR_PIXEL_SIZE*2, pnt2++) {\n#  endif\n#endif // AR_LABELING_DEBUG_ENABLE_F\n\n#ifndef AR_LABELING_WHITE_REGION_F\n// Black region.\n#  if defined(AR_PIXEL_FORMAT_ACCC)\n            if( *(pnt+1) + *(pnt+2) + *(pnt+3) <= labelingThresh2 ) {\n#  elif defined(AR_PIXEL_FORMAT_CCCA) || defined(AR_PIXEL_FORMAT_CCC)\n            if( *(pnt+0) + *(pnt+1) + *(pnt+2) <= labelingThresh2 ) {\n#  elif defined(AR_PIXEL_FORMAT_C)\n            if( *pnt <= labelingThresh2 ) {\n#  elif defined(AR_PIXEL_FORMAT_YC)\n            if( *pnt <= labelingThresh2 ) {\n#  elif defined(AR_PIXEL_FORMAT_CY)\n\t\t\tif( *(pnt+1) <= labelingThresh2 ) {\n#  elif defined(AR_PIXEL_FORMAT_CCC_565)\n            if( ((*(pnt+0)) & 0xf8) + (((*(pnt+0)) & 0x07) << 5) + (((*(pnt+1)) & 0xe0) >> 3) + (((*(pnt+1)) & 0x1f) << 3) + 10 <= labelingThresh2 ) { // 10 = 4 + 2 + 4, provides midpoint of missing bits.\n#  elif defined(AR_PIXEL_FORMAT_CCCA_5551)\n            if( ((*(pnt+0)) & 0xf8) + (((*(pnt+0)) & 0x07) << 5) + (((*(pnt+1)) & 0xc0) >> 3) + (((*(pnt+1)) & 0x3e) << 2) + 12 <= labelingThresh2 ) { // 12 = 4 + 4 + 4, provides midpoint of missing bits.\n#  elif defined(AR_PIXEL_FORMAT_CCCA_4444)\n            if( ((*(pnt+0)) & 0xf0) + (((*(pnt+0)) & 0x0f) << 4) + ((*(pnt+1)) & 0xf0) + 24 <= labelingThresh2 ) {  // 24 = 8 + 8 + 8, provides midpoint of missing bits.\n#  elif defined(AR_LABELING_ADAPTIVE)\n            if( *pnt <= *pnt_thresh ) {\n#  endif\n#else\n// White region.\n#  if defined(AR_PIXEL_FORMAT_ACCC)\n            if( *(pnt+1) + *(pnt+2) + *(pnt+3) > labelingThresh2 ) {\n#  elif defined(AR_PIXEL_FORMAT_CCCA) || defined(AR_PIXEL_FORMAT_CCC)\n            if( *(pnt+0) + *(pnt+1) + *(pnt+2) > labelingThresh2 ) {\n#  elif defined(AR_PIXEL_FORMAT_C)\n            if( *pnt > labelingThresh2 ) {\n#  elif defined(AR_PIXEL_FORMAT_YC)\n\t\t\tif( *pnt > labelingThresh2 ) {\n#  elif defined(AR_PIXEL_FORMAT_CY)\n\t\t\tif( *(pnt+1) > labelingThresh2 ) {\n#  elif defined(AR_PIXEL_FORMAT_CCC_565)\n            if( ((*(pnt+0)) & 0xf8) + (((*(pnt+0)) & 0x07) << 5) + (((*(pnt+1)) & 0xe0) >> 3) + (((*(pnt+1)) & 0x1f) << 3) + 10 > labelingThresh2 ) { // 10 = 4 + 2 + 4, provides midpoint of missing bits.\n#  elif defined(AR_PIXEL_FORMAT_CCCA_5551)\n            if( ((*(pnt+0)) & 0xf8) + (((*(pnt+0)) & 0x07) << 5) + (((*(pnt+1)) & 0xc0) >> 3) + (((*(pnt+1)) & 0x3e) << 2) + 12 > labelingThresh2 ) { // 12 = 4 + 4 + 4, provides midpoint of missing bits.\n#  elif defined(AR_PIXEL_FORMAT_CCCA_4444)\n            if( ((*(pnt+0)) & 0xf0) + (((*(pnt+0)) & 0x0f) << 4) + ((*(pnt+1)) & 0xf0) + 24 > labelingThresh2 ) {  // 24 = 8 + 8 + 8, provides midpoint of missing bits.\n#  elif defined(AR_LABELING_ADAPTIVE)\n            if( *pnt > *pnt_thresh ) {\n#  endif\n#endif // !AR_LABELING_WHITE_REGION_F\n                // pnt is in region.\n#  ifdef AR_LABELING_DEBUG_ENABLE_F\n                *dpnt = 255;\n#  endif\n                pnt1 = &(pnt2[-lxsize]);\n                if( *pnt1 > 0 ) {\n                    *pnt2 = *pnt1;\n                    l = ((*pnt2) - 1) * 7;\n                    work2[l+0] ++; // area\n                    work2[l+1] += i; // pos[0]\n                    work2[l+2] += j; // pos[1]\n                    work2[l+6]  = j; // clip[3]\n                }\n                else if( *(pnt1+1) > 0 ) {\n                    if( *(pnt1-1) > 0 ) {\n                        m = work[*(pnt1+1)-1];\n                        n = work[*(pnt1-1)-1];\n                        if( m > n ) {\n                            *pnt2 = n;\n                            wk = &(work[0]);\n                            for(k = 0; k < wk_max; k++) {\n                                if( *wk == m ) *wk = n;\n                                wk++;\n                            }\n                        }\n                        else if( m < n ) {\n                            *pnt2 = m;\n                            wk = &(work[0]);\n                            for(k = 0; k < wk_max; k++) {\n                                if( *wk == n ) *wk = m;\n                                wk++;\n                            }\n                        }\n                        else *pnt2 = m;\n                        l = ((*pnt2)-1)*7;\n                        work2[l+0]  ++; // area.\n                        work2[l+1] += i; // pos[0]\n                        work2[l+2] += j; // pos[1]\n                        work2[l+6]  = j; // clip[3]\n                    }\n                    else if( *(pnt2-1) > 0 ) {\n                        m = work[*(pnt1+1)-1];\n                        n = work[*(pnt2-1)-1];\n                        if( m > n ) {\n                            *pnt2 = n;\n                            wk = &(work[0]);\n                            for(k = 0; k < wk_max; k++) {\n                                if( *wk == m ) *wk = n;\n                                wk++;\n                            }\n                        }\n                        else if( m < n ) {\n                            *pnt2 = m;\n                            wk = &(work[0]);\n                            for(k = 0; k < wk_max; k++) {\n                                if( *wk == n ) *wk = m;\n                                wk++;\n                            }\n                        }\n                        else *pnt2 = m;\n                        l = ((*pnt2)-1)*7;\n                        work2[l+0] ++; // area\n                        work2[l+1] += i; // pos[0]\n                        work2[l+2] += j; // pos[1]\n                    }\n                    else {\n                        *pnt2 = *(pnt1+1);\n                        l = ((*pnt2)-1)*7;\n                        work2[l+0] ++; // area\n                        work2[l+1] += i; // pos[0]\n                        work2[l+2] += j; // pos[1]\n                        if( work2[l+3] > i ) work2[l+3] = i; // clip[0]\n                        work2[l+6] = j; // clip [3]\n                    }\n                }\n                else if( *(pnt1-1) > 0 ) {\n                    *pnt2 = *(pnt1-1);\n                    l = ((*pnt2)-1)*7;\n                    work2[l+0] ++; // area\n                    work2[l+1] += i; // pos[0]\n                    work2[l+2] += j; // pos[1]\n                    if( work2[l+4] < i ) work2[l+4] = i; // clip[1]\n                    work2[l+6] = j; // clip[3]\n                }\n                else if( *(pnt2-1) > 0) {\n                    *pnt2 = *(pnt2-1);\n                    l = ((*pnt2)-1)*7;\n                    work2[l+0] ++; // area\n                    work2[l+1] += i; // pos[0]\n                    work2[l+2] += j; // pos[1]\n                    if( work2[l+4] < i ) work2[l+4] = i; // clip[1]\n                }\n                else {\n                    wk_max++;\n                    if( wk_max > AR_LABELING_WORK_SIZE ) {\n                        ARLOGe(\"Error: labeling work overflow.\\n\");\n                        return(-1);\n                    }\n                    work[wk_max-1] = *pnt2 = wk_max;\n                    l = (wk_max-1)*7;\n                    work2[l+0] = 1; // area\n                    work2[l+1] = i; // pos[0]\n                    work2[l+2] = j; // pos[1]\n                    work2[l+3] = i; // clip[0]\n                    work2[l+4] = i; // clip[1]\n                    work2[l+5] = j; // clip[2]\n                    work2[l+6] = j; // clip[3]\n                }\n            }\n            else {\n                // pnt is NOT in region.\n                *pnt2 = 0;\n#ifdef AR_LABELING_DEBUG_ENABLE_F\n\t\t\t\t*dpnt = 0;\n#endif\n            }\n        }\n#ifndef AR_LABELING_FRAME_IMAGE_F\n        pnt += xsize*AR_PIXEL_SIZE;\n#endif\n    }\n\n    label_num = &(labelInfo->label_num);\n    area = &(labelInfo->area[0]);\n    clip = &(labelInfo->clip[0][0]);\n    pos  = &(labelInfo->pos[0][0]);\n    j = 1;\n    wk = &(work[0]);\n    for(i = 1; i <= wk_max; i++, wk++) {\n        *wk = (*wk==i)? j++: work[(*wk)-1];\n    }\n    *label_num = *label_num = j - 1;\n    if( *label_num == 0 ) {\n        return 0;\n    }\n\n    memset( (ARUint8 *)area, 0, *label_num *     sizeof(int) );\n    memset( (ARUint8 *)pos,  0, *label_num * 2 * sizeof(ARdouble) );\n    for(i = 0; i < *label_num; i++) {\n        clip[i*4+0] = lxsize;\n        clip[i*4+1] = 0;\n        clip[i*4+2] = lysize;\n        clip[i*4+3] = 0;\n    }\n    for(i = 0; i < wk_max; i++) {\n        j = work[i] - 1;\n        area[j]    += work2[i*7+0];\n        pos[j*2+0] += work2[i*7+1];\n        pos[j*2+1] += work2[i*7+2];\n        if( clip[j*4+0] > work2[i*7+3] ) clip[j*4+0] = work2[i*7+3];\n        if( clip[j*4+1] < work2[i*7+4] ) clip[j*4+1] = work2[i*7+4];\n        if( clip[j*4+2] > work2[i*7+5] ) clip[j*4+2] = work2[i*7+5];\n        if( clip[j*4+3] < work2[i*7+6] ) clip[j*4+3] = work2[i*7+6];\n    }\n\n    for( i = 0; i < *label_num; i++ ) {\n        pos[i*2+0] /= area[i];\n        pos[i*2+1] /= area[i];\n    }\n\n    return 0;\n}\n","// -*- C++ -*-\n//===---------------------------- ios -------------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_IOS\n#define _LIBCPP_IOS\n\n/*\n    ios synopsis\n\n#include <iosfwd>\n\nnamespace std\n{\n\ntypedef OFF_T streamoff;\ntypedef SZ_T streamsize;\ntemplate <class stateT> class fpos;\n\nclass ios_base\n{\npublic:\n    class failure;\n\n    typedef T1 fmtflags;\n    static constexpr fmtflags boolalpha;\n    static constexpr fmtflags dec;\n    static constexpr fmtflags fixed;\n    static constexpr fmtflags hex;\n    static constexpr fmtflags internal;\n    static constexpr fmtflags left;\n    static constexpr fmtflags oct;\n    static constexpr fmtflags right;\n    static constexpr fmtflags scientific;\n    static constexpr fmtflags showbase;\n    static constexpr fmtflags showpoint;\n    static constexpr fmtflags showpos;\n    static constexpr fmtflags skipws;\n    static constexpr fmtflags unitbuf;\n    static constexpr fmtflags uppercase;\n    static constexpr fmtflags adjustfield;\n    static constexpr fmtflags basefield;\n    static constexpr fmtflags floatfield;\n\n    typedef T2 iostate;\n    static constexpr iostate badbit;\n    static constexpr iostate eofbit;\n    static constexpr iostate failbit;\n    static constexpr iostate goodbit;\n\n    typedef T3 openmode;\n    static constexpr openmode app;\n    static constexpr openmode ate;\n    static constexpr openmode binary;\n    static constexpr openmode in;\n    static constexpr openmode out;\n    static constexpr openmode trunc;\n\n    typedef T4 seekdir;\n    static constexpr seekdir beg;\n    static constexpr seekdir cur;\n    static constexpr seekdir end;\n\n    class Init;\n\n    // 27.5.2.2 fmtflags state:\n    fmtflags flags() const;\n    fmtflags flags(fmtflags fmtfl);\n    fmtflags setf(fmtflags fmtfl);\n    fmtflags setf(fmtflags fmtfl, fmtflags mask);\n    void unsetf(fmtflags mask);\n\n    streamsize precision() const;\n    streamsize precision(streamsize prec);\n    streamsize width() const;\n    streamsize width(streamsize wide);\n\n    // 27.5.2.3 locales:\n    locale imbue(const locale& loc);\n    locale getloc() const;\n\n    // 27.5.2.5 storage:\n    static int xalloc();\n    long& iword(int index);\n    void*& pword(int index);\n\n    // destructor\n    virtual ~ios_base();\n\n    // 27.5.2.6 callbacks;\n    enum event { erase_event, imbue_event, copyfmt_event };\n    typedef void (*event_callback)(event, ios_base&, int index);\n    void register_callback(event_callback fn, int index);\n\n    ios_base(const ios_base&) = delete;\n    ios_base& operator=(const ios_base&) = delete;\n\n    static bool sync_with_stdio(bool sync = true);\n\nprotected:\n    ios_base();\n};\n\ntemplate <class charT, class traits = char_traits<charT> >\nclass basic_ios\n    : public ios_base\n{\npublic:\n    // types:\n    typedef charT char_type;\n    typedef typename traits::int_type int_type;  // removed in C++17\n    typedef typename traits::pos_type pos_type;  // removed in C++17\n    typedef typename traits::off_type off_type;  // removed in C++17\n    typedef traits traits_type;\n\n    operator unspecified-bool-type() const;\n    bool operator!() const;\n    iostate rdstate() const;\n    void clear(iostate state = goodbit);\n    void setstate(iostate state);\n    bool good() const;\n    bool eof() const;\n    bool fail() const;\n    bool bad() const;\n\n    iostate exceptions() const;\n    void exceptions(iostate except);\n\n    // 27.5.4.1 Constructor/destructor:\n    explicit basic_ios(basic_streambuf<charT,traits>* sb);\n    virtual ~basic_ios();\n\n    // 27.5.4.2 Members:\n    basic_ostream<charT,traits>* tie() const;\n    basic_ostream<charT,traits>* tie(basic_ostream<charT,traits>* tiestr);\n\n    basic_streambuf<charT,traits>* rdbuf() const;\n    basic_streambuf<charT,traits>* rdbuf(basic_streambuf<charT,traits>* sb);\n\n    basic_ios& copyfmt(const basic_ios& rhs);\n\n    char_type fill() const;\n    char_type fill(char_type ch);\n\n    locale imbue(const locale& loc);\n\n    char narrow(char_type c, char dfault) const;\n    char_type widen(char c) const;\n\n    basic_ios(const basic_ios& ) = delete;\n    basic_ios& operator=(const basic_ios&) = delete;\n\nprotected:\n    basic_ios();\n    void init(basic_streambuf<charT,traits>* sb);\n    void move(basic_ios& rhs);\n    void swap(basic_ios& rhs) noexcept;\n    void set_rdbuf(basic_streambuf<charT, traits>* sb);\n};\n\n// 27.5.5, manipulators:\nios_base& boolalpha (ios_base& str);\nios_base& noboolalpha(ios_base& str);\nios_base& showbase (ios_base& str);\nios_base& noshowbase (ios_base& str);\nios_base& showpoint (ios_base& str);\nios_base& noshowpoint(ios_base& str);\nios_base& showpos (ios_base& str);\nios_base& noshowpos (ios_base& str);\nios_base& skipws (ios_base& str);\nios_base& noskipws (ios_base& str);\nios_base& uppercase (ios_base& str);\nios_base& nouppercase(ios_base& str);\nios_base& unitbuf (ios_base& str);\nios_base& nounitbuf (ios_base& str);\n\n// 27.5.5.2 adjustfield:\nios_base& internal (ios_base& str);\nios_base& left (ios_base& str);\nios_base& right (ios_base& str);\n\n// 27.5.5.3 basefield:\nios_base& dec (ios_base& str);\nios_base& hex (ios_base& str);\nios_base& oct (ios_base& str);\n\n// 27.5.5.4 floatfield:\nios_base& fixed (ios_base& str);\nios_base& scientific (ios_base& str);\nios_base& hexfloat (ios_base& str);\nios_base& defaultfloat(ios_base& str);\n\n// 27.5.5.5 error reporting:\nenum class io_errc\n{\n    stream = 1\n};\n\nconcept_map ErrorCodeEnum<io_errc> { };\nerror_code make_error_code(io_errc e) noexcept; \nerror_condition make_error_condition(io_errc e) noexcept; \nstorage-class-specifier const error_category& iostream_category() noexcept;\n\n}  // std\n\n*/\n\n#include <__config>\n#include <iosfwd>\n#include <__locale>\n#include <system_error>\n\n#if !defined(_LIBCPP_HAS_NO_ATOMIC_HEADER)\n#include <atomic>     // for __xindex_\n#endif\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\ntypedef ptrdiff_t streamsize;\n\nclass _LIBCPP_TYPE_VIS ios_base\n{\npublic:\n    class _LIBCPP_EXCEPTION_ABI failure;\n\n    typedef unsigned int fmtflags;\n    static const fmtflags boolalpha   = 0x0001;\n    static const fmtflags dec         = 0x0002;\n    static const fmtflags fixed       = 0x0004;\n    static const fmtflags hex         = 0x0008;\n    static const fmtflags internal    = 0x0010;\n    static const fmtflags left        = 0x0020;\n    static const fmtflags oct         = 0x0040;\n    static const fmtflags right       = 0x0080;\n    static const fmtflags scientific  = 0x0100;\n    static const fmtflags showbase    = 0x0200;\n    static const fmtflags showpoint   = 0x0400;\n    static const fmtflags showpos     = 0x0800;\n    static const fmtflags skipws      = 0x1000;\n    static const fmtflags unitbuf     = 0x2000;\n    static const fmtflags uppercase   = 0x4000;\n    static const fmtflags adjustfield = left | right | internal;\n    static const fmtflags basefield   = dec | oct | hex;\n    static const fmtflags floatfield  = scientific | fixed;\n\n    typedef unsigned int iostate;\n    static const iostate badbit  = 0x1;\n    static const iostate eofbit  = 0x2;\n    static const iostate failbit = 0x4;\n    static const iostate goodbit = 0x0;\n\n    typedef unsigned int openmode;\n    static const openmode app    = 0x01;\n    static const openmode ate    = 0x02;\n    static const openmode binary = 0x04;\n    static const openmode in     = 0x08;\n    static const openmode out    = 0x10;\n    static const openmode trunc  = 0x20;\n\n    enum seekdir {beg, cur, end};\n\n#if _LIBCPP_STD_VER <= 14\n    typedef iostate      io_state;\n    typedef openmode     open_mode;\n    typedef seekdir      seek_dir;\n\n    typedef _VSTD::streamoff streamoff;\n    typedef _VSTD::streampos streampos;\n#endif\n\n    class _LIBCPP_TYPE_VIS Init;\n\n    // 27.5.2.2 fmtflags state:\n    _LIBCPP_INLINE_VISIBILITY fmtflags flags() const;\n    _LIBCPP_INLINE_VISIBILITY fmtflags flags(fmtflags __fmtfl);\n    _LIBCPP_INLINE_VISIBILITY fmtflags setf(fmtflags __fmtfl);\n    _LIBCPP_INLINE_VISIBILITY fmtflags setf(fmtflags __fmtfl, fmtflags __mask);\n    _LIBCPP_INLINE_VISIBILITY void unsetf(fmtflags __mask);\n\n    _LIBCPP_INLINE_VISIBILITY streamsize precision() const;\n    _LIBCPP_INLINE_VISIBILITY streamsize precision(streamsize __prec);\n    _LIBCPP_INLINE_VISIBILITY streamsize width() const;\n    _LIBCPP_INLINE_VISIBILITY streamsize width(streamsize __wide);\n\n    // 27.5.2.3 locales:\n    locale imbue(const locale& __loc);\n    locale getloc() const;\n\n    // 27.5.2.5 storage:\n    static int xalloc();\n    long& iword(int __index);\n    void*& pword(int __index);\n\n    // destructor\n    virtual ~ios_base();\n\n    // 27.5.2.6 callbacks;\n    enum event { erase_event, imbue_event, copyfmt_event };\n    typedef void (*event_callback)(event, ios_base&, int __index);\n    void register_callback(event_callback __fn, int __index);\n\nprivate:\n    ios_base(const ios_base&); // = delete;\n    ios_base& operator=(const ios_base&); // = delete;\n\npublic:\n    static bool sync_with_stdio(bool __sync = true);\n\n    _LIBCPP_INLINE_VISIBILITY iostate rdstate() const;\n    void clear(iostate __state = goodbit);\n    _LIBCPP_INLINE_VISIBILITY void setstate(iostate __state);\n\n    _LIBCPP_INLINE_VISIBILITY bool good() const;\n    _LIBCPP_INLINE_VISIBILITY bool eof() const;\n    _LIBCPP_INLINE_VISIBILITY bool fail() const;\n    _LIBCPP_INLINE_VISIBILITY bool bad() const;\n\n    _LIBCPP_INLINE_VISIBILITY iostate exceptions() const;\n    _LIBCPP_INLINE_VISIBILITY void exceptions(iostate __iostate);\n\n    void __set_badbit_and_consider_rethrow();\n    void __set_failbit_and_consider_rethrow();\n\nprotected:\n    _LIBCPP_INLINE_VISIBILITY\n    ios_base() {// purposefully does no initialization\n               }\n\n    void init(void* __sb);\n    _LIBCPP_ALWAYS_INLINE void* rdbuf() const {return __rdbuf_;}\n\n    _LIBCPP_ALWAYS_INLINE\n    void rdbuf(void* __sb)\n    {\n        __rdbuf_ = __sb;\n        clear();\n    }\n\n    void __call_callbacks(event);\n    void copyfmt(const ios_base&);\n    void move(ios_base&);\n    void swap(ios_base&) _NOEXCEPT;\n\n    _LIBCPP_ALWAYS_INLINE\n    void set_rdbuf(void* __sb)\n    {\n        __rdbuf_ = __sb;\n    }\n\nprivate:\n    // All data members must be scalars\n    fmtflags        __fmtflags_;\n    streamsize      __precision_;\n    streamsize      __width_;\n    iostate         __rdstate_;\n    iostate         __exceptions_;\n    void*           __rdbuf_;\n    void*           __loc_;\n    event_callback* __fn_;\n    int*            __index_;\n    size_t          __event_size_;\n    size_t          __event_cap_;\n// TODO(EricWF): Enable this for both Clang and GCC. Currently it is only\n// enabled with clang.\n#if defined(_LIBCPP_HAS_C_ATOMIC_IMP) && !defined(_LIBCPP_HAS_NO_THREADS)\n    static atomic<int> __xindex_;\n#else\n    static int      __xindex_;\n#endif\n    long*           __iarray_;\n    size_t          __iarray_size_;\n    size_t          __iarray_cap_;\n    void**          __parray_;\n    size_t          __parray_size_;\n    size_t          __parray_cap_;\n};\n\n//enum class io_errc\n_LIBCPP_DECLARE_STRONG_ENUM(io_errc)\n{\n    stream = 1\n};\n_LIBCPP_DECLARE_STRONG_ENUM_EPILOG(io_errc)\n\ntemplate <>\nstruct _LIBCPP_TEMPLATE_VIS is_error_code_enum<io_errc> : public true_type { };\n\n#ifdef _LIBCPP_HAS_NO_STRONG_ENUMS\ntemplate <>\nstruct _LIBCPP_TEMPLATE_VIS is_error_code_enum<io_errc::__lx> : public true_type { };\n#endif\n\n_LIBCPP_FUNC_VIS\nconst error_category& iostream_category() _NOEXCEPT;\n\ninline _LIBCPP_INLINE_VISIBILITY\nerror_code\nmake_error_code(io_errc __e) _NOEXCEPT\n{\n    return error_code(static_cast<int>(__e), iostream_category());\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nerror_condition\nmake_error_condition(io_errc __e) _NOEXCEPT\n{\n    return error_condition(static_cast<int>(__e), iostream_category());\n}\n\nclass _LIBCPP_EXCEPTION_ABI ios_base::failure\n    : public system_error\n{\npublic:\n    explicit failure(const string& __msg, const error_code& __ec = io_errc::stream);\n    explicit failure(const char* __msg, const error_code& __ec = io_errc::stream);\n    virtual ~failure() throw();\n};\n\nclass _LIBCPP_TYPE_VIS ios_base::Init\n{\npublic:\n    Init();\n    ~Init();\n};\n\n// fmtflags\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base::fmtflags\nios_base::flags() const\n{\n    return __fmtflags_;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base::fmtflags\nios_base::flags(fmtflags __fmtfl)\n{\n    fmtflags __r = __fmtflags_;\n    __fmtflags_ = __fmtfl;\n    return __r;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base::fmtflags\nios_base::setf(fmtflags __fmtfl)\n{\n    fmtflags __r = __fmtflags_;\n    __fmtflags_ |= __fmtfl;\n    return __r;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nios_base::unsetf(fmtflags __mask)\n{\n    __fmtflags_ &= ~__mask;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base::fmtflags\nios_base::setf(fmtflags __fmtfl, fmtflags __mask)\n{\n    fmtflags __r = __fmtflags_;\n    unsetf(__mask);\n    __fmtflags_ |= __fmtfl & __mask;\n    return __r;\n}\n\n// precision\n\ninline _LIBCPP_INLINE_VISIBILITY\nstreamsize\nios_base::precision() const\n{\n    return __precision_;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nstreamsize\nios_base::precision(streamsize __prec)\n{\n    streamsize __r = __precision_;\n    __precision_ = __prec;\n    return __r;\n}\n\n// width\n\ninline _LIBCPP_INLINE_VISIBILITY\nstreamsize\nios_base::width() const\n{\n    return __width_;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nstreamsize\nios_base::width(streamsize __wide)\n{\n    streamsize __r = __width_;\n    __width_ = __wide;\n    return __r;\n}\n\n// iostate\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base::iostate\nios_base::rdstate() const\n{\n    return __rdstate_;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nios_base::setstate(iostate __state)\n{\n    clear(__rdstate_ | __state);\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nios_base::good() const\n{\n    return __rdstate_ == 0;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nios_base::eof() const\n{\n    return (__rdstate_ & eofbit) != 0;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nios_base::fail() const\n{\n    return (__rdstate_ & (failbit | badbit)) != 0;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nios_base::bad() const\n{\n    return (__rdstate_ & badbit) != 0;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base::iostate\nios_base::exceptions() const\n{\n    return __exceptions_;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nios_base::exceptions(iostate __iostate)\n{\n    __exceptions_ = __iostate;\n    clear(__rdstate_);\n}\n\n#if defined(_LIBCPP_CXX03_LANG)\nstruct _LIBCPP_TYPE_VIS __cxx03_bool {\n  typedef void (__cxx03_bool::*__bool_type)();\n  void __true_value() {}\n};\n#endif\n\ntemplate <class _CharT, class _Traits>\nclass _LIBCPP_TEMPLATE_VIS basic_ios\n    : public ios_base\n{\npublic:\n    // types:\n    typedef _CharT char_type;\n    typedef _Traits traits_type;\n\n    typedef typename traits_type::int_type int_type;\n    typedef typename traits_type::pos_type pos_type;\n    typedef typename traits_type::off_type off_type;\n\n#if defined(_LIBCPP_CXX03_LANG)\n    _LIBCPP_ALWAYS_INLINE\n    operator __cxx03_bool::__bool_type() const {\n        return !fail() ? &__cxx03_bool::__true_value : nullptr;\n    }\n#else\n    _LIBCPP_ALWAYS_INLINE\n    _LIBCPP_EXPLICIT operator bool() const {return !fail();}\n#endif\n\n    _LIBCPP_ALWAYS_INLINE bool operator!() const    {return  fail();}\n    _LIBCPP_ALWAYS_INLINE iostate rdstate() const   {return ios_base::rdstate();}\n    _LIBCPP_ALWAYS_INLINE void clear(iostate __state = goodbit) {ios_base::clear(__state);}\n    _LIBCPP_ALWAYS_INLINE void setstate(iostate __state) {ios_base::setstate(__state);}\n    _LIBCPP_ALWAYS_INLINE bool good() const {return ios_base::good();}\n    _LIBCPP_ALWAYS_INLINE bool eof() const  {return ios_base::eof();}\n    _LIBCPP_ALWAYS_INLINE bool fail() const {return ios_base::fail();}\n    _LIBCPP_ALWAYS_INLINE bool bad() const  {return ios_base::bad();}\n\n    _LIBCPP_ALWAYS_INLINE iostate exceptions() const {return ios_base::exceptions();}\n    _LIBCPP_ALWAYS_INLINE void exceptions(iostate __iostate) {ios_base::exceptions(__iostate);}\n\n    // 27.5.4.1 Constructor/destructor:\n    _LIBCPP_INLINE_VISIBILITY\n    explicit basic_ios(basic_streambuf<char_type,traits_type>* __sb);\n    virtual ~basic_ios();\n\n    // 27.5.4.2 Members:\n    _LIBCPP_INLINE_VISIBILITY \n    basic_ostream<char_type, traits_type>* tie() const;\n    _LIBCPP_INLINE_VISIBILITY \n    basic_ostream<char_type, traits_type>* tie(basic_ostream<char_type, traits_type>* __tiestr);\n\n    _LIBCPP_INLINE_VISIBILITY \n    basic_streambuf<char_type, traits_type>* rdbuf() const;\n    _LIBCPP_INLINE_VISIBILITY \n    basic_streambuf<char_type, traits_type>* rdbuf(basic_streambuf<char_type, traits_type>* __sb);\n\n    basic_ios& copyfmt(const basic_ios& __rhs);\n\n    _LIBCPP_INLINE_VISIBILITY \n    char_type fill() const;\n    _LIBCPP_INLINE_VISIBILITY \n    char_type fill(char_type __ch);\n\n    _LIBCPP_INLINE_VISIBILITY \n    locale imbue(const locale& __loc);\n\n    _LIBCPP_INLINE_VISIBILITY \n    char narrow(char_type __c, char __dfault) const;\n    _LIBCPP_INLINE_VISIBILITY \n    char_type widen(char __c) const;\n\nprotected:\n    _LIBCPP_ALWAYS_INLINE\n    basic_ios() {// purposefully does no initialization\n                }\n    _LIBCPP_INLINE_VISIBILITY \n    void init(basic_streambuf<char_type, traits_type>* __sb);\n\n    _LIBCPP_INLINE_VISIBILITY \n    void move(basic_ios& __rhs);\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_ALWAYS_INLINE\n    void move(basic_ios&& __rhs) {move(__rhs);}\n#endif\n    _LIBCPP_INLINE_VISIBILITY \n    void swap(basic_ios& __rhs) _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY \n    void set_rdbuf(basic_streambuf<char_type, traits_type>* __sb);\nprivate:\n    basic_ostream<char_type, traits_type>* __tie_;\n     mutable int_type __fill_;\n};\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_ios<_CharT, _Traits>::basic_ios(basic_streambuf<char_type,traits_type>* __sb)\n{\n    init(__sb);\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ios<_CharT, _Traits>::~basic_ios()\n{\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_ios<_CharT, _Traits>::init(basic_streambuf<char_type, traits_type>* __sb)\n{\n    ios_base::init(__sb);\n    __tie_ = 0;\n    __fill_ = traits_type::eof();\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_ostream<_CharT, _Traits>*\nbasic_ios<_CharT, _Traits>::tie() const\n{\n    return __tie_;\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_ostream<_CharT, _Traits>*\nbasic_ios<_CharT, _Traits>::tie(basic_ostream<char_type, traits_type>* __tiestr)\n{\n    basic_ostream<char_type, traits_type>* __r = __tie_;\n    __tie_ = __tiestr;\n    return __r;\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_streambuf<_CharT, _Traits>*\nbasic_ios<_CharT, _Traits>::rdbuf() const\n{\n    return static_cast<basic_streambuf<char_type, traits_type>*>(ios_base::rdbuf());\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_streambuf<_CharT, _Traits>*\nbasic_ios<_CharT, _Traits>::rdbuf(basic_streambuf<char_type, traits_type>* __sb)\n{\n    basic_streambuf<char_type, traits_type>* __r = rdbuf();\n    ios_base::rdbuf(__sb);\n    return __r;\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nlocale\nbasic_ios<_CharT, _Traits>::imbue(const locale& __loc)\n{\n    locale __r = getloc();\n    ios_base::imbue(__loc);\n    if (rdbuf())\n        rdbuf()->pubimbue(__loc);\n    return __r;\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nchar\nbasic_ios<_CharT, _Traits>::narrow(char_type __c, char __dfault) const\n{\n    return use_facet<ctype<char_type> >(getloc()).narrow(__c, __dfault);\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\n_CharT\nbasic_ios<_CharT, _Traits>::widen(char __c) const\n{\n    return use_facet<ctype<char_type> >(getloc()).widen(__c);\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\n_CharT\nbasic_ios<_CharT, _Traits>::fill() const\n{\n    if (traits_type::eq_int_type(traits_type::eof(), __fill_))\n        __fill_ = widen(' ');\n    return __fill_;\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\n_CharT\nbasic_ios<_CharT, _Traits>::fill(char_type __ch)\n{\n    char_type __r = __fill_;\n    __fill_ = __ch;\n    return __r;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ios<_CharT, _Traits>&\nbasic_ios<_CharT, _Traits>::copyfmt(const basic_ios& __rhs)\n{\n    if (this != &__rhs)\n    {\n        __call_callbacks(erase_event);\n        ios_base::copyfmt(__rhs);\n        __tie_ = __rhs.__tie_;\n        __fill_ = __rhs.__fill_;\n        __call_callbacks(copyfmt_event);\n        exceptions(__rhs.exceptions());\n    }\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_ios<_CharT, _Traits>::move(basic_ios& __rhs)\n{\n    ios_base::move(__rhs);\n    __tie_ = __rhs.__tie_;\n    __rhs.__tie_ = 0;\n    __fill_ = __rhs.__fill_;\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_ios<_CharT, _Traits>::swap(basic_ios& __rhs) _NOEXCEPT\n{\n    ios_base::swap(__rhs);\n    _VSTD::swap(__tie_, __rhs.__tie_);\n    _VSTD::swap(__fill_, __rhs.__fill_);\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_ios<_CharT, _Traits>::set_rdbuf(basic_streambuf<char_type, traits_type>* __sb)\n{\n    ios_base::set_rdbuf(__sb);\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nboolalpha(ios_base& __str)\n{\n    __str.setf(ios_base::boolalpha);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nnoboolalpha(ios_base& __str)\n{\n    __str.unsetf(ios_base::boolalpha);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nshowbase(ios_base& __str)\n{\n    __str.setf(ios_base::showbase);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nnoshowbase(ios_base& __str)\n{\n    __str.unsetf(ios_base::showbase);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nshowpoint(ios_base& __str)\n{\n    __str.setf(ios_base::showpoint);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nnoshowpoint(ios_base& __str)\n{\n    __str.unsetf(ios_base::showpoint);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nshowpos(ios_base& __str)\n{\n    __str.setf(ios_base::showpos);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nnoshowpos(ios_base& __str)\n{\n    __str.unsetf(ios_base::showpos);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nskipws(ios_base& __str)\n{\n    __str.setf(ios_base::skipws);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nnoskipws(ios_base& __str)\n{\n    __str.unsetf(ios_base::skipws);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nuppercase(ios_base& __str)\n{\n    __str.setf(ios_base::uppercase);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nnouppercase(ios_base& __str)\n{\n    __str.unsetf(ios_base::uppercase);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nunitbuf(ios_base& __str)\n{\n    __str.setf(ios_base::unitbuf);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nnounitbuf(ios_base& __str)\n{\n    __str.unsetf(ios_base::unitbuf);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\ninternal(ios_base& __str)\n{\n    __str.setf(ios_base::internal, ios_base::adjustfield);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nleft(ios_base& __str)\n{\n    __str.setf(ios_base::left, ios_base::adjustfield);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nright(ios_base& __str)\n{\n    __str.setf(ios_base::right, ios_base::adjustfield);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\ndec(ios_base& __str)\n{\n    __str.setf(ios_base::dec, ios_base::basefield);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nhex(ios_base& __str)\n{\n    __str.setf(ios_base::hex, ios_base::basefield);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\noct(ios_base& __str)\n{\n    __str.setf(ios_base::oct, ios_base::basefield);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nfixed(ios_base& __str)\n{\n    __str.setf(ios_base::fixed, ios_base::floatfield);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nscientific(ios_base& __str)\n{\n    __str.setf(ios_base::scientific, ios_base::floatfield);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nhexfloat(ios_base& __str)\n{\n    __str.setf(ios_base::fixed | ios_base::scientific, ios_base::floatfield);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\ndefaultfloat(ios_base& __str)\n{\n    __str.unsetf(ios_base::floatfield);\n    return __str;\n}\n\ntemplate <class _CharT, class _Traits>\nclass __save_flags\n{\n    typedef basic_ios<_CharT, _Traits> __stream_type;\n    typedef typename __stream_type::fmtflags fmtflags;\n\n    __stream_type& __stream_;\n    fmtflags       __fmtflags_;\n    _CharT         __fill_;\n\n    __save_flags(const __save_flags&);\n    __save_flags& operator=(const __save_flags&);\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __save_flags(__stream_type& __stream)\n        : __stream_(__stream),\n          __fmtflags_(__stream.flags()),\n          __fill_(__stream.fill())\n        {}\n    _LIBCPP_INLINE_VISIBILITY\n    ~__save_flags()\n    {\n        __stream_.flags(__fmtflags_);\n        __stream_.fill(__fill_);\n    }\n};\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_IOS\n","//\n//  interpolate.h\n//  ARToolKit5\n//\n//  This file is part of ARToolKit.\n//\n//  ARToolKit is free software: you can redistribute it and/or modify\n//  it under the terms of the GNU Lesser General Public License as published by\n//  the Free Software Foundation, either version 3 of the License, or\n//  (at your option) any later version.\n//\n//  ARToolKit is distributed in the hope that it will be useful,\n//  but WITHOUT ANY WARRANTY; without even the implied warranty of\n//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n//  GNU Lesser General Public License for more details.\n//\n//  You should have received a copy of the GNU Lesser General Public License\n//  along with ARToolKit.  If not, see <http://www.gnu.org/licenses/>.\n//\n//  As a special exception, the copyright holders of this library give you\n//  permission to link this library with independent modules to produce an\n//  executable, regardless of the license terms of these independent modules, and to\n//  copy and distribute the resulting executable under terms of your choice,\n//  provided that you also meet, for each linked independent module, the terms and\n//  conditions of the license of that module. An independent module is a module\n//  which is neither derived from nor based on this library. If you modify this\n//  library, you may extend this exception to your version of the library, but you\n//  are not obligated to do so. If you do not wish to do so, delete this exception\n//  statement from your version.\n//\n//  Copyright 2013-2015 Daqri, LLC.\n//\n//  Author(s): Chris Broaddus\n//\n\n#pragma once\n\n#include <framework/error.h>\n#include <framework/image.h>\n#include <math/math_utils.h>\n\nnamespace vision {\n    \n    /**\n     * Perform bilinear interpolation.\n     *\n     * @param[in] im Image\n     * @param[in] width Widht of image\n     * @param[in] height Height of image\n     * @param[in] step Width step\n     * @param[in] x x-location to interpolate\n     * @param[in] y y-location to interpolate\n     */\n    template<typename Tin, typename Tout>\n    inline Tout bilinear_interpolation(const Tin* im,\n                                       size_t width,\n                                       size_t height,\n                                       size_t step,\n                                       float x,\n                                       float y) {\n        int xp, yp;\n        int xp_plus_1, yp_plus_1;\n        Tout w0, w1, w2, w3;\n        const Tin* p0;\n        const Tin* p1;\n        Tout res;\n        \n        // Integer casting and floor should be the same since (x,y) are always positive\n        ASSERT((int)std::floor(x) == (int)x, \"floor() and cast not the same\");\n        ASSERT((int)std::floor(y) == (int)y, \"floor() and cast not the same\");\n        \n        // Compute location of 4 neighbor pixels\n        xp = (int)x;\n        yp = (int)y;\n        xp_plus_1 = xp+1;\n        yp_plus_1 = yp+1;\n        \n        // Some sanity checks\n        ASSERT(yp >= 0 && yp < height, \"yp out of bounds\");\n        ASSERT(yp_plus_1 >= 0 && yp_plus_1 < height, \"yp_plus_1 out of bounds\");\n        ASSERT(xp >= 0 && xp < width, \"xp out of bounds\");\n        ASSERT(xp_plus_1 >= 0 && xp_plus_1 < width, \"xp_plus_1 out of bounds\");\n        \n        // Pointer to 2 image rows\n        p0 = (const Tin*)((const unsigned char*)im+step*yp);\n        p1 = (const Tin*)((const unsigned char*)p0+step);\n        \n        // Compute weights\n        w0 = (xp_plus_1-x)*(yp_plus_1-y);\n        w1 = (x-xp)*(yp_plus_1-y);\n        w2 = (xp_plus_1-x)*(y-yp);\n        w3 = (x-xp)*(y-yp);\n        \n        ASSERT(w0 >= 0 && w0 <= 1.0001, \"Out of range\");\n        ASSERT(w1 >= 0 && w1 <= 1.0001, \"Out of range\");\n        ASSERT(w2 >= 0 && w2 <= 1.0001, \"Out of range\");\n        ASSERT(w3 >= 0 && w3 <= 1.0001, \"Out of range\");\n        ASSERT((w0+w1+w2+w3) <= 1.0001, \"Out of range\");\n        \n        // Compute weighted pixel\n        res = w0*p0[xp] + w1*p0[xp_plus_1] + w2*p1[xp] + w3*p1[xp_plus_1];\n        \n        return res;\n    }\n    template<typename T>\n    inline T bilinear_interpolation(const T* im,\n                                    size_t width,\n                                    size_t height,\n                                    size_t step,\n                                    float x,\n                                    float y) {\n        return bilinear_interpolation<T, T>(im, width, height, step, x, y); \n    }\n    \n    /**\n     * Perform bilinear interpolation on an \"unsigned char\" image. The interpolation is done in \n     * FLOAT precision and rounded.\n     */\n    inline unsigned char bilinear_interpolation(const unsigned char* im,\n                                                size_t width,\n                                                size_t height,\n                                                size_t step,\n                                                float x,\n                                                float y) {\n        float ret = bilinear_interpolation<unsigned char, float>(im, width, height, step, x, y);\n        ASSERT(ret >= 0, \"Out of range\");\n        ASSERT(ret <= 255, \"Out of range\");\n        return (unsigned char)(ret+0.5f);\n    }\n    \n    /**\n     * Bilinear interpolation. Integer pixel locations specify the center of the pixel.\n     *\n     * @param[in] im Image\n     * @param[in] x\n     * @param[in] y\n     */\n    template<typename Tin, typename Tout>\n    inline Tout bilinear_interpolation(const Image& im,\n                                        float x,\n                                        float y) {\n        return bilinear_interpolation<Tin, Tout>((const Tin*)im.get(), im.width(), im.height(), im.step(), x, y);\n    }\n    template<typename T>\n    inline T bilinear_interpolation(const Image& im,\n                                    float x,\n                                    float y) {\n        return bilinear_interpolation<T>((const T*)im.get(), im.width(), im.height(), im.step(), x, y);\n    }\n    \n} // vision","// -*- C++ -*-\n//===-------------------------- ostream -----------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_OSTREAM\n#define _LIBCPP_OSTREAM\n\n/*\n    ostream synopsis\n\ntemplate <class charT, class traits = char_traits<charT> >\nclass basic_ostream\n    : virtual public basic_ios<charT,traits>\n{\npublic:\n    // types (inherited from basic_ios (27.5.4)):\n    typedef charT                          char_type;\n    typedef traits                         traits_type;\n    typedef typename traits_type::int_type int_type;\n    typedef typename traits_type::pos_type pos_type;\n    typedef typename traits_type::off_type off_type;\n\n    // 27.7.2.2 Constructor/destructor:\n    explicit basic_ostream(basic_streambuf<char_type,traits>* sb);\n    basic_ostream(basic_ostream&& rhs);\n    virtual ~basic_ostream();\n\n    // 27.7.2.3 Assign/swap\n    basic_ostream& operator=(const basic_ostream& rhs) = delete; // C++14\n    basic_ostream& operator=(basic_ostream&& rhs);\n    void swap(basic_ostream& rhs);\n\n    // 27.7.2.4 Prefix/suffix:\n    class sentry;\n\n    // 27.7.2.6 Formatted output:\n    basic_ostream& operator<<(basic_ostream& (*pf)(basic_ostream&));\n    basic_ostream& operator<<(basic_ios<charT, traits>& (*pf)(basic_ios<charT,traits>&));\n    basic_ostream& operator<<(ios_base& (*pf)(ios_base&));\n    basic_ostream& operator<<(bool n);\n    basic_ostream& operator<<(short n);\n    basic_ostream& operator<<(unsigned short n);\n    basic_ostream& operator<<(int n);\n    basic_ostream& operator<<(unsigned int n);\n    basic_ostream& operator<<(long n);\n    basic_ostream& operator<<(unsigned long n);\n    basic_ostream& operator<<(long long n);\n    basic_ostream& operator<<(unsigned long long n);\n    basic_ostream& operator<<(float f);\n    basic_ostream& operator<<(double f);\n    basic_ostream& operator<<(long double f);\n    basic_ostream& operator<<(const void* p);\n    basic_ostream& operator<<(basic_streambuf<char_type,traits>* sb);\n\n    // 27.7.2.7 Unformatted output:\n    basic_ostream& put(char_type c);\n    basic_ostream& write(const char_type* s, streamsize n);\n    basic_ostream& flush();\n\n    // 27.7.2.5 seeks:\n    pos_type tellp();\n    basic_ostream& seekp(pos_type);\n    basic_ostream& seekp(off_type, ios_base::seekdir);\nprotected:\n    basic_ostream(const basic_ostream& rhs) = delete;\n    basic_ostream(basic_ostream&& rhs);\n    // 27.7.3.3 Assign/swap\n    basic_ostream& operator=(basic_ostream& rhs) = delete;\n    basic_ostream& operator=(const basic_ostream&& rhs);\n    void swap(basic_ostream& rhs);\n};\n\n// 27.7.2.6.4 character inserters\n\ntemplate<class charT, class traits>\n  basic_ostream<charT,traits>& operator<<(basic_ostream<charT,traits>&, charT);\n\ntemplate<class charT, class traits>\n  basic_ostream<charT,traits>& operator<<(basic_ostream<charT,traits>&, char);\n\ntemplate<class traits>\n  basic_ostream<char,traits>& operator<<(basic_ostream<char,traits>&, char);\n\n// signed and unsigned\n\ntemplate<class traits>\n  basic_ostream<char,traits>& operator<<(basic_ostream<char,traits>&, signed char);\n\ntemplate<class traits>\n  basic_ostream<char,traits>& operator<<(basic_ostream<char,traits>&, unsigned char);\n\n// NTBS\ntemplate<class charT, class traits>\n  basic_ostream<charT,traits>& operator<<(basic_ostream<charT,traits>&, const charT*);\n\ntemplate<class charT, class traits>\n  basic_ostream<charT,traits>& operator<<(basic_ostream<charT,traits>&, const char*);\n\ntemplate<class traits>\n  basic_ostream<char,traits>& operator<<(basic_ostream<char,traits>&, const char*);\n\n// signed and unsigned\ntemplate<class traits>\nbasic_ostream<char,traits>& operator<<(basic_ostream<char,traits>&, const signed char*);\n\ntemplate<class traits>\n  basic_ostream<char,traits>& operator<<(basic_ostream<char,traits>&, const unsigned char*);\n\n// swap:\ntemplate <class charT, class traits>\n  void swap(basic_ostream<charT, traits>& x, basic_ostream<charT, traits>& y);\n\ntemplate <class charT, class traits>\n  basic_ostream<charT,traits>& endl(basic_ostream<charT,traits>& os);\n\ntemplate <class charT, class traits>\n  basic_ostream<charT,traits>& ends(basic_ostream<charT,traits>& os);\n\ntemplate <class charT, class traits>\n  basic_ostream<charT,traits>& flush(basic_ostream<charT,traits>& os);\n\n// rvalue stream insertion\ntemplate <class charT, class traits, class T>\n  basic_ostream<charT, traits>&\n  operator<<(basic_ostream<charT, traits>&& os, const T& x);\n\n}  // std\n\n*/\n\n#include <__config>\n#include <ios>\n#include <streambuf>\n#include <locale>\n#include <iterator>\n#include <bitset>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\ntemplate <class _CharT, class _Traits>\nclass _LIBCPP_TEMPLATE_VIS basic_ostream\n    : virtual public basic_ios<_CharT, _Traits>\n{\npublic:\n    // types (inherited from basic_ios (27.5.4)):\n    typedef _CharT                         char_type;\n    typedef _Traits                        traits_type;\n    typedef typename traits_type::int_type int_type;\n    typedef typename traits_type::pos_type pos_type;\n    typedef typename traits_type::off_type off_type;\n\n    // 27.7.2.2 Constructor/destructor:\n    inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY\n    explicit basic_ostream(basic_streambuf<char_type, traits_type>* __sb)\n    { this->init(__sb); }\n    virtual ~basic_ostream();\nprotected:\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    inline _LIBCPP_INLINE_VISIBILITY\n    basic_ostream(basic_ostream&& __rhs);\n#endif\n\n    // 27.7.2.3 Assign/swap\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    inline _LIBCPP_INLINE_VISIBILITY\n    basic_ostream& operator=(basic_ostream&& __rhs);\n#endif\n    inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY\n    void swap(basic_ostream& __rhs)\n    { basic_ios<char_type, traits_type>::swap(__rhs); }\n\n#ifndef _LIBCPP_CXX03_LANG\n    basic_ostream           (const basic_ostream& __rhs) = delete;\n    basic_ostream& operator=(const basic_ostream& __rhs) = delete;\n#else\n    basic_ostream           (const basic_ostream& __rhs); // not defined\n    basic_ostream& operator=(const basic_ostream& __rhs); // not defined\n#endif\npublic:\n\n    // 27.7.2.4 Prefix/suffix:\n    class _LIBCPP_TEMPLATE_VIS sentry;\n\n    // 27.7.2.6 Formatted output:\n    inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY\n    basic_ostream& operator<<(basic_ostream& (*__pf)(basic_ostream&))\n    { return __pf(*this); }\n\n    inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY\n    basic_ostream& operator<<(basic_ios<char_type, traits_type>&\n                              (*__pf)(basic_ios<char_type,traits_type>&))\n    { __pf(*this); return *this; }\n\n    inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY\n    basic_ostream& operator<<(ios_base& (*__pf)(ios_base&))\n    { __pf(*this); return *this; }\n\n    basic_ostream& operator<<(bool __n);\n    basic_ostream& operator<<(short __n);\n    basic_ostream& operator<<(unsigned short __n);\n    basic_ostream& operator<<(int __n);\n    basic_ostream& operator<<(unsigned int __n);\n    basic_ostream& operator<<(long __n);\n    basic_ostream& operator<<(unsigned long __n);\n    basic_ostream& operator<<(long long __n);\n    basic_ostream& operator<<(unsigned long long __n);\n    basic_ostream& operator<<(float __f);\n    basic_ostream& operator<<(double __f);\n    basic_ostream& operator<<(long double __f);\n    basic_ostream& operator<<(const void* __p);\n    basic_ostream& operator<<(basic_streambuf<char_type, traits_type>* __sb);\n\n    // 27.7.2.7 Unformatted output:\n    basic_ostream& put(char_type __c);\n    basic_ostream& write(const char_type* __s, streamsize __n);\n    basic_ostream& flush();\n\n    // 27.7.2.5 seeks:\n    inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY\n    pos_type tellp();\n    inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY\n    basic_ostream& seekp(pos_type __pos);\n    inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY\n    basic_ostream& seekp(off_type __off, ios_base::seekdir __dir);\n\nprotected:\n    _LIBCPP_ALWAYS_INLINE\n    basic_ostream() {}  // extension, intentially does not initialize\n};\n\ntemplate <class _CharT, class _Traits>\nclass _LIBCPP_TEMPLATE_VIS basic_ostream<_CharT, _Traits>::sentry\n{\n    bool __ok_;\n    basic_ostream<_CharT, _Traits>& __os_;\n\n    sentry(const sentry&); // = delete;\n    sentry& operator=(const sentry&); // = delete;\n\npublic:\n    explicit sentry(basic_ostream<_CharT, _Traits>& __os);\n    ~sentry();\n\n    _LIBCPP_ALWAYS_INLINE\n        _LIBCPP_EXPLICIT\n        operator bool() const {return __ok_;}\n};\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>::sentry::sentry(basic_ostream<_CharT, _Traits>& __os)\n    : __ok_(false),\n      __os_(__os)\n{\n    if (__os.good())\n    {\n        if (__os.tie())\n            __os.tie()->flush();\n        __ok_ = true;\n    }\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>::sentry::~sentry()\n{\n    if (__os_.rdbuf() && __os_.good() && (__os_.flags() & ios_base::unitbuf)\n                      && !uncaught_exception())\n    {\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        try\n        {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n            if (__os_.rdbuf()->pubsync() == -1)\n                __os_.setstate(ios_base::badbit);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        }\n        catch (...)\n        {\n        }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    }\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>::basic_ostream(basic_ostream&& __rhs)\n{\n    this->move(__rhs);\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::operator=(basic_ostream&& __rhs)\n{\n    swap(__rhs);\n    return *this;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>::~basic_ostream()\n{\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::operator<<(basic_streambuf<char_type, traits_type>* __sb)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            if (__sb)\n            {\n#ifndef _LIBCPP_NO_EXCEPTIONS\n                try\n                {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n                    typedef istreambuf_iterator<_CharT, _Traits> _Ip;\n                    typedef ostreambuf_iterator<_CharT, _Traits> _Op;\n                    _Ip __i(__sb);\n                    _Ip __eof;\n                    _Op __o(*this);\n                    size_t __c = 0;\n                    for (; __i != __eof; ++__i, ++__o, ++__c)\n                    {\n                        *__o = *__i;\n                        if (__o.failed())\n                            break;\n                    }\n                    if (__c == 0)\n                        this->setstate(ios_base::failbit);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n                }\n                catch (...)\n                {\n                    this->__set_failbit_and_consider_rethrow();\n                }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n            }\n            else\n                this->setstate(ios_base::badbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::operator<<(bool __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;\n            const _Fp& __f = use_facet<_Fp>(this->getloc());\n            if (__f.put(*this, *this, this->fill(), __n).failed())\n                this->setstate(ios_base::badbit | ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::operator<<(short __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            ios_base::fmtflags __flags = ios_base::flags() & ios_base::basefield;\n            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;\n            const _Fp& __f = use_facet<_Fp>(this->getloc());\n            if (__f.put(*this, *this, this->fill(),\n                        __flags == ios_base::oct || __flags == ios_base::hex ?\n                        static_cast<long>(static_cast<unsigned short>(__n))  :\n                        static_cast<long>(__n)).failed())\n                this->setstate(ios_base::badbit | ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::operator<<(unsigned short __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;\n            const _Fp& __f = use_facet<_Fp>(this->getloc());\n            if (__f.put(*this, *this, this->fill(), static_cast<unsigned long>(__n)).failed())\n                this->setstate(ios_base::badbit | ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::operator<<(int __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            ios_base::fmtflags __flags = ios_base::flags() & ios_base::basefield;\n            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;\n            const _Fp& __f = use_facet<_Fp>(this->getloc());\n            if (__f.put(*this, *this, this->fill(),\n                        __flags == ios_base::oct || __flags == ios_base::hex ?\n                        static_cast<long>(static_cast<unsigned int>(__n))  :\n                        static_cast<long>(__n)).failed())\n                this->setstate(ios_base::badbit | ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::operator<<(unsigned int __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;\n            const _Fp& __f = use_facet<_Fp>(this->getloc());\n            if (__f.put(*this, *this, this->fill(), static_cast<unsigned long>(__n)).failed())\n                this->setstate(ios_base::badbit | ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::operator<<(long __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;\n            const _Fp& __f = use_facet<_Fp>(this->getloc());\n            if (__f.put(*this, *this, this->fill(), __n).failed())\n                this->setstate(ios_base::badbit | ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::operator<<(unsigned long __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;\n            const _Fp& __f = use_facet<_Fp>(this->getloc());\n            if (__f.put(*this, *this, this->fill(), __n).failed())\n                this->setstate(ios_base::badbit | ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::operator<<(long long __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;\n            const _Fp& __f = use_facet<_Fp>(this->getloc());\n            if (__f.put(*this, *this, this->fill(), __n).failed())\n                this->setstate(ios_base::badbit | ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::operator<<(unsigned long long __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;\n            const _Fp& __f = use_facet<_Fp>(this->getloc());\n            if (__f.put(*this, *this, this->fill(), __n).failed())\n                this->setstate(ios_base::badbit | ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::operator<<(float __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;\n            const _Fp& __f = use_facet<_Fp>(this->getloc());\n            if (__f.put(*this, *this, this->fill(), static_cast<double>(__n)).failed())\n                this->setstate(ios_base::badbit | ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::operator<<(double __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;\n            const _Fp& __f = use_facet<_Fp>(this->getloc());\n            if (__f.put(*this, *this, this->fill(), __n).failed())\n                this->setstate(ios_base::badbit | ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::operator<<(long double __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;\n            const _Fp& __f = use_facet<_Fp>(this->getloc());\n            if (__f.put(*this, *this, this->fill(), __n).failed())\n                this->setstate(ios_base::badbit | ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::operator<<(const void* __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;\n            const _Fp& __f = use_facet<_Fp>(this->getloc());\n            if (__f.put(*this, *this, this->fill(), __n).failed())\n                this->setstate(ios_base::badbit | ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate<class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\n__put_character_sequence(basic_ostream<_CharT, _Traits>& __os,\n                          const _CharT* __str, size_t __len)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        typename basic_ostream<_CharT, _Traits>::sentry __s(__os);\n        if (__s)\n        {\n            typedef ostreambuf_iterator<_CharT, _Traits> _Ip;\n            if (__pad_and_output(_Ip(__os),\n                                 __str,\n                                 (__os.flags() & ios_base::adjustfield) == ios_base::left ?\n                                     __str + __len :\n                                     __str,\n                                 __str + __len,\n                                 __os,\n                                 __os.fill()).failed())\n                __os.setstate(ios_base::badbit | ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        __os.__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return __os;\n}\n\n\ntemplate<class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\noperator<<(basic_ostream<_CharT, _Traits>& __os, _CharT __c)\n{\n    return _VSTD::__put_character_sequence(__os, &__c, 1);\n}\n\ntemplate<class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\noperator<<(basic_ostream<_CharT, _Traits>& __os, char __cn)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        typename basic_ostream<_CharT, _Traits>::sentry __s(__os);\n        if (__s)\n        {\n            _CharT __c = __os.widen(__cn);\n            typedef ostreambuf_iterator<_CharT, _Traits> _Ip;\n            if (__pad_and_output(_Ip(__os),\n                                 &__c,\n                                 (__os.flags() & ios_base::adjustfield) == ios_base::left ?\n                                     &__c + 1 :\n                                     &__c,\n                                 &__c + 1,\n                                 __os,\n                                 __os.fill()).failed())\n                __os.setstate(ios_base::badbit | ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        __os.__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return __os;\n}\n\ntemplate<class _Traits>\nbasic_ostream<char, _Traits>&\noperator<<(basic_ostream<char, _Traits>& __os, char __c)\n{\n    return _VSTD::__put_character_sequence(__os, &__c, 1);\n}\n\ntemplate<class _Traits>\nbasic_ostream<char, _Traits>&\noperator<<(basic_ostream<char, _Traits>& __os, signed char __c)\n{\n    return _VSTD::__put_character_sequence(__os, (char *) &__c, 1);\n}\n\ntemplate<class _Traits>\nbasic_ostream<char, _Traits>&\noperator<<(basic_ostream<char, _Traits>& __os, unsigned char __c)\n{\n    return _VSTD::__put_character_sequence(__os, (char *) &__c, 1);\n}\n\ntemplate<class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\noperator<<(basic_ostream<_CharT, _Traits>& __os, const _CharT* __str)\n{\n    return _VSTD::__put_character_sequence(__os, __str, _Traits::length(__str));\n}\n\ntemplate<class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\noperator<<(basic_ostream<_CharT, _Traits>& __os, const char* __strn)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        typename basic_ostream<_CharT, _Traits>::sentry __s(__os);\n        if (__s)\n        {\n            typedef ostreambuf_iterator<_CharT, _Traits> _Ip;\n            size_t __len = char_traits<char>::length(__strn);\n            const int __bs = 100;\n            _CharT __wbb[__bs];\n            _CharT* __wb = __wbb;\n            unique_ptr<_CharT, void(*)(void*)> __h(0, free);\n            if (__len > __bs)\n            {\n                __wb = (_CharT*)malloc(__len*sizeof(_CharT));\n                if (__wb == 0)\n                    __throw_bad_alloc();\n                __h.reset(__wb);\n            }\n            for (_CharT* __p = __wb; *__strn != '\\0'; ++__strn, ++__p)\n                *__p = __os.widen(*__strn);\n            if (__pad_and_output(_Ip(__os),\n                                 __wb,\n                                 (__os.flags() & ios_base::adjustfield) == ios_base::left ?\n                                     __wb + __len :\n                                     __wb,\n                                 __wb + __len,\n                                 __os,\n                                 __os.fill()).failed())\n                __os.setstate(ios_base::badbit | ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        __os.__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return __os;\n}\n\ntemplate<class _Traits>\nbasic_ostream<char, _Traits>&\noperator<<(basic_ostream<char, _Traits>& __os, const char* __str)\n{\n    return _VSTD::__put_character_sequence(__os, __str, _Traits::length(__str));\n}\n\ntemplate<class _Traits>\nbasic_ostream<char, _Traits>&\noperator<<(basic_ostream<char, _Traits>& __os, const signed char* __str)\n{\n    const char *__s = (const char *) __str;\n    return _VSTD::__put_character_sequence(__os, __s, _Traits::length(__s));\n}\n\ntemplate<class _Traits>\nbasic_ostream<char, _Traits>&\noperator<<(basic_ostream<char, _Traits>& __os, const unsigned char* __str)\n{\n    const char *__s = (const char *) __str;\n    return _VSTD::__put_character_sequence(__os, __s, _Traits::length(__s));\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::put(char_type __c)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            typedef ostreambuf_iterator<_CharT, _Traits> _Op;\n            _Op __o(*this);\n            *__o = __c;\n            if (__o.failed())\n                this->setstate(ios_base::badbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::write(const char_type* __s, streamsize __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __sen(*this);\n        if (__sen && __n)\n        {\n            if (this->rdbuf()->sputn(__s, __n) != __n)\n                this->setstate(ios_base::badbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::flush()\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        if (this->rdbuf())\n        {\n            sentry __s(*this);\n            if (__s)\n            {\n                if (this->rdbuf()->pubsync() == -1)\n                    this->setstate(ios_base::badbit);\n            }\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\ntypename basic_ostream<_CharT, _Traits>::pos_type\nbasic_ostream<_CharT, _Traits>::tellp()\n{\n    if (this->fail())\n        return pos_type(-1);\n    return this->rdbuf()->pubseekoff(0, ios_base::cur, ios_base::out);\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::seekp(pos_type __pos)\n{\n    sentry __s(*this);\n    if (!this->fail())\n    {\n        if (this->rdbuf()->pubseekpos(__pos, ios_base::out) == pos_type(-1))\n            this->setstate(ios_base::failbit);\n    }\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::seekp(off_type __off, ios_base::seekdir __dir)\n{\n    sentry __s(*this);\n    if (!this->fail())\n    {\n        if (this->rdbuf()->pubseekoff(__off, __dir, ios_base::out) == pos_type(-1))\n            this->setstate(ios_base::failbit);\n    }\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_ostream<_CharT, _Traits>&\nendl(basic_ostream<_CharT, _Traits>& __os)\n{\n    __os.put(__os.widen('\\n'));\n    __os.flush();\n    return __os;\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_ostream<_CharT, _Traits>&\nends(basic_ostream<_CharT, _Traits>& __os)\n{\n    __os.put(_CharT());\n    return __os;\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_ostream<_CharT, _Traits>&\nflush(basic_ostream<_CharT, _Traits>& __os)\n{\n    __os.flush();\n    return __os;\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Stream, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    !is_lvalue_reference<_Stream>::value &&\n    is_base_of<ios_base, _Stream>::value,\n    _Stream&&\n>::type\noperator<<(_Stream&& __os, const _Tp& __x)\n{\n    __os << __x;\n    return _VSTD::move(__os);\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_ostream<_CharT, _Traits>&\noperator<<(basic_ostream<_CharT, _Traits>& __os,\n           const basic_string<_CharT, _Traits, _Allocator>& __str)\n{\n    return _VSTD::__put_character_sequence(__os, __str.data(), __str.size());\n}\n\ntemplate<class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\noperator<<(basic_ostream<_CharT, _Traits>& __os,\n           const basic_string_view<_CharT, _Traits> __sv)\n{\n    return _VSTD::__put_character_sequence(__os, __sv.data(), __sv.size());\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_ostream<_CharT, _Traits>&\noperator<<(basic_ostream<_CharT, _Traits>& __os, const error_code& __ec)\n{\n    return __os << __ec.category().name() << ':' << __ec.value();\n}\n\ntemplate<class _CharT, class _Traits, class _Yp>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_ostream<_CharT, _Traits>&\noperator<<(basic_ostream<_CharT, _Traits>& __os, shared_ptr<_Yp> const& __p)\n{\n    return __os << __p.get();\n}\n\ntemplate <class _CharT, class _Traits, size_t _Size>\nbasic_ostream<_CharT, _Traits>&\noperator<<(basic_ostream<_CharT, _Traits>& __os, const bitset<_Size>& __x)\n{\n    return __os << __x.template to_string<_CharT, _Traits>\n                        (use_facet<ctype<_CharT> >(__os.getloc()).widen('0'),\n                         use_facet<ctype<_CharT> >(__os.getloc()).widen('1'));\n}\n\n_LIBCPP_EXTERN_TEMPLATE(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS basic_ostream<char>)\n_LIBCPP_EXTERN_TEMPLATE(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS basic_ostream<wchar_t>)\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_OSTREAM\n","// -*- C++ -*-\n//===----------------------------------------------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP___LOCALE\n#define _LIBCPP___LOCALE\n\n#include <__config>\n#include <string>\n#include <memory>\n#include <utility>\n#include <mutex>\n#include <cstdint>\n#include <cctype>\n#include <locale.h>\n#if defined(_LIBCPP_MSVCRT) || defined(__MINGW32__)\n# include <support/win32/locale_win32.h>\n#elif defined(_AIX)\n# include <support/ibm/xlocale.h>\n#elif defined(__ANDROID__)\n// Android gained the locale aware functions in L (API level 21)\n# include <android/api-level.h>\n# if __ANDROID_API__ <= 20\n#  include <support/android/locale_bionic.h>\n# endif\n#elif defined(__sun__)\n# include <xlocale.h>\n# include <support/solaris/xlocale.h>\n#elif defined(_NEWLIB_VERSION)\n# include <support/newlib/xlocale.h>\n#elif (defined(__GLIBC__) || defined(__APPLE__)      || defined(__FreeBSD__) \\\n    || defined(__EMSCRIPTEN__) || defined(__IBMCPP__))\n# include <xlocale.h>\n#elif defined(_LIBCPP_HAS_MUSL_LIBC)\n# include <support/musl/xlocale.h>\n#endif // __GLIBC__ || __APPLE__ || __FreeBSD__ || __sun__ || __EMSCRIPTEN__ || __IBMCPP__\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\nclass _LIBCPP_TYPE_VIS locale;\n\ntemplate <class _Facet>\n_LIBCPP_INLINE_VISIBILITY\nbool\nhas_facet(const locale&) _NOEXCEPT;\n\ntemplate <class _Facet>\n_LIBCPP_INLINE_VISIBILITY\nconst _Facet&\nuse_facet(const locale&);\n\nclass _LIBCPP_TYPE_VIS locale\n{\npublic:\n    // types:\n    class _LIBCPP_TYPE_VIS facet;\n    class _LIBCPP_TYPE_VIS id;\n\n    typedef int category;\n    static const category // values assigned here are for exposition only\n        none     = 0,\n        collate  = LC_COLLATE_MASK,\n        ctype    = LC_CTYPE_MASK,\n        monetary = LC_MONETARY_MASK,\n        numeric  = LC_NUMERIC_MASK,\n        time     = LC_TIME_MASK,\n        messages = LC_MESSAGES_MASK,\n        all = collate | ctype | monetary | numeric | time | messages;\n\n    // construct/copy/destroy:\n    locale()  _NOEXCEPT;\n    locale(const locale&)  _NOEXCEPT;\n    explicit locale(const char*);\n    explicit locale(const string&);\n    locale(const locale&, const char*, category);\n    locale(const locale&, const string&, category);\n    template <class _Facet>\n        _LIBCPP_INLINE_VISIBILITY locale(const locale&, _Facet*);\n    locale(const locale&, const locale&, category);\n\n    ~locale();\n\n    const locale& operator=(const locale&)  _NOEXCEPT;\n\n    template <class _Facet> locale combine(const locale&) const;\n\n    // locale operations:\n    string name() const;\n    bool operator==(const locale&) const;\n    bool operator!=(const locale& __y) const {return !(*this == __y);}\n    template <class _CharT, class _Traits, class _Allocator>\n      bool operator()(const basic_string<_CharT, _Traits, _Allocator>&,\n                      const basic_string<_CharT, _Traits, _Allocator>&) const;\n\n    // global locale objects:\n    static locale global(const locale&);\n    static const locale& classic();\n\nprivate:\n    class __imp;\n    __imp* __locale_;\n\n    void __install_ctor(const locale&, facet*, long);\n    static locale& __global();\n    bool has_facet(id&) const;\n    const facet* use_facet(id&) const;\n\n    template <class _Facet> friend bool has_facet(const locale&)  _NOEXCEPT;\n    template <class _Facet> friend const _Facet& use_facet(const locale&);\n};\n\nclass _LIBCPP_TYPE_VIS locale::facet\n    : public __shared_count\n{\nprotected:\n    _LIBCPP_INLINE_VISIBILITY\n    explicit facet(size_t __refs = 0)\n        : __shared_count(static_cast<long>(__refs)-1) {}\n\n    virtual ~facet();\n\n//    facet(const facet&) = delete;     // effectively done in __shared_count\n//    void operator=(const facet&) = delete;\nprivate:\n    virtual void __on_zero_shared() _NOEXCEPT;\n};\n\nclass _LIBCPP_TYPE_VIS locale::id\n{\n    once_flag      __flag_;\n    int32_t        __id_;\n\n    static int32_t __next_id;\npublic:\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR id() :__id_(0) {}\nprivate:\n    void __init();\n    void operator=(const id&); // = delete;\n    id(const id&); // = delete;\npublic:  // only needed for tests\n    long __get();\n\n    friend class locale;\n    friend class locale::__imp;\n};\n\ntemplate <class _Facet>\ninline _LIBCPP_INLINE_VISIBILITY\nlocale::locale(const locale& __other, _Facet* __f)\n{\n    __install_ctor(__other, __f, __f ? __f->id.__get() : 0);\n}\n\ntemplate <class _Facet>\nlocale\nlocale::combine(const locale& __other) const\n{\n    if (!_VSTD::has_facet<_Facet>(__other))\n        __throw_runtime_error(\"locale::combine: locale missing facet\");\n\n    return locale(*this, &const_cast<_Facet&>(_VSTD::use_facet<_Facet>(__other)));\n}\n\ntemplate <class _Facet>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nhas_facet(const locale& __l)  _NOEXCEPT\n{\n    return __l.has_facet(_Facet::id);\n}\n\ntemplate <class _Facet>\ninline _LIBCPP_INLINE_VISIBILITY\nconst _Facet&\nuse_facet(const locale& __l)\n{\n    return static_cast<const _Facet&>(*__l.use_facet(_Facet::id));\n}\n\n// template <class _CharT> class collate;\n\ntemplate <class _CharT>\nclass _LIBCPP_TEMPLATE_VIS collate\n    : public locale::facet\n{\npublic:\n    typedef _CharT char_type;\n    typedef basic_string<char_type> string_type;\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit collate(size_t __refs = 0)\n        : locale::facet(__refs) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    int compare(const char_type* __lo1, const char_type* __hi1,\n                const char_type* __lo2, const char_type* __hi2) const\n    {\n        return do_compare(__lo1, __hi1, __lo2, __hi2);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    string_type transform(const char_type* __lo, const char_type* __hi) const\n    {\n        return do_transform(__lo, __hi);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    long hash(const char_type* __lo, const char_type* __hi) const\n    {\n        return do_hash(__lo, __hi);\n    }\n\n    static locale::id id;\n\nprotected:\n    ~collate();\n    virtual int do_compare(const char_type* __lo1, const char_type* __hi1,\n                           const char_type* __lo2, const char_type* __hi2) const;\n    virtual string_type do_transform(const char_type* __lo, const char_type* __hi) const\n        {return string_type(__lo, __hi);}\n    virtual long do_hash(const char_type* __lo, const char_type* __hi) const;\n};\n\ntemplate <class _CharT> locale::id collate<_CharT>::id;\n\ntemplate <class _CharT>\ncollate<_CharT>::~collate()\n{\n}\n\ntemplate <class _CharT>\nint\ncollate<_CharT>::do_compare(const char_type* __lo1, const char_type* __hi1,\n                            const char_type* __lo2, const char_type* __hi2) const\n{\n    for (; __lo2 != __hi2; ++__lo1, ++__lo2)\n    {\n        if (__lo1 == __hi1 || *__lo1 < *__lo2)\n            return -1;\n        if (*__lo2 < *__lo1)\n            return 1;\n    }\n    return __lo1 != __hi1;\n}\n\ntemplate <class _CharT>\nlong\ncollate<_CharT>::do_hash(const char_type* __lo, const char_type* __hi) const\n{\n    size_t __h = 0;\n    const size_t __sr = __CHAR_BIT__ * sizeof(size_t) - 8;\n    const size_t __mask = size_t(0xF) << (__sr + 4);\n    for(const char_type* __p = __lo; __p != __hi; ++__p)\n    {\n        __h = (__h << 4) + static_cast<size_t>(*__p);\n        size_t __g = __h & __mask;\n        __h ^= __g | (__g >> __sr);\n    }\n    return static_cast<long>(__h);\n}\n\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS collate<char>)\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS collate<wchar_t>)\n\n// template <class CharT> class collate_byname;\n\ntemplate <class _CharT> class _LIBCPP_TEMPLATE_VIS collate_byname;\n\ntemplate <>\nclass _LIBCPP_TYPE_VIS collate_byname<char>\n    : public collate<char>\n{\n    locale_t __l;\npublic:\n    typedef char char_type;\n    typedef basic_string<char_type> string_type;\n\n    explicit collate_byname(const char* __n, size_t __refs = 0);\n    explicit collate_byname(const string& __n, size_t __refs = 0);\n\nprotected:\n    ~collate_byname();\n    virtual int do_compare(const char_type* __lo1, const char_type* __hi1,\n                           const char_type* __lo2, const char_type* __hi2) const;\n    virtual string_type do_transform(const char_type* __lo, const char_type* __hi) const;\n};\n\ntemplate <>\nclass _LIBCPP_TYPE_VIS collate_byname<wchar_t>\n    : public collate<wchar_t>\n{\n    locale_t __l;\npublic:\n    typedef wchar_t char_type;\n    typedef basic_string<char_type> string_type;\n\n    explicit collate_byname(const char* __n, size_t __refs = 0);\n    explicit collate_byname(const string& __n, size_t __refs = 0);\n\nprotected:\n    ~collate_byname();\n\n    virtual int do_compare(const char_type* __lo1, const char_type* __hi1,\n                           const char_type* __lo2, const char_type* __hi2) const;\n    virtual string_type do_transform(const char_type* __lo, const char_type* __hi) const;\n};\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbool\nlocale::operator()(const basic_string<_CharT, _Traits, _Allocator>& __x,\n                   const basic_string<_CharT, _Traits, _Allocator>& __y) const\n{\n    return _VSTD::use_facet<_VSTD::collate<_CharT> >(*this).compare(\n                                       __x.data(), __x.data() + __x.size(),\n                                       __y.data(), __y.data() + __y.size()) < 0;\n}\n\n// template <class charT> class ctype\n\nclass _LIBCPP_TYPE_VIS ctype_base\n{\npublic:\n#if defined(__GLIBC__)\n    typedef unsigned short mask;\n    static const mask space  = _ISspace;\n    static const mask print  = _ISprint;\n    static const mask cntrl  = _IScntrl;\n    static const mask upper  = _ISupper;\n    static const mask lower  = _ISlower;\n    static const mask alpha  = _ISalpha;\n    static const mask digit  = _ISdigit;\n    static const mask punct  = _ISpunct;\n    static const mask xdigit = _ISxdigit;\n    static const mask blank  = _ISblank;\n#elif defined(_LIBCPP_MSVCRT)\n    typedef unsigned short mask;\n    static const mask space  = _SPACE;\n    static const mask print  = _BLANK|_PUNCT|_ALPHA|_DIGIT;\n    static const mask cntrl  = _CONTROL;\n    static const mask upper  = _UPPER;\n    static const mask lower  = _LOWER;\n    static const mask alpha  = _ALPHA;\n    static const mask digit  = _DIGIT;\n    static const mask punct  = _PUNCT;\n    static const mask xdigit = _HEX;\n    static const mask blank  = _BLANK;\n# define _LIBCPP_CTYPE_MASK_IS_COMPOSITE_PRINT\n#elif defined(__APPLE__) || defined(__FreeBSD__) || defined(__EMSCRIPTEN__) || defined(__NetBSD__)\n# ifdef __APPLE__\n    typedef __uint32_t mask;\n# elif defined(__FreeBSD__)\n    typedef unsigned long mask;\n# elif defined(__EMSCRIPTEN__) || defined(__NetBSD__)\n    typedef unsigned short mask;\n# endif\n    static const mask space  = _CTYPE_S;\n    static const mask print  = _CTYPE_R;\n    static const mask cntrl  = _CTYPE_C;\n    static const mask upper  = _CTYPE_U;\n    static const mask lower  = _CTYPE_L;\n    static const mask alpha  = _CTYPE_A;\n    static const mask digit  = _CTYPE_D;\n    static const mask punct  = _CTYPE_P;\n    static const mask xdigit = _CTYPE_X;\n\n# if defined(__NetBSD__)\n    static const mask blank  = _CTYPE_BL;\n# else\n    static const mask blank  = _CTYPE_B;\n# endif\n#elif defined(__sun__) || defined(_AIX)\n    typedef unsigned int mask;\n    static const mask space  = _ISSPACE;\n    static const mask print  = _ISPRINT;\n    static const mask cntrl  = _ISCNTRL;\n    static const mask upper  = _ISUPPER;\n    static const mask lower  = _ISLOWER;\n    static const mask alpha  = _ISALPHA;\n    static const mask digit  = _ISDIGIT;\n    static const mask punct  = _ISPUNCT;\n    static const mask xdigit = _ISXDIGIT;\n    static const mask blank  = _ISBLANK;\n#elif defined(_NEWLIB_VERSION)\n    // Same type as Newlib's _ctype_ array in newlib/libc/include/ctype.h.\n    typedef char mask;\n    static const mask space  = _S;\n    static const mask print  = _P | _U | _L | _N | _B;\n    static const mask cntrl  = _C;\n    static const mask upper  = _U;\n    static const mask lower  = _L;\n    static const mask alpha  = _U | _L;\n    static const mask digit  = _N;\n    static const mask punct  = _P;\n    static const mask xdigit = _X | _N;\n    static const mask blank  = _B;\n# define _LIBCPP_CTYPE_MASK_IS_COMPOSITE_PRINT\n# define _LIBCPP_CTYPE_MASK_IS_COMPOSITE_ALPHA\n# define _LIBCPP_CTYPE_MASK_IS_COMPOSITE_XDIGIT\n#else\n    typedef unsigned long mask;\n    static const mask space  = 1<<0;\n    static const mask print  = 1<<1;\n    static const mask cntrl  = 1<<2;\n    static const mask upper  = 1<<3;\n    static const mask lower  = 1<<4;\n    static const mask alpha  = 1<<5;\n    static const mask digit  = 1<<6;\n    static const mask punct  = 1<<7;\n    static const mask xdigit = 1<<8;\n    static const mask blank  = 1<<9;\n#endif\n    static const mask alnum  = alpha | digit;\n    static const mask graph  = alnum | punct;\n\n    _LIBCPP_ALWAYS_INLINE ctype_base() {}\n};\n\ntemplate <class _CharT> class _LIBCPP_TEMPLATE_VIS ctype;\n\ntemplate <>\nclass _LIBCPP_TYPE_VIS ctype<wchar_t>\n    : public locale::facet,\n      public ctype_base\n{\npublic:\n    typedef wchar_t char_type;\n\n    _LIBCPP_ALWAYS_INLINE\n    explicit ctype(size_t __refs = 0)\n        : locale::facet(__refs) {}\n\n    _LIBCPP_ALWAYS_INLINE\n    bool is(mask __m, char_type __c) const\n    {\n        return do_is(__m, __c);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    const char_type* is(const char_type* __low, const char_type* __high, mask* __vec) const\n    {\n        return do_is(__low, __high, __vec);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    const char_type* scan_is(mask __m, const char_type* __low, const char_type* __high) const\n    {\n        return do_scan_is(__m, __low, __high);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    const char_type* scan_not(mask __m, const char_type* __low, const char_type* __high) const\n    {\n        return do_scan_not(__m, __low, __high);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    char_type toupper(char_type __c) const\n    {\n        return do_toupper(__c);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    const char_type* toupper(char_type* __low, const char_type* __high) const\n    {\n        return do_toupper(__low, __high);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    char_type tolower(char_type __c) const\n    {\n        return do_tolower(__c);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    const char_type* tolower(char_type* __low, const char_type* __high) const\n    {\n        return do_tolower(__low, __high);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    char_type widen(char __c) const\n    {\n        return do_widen(__c);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    const char* widen(const char* __low, const char* __high, char_type* __to) const\n    {\n        return do_widen(__low, __high, __to);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    char narrow(char_type __c, char __dfault) const\n    {\n        return do_narrow(__c, __dfault);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    const char_type* narrow(const char_type* __low, const char_type* __high, char __dfault, char* __to) const\n    {\n        return do_narrow(__low, __high, __dfault, __to);\n    }\n\n    static locale::id id;\n\nprotected:\n    ~ctype();\n    virtual bool do_is(mask __m, char_type __c) const;\n    virtual const char_type* do_is(const char_type* __low, const char_type* __high, mask* __vec) const;\n    virtual const char_type* do_scan_is(mask __m, const char_type* __low, const char_type* __high) const;\n    virtual const char_type* do_scan_not(mask __m, const char_type* __low, const char_type* __high) const;\n    virtual char_type do_toupper(char_type) const;\n    virtual const char_type* do_toupper(char_type* __low, const char_type* __high) const;\n    virtual char_type do_tolower(char_type) const;\n    virtual const char_type* do_tolower(char_type* __low, const char_type* __high) const;\n    virtual char_type do_widen(char) const;\n    virtual const char* do_widen(const char* __low, const char* __high, char_type* __dest) const;\n    virtual char do_narrow(char_type, char __dfault) const;\n    virtual const char_type* do_narrow(const char_type* __low, const char_type* __high, char __dfault, char* __dest) const;\n};\n\ntemplate <>\nclass _LIBCPP_TYPE_VIS ctype<char>\n    : public locale::facet, public ctype_base\n{\n    const mask* __tab_;\n    bool        __del_;\npublic:\n    typedef char char_type;\n\n    explicit ctype(const mask* __tab = 0, bool __del = false, size_t __refs = 0);\n\n    _LIBCPP_ALWAYS_INLINE\n    bool is(mask __m, char_type __c) const\n    {\n        return isascii(__c) ? (__tab_[static_cast<int>(__c)] & __m) !=0 : false;\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    const char_type* is(const char_type* __low, const char_type* __high, mask* __vec) const\n    {\n        for (; __low != __high; ++__low, ++__vec)\n            *__vec = isascii(*__low) ? __tab_[static_cast<int>(*__low)] : 0;\n        return __low;\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    const char_type* scan_is (mask __m, const char_type* __low, const char_type* __high) const\n    {\n        for (; __low != __high; ++__low)\n            if (isascii(*__low) && (__tab_[static_cast<int>(*__low)] & __m))\n                break;\n        return __low;\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    const char_type* scan_not(mask __m, const char_type* __low, const char_type* __high) const\n    {\n        for (; __low != __high; ++__low)\n            if (!(isascii(*__low) && (__tab_[static_cast<int>(*__low)] & __m)))\n                break;\n        return __low;\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    char_type toupper(char_type __c) const\n    {\n        return do_toupper(__c);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    const char_type* toupper(char_type* __low, const char_type* __high) const\n    {\n        return do_toupper(__low, __high);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    char_type tolower(char_type __c) const\n    {\n        return do_tolower(__c);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    const char_type* tolower(char_type* __low, const char_type* __high) const\n    {\n        return do_tolower(__low, __high);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    char_type widen(char __c) const\n    {\n        return do_widen(__c);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    const char* widen(const char* __low, const char* __high, char_type* __to) const\n    {\n        return do_widen(__low, __high, __to);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    char narrow(char_type __c, char __dfault) const\n    {\n        return do_narrow(__c, __dfault);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    const char* narrow(const char_type* __low, const char_type* __high, char __dfault, char* __to) const\n    {\n        return do_narrow(__low, __high, __dfault, __to);\n    }\n\n    static locale::id id;\n\n#ifdef _CACHED_RUNES\n    static const size_t table_size = _CACHED_RUNES;\n#else\n    static const size_t table_size = 256;  // FIXME: Don't hardcode this.\n#endif\n    _LIBCPP_ALWAYS_INLINE const mask* table() const  _NOEXCEPT {return __tab_;}\n    static const mask* classic_table()  _NOEXCEPT;\n#if defined(__GLIBC__) || defined(__EMSCRIPTEN__)\n    static const int* __classic_upper_table() _NOEXCEPT;\n    static const int* __classic_lower_table() _NOEXCEPT;\n#endif\n#if defined(__NetBSD__)\n    static const short* __classic_upper_table() _NOEXCEPT;\n    static const short* __classic_lower_table() _NOEXCEPT;\n#endif\n\nprotected:\n    ~ctype();\n    virtual char_type do_toupper(char_type __c) const;\n    virtual const char_type* do_toupper(char_type* __low, const char_type* __high) const;\n    virtual char_type do_tolower(char_type __c) const;\n    virtual const char_type* do_tolower(char_type* __low, const char_type* __high) const;\n    virtual char_type do_widen(char __c) const;\n    virtual const char* do_widen(const char* __low, const char* __high, char_type* __to) const;\n    virtual char do_narrow(char_type __c, char __dfault) const;\n    virtual const char* do_narrow(const char_type* __low, const char_type* __high, char __dfault, char* __to) const;\n};\n\n// template <class CharT> class ctype_byname;\n\ntemplate <class _CharT> class _LIBCPP_TEMPLATE_VIS ctype_byname;\n\ntemplate <>\nclass _LIBCPP_TYPE_VIS ctype_byname<char>\n    : public ctype<char>\n{\n    locale_t __l;\n\npublic:\n    explicit ctype_byname(const char*, size_t = 0);\n    explicit ctype_byname(const string&, size_t = 0);\n\nprotected:\n    ~ctype_byname();\n    virtual char_type do_toupper(char_type) const;\n    virtual const char_type* do_toupper(char_type* __low, const char_type* __high) const;\n    virtual char_type do_tolower(char_type) const;\n    virtual const char_type* do_tolower(char_type* __low, const char_type* __high) const;\n};\n\ntemplate <>\nclass _LIBCPP_TYPE_VIS ctype_byname<wchar_t>\n    : public ctype<wchar_t>\n{\n    locale_t __l;\n\npublic:\n    explicit ctype_byname(const char*, size_t = 0);\n    explicit ctype_byname(const string&, size_t = 0);\n\nprotected:\n    ~ctype_byname();\n    virtual bool do_is(mask __m, char_type __c) const;\n    virtual const char_type* do_is(const char_type* __low, const char_type* __high, mask* __vec) const;\n    virtual const char_type* do_scan_is(mask __m, const char_type* __low, const char_type* __high) const;\n    virtual const char_type* do_scan_not(mask __m, const char_type* __low, const char_type* __high) const;\n    virtual char_type do_toupper(char_type) const;\n    virtual const char_type* do_toupper(char_type* __low, const char_type* __high) const;\n    virtual char_type do_tolower(char_type) const;\n    virtual const char_type* do_tolower(char_type* __low, const char_type* __high) const;\n    virtual char_type do_widen(char) const;\n    virtual const char* do_widen(const char* __low, const char* __high, char_type* __dest) const;\n    virtual char do_narrow(char_type, char __dfault) const;\n    virtual const char_type* do_narrow(const char_type* __low, const char_type* __high, char __dfault, char* __dest) const;\n};\n\ntemplate <class _CharT>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nisspace(_CharT __c, const locale& __loc)\n{\n    return use_facet<ctype<_CharT> >(__loc).is(ctype_base::space, __c);\n}\n\ntemplate <class _CharT>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nisprint(_CharT __c, const locale& __loc)\n{\n    return use_facet<ctype<_CharT> >(__loc).is(ctype_base::print, __c);\n}\n\ntemplate <class _CharT>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\niscntrl(_CharT __c, const locale& __loc)\n{\n    return use_facet<ctype<_CharT> >(__loc).is(ctype_base::cntrl, __c);\n}\n\ntemplate <class _CharT>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nisupper(_CharT __c, const locale& __loc)\n{\n    return use_facet<ctype<_CharT> >(__loc).is(ctype_base::upper, __c);\n}\n\ntemplate <class _CharT>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nislower(_CharT __c, const locale& __loc)\n{\n    return use_facet<ctype<_CharT> >(__loc).is(ctype_base::lower, __c);\n}\n\ntemplate <class _CharT>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nisalpha(_CharT __c, const locale& __loc)\n{\n    return use_facet<ctype<_CharT> >(__loc).is(ctype_base::alpha, __c);\n}\n\ntemplate <class _CharT>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nisdigit(_CharT __c, const locale& __loc)\n{\n    return use_facet<ctype<_CharT> >(__loc).is(ctype_base::digit, __c);\n}\n\ntemplate <class _CharT>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nispunct(_CharT __c, const locale& __loc)\n{\n    return use_facet<ctype<_CharT> >(__loc).is(ctype_base::punct, __c);\n}\n\ntemplate <class _CharT>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nisxdigit(_CharT __c, const locale& __loc)\n{\n    return use_facet<ctype<_CharT> >(__loc).is(ctype_base::xdigit, __c);\n}\n\ntemplate <class _CharT>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nisalnum(_CharT __c, const locale& __loc)\n{\n    return use_facet<ctype<_CharT> >(__loc).is(ctype_base::alnum, __c);\n}\n\ntemplate <class _CharT>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nisgraph(_CharT __c, const locale& __loc)\n{\n    return use_facet<ctype<_CharT> >(__loc).is(ctype_base::graph, __c);\n}\n\ntemplate <class _CharT>\ninline _LIBCPP_INLINE_VISIBILITY\n_CharT\ntoupper(_CharT __c, const locale& __loc)\n{\n    return use_facet<ctype<_CharT> >(__loc).toupper(__c);\n}\n\ntemplate <class _CharT>\ninline _LIBCPP_INLINE_VISIBILITY\n_CharT\ntolower(_CharT __c, const locale& __loc)\n{\n    return use_facet<ctype<_CharT> >(__loc).tolower(__c);\n}\n\n// codecvt_base\n\nclass _LIBCPP_TYPE_VIS codecvt_base\n{\npublic:\n    _LIBCPP_ALWAYS_INLINE codecvt_base() {}\n    enum result {ok, partial, error, noconv};\n};\n\n// template <class internT, class externT, class stateT> class codecvt;\n\ntemplate <class _InternT, class _ExternT, class _StateT> class _LIBCPP_TEMPLATE_VIS codecvt;\n\n// template <> class codecvt<char, char, mbstate_t>\n\ntemplate <>\nclass _LIBCPP_TYPE_VIS codecvt<char, char, mbstate_t>\n    : public locale::facet,\n      public codecvt_base\n{\npublic:\n    typedef char      intern_type;\n    typedef char      extern_type;\n    typedef mbstate_t state_type;\n\n    _LIBCPP_ALWAYS_INLINE\n    explicit codecvt(size_t __refs = 0)\n        : locale::facet(__refs) {}\n\n    _LIBCPP_ALWAYS_INLINE\n    result out(state_type& __st,\n               const intern_type* __frm, const intern_type* __frm_end, const intern_type*& __frm_nxt,\n               extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const\n    {\n        return do_out(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    result unshift(state_type& __st,\n                   extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const\n    {\n        return do_unshift(__st, __to, __to_end, __to_nxt);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    result in(state_type& __st,\n              const extern_type* __frm, const extern_type* __frm_end, const extern_type*& __frm_nxt,\n              intern_type* __to, intern_type* __to_end, intern_type*& __to_nxt) const\n    {\n        return do_in(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    int encoding() const  _NOEXCEPT\n    {\n        return do_encoding();\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    bool always_noconv() const  _NOEXCEPT\n    {\n        return do_always_noconv();\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    int length(state_type& __st, const extern_type* __frm, const extern_type* __end, size_t __mx) const\n    {\n        return do_length(__st, __frm, __end, __mx);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    int max_length() const  _NOEXCEPT\n    {\n        return do_max_length();\n    }\n\n    static locale::id id;\n\nprotected:\n    _LIBCPP_ALWAYS_INLINE\n    explicit codecvt(const char*, size_t __refs = 0)\n        : locale::facet(__refs) {}\n\n    ~codecvt();\n\n    virtual result do_out(state_type& __st,\n                          const intern_type* __frm, const intern_type* __frm_end, const intern_type*& __frm_nxt,\n                          extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const;\n    virtual result do_in(state_type& __st,\n                         const extern_type* __frm, const extern_type* __frm_end, const extern_type*& __frm_nxt,\n                         intern_type* __to, intern_type* __to_end, intern_type*& __to_nxt) const;\n    virtual result do_unshift(state_type& __st,\n                              extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const;\n    virtual int do_encoding() const  _NOEXCEPT;\n    virtual bool do_always_noconv() const  _NOEXCEPT;\n    virtual int do_length(state_type& __st, const extern_type* __frm, const extern_type* __end, size_t __mx) const;\n    virtual int do_max_length() const  _NOEXCEPT;\n};\n\n// template <> class codecvt<wchar_t, char, mbstate_t>\n\ntemplate <>\nclass _LIBCPP_TYPE_VIS codecvt<wchar_t, char, mbstate_t>\n    : public locale::facet,\n      public codecvt_base\n{\n    locale_t __l;\npublic:\n    typedef wchar_t   intern_type;\n    typedef char      extern_type;\n    typedef mbstate_t state_type;\n\n    explicit codecvt(size_t __refs = 0);\n\n    _LIBCPP_ALWAYS_INLINE\n    result out(state_type& __st,\n               const intern_type* __frm, const intern_type* __frm_end, const intern_type*& __frm_nxt,\n               extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const\n    {\n        return do_out(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    result unshift(state_type& __st,\n                   extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const\n    {\n        return do_unshift(__st, __to, __to_end, __to_nxt);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    result in(state_type& __st,\n              const extern_type* __frm, const extern_type* __frm_end, const extern_type*& __frm_nxt,\n              intern_type* __to, intern_type* __to_end, intern_type*& __to_nxt) const\n    {\n        return do_in(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    int encoding() const  _NOEXCEPT\n    {\n        return do_encoding();\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    bool always_noconv() const  _NOEXCEPT\n    {\n        return do_always_noconv();\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    int length(state_type& __st, const extern_type* __frm, const extern_type* __end, size_t __mx) const\n    {\n        return do_length(__st, __frm, __end, __mx);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    int max_length() const  _NOEXCEPT\n    {\n        return do_max_length();\n    }\n\n    static locale::id id;\n\nprotected:\n    explicit codecvt(const char*, size_t __refs = 0);\n\n    ~codecvt();\n\n    virtual result do_out(state_type& __st,\n                          const intern_type* __frm, const intern_type* __frm_end, const intern_type*& __frm_nxt,\n                          extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const;\n    virtual result do_in(state_type& __st,\n                         const extern_type* __frm, const extern_type* __frm_end, const extern_type*& __frm_nxt,\n                         intern_type* __to, intern_type* __to_end, intern_type*& __to_nxt) const;\n    virtual result do_unshift(state_type& __st,\n                              extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const;\n    virtual int do_encoding() const  _NOEXCEPT;\n    virtual bool do_always_noconv() const  _NOEXCEPT;\n    virtual int do_length(state_type&, const extern_type* __frm, const extern_type* __end, size_t __mx) const;\n    virtual int do_max_length() const  _NOEXCEPT;\n};\n\n// template <> class codecvt<char16_t, char, mbstate_t>\n\ntemplate <>\nclass _LIBCPP_TYPE_VIS codecvt<char16_t, char, mbstate_t>\n    : public locale::facet,\n      public codecvt_base\n{\npublic:\n    typedef char16_t  intern_type;\n    typedef char      extern_type;\n    typedef mbstate_t state_type;\n\n    _LIBCPP_ALWAYS_INLINE\n    explicit codecvt(size_t __refs = 0)\n        : locale::facet(__refs) {}\n\n    _LIBCPP_ALWAYS_INLINE\n    result out(state_type& __st,\n               const intern_type* __frm, const intern_type* __frm_end, const intern_type*& __frm_nxt,\n               extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const\n    {\n        return do_out(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    result unshift(state_type& __st,\n                   extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const\n    {\n        return do_unshift(__st, __to, __to_end, __to_nxt);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    result in(state_type& __st,\n              const extern_type* __frm, const extern_type* __frm_end, const extern_type*& __frm_nxt,\n              intern_type* __to, intern_type* __to_end, intern_type*& __to_nxt) const\n    {\n        return do_in(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    int encoding() const  _NOEXCEPT\n    {\n        return do_encoding();\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    bool always_noconv() const  _NOEXCEPT\n    {\n        return do_always_noconv();\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    int length(state_type& __st, const extern_type* __frm, const extern_type* __end, size_t __mx) const\n    {\n        return do_length(__st, __frm, __end, __mx);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    int max_length() const  _NOEXCEPT\n    {\n        return do_max_length();\n    }\n\n    static locale::id id;\n\nprotected:\n    _LIBCPP_ALWAYS_INLINE\n    explicit codecvt(const char*, size_t __refs = 0)\n        : locale::facet(__refs) {}\n\n    ~codecvt();\n\n    virtual result do_out(state_type& __st,\n                          const intern_type* __frm, const intern_type* __frm_end, const intern_type*& __frm_nxt,\n                          extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const;\n    virtual result do_in(state_type& __st,\n                         const extern_type* __frm, const extern_type* __frm_end, const extern_type*& __frm_nxt,\n                         intern_type* __to, intern_type* __to_end, intern_type*& __to_nxt) const;\n    virtual result do_unshift(state_type& __st,\n                              extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const;\n    virtual int do_encoding() const  _NOEXCEPT;\n    virtual bool do_always_noconv() const  _NOEXCEPT;\n    virtual int do_length(state_type&, const extern_type* __frm, const extern_type* __end, size_t __mx) const;\n    virtual int do_max_length() const  _NOEXCEPT;\n};\n\n// template <> class codecvt<char32_t, char, mbstate_t>\n\ntemplate <>\nclass _LIBCPP_TYPE_VIS codecvt<char32_t, char, mbstate_t>\n    : public locale::facet,\n      public codecvt_base\n{\npublic:\n    typedef char32_t  intern_type;\n    typedef char      extern_type;\n    typedef mbstate_t state_type;\n\n    _LIBCPP_ALWAYS_INLINE\n    explicit codecvt(size_t __refs = 0)\n        : locale::facet(__refs) {}\n\n    _LIBCPP_ALWAYS_INLINE\n    result out(state_type& __st,\n               const intern_type* __frm, const intern_type* __frm_end, const intern_type*& __frm_nxt,\n               extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const\n    {\n        return do_out(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    result unshift(state_type& __st,\n                   extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const\n    {\n        return do_unshift(__st, __to, __to_end, __to_nxt);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    result in(state_type& __st,\n              const extern_type* __frm, const extern_type* __frm_end, const extern_type*& __frm_nxt,\n              intern_type* __to, intern_type* __to_end, intern_type*& __to_nxt) const\n    {\n        return do_in(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    int encoding() const  _NOEXCEPT\n    {\n        return do_encoding();\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    bool always_noconv() const  _NOEXCEPT\n    {\n        return do_always_noconv();\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    int length(state_type& __st, const extern_type* __frm, const extern_type* __end, size_t __mx) const\n    {\n        return do_length(__st, __frm, __end, __mx);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    int max_length() const  _NOEXCEPT\n    {\n        return do_max_length();\n    }\n\n    static locale::id id;\n\nprotected:\n    _LIBCPP_ALWAYS_INLINE\n    explicit codecvt(const char*, size_t __refs = 0)\n        : locale::facet(__refs) {}\n\n    ~codecvt();\n\n    virtual result do_out(state_type& __st,\n                          const intern_type* __frm, const intern_type* __frm_end, const intern_type*& __frm_nxt,\n                          extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const;\n    virtual result do_in(state_type& __st,\n                         const extern_type* __frm, const extern_type* __frm_end, const extern_type*& __frm_nxt,\n                         intern_type* __to, intern_type* __to_end, intern_type*& __to_nxt) const;\n    virtual result do_unshift(state_type& __st,\n                              extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const;\n    virtual int do_encoding() const  _NOEXCEPT;\n    virtual bool do_always_noconv() const  _NOEXCEPT;\n    virtual int do_length(state_type&, const extern_type* __frm, const extern_type* __end, size_t __mx) const;\n    virtual int do_max_length() const  _NOEXCEPT;\n};\n\n// template <class _InternT, class _ExternT, class _StateT> class codecvt_byname\n\ntemplate <class _InternT, class _ExternT, class _StateT>\nclass _LIBCPP_TEMPLATE_VIS codecvt_byname\n    : public codecvt<_InternT, _ExternT, _StateT>\n{\npublic:\n    _LIBCPP_ALWAYS_INLINE\n    explicit codecvt_byname(const char* __nm, size_t __refs = 0)\n        : codecvt<_InternT, _ExternT, _StateT>(__nm, __refs) {}\n    _LIBCPP_ALWAYS_INLINE\n    explicit codecvt_byname(const string& __nm, size_t __refs = 0)\n        : codecvt<_InternT, _ExternT, _StateT>(__nm.c_str(), __refs) {}\nprotected:\n    ~codecvt_byname();\n};\n\ntemplate <class _InternT, class _ExternT, class _StateT>\ncodecvt_byname<_InternT, _ExternT, _StateT>::~codecvt_byname()\n{\n}\n\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS codecvt_byname<char, char, mbstate_t>)\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS codecvt_byname<wchar_t, char, mbstate_t>)\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS codecvt_byname<char16_t, char, mbstate_t>)\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS codecvt_byname<char32_t, char, mbstate_t>)\n\n_LIBCPP_NORETURN _LIBCPP_FUNC_VIS void __throw_runtime_error(const char*);\n\ntemplate <size_t _Np>\nstruct __narrow_to_utf8\n{\n    template <class _OutputIterator, class _CharT>\n    _OutputIterator\n    operator()(_OutputIterator __s, const _CharT* __wb, const _CharT* __we) const;\n};\n\ntemplate <>\nstruct __narrow_to_utf8<8>\n{\n    template <class _OutputIterator, class _CharT>\n    _LIBCPP_ALWAYS_INLINE\n    _OutputIterator\n    operator()(_OutputIterator __s, const _CharT* __wb, const _CharT* __we) const\n    {\n        for (; __wb < __we; ++__wb, ++__s)\n            *__s = *__wb;\n        return __s;\n    }\n};\n\ntemplate <>\nstruct __narrow_to_utf8<16>\n    : public codecvt<char16_t, char, mbstate_t>\n{\n    _LIBCPP_ALWAYS_INLINE\n    __narrow_to_utf8() : codecvt<char16_t, char, mbstate_t>(1) {}\n\n    ~__narrow_to_utf8();\n\n    template <class _OutputIterator, class _CharT>\n    _LIBCPP_ALWAYS_INLINE\n    _OutputIterator\n    operator()(_OutputIterator __s, const _CharT* __wb, const _CharT* __we) const\n    {\n        result __r = ok;\n        mbstate_t __mb;\n        while (__wb < __we && __r != error)\n        {\n            const int __sz = 32;\n            char __buf[__sz];\n            char* __bn;\n            const char16_t* __wn = (const char16_t*)__wb;\n            __r = do_out(__mb, (const char16_t*)__wb, (const char16_t*)__we, __wn,\n                         __buf, __buf+__sz, __bn);\n            if (__r == codecvt_base::error || __wn == (const char16_t*)__wb)\n                __throw_runtime_error(\"locale not supported\");\n            for (const char* __p = __buf; __p < __bn; ++__p, ++__s)\n                *__s = *__p;\n            __wb = (const _CharT*)__wn;\n        }\n        return __s;\n    }\n};\n\ntemplate <>\nstruct __narrow_to_utf8<32>\n    : public codecvt<char32_t, char, mbstate_t>\n{\n    _LIBCPP_ALWAYS_INLINE\n    __narrow_to_utf8() : codecvt<char32_t, char, mbstate_t>(1) {}\n\n    ~__narrow_to_utf8();\n\n    template <class _OutputIterator, class _CharT>\n    _LIBCPP_ALWAYS_INLINE\n    _OutputIterator\n    operator()(_OutputIterator __s, const _CharT* __wb, const _CharT* __we) const\n    {\n        result __r = ok;\n        mbstate_t __mb;\n        while (__wb < __we && __r != error)\n        {\n            const int __sz = 32;\n            char __buf[__sz];\n            char* __bn;\n            const char32_t* __wn = (const char32_t*)__wb;\n            __r = do_out(__mb, (const char32_t*)__wb, (const char32_t*)__we, __wn,\n                         __buf, __buf+__sz, __bn);\n            if (__r == codecvt_base::error || __wn == (const char32_t*)__wb)\n                __throw_runtime_error(\"locale not supported\");\n            for (const char* __p = __buf; __p < __bn; ++__p, ++__s)\n                *__s = *__p;\n            __wb = (const _CharT*)__wn;\n        }\n        return __s;\n    }\n};\n\ntemplate <size_t _Np>\nstruct __widen_from_utf8\n{\n    template <class _OutputIterator>\n    _OutputIterator\n    operator()(_OutputIterator __s, const char* __nb, const char* __ne) const;\n};\n\ntemplate <>\nstruct __widen_from_utf8<8>\n{\n    template <class _OutputIterator>\n    _LIBCPP_ALWAYS_INLINE\n    _OutputIterator\n    operator()(_OutputIterator __s, const char* __nb, const char* __ne) const\n    {\n        for (; __nb < __ne; ++__nb, ++__s)\n            *__s = *__nb;\n        return __s;\n    }\n};\n\ntemplate <>\nstruct __widen_from_utf8<16>\n    : public codecvt<char16_t, char, mbstate_t>\n{\n    _LIBCPP_ALWAYS_INLINE\n    __widen_from_utf8() : codecvt<char16_t, char, mbstate_t>(1) {}\n\n    ~__widen_from_utf8();\n\n    template <class _OutputIterator>\n    _LIBCPP_ALWAYS_INLINE\n    _OutputIterator\n    operator()(_OutputIterator __s, const char* __nb, const char* __ne) const\n    {\n        result __r = ok;\n        mbstate_t __mb;\n        while (__nb < __ne && __r != error)\n        {\n            const int __sz = 32;\n            char16_t __buf[__sz];\n            char16_t* __bn;\n            const char* __nn = __nb;\n            __r = do_in(__mb, __nb, __ne - __nb > __sz ? __nb+__sz : __ne, __nn,\n                        __buf, __buf+__sz, __bn);\n            if (__r == codecvt_base::error || __nn == __nb)\n                __throw_runtime_error(\"locale not supported\");\n            for (const char16_t* __p = __buf; __p < __bn; ++__p, ++__s)\n                *__s = (wchar_t)*__p;\n            __nb = __nn;\n        }\n        return __s;\n    }\n};\n\ntemplate <>\nstruct __widen_from_utf8<32>\n    : public codecvt<char32_t, char, mbstate_t>\n{\n    _LIBCPP_ALWAYS_INLINE\n    __widen_from_utf8() : codecvt<char32_t, char, mbstate_t>(1) {}\n\n    ~__widen_from_utf8();\n\n    template <class _OutputIterator>\n    _LIBCPP_ALWAYS_INLINE\n    _OutputIterator\n    operator()(_OutputIterator __s, const char* __nb, const char* __ne) const\n    {\n        result __r = ok;\n        mbstate_t __mb;\n        while (__nb < __ne && __r != error)\n        {\n            const int __sz = 32;\n            char32_t __buf[__sz];\n            char32_t* __bn;\n            const char* __nn = __nb;\n            __r = do_in(__mb, __nb, __ne - __nb > __sz ? __nb+__sz : __ne, __nn,\n                        __buf, __buf+__sz, __bn);\n            if (__r == codecvt_base::error || __nn == __nb)\n                __throw_runtime_error(\"locale not supported\");\n            for (const char32_t* __p = __buf; __p < __bn; ++__p, ++__s)\n                *__s = (wchar_t)*__p;\n            __nb = __nn;\n        }\n        return __s;\n    }\n};\n\n// template <class charT> class numpunct\n\ntemplate <class _CharT> class _LIBCPP_TEMPLATE_VIS numpunct;\n\ntemplate <>\nclass _LIBCPP_TYPE_VIS numpunct<char>\n    : public locale::facet\n{\npublic:\n    typedef char char_type;\n    typedef basic_string<char_type> string_type;\n\n    explicit numpunct(size_t __refs = 0);\n\n    _LIBCPP_ALWAYS_INLINE char_type decimal_point() const {return do_decimal_point();}\n    _LIBCPP_ALWAYS_INLINE char_type thousands_sep() const {return do_thousands_sep();}\n    _LIBCPP_ALWAYS_INLINE string grouping() const         {return do_grouping();}\n    _LIBCPP_ALWAYS_INLINE string_type truename() const    {return do_truename();}\n    _LIBCPP_ALWAYS_INLINE string_type falsename() const   {return do_falsename();}\n\n    static locale::id id;\n\nprotected:\n    ~numpunct();\n    virtual char_type do_decimal_point() const;\n    virtual char_type do_thousands_sep() const;\n    virtual string do_grouping() const;\n    virtual string_type do_truename() const;\n    virtual string_type do_falsename() const;\n\n    char_type __decimal_point_;\n    char_type __thousands_sep_;\n    string __grouping_;\n};\n\ntemplate <>\nclass _LIBCPP_TYPE_VIS numpunct<wchar_t>\n    : public locale::facet\n{\npublic:\n    typedef wchar_t char_type;\n    typedef basic_string<char_type> string_type;\n\n    explicit numpunct(size_t __refs = 0);\n\n    _LIBCPP_ALWAYS_INLINE char_type decimal_point() const {return do_decimal_point();}\n    _LIBCPP_ALWAYS_INLINE char_type thousands_sep() const {return do_thousands_sep();}\n    _LIBCPP_ALWAYS_INLINE string grouping() const         {return do_grouping();}\n    _LIBCPP_ALWAYS_INLINE string_type truename() const    {return do_truename();}\n    _LIBCPP_ALWAYS_INLINE string_type falsename() const   {return do_falsename();}\n\n    static locale::id id;\n\nprotected:\n    ~numpunct();\n    virtual char_type do_decimal_point() const;\n    virtual char_type do_thousands_sep() const;\n    virtual string do_grouping() const;\n    virtual string_type do_truename() const;\n    virtual string_type do_falsename() const;\n\n    char_type __decimal_point_;\n    char_type __thousands_sep_;\n    string __grouping_;\n};\n\n// template <class charT> class numpunct_byname\n\ntemplate <class _CharT> class _LIBCPP_TEMPLATE_VIS numpunct_byname;\n\ntemplate <>\nclass _LIBCPP_TYPE_VIS numpunct_byname<char>\n: public numpunct<char>\n{\npublic:\n    typedef char char_type;\n    typedef basic_string<char_type> string_type;\n\n    explicit numpunct_byname(const char* __nm, size_t __refs = 0);\n    explicit numpunct_byname(const string& __nm, size_t __refs = 0);\n\nprotected:\n    ~numpunct_byname();\n\nprivate:\n    void __init(const char*);\n};\n\ntemplate <>\nclass _LIBCPP_TYPE_VIS numpunct_byname<wchar_t>\n: public numpunct<wchar_t>\n{\npublic:\n    typedef wchar_t char_type;\n    typedef basic_string<char_type> string_type;\n\n    explicit numpunct_byname(const char* __nm, size_t __refs = 0);\n    explicit numpunct_byname(const string& __nm, size_t __refs = 0);\n\nprotected:\n    ~numpunct_byname();\n\nprivate:\n    void __init(const char*);\n};\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP___LOCALE\n","// -*- C++ -*-\n//===------------------------------ vector --------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_VECTOR\n#define _LIBCPP_VECTOR\n\n/*\n    vector synopsis\n\nnamespace std\n{\n\ntemplate <class T, class Allocator = allocator<T> >\nclass vector\n{\npublic:\n    typedef T                                        value_type;\n    typedef Allocator                                allocator_type;\n    typedef typename allocator_type::reference       reference;\n    typedef typename allocator_type::const_reference const_reference;\n    typedef implementation-defined                   iterator;\n    typedef implementation-defined                   const_iterator;\n    typedef typename allocator_type::size_type       size_type;\n    typedef typename allocator_type::difference_type difference_type;\n    typedef typename allocator_type::pointer         pointer;\n    typedef typename allocator_type::const_pointer   const_pointer;\n    typedef std::reverse_iterator<iterator>          reverse_iterator;\n    typedef std::reverse_iterator<const_iterator>    const_reverse_iterator;\n\n    vector()\n        noexcept(is_nothrow_default_constructible<allocator_type>::value);\n    explicit vector(const allocator_type&);\n    explicit vector(size_type n);\n    explicit vector(size_type n, const allocator_type&); // C++14\n    vector(size_type n, const value_type& value, const allocator_type& = allocator_type());\n    template <class InputIterator>\n        vector(InputIterator first, InputIterator last, const allocator_type& = allocator_type());\n    vector(const vector& x);\n    vector(vector&& x)\n        noexcept(is_nothrow_move_constructible<allocator_type>::value);\n    vector(initializer_list<value_type> il);\n    vector(initializer_list<value_type> il, const allocator_type& a);\n    ~vector();\n    vector& operator=(const vector& x);\n    vector& operator=(vector&& x)\n        noexcept(\n             allocator_type::propagate_on_container_move_assignment::value ||\n             allocator_type::is_always_equal::value); // C++17\n    vector& operator=(initializer_list<value_type> il);\n    template <class InputIterator>\n        void assign(InputIterator first, InputIterator last);\n    void assign(size_type n, const value_type& u);\n    void assign(initializer_list<value_type> il);\n\n    allocator_type get_allocator() const noexcept;\n\n    iterator               begin() noexcept;\n    const_iterator         begin()   const noexcept;\n    iterator               end() noexcept;\n    const_iterator         end()     const noexcept;\n\n    reverse_iterator       rbegin() noexcept;\n    const_reverse_iterator rbegin()  const noexcept;\n    reverse_iterator       rend() noexcept;\n    const_reverse_iterator rend()    const noexcept;\n\n    const_iterator         cbegin()  const noexcept;\n    const_iterator         cend()    const noexcept;\n    const_reverse_iterator crbegin() const noexcept;\n    const_reverse_iterator crend()   const noexcept;\n\n    size_type size() const noexcept;\n    size_type max_size() const noexcept;\n    size_type capacity() const noexcept;\n    bool empty() const noexcept;\n    void reserve(size_type n);\n    void shrink_to_fit() noexcept;\n\n    reference       operator[](size_type n);\n    const_reference operator[](size_type n) const;\n    reference       at(size_type n);\n    const_reference at(size_type n) const;\n\n    reference       front();\n    const_reference front() const;\n    reference       back();\n    const_reference back() const;\n\n    value_type*       data() noexcept;\n    const value_type* data() const noexcept;\n\n    void push_back(const value_type& x);\n    void push_back(value_type&& x);\n    template <class... Args>\n        reference emplace_back(Args&&... args); // reference in C++17\n    void pop_back();\n\n    template <class... Args> iterator emplace(const_iterator position, Args&&... args);\n    iterator insert(const_iterator position, const value_type& x);\n    iterator insert(const_iterator position, value_type&& x);\n    iterator insert(const_iterator position, size_type n, const value_type& x);\n    template <class InputIterator>\n        iterator insert(const_iterator position, InputIterator first, InputIterator last);\n    iterator insert(const_iterator position, initializer_list<value_type> il);\n\n    iterator erase(const_iterator position);\n    iterator erase(const_iterator first, const_iterator last);\n\n    void clear() noexcept;\n\n    void resize(size_type sz);\n    void resize(size_type sz, const value_type& c);\n\n    void swap(vector&)\n        noexcept(allocator_traits<allocator_type>::propagate_on_container_swap::value ||\n                 allocator_traits<allocator_type>::is_always_equal::value);  // C++17\n\n    bool __invariants() const;\n};\n\ntemplate <class Allocator = allocator<T> >\nclass vector<bool, Allocator>\n{\npublic:\n    typedef bool                                     value_type;\n    typedef Allocator                                allocator_type;\n    typedef implementation-defined                   iterator;\n    typedef implementation-defined                   const_iterator;\n    typedef typename allocator_type::size_type       size_type;\n    typedef typename allocator_type::difference_type difference_type;\n    typedef iterator                                 pointer;\n    typedef const_iterator                           const_pointer;\n    typedef std::reverse_iterator<iterator>          reverse_iterator;\n    typedef std::reverse_iterator<const_iterator>    const_reverse_iterator;\n\n    class reference\n    {\n    public:\n        reference(const reference&) noexcept;\n        operator bool() const noexcept;\n        reference& operator=(const bool x) noexcept;\n        reference& operator=(const reference& x) noexcept;\n        iterator operator&() const noexcept;\n        void flip() noexcept;\n    };\n\n    class const_reference\n    {\n    public:\n        const_reference(const reference&) noexcept;\n        operator bool() const noexcept;\n        const_iterator operator&() const noexcept;\n    };\n\n    vector()\n        noexcept(is_nothrow_default_constructible<allocator_type>::value);\n    explicit vector(const allocator_type&);\n    explicit vector(size_type n, const allocator_type& a = allocator_type()); // C++14\n    vector(size_type n, const value_type& value, const allocator_type& = allocator_type());\n    template <class InputIterator>\n        vector(InputIterator first, InputIterator last, const allocator_type& = allocator_type());\n    vector(const vector& x);\n    vector(vector&& x)\n        noexcept(is_nothrow_move_constructible<allocator_type>::value);\n    vector(initializer_list<value_type> il);\n    vector(initializer_list<value_type> il, const allocator_type& a);\n    ~vector();\n    vector& operator=(const vector& x);\n    vector& operator=(vector&& x)\n        noexcept(\n             allocator_type::propagate_on_container_move_assignment::value ||\n             allocator_type::is_always_equal::value); // C++17\n    vector& operator=(initializer_list<value_type> il);\n    template <class InputIterator>\n        void assign(InputIterator first, InputIterator last);\n    void assign(size_type n, const value_type& u);\n    void assign(initializer_list<value_type> il);\n\n    allocator_type get_allocator() const noexcept;\n\n    iterator               begin() noexcept;\n    const_iterator         begin()   const noexcept;\n    iterator               end() noexcept;\n    const_iterator         end()     const noexcept;\n\n    reverse_iterator       rbegin() noexcept;\n    const_reverse_iterator rbegin()  const noexcept;\n    reverse_iterator       rend() noexcept;\n    const_reverse_iterator rend()    const noexcept;\n\n    const_iterator         cbegin()  const noexcept;\n    const_iterator         cend()    const noexcept;\n    const_reverse_iterator crbegin() const noexcept;\n    const_reverse_iterator crend()   const noexcept;\n\n    size_type size() const noexcept;\n    size_type max_size() const noexcept;\n    size_type capacity() const noexcept;\n    bool empty() const noexcept;\n    void reserve(size_type n);\n    void shrink_to_fit() noexcept;\n\n    reference       operator[](size_type n);\n    const_reference operator[](size_type n) const;\n    reference       at(size_type n);\n    const_reference at(size_type n) const;\n\n    reference       front();\n    const_reference front() const;\n    reference       back();\n    const_reference back() const;\n\n    void push_back(const value_type& x);\n    template <class... Args> reference emplace_back(Args&&... args);  // C++14; reference in C++17\n    void pop_back();\n\n    template <class... Args> iterator emplace(const_iterator position, Args&&... args);  // C++14\n    iterator insert(const_iterator position, const value_type& x);\n    iterator insert(const_iterator position, size_type n, const value_type& x);\n    template <class InputIterator>\n        iterator insert(const_iterator position, InputIterator first, InputIterator last);\n    iterator insert(const_iterator position, initializer_list<value_type> il);\n\n    iterator erase(const_iterator position);\n    iterator erase(const_iterator first, const_iterator last);\n\n    void clear() noexcept;\n\n    void resize(size_type sz);\n    void resize(size_type sz, value_type x);\n\n    void swap(vector&)\n        noexcept(allocator_traits<allocator_type>::propagate_on_container_swap::value ||\n                 allocator_traits<allocator_type>::is_always_equal::value);  // C++17\n    void flip() noexcept;\n\n    bool __invariants() const;\n};\n\ntemplate <class Allocator> struct hash<std::vector<bool, Allocator>>;\n\ntemplate <class T, class Allocator> bool operator==(const vector<T,Allocator>& x, const vector<T,Allocator>& y);\ntemplate <class T, class Allocator> bool operator< (const vector<T,Allocator>& x, const vector<T,Allocator>& y);\ntemplate <class T, class Allocator> bool operator!=(const vector<T,Allocator>& x, const vector<T,Allocator>& y);\ntemplate <class T, class Allocator> bool operator> (const vector<T,Allocator>& x, const vector<T,Allocator>& y);\ntemplate <class T, class Allocator> bool operator>=(const vector<T,Allocator>& x, const vector<T,Allocator>& y);\ntemplate <class T, class Allocator> bool operator<=(const vector<T,Allocator>& x, const vector<T,Allocator>& y);\n\ntemplate <class T, class Allocator>\nvoid swap(vector<T,Allocator>& x, vector<T,Allocator>& y)\n    noexcept(noexcept(x.swap(y)));\n\n}  // std\n\n*/\n\n#include <__config>\n#include <iosfwd> // for forward declaration of vector\n#include <__bit_reference>\n#include <type_traits>\n#include <climits>\n#include <limits>\n#include <initializer_list>\n#include <memory>\n#include <stdexcept>\n#include <algorithm>\n#include <cstring>\n#include <__split_buffer>\n#include <__functional_base>\n\n#include <__undef_min_max>\n\n#include <__debug>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\ntemplate <bool>\nclass __vector_base_common\n{\nprotected:\n    _LIBCPP_ALWAYS_INLINE __vector_base_common() {}\n    _LIBCPP_NORETURN void __throw_length_error() const;\n    _LIBCPP_NORETURN void __throw_out_of_range() const;\n};\n\ntemplate <bool __b>\nvoid\n__vector_base_common<__b>::__throw_length_error() const\n{\n    _VSTD::__throw_length_error(\"vector\");\n}\n\ntemplate <bool __b>\nvoid\n__vector_base_common<__b>::__throw_out_of_range() const\n{\n    _VSTD::__throw_out_of_range(\"vector\");\n}\n\n#ifdef _LIBCPP_MSVC\n#pragma warning( push )\n#pragma warning( disable: 4231 )\n#endif // _LIBCPP_MSVC\n_LIBCPP_EXTERN_TEMPLATE(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS __vector_base_common<true>)\n#ifdef _LIBCPP_MSVC\n#pragma warning( pop )\n#endif // _LIBCPP_MSVC\n\ntemplate <class _Tp, class _Allocator>\nclass __vector_base\n    : protected __vector_base_common<true>\n{\nprotected:\n    typedef _Tp                                      value_type;\n    typedef _Allocator                               allocator_type;\n    typedef allocator_traits<allocator_type>         __alloc_traits;\n    typedef value_type&                              reference;\n    typedef const value_type&                        const_reference;\n    typedef typename __alloc_traits::size_type       size_type;\n    typedef typename __alloc_traits::difference_type difference_type;\n    typedef typename __alloc_traits::pointer         pointer;\n    typedef typename __alloc_traits::const_pointer   const_pointer;\n    typedef pointer                                  iterator;\n    typedef const_pointer                            const_iterator;\n\n    pointer                                         __begin_;\n    pointer                                         __end_;\n    __compressed_pair<pointer, allocator_type> __end_cap_;\n\n    _LIBCPP_INLINE_VISIBILITY\n    allocator_type& __alloc() _NOEXCEPT\n        {return __end_cap_.second();}\n    _LIBCPP_INLINE_VISIBILITY\n    const allocator_type& __alloc() const _NOEXCEPT\n        {return __end_cap_.second();}\n    _LIBCPP_INLINE_VISIBILITY\n    pointer& __end_cap() _NOEXCEPT\n        {return __end_cap_.first();}\n    _LIBCPP_INLINE_VISIBILITY\n    const pointer& __end_cap() const _NOEXCEPT\n        {return __end_cap_.first();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __vector_base()\n        _NOEXCEPT_(is_nothrow_default_constructible<allocator_type>::value);\n    _LIBCPP_INLINE_VISIBILITY __vector_base(const allocator_type& __a);\n    ~__vector_base();\n\n    _LIBCPP_INLINE_VISIBILITY\n    void clear() _NOEXCEPT {__destruct_at_end(__begin_);}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type capacity() const _NOEXCEPT\n        {return static_cast<size_type>(__end_cap() - __begin_);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __destruct_at_end(pointer __new_last) _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __copy_assign_alloc(const __vector_base& __c)\n        {__copy_assign_alloc(__c, integral_constant<bool,\n                      __alloc_traits::propagate_on_container_copy_assignment::value>());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign_alloc(__vector_base& __c)\n        _NOEXCEPT_(\n            !__alloc_traits::propagate_on_container_move_assignment::value ||\n            is_nothrow_move_assignable<allocator_type>::value)\n        {__move_assign_alloc(__c, integral_constant<bool,\n                      __alloc_traits::propagate_on_container_move_assignment::value>());}\nprivate:\n    _LIBCPP_INLINE_VISIBILITY\n    void __copy_assign_alloc(const __vector_base& __c, true_type)\n        {\n            if (__alloc() != __c.__alloc())\n            {\n                clear();\n                __alloc_traits::deallocate(__alloc(), __begin_, capacity());\n                __begin_ = __end_ = __end_cap() = nullptr;\n            }\n            __alloc() = __c.__alloc();\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __copy_assign_alloc(const __vector_base&, false_type)\n        {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign_alloc(__vector_base& __c, true_type)\n        _NOEXCEPT_(is_nothrow_move_assignable<allocator_type>::value)\n        {\n            __alloc() = _VSTD::move(__c.__alloc());\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign_alloc(__vector_base&, false_type)\n        _NOEXCEPT\n        {}\n};\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\n__vector_base<_Tp, _Allocator>::__destruct_at_end(pointer __new_last) _NOEXCEPT\n{\n    while (__new_last != __end_)\n        __alloc_traits::destroy(__alloc(), _VSTD::__to_raw_pointer(--__end_));\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\n__vector_base<_Tp, _Allocator>::__vector_base()\n        _NOEXCEPT_(is_nothrow_default_constructible<allocator_type>::value)\n    : __begin_(nullptr),\n      __end_(nullptr),\n      __end_cap_(nullptr)\n{\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\n__vector_base<_Tp, _Allocator>::__vector_base(const allocator_type& __a)\n    : __begin_(nullptr),\n      __end_(nullptr),\n      __end_cap_(nullptr, __a)\n{\n}\n\ntemplate <class _Tp, class _Allocator>\n__vector_base<_Tp, _Allocator>::~__vector_base()\n{\n    if (__begin_ != nullptr)\n    {\n        clear();\n        __alloc_traits::deallocate(__alloc(), __begin_, capacity());\n    }\n}\n\ntemplate <class _Tp, class _Allocator /* = allocator<_Tp> */>\nclass _LIBCPP_TEMPLATE_VIS vector\n    : private __vector_base<_Tp, _Allocator>\n{\nprivate:\n    typedef __vector_base<_Tp, _Allocator>           __base;\n    typedef allocator<_Tp>                           __default_allocator_type;\npublic:\n    typedef vector                                   __self;\n    typedef _Tp                                      value_type;\n    typedef _Allocator                               allocator_type;\n    typedef typename __base::__alloc_traits          __alloc_traits;\n    typedef typename __base::reference               reference;\n    typedef typename __base::const_reference         const_reference;\n    typedef typename __base::size_type               size_type;\n    typedef typename __base::difference_type         difference_type;\n    typedef typename __base::pointer                 pointer;\n    typedef typename __base::const_pointer           const_pointer;\n    typedef __wrap_iter<pointer>                     iterator;\n    typedef __wrap_iter<const_pointer>               const_iterator;\n    typedef _VSTD::reverse_iterator<iterator>         reverse_iterator;\n    typedef _VSTD::reverse_iterator<const_iterator>   const_reverse_iterator;\n\n    static_assert((is_same<typename allocator_type::value_type, value_type>::value),\n                  \"Allocator::value_type must be same type as value_type\");\n\n    _LIBCPP_INLINE_VISIBILITY\n    vector() _NOEXCEPT_(is_nothrow_default_constructible<allocator_type>::value)\n        {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n            __get_db()->__insert_c(this);\n#endif\n        }\n    _LIBCPP_INLINE_VISIBILITY explicit vector(const allocator_type& __a)\n#if _LIBCPP_STD_VER <= 14\n        _NOEXCEPT_(is_nothrow_copy_constructible<allocator_type>::value)\n#else\n        _NOEXCEPT\n#endif\n        : __base(__a)\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        __get_db()->__insert_c(this);\n#endif\n    }\n    explicit vector(size_type __n);\n#if _LIBCPP_STD_VER > 11\n    explicit vector(size_type __n, const allocator_type& __a);\n#endif\n    vector(size_type __n, const_reference __x);\n    vector(size_type __n, const_reference __x, const allocator_type& __a);\n    template <class _InputIterator>\n        vector(_InputIterator __first,\n               typename enable_if<__is_input_iterator  <_InputIterator>::value &&\n                                 !__is_forward_iterator<_InputIterator>::value &&\n                                 is_constructible<\n                                    value_type,\n                                    typename iterator_traits<_InputIterator>::reference>::value,\n                                 _InputIterator>::type __last);\n    template <class _InputIterator>\n        vector(_InputIterator __first, _InputIterator __last, const allocator_type& __a,\n               typename enable_if<__is_input_iterator  <_InputIterator>::value &&\n                                 !__is_forward_iterator<_InputIterator>::value &&\n                                 is_constructible<\n                                    value_type,\n                                    typename iterator_traits<_InputIterator>::reference>::value>::type* = 0);\n    template <class _ForwardIterator>\n        vector(_ForwardIterator __first,\n               typename enable_if<__is_forward_iterator<_ForwardIterator>::value &&\n                                 is_constructible<\n                                    value_type,\n                                    typename iterator_traits<_ForwardIterator>::reference>::value,\n                                 _ForwardIterator>::type __last);\n    template <class _ForwardIterator>\n        vector(_ForwardIterator __first, _ForwardIterator __last, const allocator_type& __a,\n               typename enable_if<__is_forward_iterator<_ForwardIterator>::value &&\n                                 is_constructible<\n                                    value_type,\n                                    typename iterator_traits<_ForwardIterator>::reference>::value>::type* = 0);\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    vector(initializer_list<value_type> __il);\n    _LIBCPP_INLINE_VISIBILITY\n    vector(initializer_list<value_type> __il, const allocator_type& __a);\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_INLINE_VISIBILITY\n    ~vector()\n    {\n        __get_db()->__erase_c(this);\n    }\n#endif\n\n    vector(const vector& __x);\n    vector(const vector& __x, const allocator_type& __a);\n    _LIBCPP_INLINE_VISIBILITY\n    vector& operator=(const vector& __x);\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    vector(vector&& __x)\n#if _LIBCPP_STD_VER > 14\n        _NOEXCEPT;\n#else\n        _NOEXCEPT_(is_nothrow_move_constructible<allocator_type>::value);\n#endif\n    _LIBCPP_INLINE_VISIBILITY\n    vector(vector&& __x, const allocator_type& __a);\n    _LIBCPP_INLINE_VISIBILITY\n    vector& operator=(vector&& __x)\n        _NOEXCEPT_((__noexcept_move_assign_container<_Allocator, __alloc_traits>::value));\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    vector& operator=(initializer_list<value_type> __il)\n        {assign(__il.begin(), __il.end()); return *this;}\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    template <class _InputIterator>\n        typename enable_if\n        <\n             __is_input_iterator  <_InputIterator>::value &&\n            !__is_forward_iterator<_InputIterator>::value &&\n            is_constructible<\n                 value_type,\n                 typename iterator_traits<_InputIterator>::reference>::value,\n            void\n        >::type\n        assign(_InputIterator __first, _InputIterator __last);\n    template <class _ForwardIterator>\n        typename enable_if\n        <\n            __is_forward_iterator<_ForwardIterator>::value &&\n            is_constructible<\n                 value_type,\n                 typename iterator_traits<_ForwardIterator>::reference>::value,\n            void\n        >::type\n        assign(_ForwardIterator __first, _ForwardIterator __last);\n\n    void assign(size_type __n, const_reference __u);\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    void assign(initializer_list<value_type> __il)\n        {assign(__il.begin(), __il.end());}\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    _LIBCPP_INLINE_VISIBILITY\n    allocator_type get_allocator() const _NOEXCEPT\n        {return this->__alloc();}\n\n    _LIBCPP_INLINE_VISIBILITY iterator               begin() _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY const_iterator         begin()   const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY iterator               end() _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY const_iterator         end()     const _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    reverse_iterator       rbegin() _NOEXCEPT\n        {return       reverse_iterator(end());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator rbegin()  const _NOEXCEPT\n        {return const_reverse_iterator(end());}\n    _LIBCPP_INLINE_VISIBILITY\n    reverse_iterator       rend() _NOEXCEPT\n        {return       reverse_iterator(begin());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator rend()    const _NOEXCEPT\n        {return const_reverse_iterator(begin());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator         cbegin()  const _NOEXCEPT\n        {return begin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator         cend()    const _NOEXCEPT\n        {return end();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator crbegin() const _NOEXCEPT\n        {return rbegin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator crend()   const _NOEXCEPT\n        {return rend();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type size() const _NOEXCEPT\n        {return static_cast<size_type>(this->__end_ - this->__begin_);}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type capacity() const _NOEXCEPT\n        {return __base::capacity();}\n    _LIBCPP_INLINE_VISIBILITY\n    bool empty() const _NOEXCEPT\n        {return this->__begin_ == this->__end_;}\n    size_type max_size() const _NOEXCEPT;\n    void reserve(size_type __n);\n    void shrink_to_fit() _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY reference       operator[](size_type __n);\n    _LIBCPP_INLINE_VISIBILITY const_reference operator[](size_type __n) const;\n    reference       at(size_type __n);\n    const_reference at(size_type __n) const;\n\n    _LIBCPP_INLINE_VISIBILITY reference       front()\n    {\n        _LIBCPP_ASSERT(!empty(), \"front() called for empty vector\");\n        return *this->__begin_;\n    }\n    _LIBCPP_INLINE_VISIBILITY const_reference front() const\n    {\n        _LIBCPP_ASSERT(!empty(), \"front() called for empty vector\");\n        return *this->__begin_;\n    }\n    _LIBCPP_INLINE_VISIBILITY reference       back()\n    {\n        _LIBCPP_ASSERT(!empty(), \"back() called for empty vector\");\n        return *(this->__end_ - 1);\n    }\n    _LIBCPP_INLINE_VISIBILITY const_reference back()  const\n    {\n        _LIBCPP_ASSERT(!empty(), \"back() called for empty vector\");\n        return *(this->__end_ - 1);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    value_type*       data() _NOEXCEPT\n        {return _VSTD::__to_raw_pointer(this->__begin_);}\n    _LIBCPP_INLINE_VISIBILITY\n    const value_type* data() const _NOEXCEPT\n        {return _VSTD::__to_raw_pointer(this->__begin_);}\n\n    _LIBCPP_INLINE_VISIBILITY void push_back(const_reference __x);\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY void push_back(value_type&& __x);\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n    template <class... _Args>\n        _LIBCPP_INLINE_VISIBILITY\n#if _LIBCPP_STD_VER > 14\n        reference emplace_back(_Args&&... __args);\n#else\n        void      emplace_back(_Args&&... __args);\n#endif\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    void pop_back();\n\n    iterator insert(const_iterator __position, const_reference __x);\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    iterator insert(const_iterator __position, value_type&& __x);\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n    template <class... _Args>\n        iterator emplace(const_iterator __position, _Args&&... __args);\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    iterator insert(const_iterator __position, size_type __n, const_reference __x);\n    template <class _InputIterator>\n        typename enable_if\n        <\n             __is_input_iterator  <_InputIterator>::value &&\n            !__is_forward_iterator<_InputIterator>::value &&\n            is_constructible<\n                 value_type,\n                 typename iterator_traits<_InputIterator>::reference>::value,\n            iterator\n        >::type\n        insert(const_iterator __position, _InputIterator __first, _InputIterator __last);\n    template <class _ForwardIterator>\n        typename enable_if\n        <\n            __is_forward_iterator<_ForwardIterator>::value &&\n            is_constructible<\n                 value_type,\n                 typename iterator_traits<_ForwardIterator>::reference>::value,\n            iterator\n        >::type\n        insert(const_iterator __position, _ForwardIterator __first, _ForwardIterator __last);\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    iterator insert(const_iterator __position, initializer_list<value_type> __il)\n        {return insert(__position, __il.begin(), __il.end());}\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    _LIBCPP_INLINE_VISIBILITY iterator erase(const_iterator __position);\n    iterator erase(const_iterator __first, const_iterator __last);\n\n    _LIBCPP_INLINE_VISIBILITY\n    void clear() _NOEXCEPT\n    {\n        size_type __old_size = size();\n        __base::clear();\n        __annotate_shrink(__old_size);\n        __invalidate_all_iterators();\n    }\n\n    void resize(size_type __sz);\n    void resize(size_type __sz, const_reference __x);\n\n    void swap(vector&)\n#if _LIBCPP_STD_VER >= 14\n        _NOEXCEPT_DEBUG;\n#else\n        _NOEXCEPT_DEBUG_(!__alloc_traits::propagate_on_container_swap::value ||\n                    __is_nothrow_swappable<allocator_type>::value);\n#endif\n\n    bool __invariants() const;\n\n#if _LIBCPP_DEBUG_LEVEL >= 2\n\n    bool __dereferenceable(const const_iterator* __i) const;\n    bool __decrementable(const const_iterator* __i) const;\n    bool __addable(const const_iterator* __i, ptrdiff_t __n) const;\n    bool __subscriptable(const const_iterator* __i, ptrdiff_t __n) const;\n\n#endif  // _LIBCPP_DEBUG_LEVEL >= 2\n\nprivate:\n    _LIBCPP_INLINE_VISIBILITY void __invalidate_all_iterators();\n    _LIBCPP_INLINE_VISIBILITY void __invalidate_iterators_past(pointer __new_last);\n    void allocate(size_type __n);\n    void deallocate() _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY size_type __recommend(size_type __new_size) const;\n    void __construct_at_end(size_type __n);\n    _LIBCPP_INLINE_VISIBILITY\n    void __construct_at_end(size_type __n, const_reference __x);\n    template <class _ForwardIterator>\n        typename enable_if\n        <\n            __is_forward_iterator<_ForwardIterator>::value,\n            void\n        >::type\n        __construct_at_end(_ForwardIterator __first, _ForwardIterator __last, size_type __n);\n    void __append(size_type __n);\n    void __append(size_type __n, const_reference __x);\n    _LIBCPP_INLINE_VISIBILITY\n    iterator       __make_iter(pointer __p) _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator __make_iter(const_pointer __p) const _NOEXCEPT;\n    void __swap_out_circular_buffer(__split_buffer<value_type, allocator_type&>& __v);\n    pointer __swap_out_circular_buffer(__split_buffer<value_type, allocator_type&>& __v, pointer __p);\n    void __move_range(pointer __from_s, pointer __from_e, pointer __to);\n    void __move_assign(vector& __c, true_type)\n        _NOEXCEPT_(is_nothrow_move_assignable<allocator_type>::value);\n    void __move_assign(vector& __c, false_type)\n        _NOEXCEPT_(__alloc_traits::is_always_equal::value);\n    _LIBCPP_INLINE_VISIBILITY\n    void __destruct_at_end(pointer __new_last) _NOEXCEPT\n    {\n        __invalidate_iterators_past(__new_last);\n        size_type __old_size = size();\n        __base::__destruct_at_end(__new_last);\n        __annotate_shrink(__old_size);\n    }\n    template <class _Up>\n        void\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n        __push_back_slow_path(_Up&& __x);\n#else\n        __push_back_slow_path(_Up& __x);\n#endif\n#if !defined(_LIBCPP_HAS_NO_VARIADICS) && !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)\n    template <class... _Args>\n        void\n        __emplace_back_slow_path(_Args&&... __args);\n#endif\n    // The following functions are no-ops outside of AddressSanitizer mode.\n    // We call annotatations only for the default Allocator because other allocators\n    // may not meet the AddressSanitizer alignment constraints.\n    // See the documentation for __sanitizer_annotate_contiguous_container for more details.\n#ifndef _LIBCPP_HAS_NO_ASAN\n    void __annotate_contiguous_container(const void *__beg, const void *__end,\n                                         const void *__old_mid,\n                                         const void *__new_mid) const\n    {\n\n      if (__beg && is_same<allocator_type, __default_allocator_type>::value)\n        __sanitizer_annotate_contiguous_container(__beg, __end, __old_mid, __new_mid);\n    }\n#else\n    _LIBCPP_INLINE_VISIBILITY\n    void __annotate_contiguous_container(const void*, const void*, const void*,\n                                         const void*) const {}\n#endif\n    _LIBCPP_INLINE_VISIBILITY\n    void __annotate_new(size_type __current_size) const {\n      __annotate_contiguous_container(data(), data() + capacity(),\n                                      data() + capacity(), data() + __current_size);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __annotate_delete() const {\n      __annotate_contiguous_container(data(), data() + capacity(),\n                                      data() + size(), data() + capacity());\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __annotate_increase(size_type __n) const\n    {\n      __annotate_contiguous_container(data(), data() + capacity(),\n                                      data() + size(), data() + size() + __n);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __annotate_shrink(size_type __old_size) const\n    {\n      __annotate_contiguous_container(data(), data() + capacity(),\n                                      data() + __old_size, data() + size());\n    }\n#ifndef _LIBCPP_HAS_NO_ASAN\n    // The annotation for size increase should happen before the actual increase,\n    // but if an exception is thrown after that the annotation has to be undone.\n    struct __RAII_IncreaseAnnotator {\n      __RAII_IncreaseAnnotator(const vector &__v, size_type __n = 1)\n        : __commit(false), __v(__v), __old_size(__v.size() + __n) {\n        __v.__annotate_increase(__n);\n      }\n      void __done() { __commit = true; }\n      ~__RAII_IncreaseAnnotator() {\n        if (__commit) return;\n        __v.__annotate_shrink(__old_size);\n      }\n      bool __commit;\n      const vector &__v;\n      size_type __old_size;\n    };\n#else\n    struct __RAII_IncreaseAnnotator {\n      _LIBCPP_INLINE_VISIBILITY\n      __RAII_IncreaseAnnotator(const vector &, size_type = 1) {}\n      _LIBCPP_INLINE_VISIBILITY void __done() {}\n    };\n#endif\n\n};\n\ntemplate <class _Tp, class _Allocator>\nvoid\nvector<_Tp, _Allocator>::__swap_out_circular_buffer(__split_buffer<value_type, allocator_type&>& __v)\n{\n    __annotate_delete();\n    __alloc_traits::__construct_backward(this->__alloc(), this->__begin_, this->__end_, __v.__begin_);\n    _VSTD::swap(this->__begin_, __v.__begin_);\n    _VSTD::swap(this->__end_, __v.__end_);\n    _VSTD::swap(this->__end_cap(), __v.__end_cap());\n    __v.__first_ = __v.__begin_;\n    __annotate_new(size());\n    __invalidate_all_iterators();\n}\n\ntemplate <class _Tp, class _Allocator>\ntypename vector<_Tp, _Allocator>::pointer\nvector<_Tp, _Allocator>::__swap_out_circular_buffer(__split_buffer<value_type, allocator_type&>& __v, pointer __p)\n{\n    __annotate_delete();\n    pointer __r = __v.__begin_;\n    __alloc_traits::__construct_backward(this->__alloc(), this->__begin_, __p, __v.__begin_);\n    __alloc_traits::__construct_forward(this->__alloc(), __p, this->__end_, __v.__end_);\n    _VSTD::swap(this->__begin_, __v.__begin_);\n    _VSTD::swap(this->__end_, __v.__end_);\n    _VSTD::swap(this->__end_cap(), __v.__end_cap());\n    __v.__first_ = __v.__begin_;\n    __annotate_new(size());\n    __invalidate_all_iterators();\n    return __r;\n}\n\n//  Allocate space for __n objects\n//  throws length_error if __n > max_size()\n//  throws (probably bad_alloc) if memory run out\n//  Precondition:  __begin_ == __end_ == __end_cap() == 0\n//  Precondition:  __n > 0\n//  Postcondition:  capacity() == __n\n//  Postcondition:  size() == 0\ntemplate <class _Tp, class _Allocator>\nvoid\nvector<_Tp, _Allocator>::allocate(size_type __n)\n{\n    if (__n > max_size())\n        this->__throw_length_error();\n    this->__begin_ = this->__end_ = __alloc_traits::allocate(this->__alloc(), __n);\n    this->__end_cap() = this->__begin_ + __n;\n    __annotate_new(0);\n}\n\ntemplate <class _Tp, class _Allocator>\nvoid\nvector<_Tp, _Allocator>::deallocate() _NOEXCEPT\n{\n    if (this->__begin_ != nullptr)\n    {\n        clear();\n        __alloc_traits::deallocate(this->__alloc(), this->__begin_, capacity());\n        this->__begin_ = this->__end_ = this->__end_cap() = nullptr;\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\ntypename vector<_Tp, _Allocator>::size_type\nvector<_Tp, _Allocator>::max_size() const _NOEXCEPT\n{\n    return _VSTD::min<size_type>(__alloc_traits::max_size(this->__alloc()),\n                                 numeric_limits<difference_type>::max());\n}\n\n//  Precondition:  __new_size > capacity()\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename vector<_Tp, _Allocator>::size_type\nvector<_Tp, _Allocator>::__recommend(size_type __new_size) const\n{\n    const size_type __ms = max_size();\n    if (__new_size > __ms)\n        this->__throw_length_error();\n    const size_type __cap = capacity();\n    if (__cap >= __ms / 2)\n        return __ms;\n    return _VSTD::max<size_type>(2*__cap, __new_size);\n}\n\n//  Default constructs __n objects starting at __end_\n//  throws if construction throws\n//  Precondition:  __n > 0\n//  Precondition:  size() + __n <= capacity()\n//  Postcondition:  size() == size() + __n\ntemplate <class _Tp, class _Allocator>\nvoid\nvector<_Tp, _Allocator>::__construct_at_end(size_type __n)\n{\n    allocator_type& __a = this->__alloc();\n    do\n    {\n        __RAII_IncreaseAnnotator __annotator(*this);\n        __alloc_traits::construct(__a, _VSTD::__to_raw_pointer(this->__end_));\n        ++this->__end_;\n        --__n;\n        __annotator.__done();\n    } while (__n > 0);\n}\n\n//  Copy constructs __n objects starting at __end_ from __x\n//  throws if construction throws\n//  Precondition:  __n > 0\n//  Precondition:  size() + __n <= capacity()\n//  Postcondition:  size() == old size() + __n\n//  Postcondition:  [i] == __x for all i in [size() - __n, __n)\ntemplate <class _Tp, class _Allocator>\ninline\nvoid\nvector<_Tp, _Allocator>::__construct_at_end(size_type __n, const_reference __x)\n{\n    allocator_type& __a = this->__alloc();\n    do\n    {\n        __RAII_IncreaseAnnotator __annotator(*this);\n        __alloc_traits::construct(__a, _VSTD::__to_raw_pointer(this->__end_), __x);\n        ++this->__end_;\n        --__n;\n        __annotator.__done();\n    } while (__n > 0);\n}\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class _ForwardIterator>\ntypename enable_if\n<\n    __is_forward_iterator<_ForwardIterator>::value,\n    void\n>::type\nvector<_Tp, _Allocator>::__construct_at_end(_ForwardIterator __first, _ForwardIterator __last, size_type __n)\n{\n    allocator_type& __a = this->__alloc();\n    __RAII_IncreaseAnnotator __annotator(*this, __n);\n    __alloc_traits::__construct_range_forward(__a, __first, __last, this->__end_);\n    __annotator.__done();\n}\n\n//  Default constructs __n objects starting at __end_\n//  throws if construction throws\n//  Postcondition:  size() == size() + __n\n//  Exception safety: strong.\ntemplate <class _Tp, class _Allocator>\nvoid\nvector<_Tp, _Allocator>::__append(size_type __n)\n{\n    if (static_cast<size_type>(this->__end_cap() - this->__end_) >= __n)\n        this->__construct_at_end(__n);\n    else\n    {\n        allocator_type& __a = this->__alloc();\n        __split_buffer<value_type, allocator_type&> __v(__recommend(size() + __n), size(), __a);\n        __v.__construct_at_end(__n);\n        __swap_out_circular_buffer(__v);\n    }\n}\n\n//  Default constructs __n objects starting at __end_\n//  throws if construction throws\n//  Postcondition:  size() == size() + __n\n//  Exception safety: strong.\ntemplate <class _Tp, class _Allocator>\nvoid\nvector<_Tp, _Allocator>::__append(size_type __n, const_reference __x)\n{\n    if (static_cast<size_type>(this->__end_cap() - this->__end_) >= __n)\n        this->__construct_at_end(__n, __x);\n    else\n    {\n        allocator_type& __a = this->__alloc();\n        __split_buffer<value_type, allocator_type&> __v(__recommend(size() + __n), size(), __a);\n        __v.__construct_at_end(__n, __x);\n        __swap_out_circular_buffer(__v);\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\nvector<_Tp, _Allocator>::vector(size_type __n)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    if (__n > 0)\n    {\n        allocate(__n);\n        __construct_at_end(__n);\n    }\n}\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp, class _Allocator>\nvector<_Tp, _Allocator>::vector(size_type __n, const allocator_type& __a)\n    : __base(__a)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    if (__n > 0)\n    {\n        allocate(__n);\n        __construct_at_end(__n);\n    }\n}\n#endif\n\ntemplate <class _Tp, class _Allocator>\nvector<_Tp, _Allocator>::vector(size_type __n, const_reference __x)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    if (__n > 0)\n    {\n        allocate(__n);\n        __construct_at_end(__n, __x);\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\nvector<_Tp, _Allocator>::vector(size_type __n, const_reference __x, const allocator_type& __a)\n    : __base(__a)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    if (__n > 0)\n    {\n        allocate(__n);\n        __construct_at_end(__n, __x);\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class _InputIterator>\nvector<_Tp, _Allocator>::vector(_InputIterator __first,\n       typename enable_if<__is_input_iterator  <_InputIterator>::value &&\n                         !__is_forward_iterator<_InputIterator>::value &&\n                         is_constructible<\n                            value_type,\n                            typename iterator_traits<_InputIterator>::reference>::value,\n                          _InputIterator>::type __last)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    for (; __first != __last; ++__first)\n        push_back(*__first);\n}\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class _InputIterator>\nvector<_Tp, _Allocator>::vector(_InputIterator __first, _InputIterator __last, const allocator_type& __a,\n       typename enable_if<__is_input_iterator  <_InputIterator>::value &&\n                         !__is_forward_iterator<_InputIterator>::value &&\n                         is_constructible<\n                            value_type,\n                            typename iterator_traits<_InputIterator>::reference>::value>::type*)\n    : __base(__a)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    for (; __first != __last; ++__first)\n        push_back(*__first);\n}\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class _ForwardIterator>\nvector<_Tp, _Allocator>::vector(_ForwardIterator __first,\n                                typename enable_if<__is_forward_iterator<_ForwardIterator>::value &&\n                                is_constructible<\n                                   value_type,\n                                   typename iterator_traits<_ForwardIterator>::reference>::value,\n                                                   _ForwardIterator>::type __last)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    size_type __n = static_cast<size_type>(_VSTD::distance(__first, __last));\n    if (__n > 0)\n    {\n        allocate(__n);\n        __construct_at_end(__first, __last, __n);\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class _ForwardIterator>\nvector<_Tp, _Allocator>::vector(_ForwardIterator __first, _ForwardIterator __last, const allocator_type& __a,\n                                typename enable_if<__is_forward_iterator<_ForwardIterator>::value &&\n                                is_constructible<\n                                   value_type,\n                                   typename iterator_traits<_ForwardIterator>::reference>::value>::type*)\n    : __base(__a)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    size_type __n = static_cast<size_type>(_VSTD::distance(__first, __last));\n    if (__n > 0)\n    {\n        allocate(__n);\n        __construct_at_end(__first, __last, __n);\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\nvector<_Tp, _Allocator>::vector(const vector& __x)\n    : __base(__alloc_traits::select_on_container_copy_construction(__x.__alloc()))\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    size_type __n = __x.size();\n    if (__n > 0)\n    {\n        allocate(__n);\n        __construct_at_end(__x.__begin_, __x.__end_, __n);\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\nvector<_Tp, _Allocator>::vector(const vector& __x, const allocator_type& __a)\n    : __base(__a)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    size_type __n = __x.size();\n    if (__n > 0)\n    {\n        allocate(__n);\n        __construct_at_end(__x.__begin_, __x.__end_, __n);\n    }\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvector<_Tp, _Allocator>::vector(vector&& __x)\n#if _LIBCPP_STD_VER > 14\n        _NOEXCEPT\n#else\n        _NOEXCEPT_(is_nothrow_move_constructible<allocator_type>::value)\n#endif\n    : __base(_VSTD::move(__x.__alloc()))\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n    __get_db()->swap(this, &__x);\n#endif\n    this->__begin_ = __x.__begin_;\n    this->__end_ = __x.__end_;\n    this->__end_cap() = __x.__end_cap();\n    __x.__begin_ = __x.__end_ = __x.__end_cap() = nullptr;\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvector<_Tp, _Allocator>::vector(vector&& __x, const allocator_type& __a)\n    : __base(__a)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    if (__a == __x.__alloc())\n    {\n        this->__begin_ = __x.__begin_;\n        this->__end_ = __x.__end_;\n        this->__end_cap() = __x.__end_cap();\n        __x.__begin_ = __x.__end_ = __x.__end_cap() = nullptr;\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        __get_db()->swap(this, &__x);\n#endif\n    }\n    else\n    {\n        typedef move_iterator<iterator> _Ip;\n        assign(_Ip(__x.begin()), _Ip(__x.end()));\n    }\n}\n\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvector<_Tp, _Allocator>::vector(initializer_list<value_type> __il)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    if (__il.size() > 0)\n    {\n        allocate(__il.size());\n        __construct_at_end(__il.begin(), __il.end(), __il.size());\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvector<_Tp, _Allocator>::vector(initializer_list<value_type> __il, const allocator_type& __a)\n    : __base(__a)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    if (__il.size() > 0)\n    {\n        allocate(__il.size());\n        __construct_at_end(__il.begin(), __il.end(), __il.size());\n    }\n}\n\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvector<_Tp, _Allocator>&\nvector<_Tp, _Allocator>::operator=(vector&& __x)\n    _NOEXCEPT_((__noexcept_move_assign_container<_Allocator, __alloc_traits>::value))\n{\n    __move_assign(__x, integral_constant<bool,\n          __alloc_traits::propagate_on_container_move_assignment::value>());\n    return *this;\n}\n\ntemplate <class _Tp, class _Allocator>\nvoid\nvector<_Tp, _Allocator>::__move_assign(vector& __c, false_type)\n    _NOEXCEPT_(__alloc_traits::is_always_equal::value)\n{\n    if (__base::__alloc() != __c.__alloc())\n    {\n        typedef move_iterator<iterator> _Ip;\n        assign(_Ip(__c.begin()), _Ip(__c.end()));\n    }\n    else\n        __move_assign(__c, true_type());\n}\n\ntemplate <class _Tp, class _Allocator>\nvoid\nvector<_Tp, _Allocator>::__move_assign(vector& __c, true_type)\n    _NOEXCEPT_(is_nothrow_move_assignable<allocator_type>::value)\n{\n    deallocate();\n    __base::__move_assign_alloc(__c); // this can throw\n    this->__begin_ = __c.__begin_;\n    this->__end_ = __c.__end_;\n    this->__end_cap() = __c.__end_cap();\n    __c.__begin_ = __c.__end_ = __c.__end_cap() = nullptr;\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->swap(this, &__c);\n#endif\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvector<_Tp, _Allocator>&\nvector<_Tp, _Allocator>::operator=(const vector& __x)\n{\n    if (this != &__x)\n    {\n        __base::__copy_assign_alloc(__x);\n        assign(__x.__begin_, __x.__end_);\n    }\n    return *this;\n}\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class _InputIterator>\ntypename enable_if\n<\n     __is_input_iterator  <_InputIterator>::value &&\n    !__is_forward_iterator<_InputIterator>::value &&\n    is_constructible<\n       _Tp,\n       typename iterator_traits<_InputIterator>::reference>::value,\n    void\n>::type\nvector<_Tp, _Allocator>::assign(_InputIterator __first, _InputIterator __last)\n{\n    clear();\n    for (; __first != __last; ++__first)\n        push_back(*__first);\n}\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class _ForwardIterator>\ntypename enable_if\n<\n    __is_forward_iterator<_ForwardIterator>::value &&\n    is_constructible<\n       _Tp,\n       typename iterator_traits<_ForwardIterator>::reference>::value,\n    void\n>::type\nvector<_Tp, _Allocator>::assign(_ForwardIterator __first, _ForwardIterator __last)\n{\n    size_type __new_size = static_cast<size_type>(_VSTD::distance(__first, __last));\n    if (__new_size <= capacity())\n    {\n        _ForwardIterator __mid = __last;\n        bool __growing = false;\n        if (__new_size > size())\n        {\n            __growing = true;\n            __mid =  __first;\n            _VSTD::advance(__mid, size());\n        }\n        pointer __m = _VSTD::copy(__first, __mid, this->__begin_);\n        if (__growing)\n            __construct_at_end(__mid, __last, __new_size - size());\n        else\n            this->__destruct_at_end(__m);\n    }\n    else\n    {\n        deallocate();\n        allocate(__recommend(__new_size));\n        __construct_at_end(__first, __last, __new_size);\n    }\n    __invalidate_all_iterators();\n}\n\ntemplate <class _Tp, class _Allocator>\nvoid\nvector<_Tp, _Allocator>::assign(size_type __n, const_reference __u)\n{\n    if (__n <= capacity())\n    {\n        size_type __s = size();\n        _VSTD::fill_n(this->__begin_, _VSTD::min(__n, __s), __u);\n        if (__n > __s)\n            __construct_at_end(__n - __s, __u);\n        else\n            this->__destruct_at_end(this->__begin_ + __n);\n    }\n    else\n    {\n        deallocate();\n        allocate(__recommend(static_cast<size_type>(__n)));\n        __construct_at_end(__n, __u);\n    }\n    __invalidate_all_iterators();\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename vector<_Tp, _Allocator>::iterator\nvector<_Tp, _Allocator>::__make_iter(pointer __p) _NOEXCEPT\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    return iterator(this, __p);\n#else\n    return iterator(__p);\n#endif\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename vector<_Tp, _Allocator>::const_iterator\nvector<_Tp, _Allocator>::__make_iter(const_pointer __p) const _NOEXCEPT\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    return const_iterator(this, __p);\n#else\n    return const_iterator(__p);\n#endif\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename vector<_Tp, _Allocator>::iterator\nvector<_Tp, _Allocator>::begin() _NOEXCEPT\n{\n    return __make_iter(this->__begin_);\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename vector<_Tp, _Allocator>::const_iterator\nvector<_Tp, _Allocator>::begin() const _NOEXCEPT\n{\n    return __make_iter(this->__begin_);\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename vector<_Tp, _Allocator>::iterator\nvector<_Tp, _Allocator>::end() _NOEXCEPT\n{\n    return __make_iter(this->__end_);\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename vector<_Tp, _Allocator>::const_iterator\nvector<_Tp, _Allocator>::end() const _NOEXCEPT\n{\n    return __make_iter(this->__end_);\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename vector<_Tp, _Allocator>::reference\nvector<_Tp, _Allocator>::operator[](size_type __n)\n{\n    _LIBCPP_ASSERT(__n < size(), \"vector[] index out of bounds\");\n    return this->__begin_[__n];\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename vector<_Tp, _Allocator>::const_reference\nvector<_Tp, _Allocator>::operator[](size_type __n) const\n{\n    _LIBCPP_ASSERT(__n < size(), \"vector[] index out of bounds\");\n    return this->__begin_[__n];\n}\n\ntemplate <class _Tp, class _Allocator>\ntypename vector<_Tp, _Allocator>::reference\nvector<_Tp, _Allocator>::at(size_type __n)\n{\n    if (__n >= size())\n        this->__throw_out_of_range();\n    return this->__begin_[__n];\n}\n\ntemplate <class _Tp, class _Allocator>\ntypename vector<_Tp, _Allocator>::const_reference\nvector<_Tp, _Allocator>::at(size_type __n) const\n{\n    if (__n >= size())\n        this->__throw_out_of_range();\n    return this->__begin_[__n];\n}\n\ntemplate <class _Tp, class _Allocator>\nvoid\nvector<_Tp, _Allocator>::reserve(size_type __n)\n{\n    if (__n > capacity())\n    {\n        allocator_type& __a = this->__alloc();\n        __split_buffer<value_type, allocator_type&> __v(__n, size(), __a);\n        __swap_out_circular_buffer(__v);\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\nvoid\nvector<_Tp, _Allocator>::shrink_to_fit() _NOEXCEPT\n{\n    if (capacity() > size())\n    {\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        try\n        {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n            allocator_type& __a = this->__alloc();\n            __split_buffer<value_type, allocator_type&> __v(size(), size(), __a);\n            __swap_out_circular_buffer(__v);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        }\n        catch (...)\n        {\n        }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class _Up>\nvoid\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\nvector<_Tp, _Allocator>::__push_back_slow_path(_Up&& __x)\n#else\nvector<_Tp, _Allocator>::__push_back_slow_path(_Up& __x)\n#endif\n{\n    allocator_type& __a = this->__alloc();\n    __split_buffer<value_type, allocator_type&> __v(__recommend(size() + 1), size(), __a);\n    // __v.push_back(_VSTD::forward<_Up>(__x));\n    __alloc_traits::construct(__a, _VSTD::__to_raw_pointer(__v.__end_), _VSTD::forward<_Up>(__x));\n    __v.__end_++;\n    __swap_out_circular_buffer(__v);\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nvector<_Tp, _Allocator>::push_back(const_reference __x)\n{\n    if (this->__end_ != this->__end_cap())\n    {\n        __RAII_IncreaseAnnotator __annotator(*this);\n        __alloc_traits::construct(this->__alloc(),\n                                  _VSTD::__to_raw_pointer(this->__end_), __x);\n        __annotator.__done();\n        ++this->__end_;\n    }\n    else\n        __push_back_slow_path(__x);\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nvector<_Tp, _Allocator>::push_back(value_type&& __x)\n{\n    if (this->__end_ < this->__end_cap())\n    {\n        __RAII_IncreaseAnnotator __annotator(*this);\n        __alloc_traits::construct(this->__alloc(),\n                                  _VSTD::__to_raw_pointer(this->__end_),\n                                  _VSTD::move(__x));\n        __annotator.__done();\n        ++this->__end_;\n    }\n    else\n        __push_back_slow_path(_VSTD::move(__x));\n}\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class... _Args>\nvoid\nvector<_Tp, _Allocator>::__emplace_back_slow_path(_Args&&... __args)\n{\n    allocator_type& __a = this->__alloc();\n    __split_buffer<value_type, allocator_type&> __v(__recommend(size() + 1), size(), __a);\n//    __v.emplace_back(_VSTD::forward<_Args>(__args)...);\n    __alloc_traits::construct(__a, _VSTD::__to_raw_pointer(__v.__end_), _VSTD::forward<_Args>(__args)...);\n    __v.__end_++;\n    __swap_out_circular_buffer(__v);\n}\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class... _Args>\ninline\n#if _LIBCPP_STD_VER > 14\ntypename vector<_Tp, _Allocator>::reference\n#else\nvoid\n#endif\nvector<_Tp, _Allocator>::emplace_back(_Args&&... __args)\n{\n    if (this->__end_ < this->__end_cap())\n    {\n        __RAII_IncreaseAnnotator __annotator(*this);\n        __alloc_traits::construct(this->__alloc(),\n                                  _VSTD::__to_raw_pointer(this->__end_),\n                                  _VSTD::forward<_Args>(__args)...);\n        __annotator.__done();\n        ++this->__end_;\n    }\n    else\n        __emplace_back_slow_path(_VSTD::forward<_Args>(__args)...);\n#if _LIBCPP_STD_VER > 14\n    return this->back();\n#endif\n}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Allocator>\ninline\nvoid\nvector<_Tp, _Allocator>::pop_back()\n{\n    _LIBCPP_ASSERT(!empty(), \"vector::pop_back called for empty vector\");\n    this->__destruct_at_end(this->__end_ - 1);\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename vector<_Tp, _Allocator>::iterator\nvector<_Tp, _Allocator>::erase(const_iterator __position)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__position) == this,\n        \"vector::erase(iterator) called with an iterator not\"\n        \" referring to this vector\");\n#endif\n    _LIBCPP_ASSERT(__position != end(),\n        \"vector::erase(iterator) called with a non-dereferenceable iterator\");\n    difference_type __ps = __position - cbegin();\n    pointer __p = this->__begin_ + __ps;\n    this->__destruct_at_end(_VSTD::move(__p + 1, this->__end_, __p));\n    this->__invalidate_iterators_past(__p-1);\n    iterator __r = __make_iter(__p);\n    return __r;\n}\n\ntemplate <class _Tp, class _Allocator>\ntypename vector<_Tp, _Allocator>::iterator\nvector<_Tp, _Allocator>::erase(const_iterator __first, const_iterator __last)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__first) == this,\n        \"vector::erase(iterator,  iterator) called with an iterator not\"\n        \" referring to this vector\");\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__last) == this,\n        \"vector::erase(iterator,  iterator) called with an iterator not\"\n        \" referring to this vector\");\n#endif\n    _LIBCPP_ASSERT(__first <= __last, \"vector::erase(first, last) called with invalid range\");\n    pointer __p = this->__begin_ + (__first - begin());\n    if (__first != __last) {\n        this->__destruct_at_end(_VSTD::move(__p + (__last - __first), this->__end_, __p));\n        this->__invalidate_iterators_past(__p - 1);\n    }\n    iterator __r = __make_iter(__p);\n    return __r;\n}\n\ntemplate <class _Tp, class _Allocator>\nvoid\nvector<_Tp, _Allocator>::__move_range(pointer __from_s, pointer __from_e, pointer __to)\n{\n    pointer __old_last = this->__end_;\n    difference_type __n = __old_last - __to;\n    for (pointer __i = __from_s + __n; __i < __from_e; ++__i, ++this->__end_)\n        __alloc_traits::construct(this->__alloc(),\n                                  _VSTD::__to_raw_pointer(this->__end_),\n                                  _VSTD::move(*__i));\n    _VSTD::move_backward(__from_s, __from_s + __n, __old_last);\n}\n\ntemplate <class _Tp, class _Allocator>\ntypename vector<_Tp, _Allocator>::iterator\nvector<_Tp, _Allocator>::insert(const_iterator __position, const_reference __x)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__position) == this,\n        \"vector::insert(iterator, x) called with an iterator not\"\n        \" referring to this vector\");\n#endif\n    pointer __p = this->__begin_ + (__position - begin());\n    if (this->__end_ < this->__end_cap())\n    {\n        __RAII_IncreaseAnnotator __annotator(*this);\n        if (__p == this->__end_)\n        {\n            __alloc_traits::construct(this->__alloc(),\n                                      _VSTD::__to_raw_pointer(this->__end_), __x);\n            ++this->__end_;\n        }\n        else\n        {\n            __move_range(__p, this->__end_, __p + 1);\n            const_pointer __xr = pointer_traits<const_pointer>::pointer_to(__x);\n            if (__p <= __xr && __xr < this->__end_)\n                ++__xr;\n            *__p = *__xr;\n        }\n        __annotator.__done();\n    }\n    else\n    {\n        allocator_type& __a = this->__alloc();\n        __split_buffer<value_type, allocator_type&> __v(__recommend(size() + 1), __p - this->__begin_, __a);\n        __v.push_back(__x);\n        __p = __swap_out_circular_buffer(__v, __p);\n    }\n    return __make_iter(__p);\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Allocator>\ntypename vector<_Tp, _Allocator>::iterator\nvector<_Tp, _Allocator>::insert(const_iterator __position, value_type&& __x)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__position) == this,\n        \"vector::insert(iterator, x) called with an iterator not\"\n        \" referring to this vector\");\n#endif\n    pointer __p = this->__begin_ + (__position - begin());\n    if (this->__end_ < this->__end_cap())\n    {\n        __RAII_IncreaseAnnotator __annotator(*this);\n        if (__p == this->__end_)\n        {\n            __alloc_traits::construct(this->__alloc(),\n                                      _VSTD::__to_raw_pointer(this->__end_),\n                                      _VSTD::move(__x));\n            ++this->__end_;\n        }\n        else\n        {\n            __move_range(__p, this->__end_, __p + 1);\n            *__p = _VSTD::move(__x);\n        }\n        __annotator.__done();\n    }\n    else\n    {\n        allocator_type& __a = this->__alloc();\n        __split_buffer<value_type, allocator_type&> __v(__recommend(size() + 1), __p - this->__begin_, __a);\n        __v.push_back(_VSTD::move(__x));\n        __p = __swap_out_circular_buffer(__v, __p);\n    }\n    return __make_iter(__p);\n}\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class... _Args>\ntypename vector<_Tp, _Allocator>::iterator\nvector<_Tp, _Allocator>::emplace(const_iterator __position, _Args&&... __args)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__position) == this,\n        \"vector::emplace(iterator, x) called with an iterator not\"\n        \" referring to this vector\");\n#endif\n    pointer __p = this->__begin_ + (__position - begin());\n    if (this->__end_ < this->__end_cap())\n    {\n        __RAII_IncreaseAnnotator __annotator(*this);\n        if (__p == this->__end_)\n        {\n            __alloc_traits::construct(this->__alloc(),\n                                      _VSTD::__to_raw_pointer(this->__end_),\n                                      _VSTD::forward<_Args>(__args)...);\n            ++this->__end_;\n        }\n        else\n        {\n            __temp_value<value_type, _Allocator> __tmp(this->__alloc(), _VSTD::forward<_Args>(__args)...);\n            __move_range(__p, this->__end_, __p + 1);\n            *__p = _VSTD::move(__tmp.get());\n        }\n        __annotator.__done();\n    }\n    else\n    {\n        allocator_type& __a = this->__alloc();\n        __split_buffer<value_type, allocator_type&> __v(__recommend(size() + 1), __p - this->__begin_, __a);\n        __v.emplace_back(_VSTD::forward<_Args>(__args)...);\n        __p = __swap_out_circular_buffer(__v, __p);\n    }\n    return __make_iter(__p);\n}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Allocator>\ntypename vector<_Tp, _Allocator>::iterator\nvector<_Tp, _Allocator>::insert(const_iterator __position, size_type __n, const_reference __x)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__position) == this,\n        \"vector::insert(iterator, n, x) called with an iterator not\"\n        \" referring to this vector\");\n#endif\n    pointer __p = this->__begin_ + (__position - begin());\n    if (__n > 0)\n    {\n        if (__n <= static_cast<size_type>(this->__end_cap() - this->__end_))\n        {\n            size_type __old_n = __n;\n            pointer __old_last = this->__end_;\n            if (__n > static_cast<size_type>(this->__end_ - __p))\n            {\n                size_type __cx = __n - (this->__end_ - __p);\n                __construct_at_end(__cx, __x);\n                __n -= __cx;\n            }\n            if (__n > 0)\n            {\n                __RAII_IncreaseAnnotator __annotator(*this, __n);\n                __move_range(__p, __old_last, __p + __old_n);\n                __annotator.__done();\n                const_pointer __xr = pointer_traits<const_pointer>::pointer_to(__x);\n                if (__p <= __xr && __xr < this->__end_)\n                    __xr += __old_n;\n                _VSTD::fill_n(__p, __n, *__xr);\n            }\n        }\n        else\n        {\n            allocator_type& __a = this->__alloc();\n            __split_buffer<value_type, allocator_type&> __v(__recommend(size() + __n), __p - this->__begin_, __a);\n            __v.__construct_at_end(__n, __x);\n            __p = __swap_out_circular_buffer(__v, __p);\n        }\n    }\n    return __make_iter(__p);\n}\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class _InputIterator>\ntypename enable_if\n<\n     __is_input_iterator  <_InputIterator>::value &&\n    !__is_forward_iterator<_InputIterator>::value &&\n    is_constructible<\n       _Tp,\n       typename iterator_traits<_InputIterator>::reference>::value,\n    typename vector<_Tp, _Allocator>::iterator\n>::type\nvector<_Tp, _Allocator>::insert(const_iterator __position, _InputIterator __first, _InputIterator __last)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__position) == this,\n        \"vector::insert(iterator, range) called with an iterator not\"\n        \" referring to this vector\");\n#endif\n    difference_type __off = __position - begin();\n    pointer __p = this->__begin_ + __off;\n    allocator_type& __a = this->__alloc();\n    pointer __old_last = this->__end_;\n    for (; this->__end_ != this->__end_cap() && __first != __last; ++__first)\n    {\n        __RAII_IncreaseAnnotator __annotator(*this);\n        __alloc_traits::construct(__a, _VSTD::__to_raw_pointer(this->__end_),\n                                  *__first);\n        ++this->__end_;\n        __annotator.__done();\n    }\n    __split_buffer<value_type, allocator_type&> __v(__a);\n    if (__first != __last)\n    {\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        try\n        {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n            __v.__construct_at_end(__first, __last);\n            difference_type __old_size = __old_last - this->__begin_;\n            difference_type __old_p = __p - this->__begin_;\n            reserve(__recommend(size() + __v.size()));\n            __p = this->__begin_ + __old_p;\n            __old_last = this->__begin_ + __old_size;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        }\n        catch (...)\n        {\n            erase(__make_iter(__old_last), end());\n            throw;\n        }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    }\n    __p = _VSTD::rotate(__p, __old_last, this->__end_);\n    insert(__make_iter(__p), make_move_iterator(__v.begin()),\n                                    make_move_iterator(__v.end()));\n    return begin() + __off;\n}\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class _ForwardIterator>\ntypename enable_if\n<\n    __is_forward_iterator<_ForwardIterator>::value &&\n    is_constructible<\n       _Tp,\n       typename iterator_traits<_ForwardIterator>::reference>::value,\n    typename vector<_Tp, _Allocator>::iterator\n>::type\nvector<_Tp, _Allocator>::insert(const_iterator __position, _ForwardIterator __first, _ForwardIterator __last)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__position) == this,\n        \"vector::insert(iterator, range) called with an iterator not\"\n        \" referring to this vector\");\n#endif\n    pointer __p = this->__begin_ + (__position - begin());\n    difference_type __n = _VSTD::distance(__first, __last);\n    if (__n > 0)\n    {\n        if (__n <= this->__end_cap() - this->__end_)\n        {\n            size_type __old_n = __n;\n            pointer __old_last = this->__end_;\n            _ForwardIterator __m = __last;\n            difference_type __dx = this->__end_ - __p;\n            if (__n > __dx)\n            {\n                __m = __first;\n                difference_type __diff = this->__end_ - __p;\n                _VSTD::advance(__m, __diff);\n                __construct_at_end(__m, __last, __n - __diff);\n                __n = __dx;\n            }\n            if (__n > 0)\n            {\n                __RAII_IncreaseAnnotator __annotator(*this, __n);\n                __move_range(__p, __old_last, __p + __old_n);\n                __annotator.__done();\n                _VSTD::copy(__first, __m, __p);\n            }\n        }\n        else\n        {\n            allocator_type& __a = this->__alloc();\n            __split_buffer<value_type, allocator_type&> __v(__recommend(size() + __n), __p - this->__begin_, __a);\n            __v.__construct_at_end(__first, __last);\n            __p = __swap_out_circular_buffer(__v, __p);\n        }\n    }\n    return __make_iter(__p);\n}\n\ntemplate <class _Tp, class _Allocator>\nvoid\nvector<_Tp, _Allocator>::resize(size_type __sz)\n{\n    size_type __cs = size();\n    if (__cs < __sz)\n        this->__append(__sz - __cs);\n    else if (__cs > __sz)\n        this->__destruct_at_end(this->__begin_ + __sz);\n}\n\ntemplate <class _Tp, class _Allocator>\nvoid\nvector<_Tp, _Allocator>::resize(size_type __sz, const_reference __x)\n{\n    size_type __cs = size();\n    if (__cs < __sz)\n        this->__append(__sz - __cs, __x);\n    else if (__cs > __sz)\n        this->__destruct_at_end(this->__begin_ + __sz);\n}\n\ntemplate <class _Tp, class _Allocator>\nvoid\nvector<_Tp, _Allocator>::swap(vector& __x)\n#if _LIBCPP_STD_VER >= 14\n    _NOEXCEPT_DEBUG\n#else\n    _NOEXCEPT_DEBUG_(!__alloc_traits::propagate_on_container_swap::value ||\n                __is_nothrow_swappable<allocator_type>::value)\n#endif\n{\n    _LIBCPP_ASSERT(__alloc_traits::propagate_on_container_swap::value ||\n                   this->__alloc() == __x.__alloc(),\n                   \"vector::swap: Either propagate_on_container_swap must be true\"\n                   \" or the allocators must compare equal\");\n    _VSTD::swap(this->__begin_, __x.__begin_);\n    _VSTD::swap(this->__end_, __x.__end_);\n    _VSTD::swap(this->__end_cap(), __x.__end_cap());\n    __swap_allocator(this->__alloc(), __x.__alloc(), \n        integral_constant<bool,__alloc_traits::propagate_on_container_swap::value>());\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->swap(this, &__x);\n#endif  // _LIBCPP_DEBUG_LEVEL >= 2\n}\n\ntemplate <class _Tp, class _Allocator>\nbool\nvector<_Tp, _Allocator>::__invariants() const\n{\n    if (this->__begin_ == nullptr)\n    {\n        if (this->__end_ != nullptr || this->__end_cap() != nullptr)\n            return false;\n    }\n    else\n    {\n        if (this->__begin_ > this->__end_)\n            return false;\n        if (this->__begin_ == this->__end_cap())\n            return false;\n        if (this->__end_ > this->__end_cap())\n            return false;\n    }\n    return true;\n}\n\n#if _LIBCPP_DEBUG_LEVEL >= 2\n\ntemplate <class _Tp, class _Allocator>\nbool\nvector<_Tp, _Allocator>::__dereferenceable(const const_iterator* __i) const\n{\n    return this->__begin_ <= __i->base() && __i->base() < this->__end_;\n}\n\ntemplate <class _Tp, class _Allocator>\nbool\nvector<_Tp, _Allocator>::__decrementable(const const_iterator* __i) const\n{\n    return this->__begin_ < __i->base() && __i->base() <= this->__end_;\n}\n\ntemplate <class _Tp, class _Allocator>\nbool\nvector<_Tp, _Allocator>::__addable(const const_iterator* __i, ptrdiff_t __n) const\n{\n    const_pointer __p = __i->base() + __n;\n    return this->__begin_ <= __p && __p <= this->__end_;\n}\n\ntemplate <class _Tp, class _Allocator>\nbool\nvector<_Tp, _Allocator>::__subscriptable(const const_iterator* __i, ptrdiff_t __n) const\n{\n    const_pointer __p = __i->base() + __n;\n    return this->__begin_ <= __p && __p < this->__end_;\n}\n\n#endif  // _LIBCPP_DEBUG_LEVEL >= 2\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nvector<_Tp, _Allocator>::__invalidate_all_iterators()\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__invalidate_all(this);\n#endif  // _LIBCPP_DEBUG_LEVEL >= 2\n}\n\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nvector<_Tp, _Allocator>::__invalidate_iterators_past(pointer __new_last) {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n  __c_node* __c = __get_db()->__find_c_and_lock(this);\n  for (__i_node** __p = __c->end_; __p != __c->beg_; ) {\n    --__p;\n    const_iterator* __i = static_cast<const_iterator*>((*__p)->__i_);\n    if (__i->base() > __new_last) {\n      (*__p)->__c_ = nullptr;\n      if (--__c->end_ != __p)\n        memmove(__p, __p+1, (__c->end_ - __p)*sizeof(__i_node*));\n    }\n  }\n  __get_db()->unlock();\n#else\n  ((void)__new_last);\n#endif\n}\n\n// vector<bool>\n\ntemplate <class _Allocator> class vector<bool, _Allocator>;\n\ntemplate <class _Allocator> struct hash<vector<bool, _Allocator> >;\n\ntemplate <class _Allocator>\nstruct __has_storage_type<vector<bool, _Allocator> >\n{\n    static const bool value = true;\n};\n\ntemplate <class _Allocator>\nclass _LIBCPP_TEMPLATE_VIS vector<bool, _Allocator>\n    : private __vector_base_common<true>\n{\npublic:\n    typedef vector                                   __self;\n    typedef bool                                     value_type;\n    typedef _Allocator                               allocator_type;\n    typedef allocator_traits<allocator_type>         __alloc_traits;\n    typedef typename __alloc_traits::size_type       size_type;\n    typedef typename __alloc_traits::difference_type difference_type;\n    typedef size_type __storage_type;\n    typedef __bit_iterator<vector, false>            pointer;\n    typedef __bit_iterator<vector, true>             const_pointer;\n    typedef pointer                                  iterator;\n    typedef const_pointer                            const_iterator;\n    typedef _VSTD::reverse_iterator<iterator>         reverse_iterator;\n    typedef _VSTD::reverse_iterator<const_iterator>   const_reverse_iterator;\n\nprivate:\n    typedef typename __rebind_alloc_helper<__alloc_traits, __storage_type>::type __storage_allocator;\n    typedef allocator_traits<__storage_allocator>    __storage_traits;\n    typedef typename __storage_traits::pointer       __storage_pointer;\n    typedef typename __storage_traits::const_pointer __const_storage_pointer;\n\n    __storage_pointer                                      __begin_;\n    size_type                                              __size_;\n    __compressed_pair<size_type, __storage_allocator> __cap_alloc_;\npublic:\n    typedef __bit_reference<vector>                  reference;\n    typedef __bit_const_reference<vector>            const_reference;\nprivate:\n    _LIBCPP_INLINE_VISIBILITY\n    size_type& __cap() _NOEXCEPT\n        {return __cap_alloc_.first();}\n    _LIBCPP_INLINE_VISIBILITY\n    const size_type& __cap() const _NOEXCEPT\n        {return __cap_alloc_.first();}\n    _LIBCPP_INLINE_VISIBILITY\n    __storage_allocator& __alloc() _NOEXCEPT\n        {return __cap_alloc_.second();}\n    _LIBCPP_INLINE_VISIBILITY\n    const __storage_allocator& __alloc() const _NOEXCEPT\n        {return __cap_alloc_.second();}\n\n    static const unsigned __bits_per_word = static_cast<unsigned>(sizeof(__storage_type) * CHAR_BIT);\n\n    _LIBCPP_INLINE_VISIBILITY\n    static size_type __internal_cap_to_external(size_type __n) _NOEXCEPT\n        {return __n * __bits_per_word;}\n    _LIBCPP_INLINE_VISIBILITY\n    static size_type __external_cap_to_internal(size_type __n) _NOEXCEPT\n        {return (__n - 1) / __bits_per_word + 1;}\n\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    vector() _NOEXCEPT_(is_nothrow_default_constructible<allocator_type>::value);\n\n    _LIBCPP_INLINE_VISIBILITY explicit vector(const allocator_type& __a)\n#if _LIBCPP_STD_VER <= 14\n        _NOEXCEPT_(is_nothrow_copy_constructible<allocator_type>::value);\n#else\n        _NOEXCEPT;\n#endif\n    ~vector();\n    explicit vector(size_type __n);\n#if _LIBCPP_STD_VER > 11\n    explicit vector(size_type __n, const allocator_type& __a);\n#endif\n    vector(size_type __n, const value_type& __v);\n    vector(size_type __n, const value_type& __v, const allocator_type& __a);\n    template <class _InputIterator>\n        vector(_InputIterator __first, _InputIterator __last,\n               typename enable_if<__is_input_iterator  <_InputIterator>::value &&\n                                 !__is_forward_iterator<_InputIterator>::value>::type* = 0);\n    template <class _InputIterator>\n        vector(_InputIterator __first, _InputIterator __last, const allocator_type& __a,\n               typename enable_if<__is_input_iterator  <_InputIterator>::value &&\n                                 !__is_forward_iterator<_InputIterator>::value>::type* = 0);\n    template <class _ForwardIterator>\n        vector(_ForwardIterator __first, _ForwardIterator __last,\n               typename enable_if<__is_forward_iterator<_ForwardIterator>::value>::type* = 0);\n    template <class _ForwardIterator>\n        vector(_ForwardIterator __first, _ForwardIterator __last, const allocator_type& __a,\n               typename enable_if<__is_forward_iterator<_ForwardIterator>::value>::type* = 0);\n\n    vector(const vector& __v);\n    vector(const vector& __v, const allocator_type& __a);\n    vector& operator=(const vector& __v);\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    vector(initializer_list<value_type> __il);\n    vector(initializer_list<value_type> __il, const allocator_type& __a);\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    vector(vector&& __v)\n#if _LIBCPP_STD_VER > 14\n        _NOEXCEPT;\n#else\n        _NOEXCEPT_(is_nothrow_move_constructible<allocator_type>::value);\n#endif\n    vector(vector&& __v, const allocator_type& __a);\n    _LIBCPP_INLINE_VISIBILITY\n    vector& operator=(vector&& __v)\n        _NOEXCEPT_((__noexcept_move_assign_container<_Allocator, __alloc_traits>::value));\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    vector& operator=(initializer_list<value_type> __il)\n        {assign(__il.begin(), __il.end()); return *this;}\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    template <class _InputIterator>\n        typename enable_if\n        <\n            __is_input_iterator<_InputIterator>::value &&\n           !__is_forward_iterator<_InputIterator>::value,\n           void\n        >::type\n        assign(_InputIterator __first, _InputIterator __last);\n    template <class _ForwardIterator>\n        typename enable_if\n        <\n            __is_forward_iterator<_ForwardIterator>::value,\n           void\n        >::type\n        assign(_ForwardIterator __first, _ForwardIterator __last);\n\n    void assign(size_type __n, const value_type& __x);\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    void assign(initializer_list<value_type> __il)\n        {assign(__il.begin(), __il.end());}\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    _LIBCPP_INLINE_VISIBILITY allocator_type get_allocator() const _NOEXCEPT\n        {return allocator_type(this->__alloc());}\n\n    size_type max_size() const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type capacity() const _NOEXCEPT\n        {return __internal_cap_to_external(__cap());}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type size() const _NOEXCEPT\n        {return __size_;}\n    _LIBCPP_INLINE_VISIBILITY\n    bool empty() const _NOEXCEPT\n        {return __size_ == 0;}\n    void reserve(size_type __n);\n    void shrink_to_fit() _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator begin() _NOEXCEPT\n        {return __make_iter(0);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator begin() const _NOEXCEPT\n        {return __make_iter(0);}\n    _LIBCPP_INLINE_VISIBILITY\n    iterator end() _NOEXCEPT\n        {return __make_iter(__size_);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator end()   const _NOEXCEPT\n        {return __make_iter(__size_);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    reverse_iterator rbegin() _NOEXCEPT\n        {return       reverse_iterator(end());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator rbegin() const _NOEXCEPT\n        {return const_reverse_iterator(end());}\n    _LIBCPP_INLINE_VISIBILITY\n    reverse_iterator rend() _NOEXCEPT\n        {return       reverse_iterator(begin());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator rend()   const _NOEXCEPT\n        {return const_reverse_iterator(begin());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator         cbegin()  const _NOEXCEPT\n        {return __make_iter(0);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator         cend()    const _NOEXCEPT\n        {return __make_iter(__size_);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator crbegin() const _NOEXCEPT\n        {return rbegin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator crend()   const _NOEXCEPT\n        {return rend();}\n\n    _LIBCPP_INLINE_VISIBILITY reference       operator[](size_type __n)       {return __make_ref(__n);}\n    _LIBCPP_INLINE_VISIBILITY const_reference operator[](size_type __n) const {return __make_ref(__n);}\n    reference       at(size_type __n);\n    const_reference at(size_type __n) const;\n\n    _LIBCPP_INLINE_VISIBILITY reference       front()       {return __make_ref(0);}\n    _LIBCPP_INLINE_VISIBILITY const_reference front() const {return __make_ref(0);}\n    _LIBCPP_INLINE_VISIBILITY reference       back()        {return __make_ref(__size_ - 1);}\n    _LIBCPP_INLINE_VISIBILITY const_reference back()  const {return __make_ref(__size_ - 1);}\n\n    void push_back(const value_type& __x);\n#if _LIBCPP_STD_VER > 11\n    template <class... _Args>\n#if _LIBCPP_STD_VER > 14\n    _LIBCPP_INLINE_VISIBILITY reference emplace_back(_Args&&... __args)\n#else\n    _LIBCPP_INLINE_VISIBILITY void      emplace_back(_Args&&... __args)\n#endif\n    {\n        push_back ( value_type ( _VSTD::forward<_Args>(__args)... ));\n#if _LIBCPP_STD_VER > 14\n        return this->back();\n#endif\n    }\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY void pop_back() {--__size_;}\n\n#if _LIBCPP_STD_VER > 11\n    template <class... _Args>\n   _LIBCPP_INLINE_VISIBILITY iterator emplace(const_iterator position, _Args&&... __args)\n        { return insert ( position, value_type ( _VSTD::forward<_Args>(__args)... )); }\n#endif\n\n    iterator insert(const_iterator __position, const value_type& __x);\n    iterator insert(const_iterator __position, size_type __n, const value_type& __x);\n    iterator insert(const_iterator __position, size_type __n, const_reference __x);\n    template <class _InputIterator>\n        typename enable_if\n        <\n             __is_input_iterator  <_InputIterator>::value &&\n            !__is_forward_iterator<_InputIterator>::value,\n            iterator\n        >::type\n        insert(const_iterator __position, _InputIterator __first, _InputIterator __last);\n    template <class _ForwardIterator>\n        typename enable_if\n        <\n            __is_forward_iterator<_ForwardIterator>::value,\n            iterator\n        >::type\n        insert(const_iterator __position, _ForwardIterator __first, _ForwardIterator __last);\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    iterator insert(const_iterator __position, initializer_list<value_type> __il)\n        {return insert(__position, __il.begin(), __il.end());}\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    _LIBCPP_INLINE_VISIBILITY iterator erase(const_iterator __position);\n    iterator erase(const_iterator __first, const_iterator __last);\n\n    _LIBCPP_INLINE_VISIBILITY\n    void clear() _NOEXCEPT {__size_ = 0;}\n\n    void swap(vector&)\n#if _LIBCPP_STD_VER >= 14\n        _NOEXCEPT;\n#else\n        _NOEXCEPT_(!__alloc_traits::propagate_on_container_swap::value ||\n                    __is_nothrow_swappable<allocator_type>::value);\n#endif\n    static void swap(reference __x, reference __y) _NOEXCEPT { _VSTD::swap(__x, __y); }\n\n    void resize(size_type __sz, value_type __x = false);\n    void flip() _NOEXCEPT;\n\n    bool __invariants() const;\n\nprivate:\n    _LIBCPP_INLINE_VISIBILITY void __invalidate_all_iterators();\n    void allocate(size_type __n);\n    void deallocate() _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    static size_type __align_it(size_type __new_size) _NOEXCEPT\n        {return __new_size + (__bits_per_word-1) & ~((size_type)__bits_per_word-1);};\n    _LIBCPP_INLINE_VISIBILITY  size_type __recommend(size_type __new_size) const;\n    _LIBCPP_INLINE_VISIBILITY void __construct_at_end(size_type __n, bool __x);\n    template <class _ForwardIterator>\n        typename enable_if\n        <\n            __is_forward_iterator<_ForwardIterator>::value,\n            void\n        >::type\n        __construct_at_end(_ForwardIterator __first, _ForwardIterator __last);\n    void __append(size_type __n, const_reference __x);\n    _LIBCPP_INLINE_VISIBILITY\n    reference __make_ref(size_type __pos) _NOEXCEPT\n        {return reference(__begin_ + __pos / __bits_per_word, __storage_type(1) << __pos % __bits_per_word);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reference __make_ref(size_type __pos) const _NOEXCEPT\n        {return const_reference(__begin_ + __pos / __bits_per_word, __storage_type(1) << __pos % __bits_per_word);}\n    _LIBCPP_INLINE_VISIBILITY\n    iterator __make_iter(size_type __pos) _NOEXCEPT\n        {return iterator(__begin_ + __pos / __bits_per_word, static_cast<unsigned>(__pos % __bits_per_word));}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator __make_iter(size_type __pos) const _NOEXCEPT\n        {return const_iterator(__begin_ + __pos / __bits_per_word, static_cast<unsigned>(__pos % __bits_per_word));}\n    _LIBCPP_INLINE_VISIBILITY\n    iterator __const_iterator_cast(const_iterator __p) _NOEXCEPT\n        {return begin() + (__p - cbegin());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __copy_assign_alloc(const vector& __v)\n        {__copy_assign_alloc(__v, integral_constant<bool,\n                      __storage_traits::propagate_on_container_copy_assignment::value>());}\n    _LIBCPP_INLINE_VISIBILITY\n    void __copy_assign_alloc(const vector& __c, true_type)\n        {\n            if (__alloc() != __c.__alloc())\n                deallocate();\n            __alloc() = __c.__alloc();\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __copy_assign_alloc(const vector&, false_type)\n        {}\n\n    void __move_assign(vector& __c, false_type);\n    void __move_assign(vector& __c, true_type)\n        _NOEXCEPT_(is_nothrow_move_assignable<allocator_type>::value);\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign_alloc(vector& __c)\n        _NOEXCEPT_(\n            !__storage_traits::propagate_on_container_move_assignment::value ||\n            is_nothrow_move_assignable<allocator_type>::value)\n        {__move_assign_alloc(__c, integral_constant<bool,\n                      __storage_traits::propagate_on_container_move_assignment::value>());}\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign_alloc(vector& __c, true_type)\n        _NOEXCEPT_(is_nothrow_move_assignable<allocator_type>::value)\n        {\n            __alloc() = _VSTD::move(__c.__alloc());\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign_alloc(vector&, false_type)\n        _NOEXCEPT\n        {}\n\n    size_t __hash_code() const _NOEXCEPT;\n\n    friend class __bit_reference<vector>;\n    friend class __bit_const_reference<vector>;\n    friend class __bit_iterator<vector, false>;\n    friend class __bit_iterator<vector, true>;\n    friend struct __bit_array<vector>;\n    friend struct _LIBCPP_TEMPLATE_VIS hash<vector>;\n};\n\ntemplate <class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nvector<bool, _Allocator>::__invalidate_all_iterators()\n{\n}\n\n//  Allocate space for __n objects\n//  throws length_error if __n > max_size()\n//  throws (probably bad_alloc) if memory run out\n//  Precondition:  __begin_ == __end_ == __cap() == 0\n//  Precondition:  __n > 0\n//  Postcondition:  capacity() == __n\n//  Postcondition:  size() == 0\ntemplate <class _Allocator>\nvoid\nvector<bool, _Allocator>::allocate(size_type __n)\n{\n    if (__n > max_size())\n        this->__throw_length_error();\n    __n = __external_cap_to_internal(__n);\n    this->__begin_ = __storage_traits::allocate(this->__alloc(), __n);\n    this->__size_ = 0;\n    this->__cap() = __n;\n}\n\ntemplate <class _Allocator>\nvoid\nvector<bool, _Allocator>::deallocate() _NOEXCEPT\n{\n    if (this->__begin_ != nullptr)\n    {\n        __storage_traits::deallocate(this->__alloc(), this->__begin_, __cap());\n        __invalidate_all_iterators();\n        this->__begin_ = nullptr;\n        this->__size_ = this->__cap() = 0;\n    }\n}\n\ntemplate <class _Allocator>\ntypename vector<bool, _Allocator>::size_type\nvector<bool, _Allocator>::max_size() const _NOEXCEPT\n{\n    size_type __amax = __storage_traits::max_size(__alloc());\n    size_type __nmax = numeric_limits<size_type>::max() / 2;  // end() >= begin(), always\n    if (__nmax / __bits_per_word <= __amax)\n        return __nmax;\n    return __internal_cap_to_external(__amax);\n}\n\n//  Precondition:  __new_size > capacity()\ntemplate <class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename vector<bool, _Allocator>::size_type\nvector<bool, _Allocator>::__recommend(size_type __new_size) const\n{\n    const size_type __ms = max_size();\n    if (__new_size > __ms)\n        this->__throw_length_error();\n    const size_type __cap = capacity();\n    if (__cap >= __ms / 2)\n        return __ms;\n    return _VSTD::max(2*__cap, __align_it(__new_size));\n}\n\n//  Default constructs __n objects starting at __end_\n//  Precondition:  __n > 0\n//  Precondition:  size() + __n <= capacity()\n//  Postcondition:  size() == size() + __n\ntemplate <class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nvector<bool, _Allocator>::__construct_at_end(size_type __n, bool __x)\n{\n    size_type __old_size = this->__size_;\n    this->__size_ += __n;\n    _VSTD::fill_n(__make_iter(__old_size), __n, __x);\n}\n\ntemplate <class _Allocator>\ntemplate <class _ForwardIterator>\ntypename enable_if\n<\n    __is_forward_iterator<_ForwardIterator>::value,\n    void\n>::type\nvector<bool, _Allocator>::__construct_at_end(_ForwardIterator __first, _ForwardIterator __last)\n{\n    size_type __old_size = this->__size_;\n    this->__size_ += _VSTD::distance(__first, __last);\n    _VSTD::copy(__first, __last, __make_iter(__old_size));\n}\n\ntemplate <class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvector<bool, _Allocator>::vector()\n    _NOEXCEPT_(is_nothrow_default_constructible<allocator_type>::value)\n    : __begin_(nullptr),\n      __size_(0),\n      __cap_alloc_(0)\n{\n}\n\ntemplate <class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvector<bool, _Allocator>::vector(const allocator_type& __a)\n#if _LIBCPP_STD_VER <= 14\n        _NOEXCEPT_(is_nothrow_copy_constructible<allocator_type>::value)\n#else\n        _NOEXCEPT\n#endif\n    : __begin_(nullptr),\n      __size_(0),\n      __cap_alloc_(0, static_cast<__storage_allocator>(__a))\n{\n}\n\ntemplate <class _Allocator>\nvector<bool, _Allocator>::vector(size_type __n)\n    : __begin_(nullptr),\n      __size_(0),\n      __cap_alloc_(0)\n{\n    if (__n > 0)\n    {\n        allocate(__n);\n        __construct_at_end(__n, false);\n    }\n}\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Allocator>\nvector<bool, _Allocator>::vector(size_type __n, const allocator_type& __a)\n    : __begin_(nullptr),\n      __size_(0),\n      __cap_alloc_(0, static_cast<__storage_allocator>(__a))\n{\n    if (__n > 0)\n    {\n        allocate(__n);\n        __construct_at_end(__n, false);\n    }\n}\n#endif\n\ntemplate <class _Allocator>\nvector<bool, _Allocator>::vector(size_type __n, const value_type& __x)\n    : __begin_(nullptr),\n      __size_(0),\n      __cap_alloc_(0)\n{\n    if (__n > 0)\n    {\n        allocate(__n);\n        __construct_at_end(__n, __x);\n    }\n}\n\ntemplate <class _Allocator>\nvector<bool, _Allocator>::vector(size_type __n, const value_type& __x, const allocator_type& __a)\n    : __begin_(nullptr),\n      __size_(0),\n      __cap_alloc_(0, static_cast<__storage_allocator>(__a))\n{\n    if (__n > 0)\n    {\n        allocate(__n);\n        __construct_at_end(__n, __x);\n    }\n}\n\ntemplate <class _Allocator>\ntemplate <class _InputIterator>\nvector<bool, _Allocator>::vector(_InputIterator __first, _InputIterator __last,\n       typename enable_if<__is_input_iterator  <_InputIterator>::value &&\n                         !__is_forward_iterator<_InputIterator>::value>::type*)\n    : __begin_(nullptr),\n      __size_(0),\n      __cap_alloc_(0)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        for (; __first != __last; ++__first)\n            push_back(*__first);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        if (__begin_ != nullptr)\n            __storage_traits::deallocate(__alloc(), __begin_, __cap());\n        __invalidate_all_iterators();\n        throw;\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n}\n\ntemplate <class _Allocator>\ntemplate <class _InputIterator>\nvector<bool, _Allocator>::vector(_InputIterator __first, _InputIterator __last, const allocator_type& __a,\n       typename enable_if<__is_input_iterator  <_InputIterator>::value &&\n                         !__is_forward_iterator<_InputIterator>::value>::type*)\n    : __begin_(nullptr),\n      __size_(0),\n      __cap_alloc_(0, static_cast<__storage_allocator>(__a))\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        for (; __first != __last; ++__first)\n            push_back(*__first);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        if (__begin_ != nullptr)\n            __storage_traits::deallocate(__alloc(), __begin_, __cap());\n        __invalidate_all_iterators();\n        throw;\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n}\n\ntemplate <class _Allocator>\ntemplate <class _ForwardIterator>\nvector<bool, _Allocator>::vector(_ForwardIterator __first, _ForwardIterator __last,\n                                typename enable_if<__is_forward_iterator<_ForwardIterator>::value>::type*)\n    : __begin_(nullptr),\n      __size_(0),\n      __cap_alloc_(0)\n{\n    size_type __n = static_cast<size_type>(_VSTD::distance(__first, __last));\n    if (__n > 0)\n    {\n        allocate(__n);\n        __construct_at_end(__first, __last);\n    }\n}\n\ntemplate <class _Allocator>\ntemplate <class _ForwardIterator>\nvector<bool, _Allocator>::vector(_ForwardIterator __first, _ForwardIterator __last, const allocator_type& __a,\n                                typename enable_if<__is_forward_iterator<_ForwardIterator>::value>::type*)\n    : __begin_(nullptr),\n      __size_(0),\n      __cap_alloc_(0, static_cast<__storage_allocator>(__a))\n{\n    size_type __n = static_cast<size_type>(_VSTD::distance(__first, __last));\n    if (__n > 0)\n    {\n        allocate(__n);\n        __construct_at_end(__first, __last);\n    }\n}\n\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\ntemplate <class _Allocator>\nvector<bool, _Allocator>::vector(initializer_list<value_type> __il)\n    : __begin_(nullptr),\n      __size_(0),\n      __cap_alloc_(0)\n{\n    size_type __n = static_cast<size_type>(__il.size());\n    if (__n > 0)\n    {\n        allocate(__n);\n        __construct_at_end(__il.begin(), __il.end());\n    }\n}\n\ntemplate <class _Allocator>\nvector<bool, _Allocator>::vector(initializer_list<value_type> __il, const allocator_type& __a)\n    : __begin_(nullptr),\n      __size_(0),\n      __cap_alloc_(0, static_cast<__storage_allocator>(__a))\n{\n    size_type __n = static_cast<size_type>(__il.size());\n    if (__n > 0)\n    {\n        allocate(__n);\n        __construct_at_end(__il.begin(), __il.end());\n    }\n}\n\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\ntemplate <class _Allocator>\nvector<bool, _Allocator>::~vector()\n{\n    if (__begin_ != nullptr)\n        __storage_traits::deallocate(__alloc(), __begin_, __cap());\n    __invalidate_all_iterators();\n}\n\ntemplate <class _Allocator>\nvector<bool, _Allocator>::vector(const vector& __v)\n    : __begin_(nullptr),\n      __size_(0),\n      __cap_alloc_(0, __storage_traits::select_on_container_copy_construction(__v.__alloc()))\n{\n    if (__v.size() > 0)\n    {\n        allocate(__v.size());\n        __construct_at_end(__v.begin(), __v.end());\n    }\n}\n\ntemplate <class _Allocator>\nvector<bool, _Allocator>::vector(const vector& __v, const allocator_type& __a)\n    : __begin_(nullptr),\n      __size_(0),\n      __cap_alloc_(0, __a)\n{\n    if (__v.size() > 0)\n    {\n        allocate(__v.size());\n        __construct_at_end(__v.begin(), __v.end());\n    }\n}\n\ntemplate <class _Allocator>\nvector<bool, _Allocator>&\nvector<bool, _Allocator>::operator=(const vector& __v)\n{\n    if (this != &__v)\n    {\n        __copy_assign_alloc(__v);\n        if (__v.__size_)\n        {\n            if (__v.__size_ > capacity())\n            {\n                deallocate();\n                allocate(__v.__size_);\n            }\n            _VSTD::copy(__v.__begin_, __v.__begin_ + __external_cap_to_internal(__v.__size_), __begin_);\n        }\n        __size_ = __v.__size_;\n    }\n    return *this;\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvector<bool, _Allocator>::vector(vector&& __v)\n#if _LIBCPP_STD_VER > 14\n        _NOEXCEPT\n#else\n        _NOEXCEPT_(is_nothrow_move_constructible<allocator_type>::value)\n#endif\n    : __begin_(__v.__begin_),\n      __size_(__v.__size_),\n      __cap_alloc_(__v.__cap_alloc_)\n{\n    __v.__begin_ = nullptr;\n    __v.__size_ = 0;\n    __v.__cap() = 0;\n}\n\ntemplate <class _Allocator>\nvector<bool, _Allocator>::vector(vector&& __v, const allocator_type& __a)\n    : __begin_(nullptr),\n      __size_(0),\n      __cap_alloc_(0, __a)\n{\n    if (__a == allocator_type(__v.__alloc()))\n    {\n        this->__begin_ = __v.__begin_;\n        this->__size_ = __v.__size_;\n        this->__cap() = __v.__cap();\n        __v.__begin_ = nullptr;\n        __v.__cap() = __v.__size_ = 0;\n    }\n    else if (__v.size() > 0)\n    {\n        allocate(__v.size());\n        __construct_at_end(__v.begin(), __v.end());\n    }\n}\n\ntemplate <class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvector<bool, _Allocator>&\nvector<bool, _Allocator>::operator=(vector&& __v)\n    _NOEXCEPT_((__noexcept_move_assign_container<_Allocator, __alloc_traits>::value))\n{\n    __move_assign(__v, integral_constant<bool,\n          __storage_traits::propagate_on_container_move_assignment::value>());\n    return *this;\n}\n\ntemplate <class _Allocator>\nvoid\nvector<bool, _Allocator>::__move_assign(vector& __c, false_type)\n{\n    if (__alloc() != __c.__alloc())\n        assign(__c.begin(), __c.end());\n    else\n        __move_assign(__c, true_type());\n}\n\ntemplate <class _Allocator>\nvoid\nvector<bool, _Allocator>::__move_assign(vector& __c, true_type)\n    _NOEXCEPT_(is_nothrow_move_assignable<allocator_type>::value)\n{\n    deallocate();\n    __move_assign_alloc(__c);\n    this->__begin_ = __c.__begin_;\n    this->__size_ = __c.__size_;\n    this->__cap() = __c.__cap();\n    __c.__begin_ = nullptr;\n    __c.__cap() = __c.__size_ = 0;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Allocator>\nvoid\nvector<bool, _Allocator>::assign(size_type __n, const value_type& __x)\n{\n    __size_ = 0;\n    if (__n > 0)\n    {\n        size_type __c = capacity();\n        if (__n <= __c)\n            __size_ = __n;\n        else\n        {\n            vector __v(__alloc());\n            __v.reserve(__recommend(__n));\n            __v.__size_ = __n;\n            swap(__v);\n        }\n        _VSTD::fill_n(begin(), __n, __x);\n    }\n  __invalidate_all_iterators();\n}\n\ntemplate <class _Allocator>\ntemplate <class _InputIterator>\ntypename enable_if\n<\n    __is_input_iterator<_InputIterator>::value &&\n   !__is_forward_iterator<_InputIterator>::value,\n   void\n>::type\nvector<bool, _Allocator>::assign(_InputIterator __first, _InputIterator __last)\n{\n    clear();\n    for (; __first != __last; ++__first)\n        push_back(*__first);\n}\n\ntemplate <class _Allocator>\ntemplate <class _ForwardIterator>\ntypename enable_if\n<\n    __is_forward_iterator<_ForwardIterator>::value,\n   void\n>::type\nvector<bool, _Allocator>::assign(_ForwardIterator __first, _ForwardIterator __last)\n{\n    clear();\n    difference_type __ns = _VSTD::distance(__first, __last);\n    _LIBCPP_ASSERT(__ns >= 0, \"invalid range specified\");\n    const size_t __n = static_cast<size_type>(__ns);\n    if (__n)\n    {\n        if (__n > capacity())\n        {\n            deallocate();\n            allocate(__n);\n        }\n        __construct_at_end(__first, __last);\n    }\n}\n\ntemplate <class _Allocator>\nvoid\nvector<bool, _Allocator>::reserve(size_type __n)\n{\n    if (__n > capacity())\n    {\n        vector __v(this->__alloc());\n        __v.allocate(__n);\n        __v.__construct_at_end(this->begin(), this->end());\n        swap(__v);\n        __invalidate_all_iterators();\n    }\n}\n\ntemplate <class _Allocator>\nvoid\nvector<bool, _Allocator>::shrink_to_fit() _NOEXCEPT\n{\n    if (__external_cap_to_internal(size()) > __cap())\n    {\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        try\n        {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n            vector(*this, allocator_type(__alloc())).swap(*this);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        }\n        catch (...)\n        {\n        }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    }\n}\n\ntemplate <class _Allocator>\ntypename vector<bool, _Allocator>::reference\nvector<bool, _Allocator>::at(size_type __n)\n{\n    if (__n >= size())\n        this->__throw_out_of_range();\n    return (*this)[__n];\n}\n\ntemplate <class _Allocator>\ntypename vector<bool, _Allocator>::const_reference\nvector<bool, _Allocator>::at(size_type __n) const\n{\n    if (__n >= size())\n        this->__throw_out_of_range();\n    return (*this)[__n];\n}\n\ntemplate <class _Allocator>\nvoid\nvector<bool, _Allocator>::push_back(const value_type& __x)\n{\n    if (this->__size_ == this->capacity())\n        reserve(__recommend(this->__size_ + 1));\n    ++this->__size_;\n    back() = __x;\n}\n\ntemplate <class _Allocator>\ntypename vector<bool, _Allocator>::iterator\nvector<bool, _Allocator>::insert(const_iterator __position, const value_type& __x)\n{\n    iterator __r;\n    if (size() < capacity())\n    {\n        const_iterator __old_end = end();\n        ++__size_;\n        _VSTD::copy_backward(__position, __old_end, end());\n        __r = __const_iterator_cast(__position);\n    }\n    else\n    {\n        vector __v(__alloc());\n        __v.reserve(__recommend(__size_ + 1));\n        __v.__size_ = __size_ + 1;\n        __r = _VSTD::copy(cbegin(), __position, __v.begin());\n        _VSTD::copy_backward(__position, cend(), __v.end());\n        swap(__v);\n    }\n    *__r = __x;\n    return __r;\n}\n\ntemplate <class _Allocator>\ntypename vector<bool, _Allocator>::iterator\nvector<bool, _Allocator>::insert(const_iterator __position, size_type __n, const value_type& __x)\n{\n    iterator __r;\n    size_type __c = capacity();\n    if (__n <= __c && size() <= __c - __n)\n    {\n        const_iterator __old_end = end();\n        __size_ += __n;\n        _VSTD::copy_backward(__position, __old_end, end());\n        __r = __const_iterator_cast(__position);\n    }\n    else\n    {\n        vector __v(__alloc());\n        __v.reserve(__recommend(__size_ + __n));\n        __v.__size_ = __size_ + __n;\n        __r = _VSTD::copy(cbegin(), __position, __v.begin());\n        _VSTD::copy_backward(__position, cend(), __v.end());\n        swap(__v);\n    }\n    _VSTD::fill_n(__r, __n, __x);\n    return __r;\n}\n\ntemplate <class _Allocator>\ntemplate <class _InputIterator>\ntypename enable_if\n<\n     __is_input_iterator  <_InputIterator>::value &&\n    !__is_forward_iterator<_InputIterator>::value,\n    typename vector<bool, _Allocator>::iterator\n>::type\nvector<bool, _Allocator>::insert(const_iterator __position, _InputIterator __first, _InputIterator __last)\n{\n    difference_type __off = __position - begin();\n    iterator __p = __const_iterator_cast(__position);\n    iterator __old_end = end();\n    for (; size() != capacity() && __first != __last; ++__first)\n    {\n        ++this->__size_;\n        back() = *__first;\n    }\n    vector __v(__alloc());\n    if (__first != __last)\n    {\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        try\n        {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n            __v.assign(__first, __last);\n            difference_type __old_size = static_cast<difference_type>(__old_end - begin());\n            difference_type __old_p = __p - begin();\n            reserve(__recommend(size() + __v.size()));\n            __p = begin() + __old_p;\n            __old_end = begin() + __old_size;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        }\n        catch (...)\n        {\n            erase(__old_end, end());\n            throw;\n        }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    }\n    __p = _VSTD::rotate(__p, __old_end, end());\n    insert(__p, __v.begin(), __v.end());\n    return begin() + __off;\n}\n\ntemplate <class _Allocator>\ntemplate <class _ForwardIterator>\ntypename enable_if\n<\n    __is_forward_iterator<_ForwardIterator>::value,\n    typename vector<bool, _Allocator>::iterator\n>::type\nvector<bool, _Allocator>::insert(const_iterator __position, _ForwardIterator __first, _ForwardIterator __last)\n{\n    const difference_type __n_signed = _VSTD::distance(__first, __last);\n    _LIBCPP_ASSERT(__n_signed >= 0, \"invalid range specified\");\n    const size_type __n = static_cast<size_type>(__n_signed);\n    iterator __r;\n    size_type __c = capacity();\n    if (__n <= __c && size() <= __c - __n)\n    {\n        const_iterator __old_end = end();\n        __size_ += __n;\n        _VSTD::copy_backward(__position, __old_end, end());\n        __r = __const_iterator_cast(__position);\n    }\n    else\n    {\n        vector __v(__alloc());\n        __v.reserve(__recommend(__size_ + __n));\n        __v.__size_ = __size_ + __n;\n        __r = _VSTD::copy(cbegin(), __position, __v.begin());\n        _VSTD::copy_backward(__position, cend(), __v.end());\n        swap(__v);\n    }\n    _VSTD::copy(__first, __last, __r);\n    return __r;\n}\n\ntemplate <class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename vector<bool, _Allocator>::iterator\nvector<bool, _Allocator>::erase(const_iterator __position)\n{\n    iterator __r = __const_iterator_cast(__position);\n    _VSTD::copy(__position + 1, this->cend(), __r);\n    --__size_;\n    return __r;\n}\n\ntemplate <class _Allocator>\ntypename vector<bool, _Allocator>::iterator\nvector<bool, _Allocator>::erase(const_iterator __first, const_iterator __last)\n{\n    iterator __r = __const_iterator_cast(__first);\n    difference_type __d = __last - __first;\n    _VSTD::copy(__last, this->cend(), __r);\n    __size_ -= __d;\n    return __r;\n}\n\ntemplate <class _Allocator>\nvoid\nvector<bool, _Allocator>::swap(vector& __x)\n#if _LIBCPP_STD_VER >= 14\n    _NOEXCEPT\n#else\n    _NOEXCEPT_(!__alloc_traits::propagate_on_container_swap::value ||\n                __is_nothrow_swappable<allocator_type>::value)\n#endif\n{\n    _VSTD::swap(this->__begin_, __x.__begin_);\n    _VSTD::swap(this->__size_, __x.__size_);\n    _VSTD::swap(this->__cap(), __x.__cap());\n    __swap_allocator(this->__alloc(), __x.__alloc(), \n        integral_constant<bool, __alloc_traits::propagate_on_container_swap::value>());\n}\n\ntemplate <class _Allocator>\nvoid\nvector<bool, _Allocator>::resize(size_type __sz, value_type __x)\n{\n    size_type __cs = size();\n    if (__cs < __sz)\n    {\n        iterator __r;\n        size_type __c = capacity();\n        size_type __n = __sz - __cs;\n        if (__n <= __c && __cs <= __c - __n)\n        {\n            __r = end();\n            __size_ += __n;\n        }\n        else\n        {\n            vector __v(__alloc());\n            __v.reserve(__recommend(__size_ + __n));\n            __v.__size_ = __size_ + __n;\n            __r = _VSTD::copy(cbegin(), cend(), __v.begin());\n            swap(__v);\n        }\n        _VSTD::fill_n(__r, __n, __x);\n    }\n    else\n        __size_ = __sz;\n}\n\ntemplate <class _Allocator>\nvoid\nvector<bool, _Allocator>::flip() _NOEXCEPT\n{\n    // do middle whole words\n    size_type __n = __size_;\n    __storage_pointer __p = __begin_;\n    for (; __n >= __bits_per_word; ++__p, __n -= __bits_per_word)\n        *__p = ~*__p;\n    // do last partial word\n    if (__n > 0)\n    {\n        __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);\n        __storage_type __b = *__p & __m;\n        *__p &= ~__m;\n        *__p |= ~__b & __m;\n    }\n}\n\ntemplate <class _Allocator>\nbool\nvector<bool, _Allocator>::__invariants() const\n{\n    if (this->__begin_ == nullptr)\n    {\n        if (this->__size_ != 0 || this->__cap() != 0)\n            return false;\n    }\n    else\n    {\n        if (this->__cap() == 0)\n            return false;\n        if (this->__size_ > this->capacity())\n            return false;\n    }\n    return true;\n}\n\ntemplate <class _Allocator>\nsize_t\nvector<bool, _Allocator>::__hash_code() const _NOEXCEPT\n{\n    size_t __h = 0;\n    // do middle whole words\n    size_type __n = __size_;\n    __storage_pointer __p = __begin_;\n    for (; __n >= __bits_per_word; ++__p, __n -= __bits_per_word)\n        __h ^= *__p;\n    // do last partial word\n    if (__n > 0)\n    {\n        const __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);\n        __h ^= *__p & __m;\n    }\n    return __h;\n}\n\ntemplate <class _Allocator>\nstruct _LIBCPP_TEMPLATE_VIS hash<vector<bool, _Allocator> >\n    : public unary_function<vector<bool, _Allocator>, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(const vector<bool, _Allocator>& __vec) const _NOEXCEPT\n        {return __vec.__hash_code();}\n};\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const vector<_Tp, _Allocator>& __x, const vector<_Tp, _Allocator>& __y)\n{\n    const typename vector<_Tp, _Allocator>::size_type __sz = __x.size();\n    return __sz == __y.size() && _VSTD::equal(__x.begin(), __x.end(), __y.begin());\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const vector<_Tp, _Allocator>& __x, const vector<_Tp, _Allocator>& __y)\n{\n    return !(__x == __y);\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator< (const vector<_Tp, _Allocator>& __x, const vector<_Tp, _Allocator>& __y)\n{\n    return _VSTD::lexicographical_compare(__x.begin(), __x.end(), __y.begin(), __y.end());\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator> (const vector<_Tp, _Allocator>& __x, const vector<_Tp, _Allocator>& __y)\n{\n    return __y < __x;\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const vector<_Tp, _Allocator>& __x, const vector<_Tp, _Allocator>& __y)\n{\n    return !(__x < __y);\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const vector<_Tp, _Allocator>& __x, const vector<_Tp, _Allocator>& __y)\n{\n    return !(__y < __x);\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(vector<_Tp, _Allocator>& __x, vector<_Tp, _Allocator>& __y)\n    _NOEXCEPT_(_NOEXCEPT_(__x.swap(__y)))\n{\n    __x.swap(__y);\n}\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_VECTOR\n","// -*- C++ -*-\n//===-------------------------- algorithm ---------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_ALGORITHM\n#define _LIBCPP_ALGORITHM\n\n/*\n    algorithm synopsis\n\n#include <initializer_list>\n\nnamespace std\n{\n\ntemplate <class InputIterator, class Predicate>\n    bool\n    all_of(InputIterator first, InputIterator last, Predicate pred);\n\ntemplate <class InputIterator, class Predicate>\n    bool\n    any_of(InputIterator first, InputIterator last, Predicate pred);\n\ntemplate <class InputIterator, class Predicate>\n    bool\n    none_of(InputIterator first, InputIterator last, Predicate pred);\n\ntemplate <class InputIterator, class Function>\n    Function\n    for_each(InputIterator first, InputIterator last, Function f);\n\ntemplate <class InputIterator, class T>\n    InputIterator\n    find(InputIterator first, InputIterator last, const T& value);\n\ntemplate <class InputIterator, class Predicate>\n    InputIterator\n    find_if(InputIterator first, InputIterator last, Predicate pred);\n\ntemplate<class InputIterator, class Predicate>\n    InputIterator\n    find_if_not(InputIterator first, InputIterator last, Predicate pred);\n\ntemplate <class ForwardIterator1, class ForwardIterator2>\n    ForwardIterator1\n    find_end(ForwardIterator1 first1, ForwardIterator1 last1,\n             ForwardIterator2 first2, ForwardIterator2 last2);\n\ntemplate <class ForwardIterator1, class ForwardIterator2, class BinaryPredicate>\n    ForwardIterator1\n    find_end(ForwardIterator1 first1, ForwardIterator1 last1,\n             ForwardIterator2 first2, ForwardIterator2 last2, BinaryPredicate pred);\n\ntemplate <class ForwardIterator1, class ForwardIterator2>\n    ForwardIterator1\n    find_first_of(ForwardIterator1 first1, ForwardIterator1 last1,\n                  ForwardIterator2 first2, ForwardIterator2 last2);\n\ntemplate <class ForwardIterator1, class ForwardIterator2, class BinaryPredicate>\n    ForwardIterator1\n    find_first_of(ForwardIterator1 first1, ForwardIterator1 last1,\n                  ForwardIterator2 first2, ForwardIterator2 last2, BinaryPredicate pred);\n\ntemplate <class ForwardIterator>\n    ForwardIterator\n    adjacent_find(ForwardIterator first, ForwardIterator last);\n\ntemplate <class ForwardIterator, class BinaryPredicate>\n    ForwardIterator\n    adjacent_find(ForwardIterator first, ForwardIterator last, BinaryPredicate pred);\n\ntemplate <class InputIterator, class T>\n    typename iterator_traits<InputIterator>::difference_type\n    count(InputIterator first, InputIterator last, const T& value);\n\ntemplate <class InputIterator, class Predicate>\n    typename iterator_traits<InputIterator>::difference_type\n    count_if(InputIterator first, InputIterator last, Predicate pred);\n\ntemplate <class InputIterator1, class InputIterator2>\n    pair<InputIterator1, InputIterator2>\n    mismatch(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2);\n\ntemplate <class InputIterator1, class InputIterator2>\n    pair<InputIterator1, InputIterator2>\n    mismatch(InputIterator1 first1, InputIterator1 last1,\n             InputIterator2 first2, InputIterator2 last2); // **C++14**\n\ntemplate <class InputIterator1, class InputIterator2, class BinaryPredicate>\n    pair<InputIterator1, InputIterator2>\n    mismatch(InputIterator1 first1, InputIterator1 last1,\n             InputIterator2 first2, BinaryPredicate pred);\n\ntemplate <class InputIterator1, class InputIterator2, class BinaryPredicate>\n    pair<InputIterator1, InputIterator2>\n    mismatch(InputIterator1 first1, InputIterator1 last1,\n             InputIterator2 first2, InputIterator2 last2,\n             BinaryPredicate pred); // **C++14**\n\ntemplate <class InputIterator1, class InputIterator2>\n    bool\n    equal(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2);\n\ntemplate <class InputIterator1, class InputIterator2>\n    bool\n    equal(InputIterator1 first1, InputIterator1 last1,\n          InputIterator2 first2, InputIterator2 last2); // **C++14**\n\ntemplate <class InputIterator1, class InputIterator2, class BinaryPredicate>\n    bool\n    equal(InputIterator1 first1, InputIterator1 last1,\n          InputIterator2 first2, BinaryPredicate pred);\n\ntemplate <class InputIterator1, class InputIterator2, class BinaryPredicate>\n    bool\n    equal(InputIterator1 first1, InputIterator1 last1,\n          InputIterator2 first2, InputIterator2 last2,\n          BinaryPredicate pred); // **C++14**\n\ntemplate<class ForwardIterator1, class ForwardIterator2>\n    bool\n    is_permutation(ForwardIterator1 first1, ForwardIterator1 last1,\n                   ForwardIterator2 first2);\n\ntemplate<class ForwardIterator1, class ForwardIterator2>\n    bool\n    is_permutation(ForwardIterator1 first1, ForwardIterator1 last1,\n                   ForwardIterator2 first2, ForwardIterator2 last2); // **C++14**\n\ntemplate<class ForwardIterator1, class ForwardIterator2, class BinaryPredicate>\n    bool\n    is_permutation(ForwardIterator1 first1, ForwardIterator1 last1,\n                   ForwardIterator2 first2, BinaryPredicate pred);\n\ntemplate<class ForwardIterator1, class ForwardIterator2, class BinaryPredicate>\n    bool\n    is_permutation(ForwardIterator1 first1, ForwardIterator1 last1,\n                   ForwardIterator2 first2, ForwardIterator2 last2,\n                   BinaryPredicate pred);  // **C++14**\n\ntemplate <class ForwardIterator1, class ForwardIterator2>\n    ForwardIterator1\n    search(ForwardIterator1 first1, ForwardIterator1 last1,\n           ForwardIterator2 first2, ForwardIterator2 last2);\n\ntemplate <class ForwardIterator1, class ForwardIterator2, class BinaryPredicate>\n    ForwardIterator1\n    search(ForwardIterator1 first1, ForwardIterator1 last1,\n           ForwardIterator2 first2, ForwardIterator2 last2, BinaryPredicate pred);\n\ntemplate <class ForwardIterator, class Size, class T>\n    ForwardIterator\n    search_n(ForwardIterator first, ForwardIterator last, Size count, const T& value);\n\ntemplate <class ForwardIterator, class Size, class T, class BinaryPredicate>\n    ForwardIterator\n    search_n(ForwardIterator first, ForwardIterator last,\n             Size count, const T& value, BinaryPredicate pred);\n\ntemplate <class InputIterator, class OutputIterator>\n    OutputIterator\n    copy(InputIterator first, InputIterator last, OutputIterator result);\n\ntemplate<class InputIterator, class OutputIterator, class Predicate>\n    OutputIterator\n    copy_if(InputIterator first, InputIterator last,\n            OutputIterator result, Predicate pred);\n\ntemplate<class InputIterator, class Size, class OutputIterator>\n    OutputIterator\n    copy_n(InputIterator first, Size n, OutputIterator result);\n\ntemplate <class BidirectionalIterator1, class BidirectionalIterator2>\n    BidirectionalIterator2\n    copy_backward(BidirectionalIterator1 first, BidirectionalIterator1 last,\n                  BidirectionalIterator2 result);\n\ntemplate <class ForwardIterator1, class ForwardIterator2>\n    ForwardIterator2\n    swap_ranges(ForwardIterator1 first1, ForwardIterator1 last1, ForwardIterator2 first2);\n\ntemplate <class ForwardIterator1, class ForwardIterator2>\n    void\n    iter_swap(ForwardIterator1 a, ForwardIterator2 b);\n\ntemplate <class InputIterator, class OutputIterator, class UnaryOperation>\n    OutputIterator\n    transform(InputIterator first, InputIterator last, OutputIterator result, UnaryOperation op);\n\ntemplate <class InputIterator1, class InputIterator2, class OutputIterator, class BinaryOperation>\n    OutputIterator\n    transform(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2,\n              OutputIterator result, BinaryOperation binary_op);\n\ntemplate <class ForwardIterator, class T>\n    void\n    replace(ForwardIterator first, ForwardIterator last, const T& old_value, const T& new_value);\n\ntemplate <class ForwardIterator, class Predicate, class T>\n    void\n    replace_if(ForwardIterator first, ForwardIterator last, Predicate pred, const T& new_value);\n\ntemplate <class InputIterator, class OutputIterator, class T>\n    OutputIterator\n    replace_copy(InputIterator first, InputIterator last, OutputIterator result,\n                 const T& old_value, const T& new_value);\n\ntemplate <class InputIterator, class OutputIterator, class Predicate, class T>\n    OutputIterator\n    replace_copy_if(InputIterator first, InputIterator last, OutputIterator result, Predicate pred, const T& new_value);\n\ntemplate <class ForwardIterator, class T>\n    void\n    fill(ForwardIterator first, ForwardIterator last, const T& value);\n\ntemplate <class OutputIterator, class Size, class T>\n    OutputIterator\n    fill_n(OutputIterator first, Size n, const T& value);\n\ntemplate <class ForwardIterator, class Generator>\n    void\n    generate(ForwardIterator first, ForwardIterator last, Generator gen);\n\ntemplate <class OutputIterator, class Size, class Generator>\n    OutputIterator\n    generate_n(OutputIterator first, Size n, Generator gen);\n\ntemplate <class ForwardIterator, class T>\n    ForwardIterator\n    remove(ForwardIterator first, ForwardIterator last, const T& value);\n\ntemplate <class ForwardIterator, class Predicate>\n    ForwardIterator\n    remove_if(ForwardIterator first, ForwardIterator last, Predicate pred);\n\ntemplate <class InputIterator, class OutputIterator, class T>\n    OutputIterator\n    remove_copy(InputIterator first, InputIterator last, OutputIterator result, const T& value);\n\ntemplate <class InputIterator, class OutputIterator, class Predicate>\n    OutputIterator\n    remove_copy_if(InputIterator first, InputIterator last, OutputIterator result, Predicate pred);\n\ntemplate <class ForwardIterator>\n    ForwardIterator\n    unique(ForwardIterator first, ForwardIterator last);\n\ntemplate <class ForwardIterator, class BinaryPredicate>\n    ForwardIterator\n    unique(ForwardIterator first, ForwardIterator last, BinaryPredicate pred);\n\ntemplate <class InputIterator, class OutputIterator>\n    OutputIterator\n    unique_copy(InputIterator first, InputIterator last, OutputIterator result);\n\ntemplate <class InputIterator, class OutputIterator, class BinaryPredicate>\n    OutputIterator\n    unique_copy(InputIterator first, InputIterator last, OutputIterator result, BinaryPredicate pred);\n\ntemplate <class BidirectionalIterator>\n    void\n    reverse(BidirectionalIterator first, BidirectionalIterator last);\n\ntemplate <class BidirectionalIterator, class OutputIterator>\n    OutputIterator\n    reverse_copy(BidirectionalIterator first, BidirectionalIterator last, OutputIterator result);\n\ntemplate <class ForwardIterator>\n    ForwardIterator\n    rotate(ForwardIterator first, ForwardIterator middle, ForwardIterator last);\n\ntemplate <class ForwardIterator, class OutputIterator>\n    OutputIterator\n    rotate_copy(ForwardIterator first, ForwardIterator middle, ForwardIterator last, OutputIterator result);\n\ntemplate <class RandomAccessIterator>\n    void\n    random_shuffle(RandomAccessIterator first, RandomAccessIterator last); // deprecated in C++14\n\ntemplate <class RandomAccessIterator, class RandomNumberGenerator>\n    void\n    random_shuffle(RandomAccessIterator first, RandomAccessIterator last,\n                   RandomNumberGenerator& rand);  // deprecated in C++14\n\ntemplate<class PopulationIterator, class SampleIterator,\n         class Distance, class UniformRandomBitGenerator>\n    SampleIterator sample(PopulationIterator first, PopulationIterator last,\n                          SampleIterator out, Distance n,\n                          UniformRandomBitGenerator&& g); // C++17\n\ntemplate<class RandomAccessIterator, class UniformRandomNumberGenerator>\n    void shuffle(RandomAccessIterator first, RandomAccessIterator last,\n                 UniformRandomNumberGenerator&& g);\n\ntemplate <class InputIterator, class Predicate>\n    bool\n    is_partitioned(InputIterator first, InputIterator last, Predicate pred);\n\ntemplate <class ForwardIterator, class Predicate>\n    ForwardIterator\n    partition(ForwardIterator first, ForwardIterator last, Predicate pred);\n\ntemplate <class InputIterator, class OutputIterator1,\n          class OutputIterator2, class Predicate>\n    pair<OutputIterator1, OutputIterator2>\n    partition_copy(InputIterator first, InputIterator last,\n                   OutputIterator1 out_true, OutputIterator2 out_false,\n                   Predicate pred);\n\ntemplate <class ForwardIterator, class Predicate>\n    ForwardIterator\n    stable_partition(ForwardIterator first, ForwardIterator last, Predicate pred);\n\ntemplate<class ForwardIterator, class Predicate>\n    ForwardIterator\n    partition_point(ForwardIterator first, ForwardIterator last, Predicate pred);\n\ntemplate <class ForwardIterator>\n    bool\n    is_sorted(ForwardIterator first, ForwardIterator last);\n\ntemplate <class ForwardIterator, class Compare>\n    bool\n    is_sorted(ForwardIterator first, ForwardIterator last, Compare comp);\n\ntemplate<class ForwardIterator>\n    ForwardIterator\n    is_sorted_until(ForwardIterator first, ForwardIterator last);\n\ntemplate <class ForwardIterator, class Compare>\n    ForwardIterator\n    is_sorted_until(ForwardIterator first, ForwardIterator last, Compare comp);\n\ntemplate <class RandomAccessIterator>\n    void\n    sort(RandomAccessIterator first, RandomAccessIterator last);\n\ntemplate <class RandomAccessIterator, class Compare>\n    void\n    sort(RandomAccessIterator first, RandomAccessIterator last, Compare comp);\n\ntemplate <class RandomAccessIterator>\n    void\n    stable_sort(RandomAccessIterator first, RandomAccessIterator last);\n\ntemplate <class RandomAccessIterator, class Compare>\n    void\n    stable_sort(RandomAccessIterator first, RandomAccessIterator last, Compare comp);\n\ntemplate <class RandomAccessIterator>\n    void\n    partial_sort(RandomAccessIterator first, RandomAccessIterator middle, RandomAccessIterator last);\n\ntemplate <class RandomAccessIterator, class Compare>\n    void\n    partial_sort(RandomAccessIterator first, RandomAccessIterator middle, RandomAccessIterator last, Compare comp);\n\ntemplate <class InputIterator, class RandomAccessIterator>\n    RandomAccessIterator\n    partial_sort_copy(InputIterator first, InputIterator last,\n                      RandomAccessIterator result_first, RandomAccessIterator result_last);\n\ntemplate <class InputIterator, class RandomAccessIterator, class Compare>\n    RandomAccessIterator\n    partial_sort_copy(InputIterator first, InputIterator last,\n                      RandomAccessIterator result_first, RandomAccessIterator result_last, Compare comp);\n\ntemplate <class RandomAccessIterator>\n    void\n    nth_element(RandomAccessIterator first, RandomAccessIterator nth, RandomAccessIterator last);\n\ntemplate <class RandomAccessIterator, class Compare>\n    void\n    nth_element(RandomAccessIterator first, RandomAccessIterator nth, RandomAccessIterator last, Compare comp);\n\ntemplate <class ForwardIterator, class T>\n    ForwardIterator\n    lower_bound(ForwardIterator first, ForwardIterator last, const T& value);\n\ntemplate <class ForwardIterator, class T, class Compare>\n    ForwardIterator\n    lower_bound(ForwardIterator first, ForwardIterator last, const T& value, Compare comp);\n\ntemplate <class ForwardIterator, class T>\n    ForwardIterator\n    upper_bound(ForwardIterator first, ForwardIterator last, const T& value);\n\ntemplate <class ForwardIterator, class T, class Compare>\n    ForwardIterator\n    upper_bound(ForwardIterator first, ForwardIterator last, const T& value, Compare comp);\n\ntemplate <class ForwardIterator, class T>\n    pair<ForwardIterator, ForwardIterator>\n    equal_range(ForwardIterator first, ForwardIterator last, const T& value);\n\ntemplate <class ForwardIterator, class T, class Compare>\n    pair<ForwardIterator, ForwardIterator>\n    equal_range(ForwardIterator first, ForwardIterator last, const T& value, Compare comp);\n\ntemplate <class ForwardIterator, class T>\n    bool\n    binary_search(ForwardIterator first, ForwardIterator last, const T& value);\n\ntemplate <class ForwardIterator, class T, class Compare>\n    bool\n    binary_search(ForwardIterator first, ForwardIterator last, const T& value, Compare comp);\n\ntemplate <class InputIterator1, class InputIterator2, class OutputIterator>\n    OutputIterator\n    merge(InputIterator1 first1, InputIterator1 last1,\n          InputIterator2 first2, InputIterator2 last2, OutputIterator result);\n\ntemplate <class InputIterator1, class InputIterator2, class OutputIterator, class Compare>\n    OutputIterator\n    merge(InputIterator1 first1, InputIterator1 last1,\n          InputIterator2 first2, InputIterator2 last2, OutputIterator result, Compare comp);\n\ntemplate <class BidirectionalIterator>\n    void\n    inplace_merge(BidirectionalIterator first, BidirectionalIterator middle, BidirectionalIterator last);\n\ntemplate <class BidirectionalIterator, class Compare>\n    void\n    inplace_merge(BidirectionalIterator first, BidirectionalIterator middle, BidirectionalIterator last, Compare comp);\n\ntemplate <class InputIterator1, class InputIterator2>\n    bool\n    includes(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2);\n\ntemplate <class InputIterator1, class InputIterator2, class Compare>\n    bool\n    includes(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2, Compare comp);\n\ntemplate <class InputIterator1, class InputIterator2, class OutputIterator>\n    OutputIterator\n    set_union(InputIterator1 first1, InputIterator1 last1,\n              InputIterator2 first2, InputIterator2 last2, OutputIterator result);\n\ntemplate <class InputIterator1, class InputIterator2, class OutputIterator, class Compare>\n    OutputIterator\n    set_union(InputIterator1 first1, InputIterator1 last1,\n              InputIterator2 first2, InputIterator2 last2, OutputIterator result, Compare comp);\n\ntemplate <class InputIterator1, class InputIterator2, class OutputIterator>\n    OutputIterator\n    set_intersection(InputIterator1 first1, InputIterator1 last1,\n                     InputIterator2 first2, InputIterator2 last2, OutputIterator result);\n\ntemplate <class InputIterator1, class InputIterator2, class OutputIterator, class Compare>\n    OutputIterator\n    set_intersection(InputIterator1 first1, InputIterator1 last1,\n                     InputIterator2 first2, InputIterator2 last2, OutputIterator result, Compare comp);\n\ntemplate <class InputIterator1, class InputIterator2, class OutputIterator>\n    OutputIterator\n    set_difference(InputIterator1 first1, InputIterator1 last1,\n                   InputIterator2 first2, InputIterator2 last2, OutputIterator result);\n\ntemplate <class InputIterator1, class InputIterator2, class OutputIterator, class Compare>\n    OutputIterator\n    set_difference(InputIterator1 first1, InputIterator1 last1,\n                   InputIterator2 first2, InputIterator2 last2, OutputIterator result, Compare comp);\n\ntemplate <class InputIterator1, class InputIterator2, class OutputIterator>\n    OutputIterator\n    set_symmetric_difference(InputIterator1 first1, InputIterator1 last1,\n                             InputIterator2 first2, InputIterator2 last2, OutputIterator result);\n\ntemplate <class InputIterator1, class InputIterator2, class OutputIterator, class Compare>\n    OutputIterator\n    set_symmetric_difference(InputIterator1 first1, InputIterator1 last1,\n                             InputIterator2 first2, InputIterator2 last2, OutputIterator result, Compare comp);\n\ntemplate <class RandomAccessIterator>\n    void\n    push_heap(RandomAccessIterator first, RandomAccessIterator last);\n\ntemplate <class RandomAccessIterator, class Compare>\n    void\n    push_heap(RandomAccessIterator first, RandomAccessIterator last, Compare comp);\n\ntemplate <class RandomAccessIterator>\n    void\n    pop_heap(RandomAccessIterator first, RandomAccessIterator last);\n\ntemplate <class RandomAccessIterator, class Compare>\n    void\n    pop_heap(RandomAccessIterator first, RandomAccessIterator last, Compare comp);\n\ntemplate <class RandomAccessIterator>\n    void\n    make_heap(RandomAccessIterator first, RandomAccessIterator last);\n\ntemplate <class RandomAccessIterator, class Compare>\n    void\n    make_heap(RandomAccessIterator first, RandomAccessIterator last, Compare comp);\n\ntemplate <class RandomAccessIterator>\n    void\n    sort_heap(RandomAccessIterator first, RandomAccessIterator last);\n\ntemplate <class RandomAccessIterator, class Compare>\n    void\n    sort_heap(RandomAccessIterator first, RandomAccessIterator last, Compare comp);\n\ntemplate <class RandomAccessIterator>\n    bool\n    is_heap(RandomAccessIterator first, RandomAccessiterator last);\n\ntemplate <class RandomAccessIterator, class Compare>\n    bool\n    is_heap(RandomAccessIterator first, RandomAccessiterator last, Compare comp);\n\ntemplate <class RandomAccessIterator>\n    RandomAccessIterator\n    is_heap_until(RandomAccessIterator first, RandomAccessiterator last);\n\ntemplate <class RandomAccessIterator, class Compare>\n    RandomAccessIterator\n    is_heap_until(RandomAccessIterator first, RandomAccessiterator last, Compare comp);\n\ntemplate <class ForwardIterator>\n    ForwardIterator\n    min_element(ForwardIterator first, ForwardIterator last);  // constexpr in C++14\n\ntemplate <class ForwardIterator, class Compare>\n    ForwardIterator\n    min_element(ForwardIterator first, ForwardIterator last, Compare comp);  // constexpr in C++14\n\ntemplate <class T>\n    const T&\n    min(const T& a, const T& b);  // constexpr in C++14\n\ntemplate <class T, class Compare>\n    const T&\n    min(const T& a, const T& b, Compare comp);  // constexpr in C++14\n\ntemplate<class T>\n    T\n    min(initializer_list<T> t);  // constexpr in C++14\n\ntemplate<class T, class Compare>\n    T\n    min(initializer_list<T> t, Compare comp);  // constexpr in C++14\n\ntemplate<class T>\n    constexpr const T& clamp( const T& v, const T& lo, const T& hi );               // C++17\n\ntemplate<class T, class Compare>\n    constexpr const T& clamp( const T& v, const T& lo, const T& hi, Compare comp ); // C++17\n\ntemplate <class ForwardIterator>\n    ForwardIterator\n    max_element(ForwardIterator first, ForwardIterator last);  // constexpr in C++14\n\ntemplate <class ForwardIterator, class Compare>\n    ForwardIterator\n    max_element(ForwardIterator first, ForwardIterator last, Compare comp);  // constexpr in C++14\n\ntemplate <class T>\n    const T&\n    max(const T& a, const T& b); // constexpr in C++14\n\ntemplate <class T, class Compare>\n    const T&\n    max(const T& a, const T& b, Compare comp);  // constexpr in C++14\n\ntemplate<class T>\n    T\n    max(initializer_list<T> t);  // constexpr in C++14\n\ntemplate<class T, class Compare>\n    T\n    max(initializer_list<T> t, Compare comp);  // constexpr in C++14\n\ntemplate<class ForwardIterator>\n    pair<ForwardIterator, ForwardIterator>\n    minmax_element(ForwardIterator first, ForwardIterator last);   // constexpr in C++14\n\ntemplate<class ForwardIterator, class Compare>\n    pair<ForwardIterator, ForwardIterator>\n    minmax_element(ForwardIterator first, ForwardIterator last, Compare comp);   // constexpr in C++14\n\ntemplate<class T>\n    pair<const T&, const T&>\n    minmax(const T& a, const T& b);  // constexpr in C++14\n\ntemplate<class T, class Compare>\n    pair<const T&, const T&>\n    minmax(const T& a, const T& b, Compare comp);  // constexpr in C++14\n\ntemplate<class T>\n    pair<T, T>\n    minmax(initializer_list<T> t);  // constexpr in C++14\n\ntemplate<class T, class Compare>\n    pair<T, T>\n    minmax(initializer_list<T> t, Compare comp);  // constexpr in C++14\n\ntemplate <class InputIterator1, class InputIterator2>\n    bool\n    lexicographical_compare(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2);\n\ntemplate <class InputIterator1, class InputIterator2, class Compare>\n    bool\n    lexicographical_compare(InputIterator1 first1, InputIterator1 last1,\n                            InputIterator2 first2, InputIterator2 last2, Compare comp);\n\ntemplate <class BidirectionalIterator>\n    bool\n    next_permutation(BidirectionalIterator first, BidirectionalIterator last);\n\ntemplate <class BidirectionalIterator, class Compare>\n    bool\n    next_permutation(BidirectionalIterator first, BidirectionalIterator last, Compare comp);\n\ntemplate <class BidirectionalIterator>\n    bool\n    prev_permutation(BidirectionalIterator first, BidirectionalIterator last);\n\ntemplate <class BidirectionalIterator, class Compare>\n    bool\n    prev_permutation(BidirectionalIterator first, BidirectionalIterator last, Compare comp);\n\n}  // std\n\n*/\n\n#include <__config>\n#include <initializer_list>\n#include <type_traits>\n#include <cstring>\n#include <utility> // needed to provide swap_ranges.\n#include <memory>\n#include <iterator>\n#include <cstddef>\n\n#if defined(__IBMCPP__)\n#include \"support/ibm/support.h\"\n#endif\n#if defined(_LIBCPP_MSVCRT) || defined(__MINGW32__)\n#include \"support/win32/support.h\"\n#endif\n\n#include <__undef_min_max>\n\n#include <__debug>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\n// I'd like to replace these with _VSTD::equal_to<void>, but can't because:\n//   * That only works with C++14 and later, and\n//   * We haven't included <functional> here.\ntemplate <class _T1, class _T2 = _T1>\nstruct __equal_to\n{\n    _LIBCPP_INLINE_VISIBILITY bool operator()(const _T1& __x, const _T1& __y) const {return __x == __y;}\n    _LIBCPP_INLINE_VISIBILITY bool operator()(const _T1& __x, const _T2& __y) const {return __x == __y;}\n    _LIBCPP_INLINE_VISIBILITY bool operator()(const _T2& __x, const _T1& __y) const {return __x == __y;}\n    _LIBCPP_INLINE_VISIBILITY bool operator()(const _T2& __x, const _T2& __y) const {return __x == __y;}\n};\n\ntemplate <class _T1>\nstruct __equal_to<_T1, _T1>\n{\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    bool operator()(const _T1& __x, const _T1& __y) const {return __x == __y;}\n};\n\ntemplate <class _T1>\nstruct __equal_to<const _T1, _T1>\n{\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    bool operator()(const _T1& __x, const _T1& __y) const {return __x == __y;}\n};\n\ntemplate <class _T1>\nstruct __equal_to<_T1, const _T1>\n{\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    bool operator()(const _T1& __x, const _T1& __y) const {return __x == __y;}\n};\n\ntemplate <class _T1, class _T2 = _T1>\nstruct __less\n{\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    bool operator()(const _T1& __x, const _T1& __y) const {return __x < __y;}\n\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    bool operator()(const _T1& __x, const _T2& __y) const {return __x < __y;}\n\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    bool operator()(const _T2& __x, const _T1& __y) const {return __x < __y;}\n\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    bool operator()(const _T2& __x, const _T2& __y) const {return __x < __y;}\n};\n\ntemplate <class _T1>\nstruct __less<_T1, _T1>\n{\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    bool operator()(const _T1& __x, const _T1& __y) const {return __x < __y;}\n};\n\ntemplate <class _T1>\nstruct __less<const _T1, _T1>\n{\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    bool operator()(const _T1& __x, const _T1& __y) const {return __x < __y;}\n};\n\ntemplate <class _T1>\nstruct __less<_T1, const _T1>\n{\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    bool operator()(const _T1& __x, const _T1& __y) const {return __x < __y;}\n};\n\ntemplate <class _Predicate>\nclass __negate\n{\nprivate:\n    _Predicate __p_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY __negate() {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __negate(_Predicate __p) : __p_(__p) {}\n\n    template <class _T1>\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const _T1& __x) {return !__p_(__x);}\n\n    template <class _T1, class _T2>\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const _T1& __x, const _T2& __y) {return !__p_(__x, __y);}\n};\n\n#ifdef _LIBCPP_DEBUG\n\ntemplate <class _Compare>\nstruct __debug_less\n{\n    _Compare __comp_;\n    __debug_less(_Compare& __c) : __comp_(__c) {}\n\n    template <class _Tp, class _Up>\n    bool operator()(const _Tp& __x, const _Up& __y)\n    {\n        bool __r = __comp_(__x, __y);\n        if (__r)\n            __do_compare_assert(0, __y, __x);\n        return __r;\n    }\n\n    template <class _LHS, class _RHS>\n    inline _LIBCPP_INLINE_VISIBILITY\n    decltype((void)_VSTD::declval<_Compare&>()(\n        _VSTD::declval<_LHS const&>(), _VSTD::declval<_RHS const&>()))\n    __do_compare_assert(int, _LHS const& __l, _RHS const& __r) {\n        _LIBCPP_ASSERT(!__comp_(__l, __r),\n            \"Comparator does not induce a strict weak ordering\");\n    }\n\n    template <class _LHS, class _RHS>\n    inline _LIBCPP_INLINE_VISIBILITY\n    void __do_compare_assert(long, _LHS const&, _RHS const&) {}\n};\n\n#endif  // _LIBCPP_DEBUG\n\n// Precondition:  __x != 0\ninline _LIBCPP_INLINE_VISIBILITY\nunsigned\n__ctz(unsigned __x)\n{\n    return static_cast<unsigned>(__builtin_ctz(__x));\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nunsigned long\n__ctz(unsigned long __x)\n{\n    return static_cast<unsigned long>(__builtin_ctzl(__x));\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nunsigned long long\n__ctz(unsigned long long __x)\n{\n    return static_cast<unsigned long long>(__builtin_ctzll(__x));\n}\n\n// Precondition:  __x != 0\ninline _LIBCPP_INLINE_VISIBILITY\nunsigned\n__clz(unsigned __x)\n{\n    return static_cast<unsigned>(__builtin_clz(__x));\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nunsigned long\n__clz(unsigned long __x)\n{\n    return static_cast<unsigned long>(__builtin_clzl (__x));\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nunsigned long long\n__clz(unsigned long long __x)\n{\n    return static_cast<unsigned long long>(__builtin_clzll(__x));\n}\n\ninline _LIBCPP_INLINE_VISIBILITY int __pop_count(unsigned           __x) {return __builtin_popcount  (__x);}\ninline _LIBCPP_INLINE_VISIBILITY int __pop_count(unsigned      long __x) {return __builtin_popcountl (__x);}\ninline _LIBCPP_INLINE_VISIBILITY int __pop_count(unsigned long long __x) {return __builtin_popcountll(__x);}\n\n// all_of\n\ntemplate <class _InputIterator, class _Predicate>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nall_of(_InputIterator __first, _InputIterator __last, _Predicate __pred)\n{\n    for (; __first != __last; ++__first)\n        if (!__pred(*__first))\n            return false;\n    return true;\n}\n\n// any_of\n\ntemplate <class _InputIterator, class _Predicate>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nany_of(_InputIterator __first, _InputIterator __last, _Predicate __pred)\n{\n    for (; __first != __last; ++__first)\n        if (__pred(*__first))\n            return true;\n    return false;\n}\n\n// none_of\n\ntemplate <class _InputIterator, class _Predicate>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nnone_of(_InputIterator __first, _InputIterator __last, _Predicate __pred)\n{\n    for (; __first != __last; ++__first)\n        if (__pred(*__first))\n            return false;\n    return true;\n}\n\n// for_each\n\ntemplate <class _InputIterator, class _Function>\ninline _LIBCPP_INLINE_VISIBILITY\n_Function\nfor_each(_InputIterator __first, _InputIterator __last, _Function __f)\n{\n    for (; __first != __last; ++__first)\n        __f(*__first);\n    return __f;\n}\n\n// find\n\ntemplate <class _InputIterator, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_InputIterator\nfind(_InputIterator __first, _InputIterator __last, const _Tp& __value_)\n{\n    for (; __first != __last; ++__first)\n        if (*__first == __value_)\n            break;\n    return __first;\n}\n\n// find_if\n\ntemplate <class _InputIterator, class _Predicate>\ninline _LIBCPP_INLINE_VISIBILITY\n_InputIterator\nfind_if(_InputIterator __first, _InputIterator __last, _Predicate __pred)\n{\n    for (; __first != __last; ++__first)\n        if (__pred(*__first))\n            break;\n    return __first;\n}\n\n// find_if_not\n\ntemplate<class _InputIterator, class _Predicate>\ninline _LIBCPP_INLINE_VISIBILITY\n_InputIterator\nfind_if_not(_InputIterator __first, _InputIterator __last, _Predicate __pred)\n{\n    for (; __first != __last; ++__first)\n        if (!__pred(*__first))\n            break;\n    return __first;\n}\n\n// find_end\n\ntemplate <class _BinaryPredicate, class _ForwardIterator1, class _ForwardIterator2>\n_ForwardIterator1\n__find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n           _ForwardIterator2 __first2, _ForwardIterator2 __last2, _BinaryPredicate __pred,\n           forward_iterator_tag, forward_iterator_tag)\n{\n    // modeled after search algorithm\n    _ForwardIterator1 __r = __last1;  // __last1 is the \"default\" answer\n    if (__first2 == __last2)\n        return __r;\n    while (true)\n    {\n        while (true)\n        {\n            if (__first1 == __last1)         // if source exhausted return last correct answer\n                return __r;                  //    (or __last1 if never found)\n            if (__pred(*__first1, *__first2))\n                break;\n            ++__first1;\n        }\n        // *__first1 matches *__first2, now match elements after here\n        _ForwardIterator1 __m1 = __first1;\n        _ForwardIterator2 __m2 = __first2;\n        while (true)\n        {\n            if (++__m2 == __last2)\n            {                         // Pattern exhaused, record answer and search for another one\n                __r = __first1;\n                ++__first1;\n                break;\n            }\n            if (++__m1 == __last1)     // Source exhausted, return last answer\n                return __r;\n            if (!__pred(*__m1, *__m2))  // mismatch, restart with a new __first\n            {\n                ++__first1;\n                break;\n            }  // else there is a match, check next elements\n        }\n    }\n}\n\ntemplate <class _BinaryPredicate, class _BidirectionalIterator1, class _BidirectionalIterator2>\n_BidirectionalIterator1\n__find_end(_BidirectionalIterator1 __first1, _BidirectionalIterator1 __last1,\n           _BidirectionalIterator2 __first2, _BidirectionalIterator2 __last2, _BinaryPredicate __pred,\n           bidirectional_iterator_tag, bidirectional_iterator_tag)\n{\n    // modeled after search algorithm (in reverse)\n    if (__first2 == __last2)\n        return __last1;  // Everything matches an empty sequence\n    _BidirectionalIterator1 __l1 = __last1;\n    _BidirectionalIterator2 __l2 = __last2;\n    --__l2;\n    while (true)\n    {\n        // Find last element in sequence 1 that matchs *(__last2-1), with a mininum of loop checks\n        while (true)\n        {\n            if (__first1 == __l1)  // return __last1 if no element matches *__first2\n                return __last1;\n            if (__pred(*--__l1, *__l2))\n                break;\n        }\n        // *__l1 matches *__l2, now match elements before here\n        _BidirectionalIterator1 __m1 = __l1;\n        _BidirectionalIterator2 __m2 = __l2;\n        while (true)\n        {\n            if (__m2 == __first2)  // If pattern exhausted, __m1 is the answer (works for 1 element pattern)\n                return __m1;\n            if (__m1 == __first1)  // Otherwise if source exhaused, pattern not found\n                return __last1;\n            if (!__pred(*--__m1, *--__m2))  // if there is a mismatch, restart with a new __l1\n            {\n                break;\n            }  // else there is a match, check next elements\n        }\n    }\n}\n\ntemplate <class _BinaryPredicate, class _RandomAccessIterator1, class _RandomAccessIterator2>\n_LIBCPP_CONSTEXPR_AFTER_CXX11 _RandomAccessIterator1\n__find_end(_RandomAccessIterator1 __first1, _RandomAccessIterator1 __last1,\n           _RandomAccessIterator2 __first2, _RandomAccessIterator2 __last2, _BinaryPredicate __pred,\n           random_access_iterator_tag, random_access_iterator_tag)\n{\n    // Take advantage of knowing source and pattern lengths.  Stop short when source is smaller than pattern\n    typename iterator_traits<_RandomAccessIterator2>::difference_type __len2 = __last2 - __first2;\n    if (__len2 == 0)\n        return __last1;\n    typename iterator_traits<_RandomAccessIterator1>::difference_type __len1 = __last1 - __first1;\n    if (__len1 < __len2)\n        return __last1;\n    const _RandomAccessIterator1 __s = __first1 + (__len2 - 1);  // End of pattern match can't go before here\n    _RandomAccessIterator1 __l1 = __last1;\n    _RandomAccessIterator2 __l2 = __last2;\n    --__l2;\n    while (true)\n    {\n        while (true)\n        {\n            if (__s == __l1)\n                return __last1;\n            if (__pred(*--__l1, *__l2))\n                break;\n        }\n        _RandomAccessIterator1 __m1 = __l1;\n        _RandomAccessIterator2 __m2 = __l2;\n        while (true)\n        {\n            if (__m2 == __first2)\n                return __m1;\n                                 // no need to check range on __m1 because __s guarantees we have enough source\n            if (!__pred(*--__m1, *--__m2))\n            {\n                break;\n            }\n        }\n    }\n}\n\ntemplate <class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator1\nfind_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n         _ForwardIterator2 __first2, _ForwardIterator2 __last2, _BinaryPredicate __pred)\n{\n    return _VSTD::__find_end<typename add_lvalue_reference<_BinaryPredicate>::type>\n                         (__first1, __last1, __first2, __last2, __pred,\n                          typename iterator_traits<_ForwardIterator1>::iterator_category(),\n                          typename iterator_traits<_ForwardIterator2>::iterator_category());\n}\n\ntemplate <class _ForwardIterator1, class _ForwardIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator1\nfind_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n         _ForwardIterator2 __first2, _ForwardIterator2 __last2)\n{\n    typedef typename iterator_traits<_ForwardIterator1>::value_type __v1;\n    typedef typename iterator_traits<_ForwardIterator2>::value_type __v2;\n    return _VSTD::find_end(__first1, __last1, __first2, __last2, __equal_to<__v1, __v2>());\n}\n\n// find_first_of\n\ntemplate <class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate>\n_LIBCPP_CONSTEXPR_AFTER_CXX11 _ForwardIterator1\n__find_first_of_ce(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n              _ForwardIterator2 __first2, _ForwardIterator2 __last2, _BinaryPredicate __pred)\n{\n    for (; __first1 != __last1; ++__first1)\n        for (_ForwardIterator2 __j = __first2; __j != __last2; ++__j)\n            if (__pred(*__first1, *__j))\n                return __first1;\n    return __last1;\n}\n\n\ntemplate <class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator1\nfind_first_of(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n              _ForwardIterator2 __first2, _ForwardIterator2 __last2, _BinaryPredicate __pred)\n{\n    return _VSTD::__find_first_of_ce(__first1, __last1, __first2, __last2, __pred);\n}\n\ntemplate <class _ForwardIterator1, class _ForwardIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator1\nfind_first_of(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n              _ForwardIterator2 __first2, _ForwardIterator2 __last2)\n{\n    typedef typename iterator_traits<_ForwardIterator1>::value_type __v1;\n    typedef typename iterator_traits<_ForwardIterator2>::value_type __v2;\n    return _VSTD::__find_first_of_ce(__first1, __last1, __first2, __last2, __equal_to<__v1, __v2>());\n}\n\n// adjacent_find\n\ntemplate <class _ForwardIterator, class _BinaryPredicate>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\nadjacent_find(_ForwardIterator __first, _ForwardIterator __last, _BinaryPredicate __pred)\n{\n    if (__first != __last)\n    {\n        _ForwardIterator __i = __first;\n        while (++__i != __last)\n        {\n            if (__pred(*__first, *__i))\n                return __first;\n            __first = __i;\n        }\n    }\n    return __last;\n}\n\ntemplate <class _ForwardIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\nadjacent_find(_ForwardIterator __first, _ForwardIterator __last)\n{\n    typedef typename iterator_traits<_ForwardIterator>::value_type __v;\n    return _VSTD::adjacent_find(__first, __last, __equal_to<__v>());\n}\n\n// count\n\ntemplate <class _InputIterator, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename iterator_traits<_InputIterator>::difference_type\ncount(_InputIterator __first, _InputIterator __last, const _Tp& __value_)\n{\n    typename iterator_traits<_InputIterator>::difference_type __r(0);\n    for (; __first != __last; ++__first)\n        if (*__first == __value_)\n            ++__r;\n    return __r;\n}\n\n// count_if\n\ntemplate <class _InputIterator, class _Predicate>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename iterator_traits<_InputIterator>::difference_type\ncount_if(_InputIterator __first, _InputIterator __last, _Predicate __pred)\n{\n    typename iterator_traits<_InputIterator>::difference_type __r(0);\n    for (; __first != __last; ++__first)\n        if (__pred(*__first))\n            ++__r;\n    return __r;\n}\n\n// mismatch\n\ntemplate <class _InputIterator1, class _InputIterator2, class _BinaryPredicate>\ninline _LIBCPP_INLINE_VISIBILITY\npair<_InputIterator1, _InputIterator2>\nmismatch(_InputIterator1 __first1, _InputIterator1 __last1,\n         _InputIterator2 __first2, _BinaryPredicate __pred)\n{\n    for (; __first1 != __last1; ++__first1, (void) ++__first2)\n        if (!__pred(*__first1, *__first2))\n            break;\n    return pair<_InputIterator1, _InputIterator2>(__first1, __first2);\n}\n\ntemplate <class _InputIterator1, class _InputIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\npair<_InputIterator1, _InputIterator2>\nmismatch(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2)\n{\n    typedef typename iterator_traits<_InputIterator1>::value_type __v1;\n    typedef typename iterator_traits<_InputIterator2>::value_type __v2;\n    return _VSTD::mismatch(__first1, __last1, __first2, __equal_to<__v1, __v2>());\n}\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _InputIterator1, class _InputIterator2, class _BinaryPredicate>\ninline _LIBCPP_INLINE_VISIBILITY\npair<_InputIterator1, _InputIterator2>\nmismatch(_InputIterator1 __first1, _InputIterator1 __last1,\n         _InputIterator2 __first2, _InputIterator2 __last2,\n         _BinaryPredicate __pred)\n{\n    for (; __first1 != __last1 && __first2 != __last2; ++__first1, (void) ++__first2)\n        if (!__pred(*__first1, *__first2))\n            break;\n    return pair<_InputIterator1, _InputIterator2>(__first1, __first2);\n}\n\ntemplate <class _InputIterator1, class _InputIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\npair<_InputIterator1, _InputIterator2>\nmismatch(_InputIterator1 __first1, _InputIterator1 __last1,\n         _InputIterator2 __first2, _InputIterator2 __last2)\n{\n    typedef typename iterator_traits<_InputIterator1>::value_type __v1;\n    typedef typename iterator_traits<_InputIterator2>::value_type __v2;\n    return _VSTD::mismatch(__first1, __last1, __first2, __last2, __equal_to<__v1, __v2>());\n}\n#endif\n\n// equal\n\ntemplate <class _InputIterator1, class _InputIterator2, class _BinaryPredicate>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nequal(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _BinaryPredicate __pred)\n{\n    for (; __first1 != __last1; ++__first1, (void) ++__first2)\n        if (!__pred(*__first1, *__first2))\n            return false;\n    return true;\n}\n\ntemplate <class _InputIterator1, class _InputIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nequal(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2)\n{\n    typedef typename iterator_traits<_InputIterator1>::value_type __v1;\n    typedef typename iterator_traits<_InputIterator2>::value_type __v2;\n    return _VSTD::equal(__first1, __last1, __first2, __equal_to<__v1, __v2>());\n}\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _BinaryPredicate, class _InputIterator1, class _InputIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\n__equal(_InputIterator1 __first1, _InputIterator1 __last1,\n        _InputIterator2 __first2, _InputIterator2 __last2, _BinaryPredicate __pred,\n        input_iterator_tag, input_iterator_tag )\n{\n    for (; __first1 != __last1 && __first2 != __last2; ++__first1, (void) ++__first2)\n        if (!__pred(*__first1, *__first2))\n            return false;\n    return __first1 == __last1 && __first2 == __last2;\n}\n\ntemplate <class _BinaryPredicate, class _RandomAccessIterator1, class _RandomAccessIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\n__equal(_RandomAccessIterator1 __first1, _RandomAccessIterator1 __last1,\n        _RandomAccessIterator2 __first2, _RandomAccessIterator2 __last2, _BinaryPredicate __pred,\n      random_access_iterator_tag, random_access_iterator_tag )\n{\n    if ( _VSTD::distance(__first1, __last1) != _VSTD::distance(__first2, __last2))\n        return false;\n    return _VSTD::equal<_RandomAccessIterator1, _RandomAccessIterator2,\n                        typename add_lvalue_reference<_BinaryPredicate>::type>\n                       (__first1, __last1, __first2, __pred );\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _BinaryPredicate>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nequal(_InputIterator1 __first1, _InputIterator1 __last1,\n      _InputIterator2 __first2, _InputIterator2 __last2, _BinaryPredicate __pred )\n{\n    return _VSTD::__equal<typename add_lvalue_reference<_BinaryPredicate>::type>\n       (__first1, __last1, __first2, __last2, __pred,\n        typename iterator_traits<_InputIterator1>::iterator_category(),\n        typename iterator_traits<_InputIterator2>::iterator_category());\n}\n\ntemplate <class _InputIterator1, class _InputIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nequal(_InputIterator1 __first1, _InputIterator1 __last1,\n      _InputIterator2 __first2, _InputIterator2 __last2)\n{\n    typedef typename iterator_traits<_InputIterator1>::value_type __v1;\n    typedef typename iterator_traits<_InputIterator2>::value_type __v2;\n    return _VSTD::__equal(__first1, __last1, __first2, __last2, __equal_to<__v1, __v2>(),\n        typename iterator_traits<_InputIterator1>::iterator_category(),\n        typename iterator_traits<_InputIterator2>::iterator_category());\n}\n#endif\n\n// is_permutation\n\ntemplate<class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate>\nbool\nis_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n               _ForwardIterator2 __first2, _BinaryPredicate __pred)\n{\n    // shorten sequences as much as possible by lopping of any equal parts\n    for (; __first1 != __last1; ++__first1, (void) ++__first2)\n        if (!__pred(*__first1, *__first2))\n            goto __not_done;\n    return true;\n__not_done:\n    // __first1 != __last1 && *__first1 != *__first2\n    typedef typename iterator_traits<_ForwardIterator1>::difference_type _D1;\n    _D1 __l1 = _VSTD::distance(__first1, __last1);\n    if (__l1 == _D1(1))\n        return false;\n    _ForwardIterator2 __last2 = _VSTD::next(__first2, __l1);\n    // For each element in [f1, l1) see if there are the same number of\n    //    equal elements in [f2, l2)\n    for (_ForwardIterator1 __i = __first1; __i != __last1; ++__i)\n    {\n        // Have we already counted the number of *__i in [f1, l1)?\n        for (_ForwardIterator1 __j = __first1; __j != __i; ++__j)\n            if (__pred(*__j, *__i))\n                goto __next_iter;\n        {\n            // Count number of *__i in [f2, l2)\n            _D1 __c2 = 0;\n            for (_ForwardIterator2 __j = __first2; __j != __last2; ++__j)\n                if (__pred(*__i, *__j))\n                    ++__c2;\n            if (__c2 == 0)\n                return false;\n            // Count number of *__i in [__i, l1) (we can start with 1)\n            _D1 __c1 = 1;\n            for (_ForwardIterator1 __j = _VSTD::next(__i); __j != __last1; ++__j)\n                if (__pred(*__i, *__j))\n                    ++__c1;\n            if (__c1 != __c2)\n                return false;\n        }\n__next_iter:;\n    }\n    return true;\n}\n\ntemplate<class _ForwardIterator1, class _ForwardIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nis_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n               _ForwardIterator2 __first2)\n{\n    typedef typename iterator_traits<_ForwardIterator1>::value_type __v1;\n    typedef typename iterator_traits<_ForwardIterator2>::value_type __v2;\n    return _VSTD::is_permutation(__first1, __last1, __first2, __equal_to<__v1, __v2>());\n}\n\n#if _LIBCPP_STD_VER > 11\ntemplate<class _BinaryPredicate, class _ForwardIterator1, class _ForwardIterator2>\nbool\n__is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n                 _ForwardIterator2 __first2, _ForwardIterator2 __last2,\n                 _BinaryPredicate __pred,\n                 forward_iterator_tag, forward_iterator_tag )\n{\n    // shorten sequences as much as possible by lopping of any equal parts\n    for (; __first1 != __last1 && __first2 != __last2; ++__first1, (void) ++__first2)\n        if (!__pred(*__first1, *__first2))\n            goto __not_done;\n    return __first1 == __last1 && __first2 == __last2;\n__not_done:\n    // __first1 != __last1 && __first2 != __last2 && *__first1 != *__first2\n    typedef typename iterator_traits<_ForwardIterator1>::difference_type _D1;\n    _D1 __l1 = _VSTD::distance(__first1, __last1);\n\n    typedef typename iterator_traits<_ForwardIterator2>::difference_type _D2;\n    _D2 __l2 = _VSTD::distance(__first2, __last2);\n    if (__l1 != __l2)\n        return false;\n\n    // For each element in [f1, l1) see if there are the same number of\n    //    equal elements in [f2, l2)\n    for (_ForwardIterator1 __i = __first1; __i != __last1; ++__i)\n    {\n        // Have we already counted the number of *__i in [f1, l1)?\n        for (_ForwardIterator1 __j = __first1; __j != __i; ++__j)\n            if (__pred(*__j, *__i))\n                goto __next_iter;\n        {\n            // Count number of *__i in [f2, l2)\n            _D1 __c2 = 0;\n            for (_ForwardIterator2 __j = __first2; __j != __last2; ++__j)\n                if (__pred(*__i, *__j))\n                    ++__c2;\n            if (__c2 == 0)\n                return false;\n            // Count number of *__i in [__i, l1) (we can start with 1)\n            _D1 __c1 = 1;\n            for (_ForwardIterator1 __j = _VSTD::next(__i); __j != __last1; ++__j)\n                if (__pred(*__i, *__j))\n                    ++__c1;\n            if (__c1 != __c2)\n                return false;\n        }\n__next_iter:;\n    }\n    return true;\n}\n\ntemplate<class _BinaryPredicate, class _RandomAccessIterator1, class _RandomAccessIterator2>\nbool\n__is_permutation(_RandomAccessIterator1 __first1, _RandomAccessIterator2 __last1,\n               _RandomAccessIterator1 __first2, _RandomAccessIterator2 __last2,\n               _BinaryPredicate __pred,\n               random_access_iterator_tag, random_access_iterator_tag )\n{\n    if ( _VSTD::distance(__first1, __last1) != _VSTD::distance(__first2, __last2))\n        return false;\n    return _VSTD::is_permutation<_RandomAccessIterator1, _RandomAccessIterator2,\n                                 typename add_lvalue_reference<_BinaryPredicate>::type>\n                                (__first1, __last1, __first2, __pred );\n}\n\ntemplate<class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nis_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n               _ForwardIterator2 __first2, _ForwardIterator2 __last2,\n               _BinaryPredicate __pred )\n{\n    return _VSTD::__is_permutation<typename add_lvalue_reference<_BinaryPredicate>::type>\n       (__first1, __last1, __first2, __last2, __pred,\n        typename iterator_traits<_ForwardIterator1>::iterator_category(),\n        typename iterator_traits<_ForwardIterator2>::iterator_category());\n}\n\ntemplate<class _ForwardIterator1, class _ForwardIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nis_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n               _ForwardIterator2 __first2, _ForwardIterator2 __last2)\n{\n    typedef typename iterator_traits<_ForwardIterator1>::value_type __v1;\n    typedef typename iterator_traits<_ForwardIterator2>::value_type __v2;\n    return _VSTD::__is_permutation(__first1, __last1, __first2, __last2,\n        __equal_to<__v1, __v2>(),\n        typename iterator_traits<_ForwardIterator1>::iterator_category(),\n        typename iterator_traits<_ForwardIterator2>::iterator_category());\n}\n#endif\n\n// search\n\ntemplate <class _BinaryPredicate, class _ForwardIterator1, class _ForwardIterator2>\npair<_ForwardIterator1, _ForwardIterator1>\n__search(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n         _ForwardIterator2 __first2, _ForwardIterator2 __last2, _BinaryPredicate __pred,\n         forward_iterator_tag, forward_iterator_tag)\n{\n    if (__first2 == __last2)\n        return make_pair(__first1, __first1);  // Everything matches an empty sequence\n    while (true)\n    {\n        // Find first element in sequence 1 that matchs *__first2, with a mininum of loop checks\n        while (true)\n        {\n            if (__first1 == __last1)  // return __last1 if no element matches *__first2\n                return make_pair(__last1, __last1);\n            if (__pred(*__first1, *__first2))\n                break;\n            ++__first1;\n        }\n        // *__first1 matches *__first2, now match elements after here\n        _ForwardIterator1 __m1 = __first1;\n        _ForwardIterator2 __m2 = __first2;\n        while (true)\n        {\n            if (++__m2 == __last2)  // If pattern exhausted, __first1 is the answer (works for 1 element pattern)\n                return make_pair(__first1, __m1);\n            if (++__m1 == __last1)  // Otherwise if source exhaused, pattern not found\n                return make_pair(__last1, __last1);\n            if (!__pred(*__m1, *__m2))  // if there is a mismatch, restart with a new __first1\n            {\n                ++__first1;\n                break;\n            }  // else there is a match, check next elements\n        }\n    }\n}\n\ntemplate <class _BinaryPredicate, class _RandomAccessIterator1, class _RandomAccessIterator2>\n_LIBCPP_CONSTEXPR_AFTER_CXX11\npair<_RandomAccessIterator1, _RandomAccessIterator1>\n__search(_RandomAccessIterator1 __first1, _RandomAccessIterator1 __last1,\n         _RandomAccessIterator2 __first2, _RandomAccessIterator2 __last2, _BinaryPredicate __pred,\n           random_access_iterator_tag, random_access_iterator_tag)\n{\n    typedef typename iterator_traits<_RandomAccessIterator1>::difference_type _D1;\n    typedef typename iterator_traits<_RandomAccessIterator2>::difference_type _D2;\n    // Take advantage of knowing source and pattern lengths.  Stop short when source is smaller than pattern\n    const _D2 __len2 = __last2 - __first2;\n    if (__len2 == 0)\n        return make_pair(__first1, __first1);\n    const _D1 __len1 = __last1 - __first1;\n    if (__len1 < __len2)\n        return make_pair(__last1, __last1);\n    const _RandomAccessIterator1 __s = __last1 - (__len2 - 1);  // Start of pattern match can't go beyond here\n\n    while (true)\n    {\n        while (true)\n        {\n            if (__first1 == __s)\n                return make_pair(__last1, __last1);\n            if (__pred(*__first1, *__first2))\n                break;\n            ++__first1;\n        }\n\n        _RandomAccessIterator1 __m1 = __first1;\n        _RandomAccessIterator2 __m2 = __first2;\n         while (true)\n         {\n             if (++__m2 == __last2)\n                 return make_pair(__first1, __first1 + __len2);\n             ++__m1;          // no need to check range on __m1 because __s guarantees we have enough source\n             if (!__pred(*__m1, *__m2))\n             {\n                 ++__first1;\n                 break;\n             }\n         }\n    }\n}\n\ntemplate <class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator1\nsearch(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n       _ForwardIterator2 __first2, _ForwardIterator2 __last2, _BinaryPredicate __pred)\n{\n    return _VSTD::__search<typename add_lvalue_reference<_BinaryPredicate>::type>\n                         (__first1, __last1, __first2, __last2, __pred,\n                          typename iterator_traits<_ForwardIterator1>::iterator_category(),\n                          typename iterator_traits<_ForwardIterator2>::iterator_category())\n            .first;\n}\n\ntemplate <class _ForwardIterator1, class _ForwardIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator1\nsearch(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n       _ForwardIterator2 __first2, _ForwardIterator2 __last2)\n{\n    typedef typename iterator_traits<_ForwardIterator1>::value_type __v1;\n    typedef typename iterator_traits<_ForwardIterator2>::value_type __v2;\n    return _VSTD::search(__first1, __last1, __first2, __last2, __equal_to<__v1, __v2>());\n}\n\n// search_n\n\ntemplate <class _BinaryPredicate, class _ForwardIterator, class _Size, class _Tp>\n_ForwardIterator\n__search_n(_ForwardIterator __first, _ForwardIterator __last,\n           _Size __count, const _Tp& __value_, _BinaryPredicate __pred, forward_iterator_tag)\n{\n    if (__count <= 0)\n        return __first;\n    while (true)\n    {\n        // Find first element in sequence that matchs __value_, with a mininum of loop checks\n        while (true)\n        {\n            if (__first == __last)  // return __last if no element matches __value_\n                return __last;\n            if (__pred(*__first, __value_))\n                break;\n            ++__first;\n        }\n        // *__first matches __value_, now match elements after here\n        _ForwardIterator __m = __first;\n        _Size __c(0);\n        while (true)\n        {\n            if (++__c == __count)  // If pattern exhausted, __first is the answer (works for 1 element pattern)\n                return __first;\n            if (++__m == __last)  // Otherwise if source exhaused, pattern not found\n                return __last;\n            if (!__pred(*__m, __value_))  // if there is a mismatch, restart with a new __first\n            {\n                __first = __m;\n                ++__first;\n                break;\n            }  // else there is a match, check next elements\n        }\n    }\n}\n\ntemplate <class _BinaryPredicate, class _RandomAccessIterator, class _Size, class _Tp>\n_RandomAccessIterator\n__search_n(_RandomAccessIterator __first, _RandomAccessIterator __last,\n           _Size __count, const _Tp& __value_, _BinaryPredicate __pred, random_access_iterator_tag)\n{\n    if (__count <= 0)\n        return __first;\n    _Size __len = static_cast<_Size>(__last - __first);\n    if (__len < __count)\n        return __last;\n    const _RandomAccessIterator __s = __last - (__count - 1);  // Start of pattern match can't go beyond here\n    while (true)\n    {\n        // Find first element in sequence that matchs __value_, with a mininum of loop checks\n        while (true)\n        {\n            if (__first >= __s)  // return __last if no element matches __value_\n                return __last;\n            if (__pred(*__first, __value_))\n                break;\n            ++__first;\n        }\n        // *__first matches __value_, now match elements after here\n        _RandomAccessIterator __m = __first;\n        _Size __c(0);\n        while (true)\n        {\n            if (++__c == __count)  // If pattern exhausted, __first is the answer (works for 1 element pattern)\n                return __first;\n             ++__m;          // no need to check range on __m because __s guarantees we have enough source\n            if (!__pred(*__m, __value_))  // if there is a mismatch, restart with a new __first\n            {\n                __first = __m;\n                ++__first;\n                break;\n            }  // else there is a match, check next elements\n        }\n    }\n}\n\ntemplate <class _ForwardIterator, class _Size, class _Tp, class _BinaryPredicate>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\nsearch_n(_ForwardIterator __first, _ForwardIterator __last,\n         _Size __count, const _Tp& __value_, _BinaryPredicate __pred)\n{\n    return _VSTD::__search_n<typename add_lvalue_reference<_BinaryPredicate>::type>\n           (__first, __last, __convert_to_integral(__count), __value_, __pred,\n           typename iterator_traits<_ForwardIterator>::iterator_category());\n}\n\ntemplate <class _ForwardIterator, class _Size, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\nsearch_n(_ForwardIterator __first, _ForwardIterator __last, _Size __count, const _Tp& __value_)\n{\n    typedef typename iterator_traits<_ForwardIterator>::value_type __v;\n    return _VSTD::search_n(__first, __last, __convert_to_integral(__count),\n                           __value_, __equal_to<__v, _Tp>());\n}\n\n// copy\ntemplate <class _Iter>\ninline _LIBCPP_INLINE_VISIBILITY\n_Iter\n__unwrap_iter(_Iter __i)\n{\n    return __i;\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_trivially_copy_assignable<_Tp>::value,\n    _Tp*\n>::type\n__unwrap_iter(move_iterator<_Tp*> __i)\n{\n    return __i.base();\n}\n\n#if _LIBCPP_DEBUG_LEVEL < 2\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_trivially_copy_assignable<_Tp>::value,\n    _Tp*\n>::type\n__unwrap_iter(__wrap_iter<_Tp*> __i)\n{\n    return __i.base();\n}\n\n#else\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_trivially_copy_assignable<_Tp>::value,\n    __wrap_iter<_Tp*>\n>::type\n__unwrap_iter(__wrap_iter<_Tp*> __i)\n{\n    return __i;\n}\n\n#endif  // _LIBCPP_DEBUG_LEVEL < 2\n\ntemplate <class _InputIterator, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\n__copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result)\n{\n    for (; __first != __last; ++__first, (void) ++__result)\n        *__result = *__first;\n    return __result;\n}\n\ntemplate <class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_same<typename remove_const<_Tp>::type, _Up>::value &&\n    is_trivially_copy_assignable<_Up>::value,\n    _Up*\n>::type\n__copy(_Tp* __first, _Tp* __last, _Up* __result)\n{\n    const size_t __n = static_cast<size_t>(__last - __first);\n    if (__n > 0)\n        _VSTD::memmove(__result, __first, __n * sizeof(_Up));\n    return __result + __n;\n}\n\ntemplate <class _InputIterator, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\ncopy(_InputIterator __first, _InputIterator __last, _OutputIterator __result)\n{\n    return _VSTD::__copy(__unwrap_iter(__first), __unwrap_iter(__last), __unwrap_iter(__result));\n}\n\n// copy_backward\n\ntemplate <class _BidirectionalIterator, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\n__copy_backward(_BidirectionalIterator __first, _BidirectionalIterator __last, _OutputIterator __result)\n{\n    while (__first != __last)\n        *--__result = *--__last;\n    return __result;\n}\n\ntemplate <class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_same<typename remove_const<_Tp>::type, _Up>::value &&\n    is_trivially_copy_assignable<_Up>::value,\n    _Up*\n>::type\n__copy_backward(_Tp* __first, _Tp* __last, _Up* __result)\n{\n    const size_t __n = static_cast<size_t>(__last - __first);\n    if (__n > 0)\n    {\n        __result -= __n;\n        _VSTD::memmove(__result, __first, __n * sizeof(_Up));\n    }\n    return __result;\n}\n\ntemplate <class _BidirectionalIterator1, class _BidirectionalIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\n_BidirectionalIterator2\ncopy_backward(_BidirectionalIterator1 __first, _BidirectionalIterator1 __last,\n              _BidirectionalIterator2 __result)\n{\n    return _VSTD::__copy_backward(__unwrap_iter(__first),\n                                  __unwrap_iter(__last),\n                                  __unwrap_iter(__result));\n}\n\n// copy_if\n\ntemplate<class _InputIterator, class _OutputIterator, class _Predicate>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\ncopy_if(_InputIterator __first, _InputIterator __last,\n        _OutputIterator __result, _Predicate __pred)\n{\n    for (; __first != __last; ++__first)\n    {\n        if (__pred(*__first))\n        {\n            *__result = *__first;\n            ++__result;\n        }\n    }\n    return __result;\n}\n\n// copy_n\n\ntemplate<class _InputIterator, class _Size, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    __is_input_iterator<_InputIterator>::value &&\n   !__is_random_access_iterator<_InputIterator>::value,\n    _OutputIterator\n>::type\ncopy_n(_InputIterator __first, _Size __orig_n, _OutputIterator __result)\n{\n    typedef decltype(__convert_to_integral(__orig_n)) _IntegralSize;\n    _IntegralSize __n = __orig_n;\n    if (__n > 0)\n    {\n        *__result = *__first;\n        ++__result;\n        for (--__n; __n > 0; --__n)\n        {\n            ++__first;\n            *__result = *__first;\n            ++__result;\n        }\n    }\n    return __result;\n}\n\ntemplate<class _InputIterator, class _Size, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    __is_random_access_iterator<_InputIterator>::value,\n    _OutputIterator\n>::type\ncopy_n(_InputIterator __first, _Size __orig_n, _OutputIterator __result)\n{\n    typedef decltype(__convert_to_integral(__orig_n)) _IntegralSize;\n    _IntegralSize __n = __orig_n;\n    return _VSTD::copy(__first, __first + __n, __result);\n}\n\n// move\n\ntemplate <class _InputIterator, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\n__move(_InputIterator __first, _InputIterator __last, _OutputIterator __result)\n{\n    for (; __first != __last; ++__first, (void) ++__result)\n        *__result = _VSTD::move(*__first);\n    return __result;\n}\n\ntemplate <class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_same<typename remove_const<_Tp>::type, _Up>::value &&\n    is_trivially_copy_assignable<_Up>::value,\n    _Up*\n>::type\n__move(_Tp* __first, _Tp* __last, _Up* __result)\n{\n    const size_t __n = static_cast<size_t>(__last - __first);\n    if (__n > 0)\n        _VSTD::memmove(__result, __first, __n * sizeof(_Up));\n    return __result + __n;\n}\n\ntemplate <class _InputIterator, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nmove(_InputIterator __first, _InputIterator __last, _OutputIterator __result)\n{\n    return _VSTD::__move(__unwrap_iter(__first), __unwrap_iter(__last), __unwrap_iter(__result));\n}\n\n// move_backward\n\ntemplate <class _InputIterator, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\n__move_backward(_InputIterator __first, _InputIterator __last, _OutputIterator __result)\n{\n    while (__first != __last)\n        *--__result = _VSTD::move(*--__last);\n    return __result;\n}\n\ntemplate <class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_same<typename remove_const<_Tp>::type, _Up>::value &&\n    is_trivially_copy_assignable<_Up>::value,\n    _Up*\n>::type\n__move_backward(_Tp* __first, _Tp* __last, _Up* __result)\n{\n    const size_t __n = static_cast<size_t>(__last - __first);\n    if (__n > 0)\n    {\n        __result -= __n;\n        _VSTD::memmove(__result, __first, __n * sizeof(_Up));\n    }\n    return __result;\n}\n\ntemplate <class _BidirectionalIterator1, class _BidirectionalIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\n_BidirectionalIterator2\nmove_backward(_BidirectionalIterator1 __first, _BidirectionalIterator1 __last,\n              _BidirectionalIterator2 __result)\n{\n    return _VSTD::__move_backward(__unwrap_iter(__first), __unwrap_iter(__last), __unwrap_iter(__result));\n}\n\n// iter_swap\n\n// moved to <type_traits> for better swap / noexcept support\n\n// transform\n\ntemplate <class _InputIterator, class _OutputIterator, class _UnaryOperation>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\ntransform(_InputIterator __first, _InputIterator __last, _OutputIterator __result, _UnaryOperation __op)\n{\n    for (; __first != __last; ++__first, (void) ++__result)\n        *__result = __op(*__first);\n    return __result;\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _OutputIterator, class _BinaryOperation>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\ntransform(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2,\n          _OutputIterator __result, _BinaryOperation __binary_op)\n{\n    for (; __first1 != __last1; ++__first1, (void) ++__first2, ++__result)\n        *__result = __binary_op(*__first1, *__first2);\n    return __result;\n}\n\n// replace\n\ntemplate <class _ForwardIterator, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nreplace(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __old_value, const _Tp& __new_value)\n{\n    for (; __first != __last; ++__first)\n        if (*__first == __old_value)\n            *__first = __new_value;\n}\n\n// replace_if\n\ntemplate <class _ForwardIterator, class _Predicate, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nreplace_if(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred, const _Tp& __new_value)\n{\n    for (; __first != __last; ++__first)\n        if (__pred(*__first))\n            *__first = __new_value;\n}\n\n// replace_copy\n\ntemplate <class _InputIterator, class _OutputIterator, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nreplace_copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result,\n             const _Tp& __old_value, const _Tp& __new_value)\n{\n    for (; __first != __last; ++__first, (void) ++__result)\n        if (*__first == __old_value)\n            *__result = __new_value;\n        else\n            *__result = *__first;\n    return __result;\n}\n\n// replace_copy_if\n\ntemplate <class _InputIterator, class _OutputIterator, class _Predicate, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nreplace_copy_if(_InputIterator __first, _InputIterator __last, _OutputIterator __result,\n                _Predicate __pred, const _Tp& __new_value)\n{\n    for (; __first != __last; ++__first, (void) ++__result)\n        if (__pred(*__first))\n            *__result = __new_value;\n        else\n            *__result = *__first;\n    return __result;\n}\n\n// fill_n\n\ntemplate <class _OutputIterator, class _Size, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\n__fill_n(_OutputIterator __first, _Size __n, const _Tp& __value_)\n{\n    for (; __n > 0; ++__first, (void) --__n)\n        *__first = __value_;\n    return __first;\n}\n\ntemplate <class _Tp, class _Size, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_integral<_Tp>::value && sizeof(_Tp) == 1 &&\n    !is_same<_Tp, bool>::value &&\n    is_integral<_Up>::value && sizeof(_Up) == 1,\n    _Tp*\n>::type\n__fill_n(_Tp* __first, _Size __n,_Up __value_)\n{\n    if (__n > 0)\n        _VSTD::memset(__first, (unsigned char)__value_, (size_t)(__n));\n    return __first + __n;\n}\n\ntemplate <class _OutputIterator, class _Size, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nfill_n(_OutputIterator __first, _Size __n, const _Tp& __value_)\n{\n   return _VSTD::__fill_n(__first, __convert_to_integral(__n), __value_);\n}\n\n// fill\n\ntemplate <class _ForwardIterator, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\n__fill(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, forward_iterator_tag)\n{\n    for (; __first != __last; ++__first)\n        *__first = __value_;\n}\n\ntemplate <class _RandomAccessIterator, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\n__fill(_RandomAccessIterator __first, _RandomAccessIterator __last, const _Tp& __value_, random_access_iterator_tag)\n{\n    _VSTD::fill_n(__first, __last - __first, __value_);\n}\n\ntemplate <class _ForwardIterator, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nfill(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_)\n{\n    _VSTD::__fill(__first, __last, __value_, typename iterator_traits<_ForwardIterator>::iterator_category());\n}\n\n// generate\n\ntemplate <class _ForwardIterator, class _Generator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\ngenerate(_ForwardIterator __first, _ForwardIterator __last, _Generator __gen)\n{\n    for (; __first != __last; ++__first)\n        *__first = __gen();\n}\n\n// generate_n\n\ntemplate <class _OutputIterator, class _Size, class _Generator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\ngenerate_n(_OutputIterator __first, _Size __orig_n, _Generator __gen)\n{\n    typedef decltype(__convert_to_integral(__orig_n)) _IntegralSize;\n    _IntegralSize __n = __orig_n;\n    for (; __n > 0; ++__first, (void) --__n)\n        *__first = __gen();\n    return __first;\n}\n\n// remove\n\ntemplate <class _ForwardIterator, class _Tp>\n_ForwardIterator\nremove(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_)\n{\n    __first = _VSTD::find(__first, __last, __value_);\n    if (__first != __last)\n    {\n        _ForwardIterator __i = __first;\n        while (++__i != __last)\n        {\n            if (!(*__i == __value_))\n            {\n                *__first = _VSTD::move(*__i);\n                ++__first;\n            }\n        }\n    }\n    return __first;\n}\n\n// remove_if\n\ntemplate <class _ForwardIterator, class _Predicate>\n_ForwardIterator\nremove_if(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred)\n{\n    __first = _VSTD::find_if<_ForwardIterator, typename add_lvalue_reference<_Predicate>::type>\n                           (__first, __last, __pred);\n    if (__first != __last)\n    {\n        _ForwardIterator __i = __first;\n        while (++__i != __last)\n        {\n            if (!__pred(*__i))\n            {\n                *__first = _VSTD::move(*__i);\n                ++__first;\n            }\n        }\n    }\n    return __first;\n}\n\n// remove_copy\n\ntemplate <class _InputIterator, class _OutputIterator, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nremove_copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result, const _Tp& __value_)\n{\n    for (; __first != __last; ++__first)\n    {\n        if (!(*__first == __value_))\n        {\n            *__result = *__first;\n            ++__result;\n        }\n    }\n    return __result;\n}\n\n// remove_copy_if\n\ntemplate <class _InputIterator, class _OutputIterator, class _Predicate>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nremove_copy_if(_InputIterator __first, _InputIterator __last, _OutputIterator __result, _Predicate __pred)\n{\n    for (; __first != __last; ++__first)\n    {\n        if (!__pred(*__first))\n        {\n            *__result = *__first;\n            ++__result;\n        }\n    }\n    return __result;\n}\n\n// unique\n\ntemplate <class _ForwardIterator, class _BinaryPredicate>\n_ForwardIterator\nunique(_ForwardIterator __first, _ForwardIterator __last, _BinaryPredicate __pred)\n{\n    __first = _VSTD::adjacent_find<_ForwardIterator, typename add_lvalue_reference<_BinaryPredicate>::type>\n                                 (__first, __last, __pred);\n    if (__first != __last)\n    {\n        // ...  a  a  ?  ...\n        //      f     i\n        _ForwardIterator __i = __first;\n        for (++__i; ++__i != __last;)\n            if (!__pred(*__first, *__i))\n                *++__first = _VSTD::move(*__i);\n        ++__first;\n    }\n    return __first;\n}\n\ntemplate <class _ForwardIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\nunique(_ForwardIterator __first, _ForwardIterator __last)\n{\n    typedef typename iterator_traits<_ForwardIterator>::value_type __v;\n    return _VSTD::unique(__first, __last, __equal_to<__v>());\n}\n\n// unique_copy\n\ntemplate <class _BinaryPredicate, class _InputIterator, class _OutputIterator>\n_OutputIterator\n__unique_copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result, _BinaryPredicate __pred,\n              input_iterator_tag, output_iterator_tag)\n{\n    if (__first != __last)\n    {\n        typename iterator_traits<_InputIterator>::value_type __t(*__first);\n        *__result = __t;\n        ++__result;\n        while (++__first != __last)\n        {\n            if (!__pred(__t, *__first))\n            {\n                __t = *__first;\n                *__result = __t;\n                ++__result;\n            }\n        }\n    }\n    return __result;\n}\n\ntemplate <class _BinaryPredicate, class _ForwardIterator, class _OutputIterator>\n_OutputIterator\n__unique_copy(_ForwardIterator __first, _ForwardIterator __last, _OutputIterator __result, _BinaryPredicate __pred,\n              forward_iterator_tag, output_iterator_tag)\n{\n    if (__first != __last)\n    {\n        _ForwardIterator __i = __first;\n        *__result = *__i;\n        ++__result;\n        while (++__first != __last)\n        {\n            if (!__pred(*__i, *__first))\n            {\n                *__result = *__first;\n                ++__result;\n                __i = __first;\n            }\n        }\n    }\n    return __result;\n}\n\ntemplate <class _BinaryPredicate, class _InputIterator, class _ForwardIterator>\n_ForwardIterator\n__unique_copy(_InputIterator __first, _InputIterator __last, _ForwardIterator __result, _BinaryPredicate __pred,\n              input_iterator_tag, forward_iterator_tag)\n{\n    if (__first != __last)\n    {\n        *__result = *__first;\n        while (++__first != __last)\n            if (!__pred(*__result, *__first))\n                *++__result = *__first;\n        ++__result;\n    }\n    return __result;\n}\n\ntemplate <class _InputIterator, class _OutputIterator, class _BinaryPredicate>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nunique_copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result, _BinaryPredicate __pred)\n{\n    return _VSTD::__unique_copy<typename add_lvalue_reference<_BinaryPredicate>::type>\n                              (__first, __last, __result, __pred,\n                               typename iterator_traits<_InputIterator>::iterator_category(),\n                               typename iterator_traits<_OutputIterator>::iterator_category());\n}\n\ntemplate <class _InputIterator, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nunique_copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result)\n{\n    typedef typename iterator_traits<_InputIterator>::value_type __v;\n    return _VSTD::unique_copy(__first, __last, __result, __equal_to<__v>());\n}\n\n// reverse\n\ntemplate <class _BidirectionalIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\n__reverse(_BidirectionalIterator __first, _BidirectionalIterator __last, bidirectional_iterator_tag)\n{\n    while (__first != __last)\n    {\n        if (__first == --__last)\n            break;\n        _VSTD::iter_swap(__first, __last);\n        ++__first;\n    }\n}\n\ntemplate <class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\n__reverse(_RandomAccessIterator __first, _RandomAccessIterator __last, random_access_iterator_tag)\n{\n    if (__first != __last)\n        for (; __first < --__last; ++__first)\n            _VSTD::iter_swap(__first, __last);\n}\n\ntemplate <class _BidirectionalIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nreverse(_BidirectionalIterator __first, _BidirectionalIterator __last)\n{\n    _VSTD::__reverse(__first, __last, typename iterator_traits<_BidirectionalIterator>::iterator_category());\n}\n\n// reverse_copy\n\ntemplate <class _BidirectionalIterator, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nreverse_copy(_BidirectionalIterator __first, _BidirectionalIterator __last, _OutputIterator __result)\n{\n    for (; __first != __last; ++__result)\n        *__result = *--__last;\n    return __result;\n}\n\n// rotate\n\ntemplate <class _ForwardIterator>\n_ForwardIterator\n__rotate_left(_ForwardIterator __first, _ForwardIterator __last)\n{\n    typedef typename iterator_traits<_ForwardIterator>::value_type value_type;\n    value_type __tmp = _VSTD::move(*__first);\n    _ForwardIterator __lm1 = _VSTD::move(_VSTD::next(__first), __last, __first);\n    *__lm1 = _VSTD::move(__tmp);\n    return __lm1;\n}\n\ntemplate <class _BidirectionalIterator>\n_BidirectionalIterator\n__rotate_right(_BidirectionalIterator __first, _BidirectionalIterator __last)\n{\n    typedef typename iterator_traits<_BidirectionalIterator>::value_type value_type;\n    _BidirectionalIterator __lm1 = _VSTD::prev(__last);\n    value_type __tmp = _VSTD::move(*__lm1);\n    _BidirectionalIterator __fp1 = _VSTD::move_backward(__first, __lm1, __last);\n    *__first = _VSTD::move(__tmp);\n    return __fp1;\n}\n\ntemplate <class _ForwardIterator>\n_ForwardIterator\n__rotate_forward(_ForwardIterator __first, _ForwardIterator __middle, _ForwardIterator __last)\n{\n    _ForwardIterator __i = __middle;\n    while (true)\n    {\n        swap(*__first, *__i);\n        ++__first;\n        if (++__i == __last)\n            break;\n        if (__first == __middle)\n            __middle = __i;\n    }\n    _ForwardIterator __r = __first;\n    if (__first != __middle)\n    {\n        __i = __middle;\n        while (true)\n        {\n            swap(*__first, *__i);\n            ++__first;\n            if (++__i == __last)\n            {\n                if (__first == __middle)\n                    break;\n                __i = __middle;\n            }\n            else if (__first == __middle)\n                __middle = __i;\n        }\n    }\n    return __r;\n}\n\ntemplate<typename _Integral>\ninline _LIBCPP_INLINE_VISIBILITY\n_Integral\n__algo_gcd(_Integral __x, _Integral __y)\n{\n    do\n    {\n        _Integral __t = __x % __y;\n        __x = __y;\n        __y = __t;\n    } while (__y);\n    return __x;\n}\n\ntemplate<typename _RandomAccessIterator>\n_RandomAccessIterator\n__rotate_gcd(_RandomAccessIterator __first, _RandomAccessIterator __middle, _RandomAccessIterator __last)\n{\n    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;\n    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;\n\n    const difference_type __m1 = __middle - __first;\n    const difference_type __m2 = __last - __middle;\n    if (__m1 == __m2)\n    {\n        _VSTD::swap_ranges(__first, __middle, __middle);\n        return __middle;\n    }\n    const difference_type __g = _VSTD::__algo_gcd(__m1, __m2);\n    for (_RandomAccessIterator __p = __first + __g; __p != __first;)\n    {\n        value_type __t(_VSTD::move(*--__p));\n        _RandomAccessIterator __p1 = __p;\n        _RandomAccessIterator __p2 = __p1 + __m1;\n        do\n        {\n            *__p1 = _VSTD::move(*__p2);\n            __p1 = __p2;\n            const difference_type __d = __last - __p2;\n            if (__m1 < __d)\n                __p2 += __m1;\n            else\n                __p2 = __first + (__m1 - __d);\n        } while (__p2 != __p);\n        *__p1 = _VSTD::move(__t);\n    }\n    return __first + __m2;\n}\n\ntemplate <class _ForwardIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\n__rotate(_ForwardIterator __first, _ForwardIterator __middle, _ForwardIterator __last,\n         _VSTD::forward_iterator_tag)\n{\n    typedef typename _VSTD::iterator_traits<_ForwardIterator>::value_type value_type;\n    if (_VSTD::is_trivially_move_assignable<value_type>::value)\n    {\n        if (_VSTD::next(__first) == __middle)\n            return _VSTD::__rotate_left(__first, __last);\n    }\n    return _VSTD::__rotate_forward(__first, __middle, __last);\n}\n\ntemplate <class _BidirectionalIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_BidirectionalIterator\n__rotate(_BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last,\n         _VSTD::bidirectional_iterator_tag)\n{\n    typedef typename _VSTD::iterator_traits<_BidirectionalIterator>::value_type value_type;\n    if (_VSTD::is_trivially_move_assignable<value_type>::value)\n    {\n        if (_VSTD::next(__first) == __middle)\n            return _VSTD::__rotate_left(__first, __last);\n        if (_VSTD::next(__middle) == __last)\n            return _VSTD::__rotate_right(__first, __last);\n    }\n    return _VSTD::__rotate_forward(__first, __middle, __last);\n}\n\ntemplate <class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_RandomAccessIterator\n__rotate(_RandomAccessIterator __first, _RandomAccessIterator __middle, _RandomAccessIterator __last,\n         _VSTD::random_access_iterator_tag)\n{\n    typedef typename _VSTD::iterator_traits<_RandomAccessIterator>::value_type value_type;\n    if (_VSTD::is_trivially_move_assignable<value_type>::value)\n    {\n        if (_VSTD::next(__first) == __middle)\n            return _VSTD::__rotate_left(__first, __last);\n        if (_VSTD::next(__middle) == __last)\n            return _VSTD::__rotate_right(__first, __last);\n        return _VSTD::__rotate_gcd(__first, __middle, __last);\n    }\n    return _VSTD::__rotate_forward(__first, __middle, __last);\n}\n\ntemplate <class _ForwardIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\nrotate(_ForwardIterator __first, _ForwardIterator __middle, _ForwardIterator __last)\n{\n    if (__first == __middle)\n        return __last;\n    if (__middle == __last)\n        return __first;\n    return _VSTD::__rotate(__first, __middle, __last,\n                           typename _VSTD::iterator_traits<_ForwardIterator>::iterator_category());\n}\n\n// rotate_copy\n\ntemplate <class _ForwardIterator, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nrotate_copy(_ForwardIterator __first, _ForwardIterator __middle, _ForwardIterator __last, _OutputIterator __result)\n{\n    return _VSTD::copy(__first, __middle, _VSTD::copy(__middle, __last, __result));\n}\n\n// min_element\n\ntemplate <class _ForwardIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n_ForwardIterator\nmin_element(_ForwardIterator __first, _ForwardIterator __last, _Compare __comp)\n{\n    if (__first != __last)\n    {\n        _ForwardIterator __i = __first;\n        while (++__i != __last)\n            if (__comp(*__i, *__first))\n                __first = __i;\n    }\n    return __first;\n}\n\ntemplate <class _ForwardIterator>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n_ForwardIterator\nmin_element(_ForwardIterator __first, _ForwardIterator __last)\n{\n    return _VSTD::min_element(__first, __last,\n              __less<typename iterator_traits<_ForwardIterator>::value_type>());\n}\n\n// min\n\ntemplate <class _Tp, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nconst _Tp&\nmin(const _Tp& __a, const _Tp& __b, _Compare __comp)\n{\n    return __comp(__b, __a) ? __b : __a;\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nconst _Tp&\nmin(const _Tp& __a, const _Tp& __b)\n{\n    return _VSTD::min(__a, __b, __less<_Tp>());\n}\n\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\ntemplate<class _Tp, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n_Tp\nmin(initializer_list<_Tp> __t, _Compare __comp)\n{\n    return *_VSTD::min_element(__t.begin(), __t.end(), __comp);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n_Tp\nmin(initializer_list<_Tp> __t)\n{\n    return *_VSTD::min_element(__t.begin(), __t.end(), __less<_Tp>());\n}\n\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n// max_element\n\ntemplate <class _ForwardIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n_ForwardIterator\nmax_element(_ForwardIterator __first, _ForwardIterator __last, _Compare __comp)\n{\n    if (__first != __last)\n    {\n        _ForwardIterator __i = __first;\n        while (++__i != __last)\n            if (__comp(*__first, *__i))\n                __first = __i;\n    }\n    return __first;\n}\n\n\ntemplate <class _ForwardIterator>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n_ForwardIterator\nmax_element(_ForwardIterator __first, _ForwardIterator __last)\n{\n    return _VSTD::max_element(__first, __last,\n              __less<typename iterator_traits<_ForwardIterator>::value_type>());\n}\n\n// max\n\ntemplate <class _Tp, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nconst _Tp&\nmax(const _Tp& __a, const _Tp& __b, _Compare __comp)\n{\n    return __comp(__a, __b) ? __b : __a;\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nconst _Tp&\nmax(const _Tp& __a, const _Tp& __b)\n{\n    return _VSTD::max(__a, __b, __less<_Tp>());\n}\n\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\ntemplate<class _Tp, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n_Tp\nmax(initializer_list<_Tp> __t, _Compare __comp)\n{\n    return *_VSTD::max_element(__t.begin(), __t.end(), __comp);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n_Tp\nmax(initializer_list<_Tp> __t)\n{\n    return *_VSTD::max_element(__t.begin(), __t.end(), __less<_Tp>());\n}\n\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n#if _LIBCPP_STD_VER > 14\n// clamp\ntemplate<class _Tp, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR\nconst _Tp&\nclamp(const _Tp& __v, const _Tp& __lo, const _Tp& __hi, _Compare __comp)\n{\n    _LIBCPP_ASSERT(!__comp(__hi, __lo), \"Bad bounds passed to std::clamp\");\n    return __comp(__v, __lo) ? __lo : __comp(__hi, __v) ? __hi : __v;\n\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR\nconst _Tp&\nclamp(const _Tp& __v, const _Tp& __lo, const _Tp& __hi)\n{\n    return _VSTD::clamp(__v, __lo, __hi, __less<_Tp>());\n}\n#endif\n\n// minmax_element\n\ntemplate <class _ForwardIterator, class _Compare>\n_LIBCPP_CONSTEXPR_AFTER_CXX11\nstd::pair<_ForwardIterator, _ForwardIterator>\nminmax_element(_ForwardIterator __first, _ForwardIterator __last, _Compare __comp)\n{\n  std::pair<_ForwardIterator, _ForwardIterator> __result(__first, __first);\n  if (__first != __last)\n  {\n      if (++__first != __last)\n      {\n          if (__comp(*__first, *__result.first))\n              __result.first = __first;\n          else\n              __result.second = __first;\n          while (++__first != __last)\n          {\n              _ForwardIterator __i = __first;\n              if (++__first == __last)\n              {\n                  if (__comp(*__i, *__result.first))\n                      __result.first = __i;\n                  else if (!__comp(*__i, *__result.second))\n                      __result.second = __i;\n                  break;\n              }\n              else\n              {\n                  if (__comp(*__first, *__i))\n                  {\n                      if (__comp(*__first, *__result.first))\n                          __result.first = __first;\n                      if (!__comp(*__i, *__result.second))\n                          __result.second = __i;\n                  }\n                  else\n                  {\n                      if (__comp(*__i, *__result.first))\n                          __result.first = __i;\n                      if (!__comp(*__first, *__result.second))\n                          __result.second = __first;\n                  }\n              }\n          }\n      }\n  }\n  return __result;\n}\n\ntemplate <class _ForwardIterator>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nstd::pair<_ForwardIterator, _ForwardIterator>\nminmax_element(_ForwardIterator __first, _ForwardIterator __last)\n{\n    return _VSTD::minmax_element(__first, __last,\n              __less<typename iterator_traits<_ForwardIterator>::value_type>());\n}\n\n// minmax\n\ntemplate<class _Tp, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\npair<const _Tp&, const _Tp&>\nminmax(const _Tp& __a, const _Tp& __b, _Compare __comp)\n{\n    return __comp(__b, __a) ? pair<const _Tp&, const _Tp&>(__b, __a) :\n                              pair<const _Tp&, const _Tp&>(__a, __b);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\npair<const _Tp&, const _Tp&>\nminmax(const _Tp& __a, const _Tp& __b)\n{\n    return _VSTD::minmax(__a, __b, __less<_Tp>());\n}\n\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\ntemplate<class _Tp, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\npair<_Tp, _Tp>\nminmax(initializer_list<_Tp> __t, _Compare __comp)\n{\n    typedef typename initializer_list<_Tp>::const_iterator _Iter;\n    _Iter __first = __t.begin();\n    _Iter __last  = __t.end();\n    std::pair<_Tp, _Tp> __result(*__first, *__first);\n\n    ++__first;\n    if (__t.size() % 2 == 0)\n    {\n        if (__comp(*__first,  __result.first))\n            __result.first  = *__first;\n        else\n            __result.second = *__first;\n        ++__first;\n    }\n\n    while (__first != __last)\n    {\n        _Tp __prev = *__first++;\n        if (__comp(*__first, __prev)) {\n            if ( __comp(*__first, __result.first)) __result.first  = *__first;\n            if (!__comp(__prev, __result.second))  __result.second = __prev;\n            }\n        else {\n            if ( __comp(__prev, __result.first))    __result.first  = __prev;\n            if (!__comp(*__first, __result.second)) __result.second = *__first;\n            }\n\n        __first++;\n    }\n    return __result;\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\npair<_Tp, _Tp>\nminmax(initializer_list<_Tp> __t)\n{\n    return _VSTD::minmax(__t, __less<_Tp>());\n}\n\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n// random_shuffle\n\n// __independent_bits_engine\n\ntemplate <unsigned long long _Xp, size_t _Rp>\nstruct __log2_imp\n{\n    static const size_t value = _Xp & ((unsigned long long)(1) << _Rp) ? _Rp\n                                           : __log2_imp<_Xp, _Rp - 1>::value;\n};\n\ntemplate <unsigned long long _Xp>\nstruct __log2_imp<_Xp, 0>\n{\n    static const size_t value = 0;\n};\n\ntemplate <size_t _Rp>\nstruct __log2_imp<0, _Rp>\n{\n    static const size_t value = _Rp + 1;\n};\n\ntemplate <class _UI, _UI _Xp>\nstruct __log2\n{\n    static const size_t value = __log2_imp<_Xp,\n                                         sizeof(_UI) * __CHAR_BIT__ - 1>::value;\n};\n\ntemplate<class _Engine, class _UIntType>\nclass __independent_bits_engine\n{\npublic:\n    // types\n    typedef _UIntType result_type;\n\nprivate:\n    typedef typename _Engine::result_type _Engine_result_type;\n    typedef typename conditional\n        <\n            sizeof(_Engine_result_type) <= sizeof(result_type),\n                result_type,\n                _Engine_result_type\n        >::type _Working_result_type;\n\n    _Engine& __e_;\n    size_t __w_;\n    size_t __w0_;\n    size_t __n_;\n    size_t __n0_;\n    _Working_result_type __y0_;\n    _Working_result_type __y1_;\n    _Engine_result_type __mask0_;\n    _Engine_result_type __mask1_;\n\n#ifdef _LIBCPP_HAS_NO_CONSTEXPR\n    static const _Working_result_type _Rp = _Engine::_Max - _Engine::_Min\n                                          + _Working_result_type(1);\n#else\n    static _LIBCPP_CONSTEXPR const _Working_result_type _Rp = _Engine::max() - _Engine::min()\n                                                      + _Working_result_type(1);\n#endif\n    static _LIBCPP_CONSTEXPR const size_t __m = __log2<_Working_result_type, _Rp>::value;\n    static _LIBCPP_CONSTEXPR const size_t _WDt = numeric_limits<_Working_result_type>::digits;\n    static _LIBCPP_CONSTEXPR const size_t _EDt = numeric_limits<_Engine_result_type>::digits;\n\npublic:\n    // constructors and seeding functions\n    __independent_bits_engine(_Engine& __e, size_t __w);\n\n    // generating functions\n    result_type operator()() {return __eval(integral_constant<bool, _Rp != 0>());}\n\nprivate:\n    result_type __eval(false_type);\n    result_type __eval(true_type);\n};\n\ntemplate<class _Engine, class _UIntType>\n__independent_bits_engine<_Engine, _UIntType>\n    ::__independent_bits_engine(_Engine& __e, size_t __w)\n        : __e_(__e),\n          __w_(__w)\n{\n    __n_ = __w_ / __m + (__w_ % __m != 0);\n    __w0_ = __w_ / __n_;\n    if (_Rp == 0)\n        __y0_ = _Rp;\n    else if (__w0_ < _WDt)\n        __y0_ = (_Rp >> __w0_) << __w0_;\n    else\n        __y0_ = 0;\n    if (_Rp - __y0_ > __y0_ / __n_)\n    {\n        ++__n_;\n        __w0_ = __w_ / __n_;\n        if (__w0_ < _WDt)\n            __y0_ = (_Rp >> __w0_) << __w0_;\n        else\n            __y0_ = 0;\n    }\n    __n0_ = __n_ - __w_ % __n_;\n    if (__w0_ < _WDt - 1)\n        __y1_ = (_Rp >> (__w0_ + 1)) << (__w0_ + 1);\n    else\n        __y1_ = 0;\n    __mask0_ = __w0_ > 0 ? _Engine_result_type(~0) >> (_EDt - __w0_) :\n                          _Engine_result_type(0);\n    __mask1_ = __w0_ < _EDt - 1 ?\n                               _Engine_result_type(~0) >> (_EDt - (__w0_ + 1)) :\n                               _Engine_result_type(~0);\n}\n\ntemplate<class _Engine, class _UIntType>\ninline\n_UIntType\n__independent_bits_engine<_Engine, _UIntType>::__eval(false_type)\n{\n    return static_cast<result_type>(__e_() & __mask0_);\n}\n\ntemplate<class _Engine, class _UIntType>\n_UIntType\n__independent_bits_engine<_Engine, _UIntType>::__eval(true_type)\n{\n    result_type _Sp = 0;\n    for (size_t __k = 0; __k < __n0_; ++__k)\n    {\n        _Engine_result_type __u;\n        do\n        {\n            __u = __e_() - _Engine::min();\n        } while (__u >= __y0_);\n        if (__w0_ < _WDt)\n            _Sp <<= __w0_;\n        else\n            _Sp = 0;\n        _Sp += __u & __mask0_;\n    }\n    for (size_t __k = __n0_; __k < __n_; ++__k)\n    {\n        _Engine_result_type __u;\n        do\n        {\n            __u = __e_() - _Engine::min();\n        } while (__u >= __y1_);\n        if (__w0_ < _WDt - 1)\n            _Sp <<= __w0_ + 1;\n        else\n            _Sp = 0;\n        _Sp += __u & __mask1_;\n    }\n    return _Sp;\n}\n\n// uniform_int_distribution\n\ntemplate<class _IntType = int>\nclass uniform_int_distribution\n{\npublic:\n    // types\n    typedef _IntType result_type;\n\n    class param_type\n    {\n        result_type __a_;\n        result_type __b_;\n    public:\n        typedef uniform_int_distribution distribution_type;\n\n        explicit param_type(result_type __a = 0,\n                            result_type __b = numeric_limits<result_type>::max())\n            : __a_(__a), __b_(__b) {}\n\n        result_type a() const {return __a_;}\n        result_type b() const {return __b_;}\n\n        friend bool operator==(const param_type& __x, const param_type& __y)\n            {return __x.__a_ == __y.__a_ && __x.__b_ == __y.__b_;}\n        friend bool operator!=(const param_type& __x, const param_type& __y)\n            {return !(__x == __y);}\n    };\n\nprivate:\n    param_type __p_;\n\npublic:\n    // constructors and reset functions\n    explicit uniform_int_distribution(result_type __a = 0,\n                                      result_type __b = numeric_limits<result_type>::max())\n        : __p_(param_type(__a, __b)) {}\n    explicit uniform_int_distribution(const param_type& __p) : __p_(__p) {}\n    void reset() {}\n\n    // generating functions\n    template<class _URNG> result_type operator()(_URNG& __g)\n        {return (*this)(__g, __p_);}\n    template<class _URNG> result_type operator()(_URNG& __g, const param_type& __p);\n\n    // property functions\n    result_type a() const {return __p_.a();}\n    result_type b() const {return __p_.b();}\n\n    param_type param() const {return __p_;}\n    void param(const param_type& __p) {__p_ = __p;}\n\n    result_type min() const {return a();}\n    result_type max() const {return b();}\n\n    friend bool operator==(const uniform_int_distribution& __x,\n                           const uniform_int_distribution& __y)\n        {return __x.__p_ == __y.__p_;}\n    friend bool operator!=(const uniform_int_distribution& __x,\n                           const uniform_int_distribution& __y)\n            {return !(__x == __y);}\n};\n\ntemplate<class _IntType>\ntemplate<class _URNG>\ntypename uniform_int_distribution<_IntType>::result_type\nuniform_int_distribution<_IntType>::operator()(_URNG& __g, const param_type& __p)\n{\n    typedef typename conditional<sizeof(result_type) <= sizeof(uint32_t),\n                                            uint32_t, uint64_t>::type _UIntType;\n    const _UIntType _Rp = __p.b() - __p.a() + _UIntType(1);\n    if (_Rp == 1)\n        return __p.a();\n    const size_t _Dt = numeric_limits<_UIntType>::digits;\n    typedef __independent_bits_engine<_URNG, _UIntType> _Eng;\n    if (_Rp == 0)\n        return static_cast<result_type>(_Eng(__g, _Dt)());\n    size_t __w = _Dt - __clz(_Rp) - 1;\n    if ((_Rp & (std::numeric_limits<_UIntType>::max() >> (_Dt - __w))) != 0)\n        ++__w;\n    _Eng __e(__g, __w);\n    _UIntType __u;\n    do\n    {\n        __u = __e();\n    } while (__u >= _Rp);\n    return static_cast<result_type>(__u + __p.a());\n}\n\nclass _LIBCPP_TYPE_VIS __rs_default;\n\n_LIBCPP_FUNC_VIS __rs_default __rs_get();\n\nclass _LIBCPP_TYPE_VIS __rs_default\n{\n    static unsigned __c_;\n\n    __rs_default();\npublic:\n    typedef uint_fast32_t result_type;\n\n    static const result_type _Min = 0;\n    static const result_type _Max = 0xFFFFFFFF;\n\n    __rs_default(const __rs_default&);\n    ~__rs_default();\n\n    result_type operator()();\n\n    static _LIBCPP_CONSTEXPR result_type min() {return _Min;}\n    static _LIBCPP_CONSTEXPR result_type max() {return _Max;}\n\n    friend _LIBCPP_FUNC_VIS __rs_default __rs_get();\n};\n\n_LIBCPP_FUNC_VIS __rs_default __rs_get();\n\ntemplate <class _RandomAccessIterator>\nvoid\nrandom_shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last)\n{\n    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;\n    typedef uniform_int_distribution<ptrdiff_t> _Dp;\n    typedef typename _Dp::param_type _Pp;\n    difference_type __d = __last - __first;\n    if (__d > 1)\n    {\n        _Dp __uid;\n        __rs_default __g = __rs_get();\n        for (--__last, --__d; __first < __last; ++__first, --__d)\n        {\n            difference_type __i = __uid(__g, _Pp(0, __d));\n            if (__i != difference_type(0))\n                swap(*__first, *(__first + __i));\n        }\n    }\n}\n\ntemplate <class _RandomAccessIterator, class _RandomNumberGenerator>\nvoid\nrandom_shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last,\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n               _RandomNumberGenerator&& __rand)\n#else\n               _RandomNumberGenerator& __rand)\n#endif\n{\n    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;\n    difference_type __d = __last - __first;\n    if (__d > 1)\n    {\n        for (--__last; __first < __last; ++__first, --__d)\n        {\n            difference_type __i = __rand(__d);\n            swap(*__first, *(__first + __i));\n        }\n    }\n}\n\ntemplate <class _PopulationIterator, class _SampleIterator, class _Distance,\n          class _UniformRandomNumberGenerator>\n_LIBCPP_INLINE_VISIBILITY\n_SampleIterator __sample(_PopulationIterator __first,\n                         _PopulationIterator __last, _SampleIterator __output,\n                         _Distance __n,\n                         _UniformRandomNumberGenerator & __g,\n                         input_iterator_tag) {\n\n  _Distance __k = 0;\n  for (; __first != __last && __k < __n; ++__first, (void)++__k)\n    __output[__k] = *__first;\n  _Distance __sz = __k;\n  for (; __first != __last; ++__first, (void)++__k) {\n    _Distance __r = _VSTD::uniform_int_distribution<_Distance>(0, __k)(__g);\n    if (__r < __sz)\n      __output[__r] = *__first;\n  }\n  return __output + _VSTD::min(__n, __k);\n}\n\ntemplate <class _PopulationIterator, class _SampleIterator, class _Distance,\n          class _UniformRandomNumberGenerator>\n_LIBCPP_INLINE_VISIBILITY\n_SampleIterator __sample(_PopulationIterator __first,\n                         _PopulationIterator __last, _SampleIterator __output,\n                         _Distance __n,\n                         _UniformRandomNumberGenerator& __g,\n                         forward_iterator_tag) {\n  _Distance __unsampled_sz = _VSTD::distance(__first, __last);\n  for (__n = _VSTD::min(__n, __unsampled_sz); __n != 0; ++__first) {\n    _Distance __r =\n        _VSTD::uniform_int_distribution<_Distance>(0, --__unsampled_sz)(__g);\n    if (__r < __n) {\n      *__output++ = *__first;\n      --__n;\n    }\n  }\n  return __output;\n}\n\ntemplate <class _PopulationIterator, class _SampleIterator, class _Distance,\n          class _UniformRandomNumberGenerator>\n_LIBCPP_INLINE_VISIBILITY\n_SampleIterator __sample(_PopulationIterator __first,\n                         _PopulationIterator __last, _SampleIterator __output,\n                         _Distance __n, _UniformRandomNumberGenerator& __g) {\n  typedef typename iterator_traits<_PopulationIterator>::iterator_category\n        _PopCategory;\n  typedef typename iterator_traits<_PopulationIterator>::difference_type\n        _Difference;\n  static_assert(__is_forward_iterator<_PopulationIterator>::value ||\n                __is_random_access_iterator<_SampleIterator>::value,\n                \"SampleIterator must meet the requirements of RandomAccessIterator\");\n  typedef typename common_type<_Distance, _Difference>::type _CommonType;\n  _LIBCPP_ASSERT(__n >= 0, \"N must be a positive number.\");\n  return _VSTD::__sample(\n      __first, __last, __output, _CommonType(__n),\n      __g, _PopCategory());\n}\n\n#if _LIBCPP_STD_VER > 14\ntemplate <class _PopulationIterator, class _SampleIterator, class _Distance,\n          class _UniformRandomNumberGenerator>\ninline _LIBCPP_INLINE_VISIBILITY\n_SampleIterator sample(_PopulationIterator __first,\n                       _PopulationIterator __last, _SampleIterator __output,\n                       _Distance __n, _UniformRandomNumberGenerator&& __g) {\n    return _VSTD::__sample(__first, __last, __output, __n, __g);\n}\n#endif // _LIBCPP_STD_VER > 14\n\ntemplate<class _RandomAccessIterator, class _UniformRandomNumberGenerator>\n    void shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last,\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n                 _UniformRandomNumberGenerator&& __g)\n#else\n                 _UniformRandomNumberGenerator& __g)\n#endif\n{\n    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;\n    typedef uniform_int_distribution<ptrdiff_t> _Dp;\n    typedef typename _Dp::param_type _Pp;\n    difference_type __d = __last - __first;\n    if (__d > 1)\n    {\n        _Dp __uid;\n        for (--__last, --__d; __first < __last; ++__first, --__d)\n        {\n            difference_type __i = __uid(__g, _Pp(0, __d));\n            if (__i != difference_type(0))\n                swap(*__first, *(__first + __i));\n        }\n    }\n}\n\ntemplate <class _InputIterator, class _Predicate>\nbool\nis_partitioned(_InputIterator __first, _InputIterator __last, _Predicate __pred)\n{\n    for (; __first != __last; ++__first)\n        if (!__pred(*__first))\n            break;\n    if ( __first == __last )\n        return true;\n    ++__first;\n    for (; __first != __last; ++__first)\n        if (__pred(*__first))\n            return false;\n    return true;\n}\n\n// partition\n\ntemplate <class _Predicate, class _ForwardIterator>\n_ForwardIterator\n__partition(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred, forward_iterator_tag)\n{\n    while (true)\n    {\n        if (__first == __last)\n            return __first;\n        if (!__pred(*__first))\n            break;\n        ++__first;\n    }\n    for (_ForwardIterator __p = __first; ++__p != __last;)\n    {\n        if (__pred(*__p))\n        {\n            swap(*__first, *__p);\n            ++__first;\n        }\n    }\n    return __first;\n}\n\ntemplate <class _Predicate, class _BidirectionalIterator>\n_BidirectionalIterator\n__partition(_BidirectionalIterator __first, _BidirectionalIterator __last, _Predicate __pred,\n            bidirectional_iterator_tag)\n{\n    while (true)\n    {\n        while (true)\n        {\n            if (__first == __last)\n                return __first;\n            if (!__pred(*__first))\n                break;\n            ++__first;\n        }\n        do\n        {\n            if (__first == --__last)\n                return __first;\n        } while (!__pred(*__last));\n        swap(*__first, *__last);\n        ++__first;\n    }\n}\n\ntemplate <class _ForwardIterator, class _Predicate>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\npartition(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred)\n{\n    return _VSTD::__partition<typename add_lvalue_reference<_Predicate>::type>\n                            (__first, __last, __pred, typename iterator_traits<_ForwardIterator>::iterator_category());\n}\n\n// partition_copy\n\ntemplate <class _InputIterator, class _OutputIterator1,\n          class _OutputIterator2, class _Predicate>\npair<_OutputIterator1, _OutputIterator2>\npartition_copy(_InputIterator __first, _InputIterator __last,\n               _OutputIterator1 __out_true, _OutputIterator2 __out_false,\n               _Predicate __pred)\n{\n    for (; __first != __last; ++__first)\n    {\n        if (__pred(*__first))\n        {\n            *__out_true = *__first;\n            ++__out_true;\n        }\n        else\n        {\n            *__out_false = *__first;\n            ++__out_false;\n        }\n    }\n    return pair<_OutputIterator1, _OutputIterator2>(__out_true, __out_false);\n}\n\n// partition_point\n\ntemplate<class _ForwardIterator, class _Predicate>\n_ForwardIterator\npartition_point(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred)\n{\n    typedef typename iterator_traits<_ForwardIterator>::difference_type difference_type;\n    difference_type __len = _VSTD::distance(__first, __last);\n    while (__len != 0)\n    {\n        difference_type __l2 = __len / 2;\n        _ForwardIterator __m = __first;\n        _VSTD::advance(__m, __l2);\n        if (__pred(*__m))\n        {\n            __first = ++__m;\n            __len -= __l2 + 1;\n        }\n        else\n            __len = __l2;\n    }\n    return __first;\n}\n\n// stable_partition\n\ntemplate <class _Predicate, class _ForwardIterator, class _Distance, class _Pair>\n_ForwardIterator\n__stable_partition(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred,\n                   _Distance __len, _Pair __p, forward_iterator_tag __fit)\n{\n    // *__first is known to be false\n    // __len >= 1\n    if (__len == 1)\n        return __first;\n    if (__len == 2)\n    {\n        _ForwardIterator __m = __first;\n        if (__pred(*++__m))\n        {\n            swap(*__first, *__m);\n            return __m;\n        }\n        return __first;\n    }\n    if (__len <= __p.second)\n    {   // The buffer is big enough to use\n        typedef typename iterator_traits<_ForwardIterator>::value_type value_type;\n        __destruct_n __d(0);\n        unique_ptr<value_type, __destruct_n&> __h(__p.first, __d);\n        // Move the falses into the temporary buffer, and the trues to the front of the line\n        // Update __first to always point to the end of the trues\n        value_type* __t = __p.first;\n        ::new(__t) value_type(_VSTD::move(*__first));\n        __d.__incr((value_type*)0);\n        ++__t;\n        _ForwardIterator __i = __first;\n        while (++__i != __last)\n        {\n            if (__pred(*__i))\n            {\n                *__first = _VSTD::move(*__i);\n                ++__first;\n            }\n            else\n            {\n                ::new(__t) value_type(_VSTD::move(*__i));\n                __d.__incr((value_type*)0);\n                ++__t;\n            }\n        }\n        // All trues now at start of range, all falses in buffer\n        // Move falses back into range, but don't mess up __first which points to first false\n        __i = __first;\n        for (value_type* __t2 = __p.first; __t2 < __t; ++__t2, ++__i)\n            *__i = _VSTD::move(*__t2);\n        // __h destructs moved-from values out of the temp buffer, but doesn't deallocate buffer\n        return __first;\n    }\n    // Else not enough buffer, do in place\n    // __len >= 3\n    _ForwardIterator __m = __first;\n    _Distance __len2 = __len / 2;  // __len2 >= 2\n    _VSTD::advance(__m, __len2);\n    // recurse on [__first, __m), *__first know to be false\n    // F?????????????????\n    // f       m         l\n    typedef typename add_lvalue_reference<_Predicate>::type _PredRef;\n    _ForwardIterator __first_false = __stable_partition<_PredRef>(__first, __m, __pred, __len2, __p, __fit);\n    // TTTFFFFF??????????\n    // f  ff   m         l\n    // recurse on [__m, __last], except increase __m until *(__m) is false, *__last know to be true\n    _ForwardIterator __m1 = __m;\n    _ForwardIterator __second_false = __last;\n    _Distance __len_half = __len - __len2;\n    while (__pred(*__m1))\n    {\n        if (++__m1 == __last)\n            goto __second_half_done;\n        --__len_half;\n    }\n    // TTTFFFFFTTTF??????\n    // f  ff   m  m1     l\n    __second_false = __stable_partition<_PredRef>(__m1, __last, __pred, __len_half, __p, __fit);\n__second_half_done:\n    // TTTFFFFFTTTTTFFFFF\n    // f  ff   m    sf   l\n    return _VSTD::rotate(__first_false, __m, __second_false);\n    // TTTTTTTTFFFFFFFFFF\n    //         |\n}\n\nstruct __return_temporary_buffer\n{\n    template <class _Tp>\n    _LIBCPP_INLINE_VISIBILITY void operator()(_Tp* __p) const {_VSTD::return_temporary_buffer(__p);}\n};\n\ntemplate <class _Predicate, class _ForwardIterator>\n_ForwardIterator\n__stable_partition(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred,\n                   forward_iterator_tag)\n{\n    const unsigned __alloc_limit = 3;  // might want to make this a function of trivial assignment\n    // Either prove all true and return __first or point to first false\n    while (true)\n    {\n        if (__first == __last)\n            return __first;\n        if (!__pred(*__first))\n            break;\n        ++__first;\n    }\n    // We now have a reduced range [__first, __last)\n    // *__first is known to be false\n    typedef typename iterator_traits<_ForwardIterator>::difference_type difference_type;\n    typedef typename iterator_traits<_ForwardIterator>::value_type value_type;\n    difference_type __len = _VSTD::distance(__first, __last);\n    pair<value_type*, ptrdiff_t> __p(0, 0);\n    unique_ptr<value_type, __return_temporary_buffer> __h;\n    if (__len >= __alloc_limit)\n    {\n        __p = _VSTD::get_temporary_buffer<value_type>(__len);\n        __h.reset(__p.first);\n    }\n    return __stable_partition<typename add_lvalue_reference<_Predicate>::type>\n                             (__first, __last, __pred, __len, __p, forward_iterator_tag());\n}\n\ntemplate <class _Predicate, class _BidirectionalIterator, class _Distance, class _Pair>\n_BidirectionalIterator\n__stable_partition(_BidirectionalIterator __first, _BidirectionalIterator __last, _Predicate __pred,\n                   _Distance __len, _Pair __p, bidirectional_iterator_tag __bit)\n{\n    // *__first is known to be false\n    // *__last is known to be true\n    // __len >= 2\n    if (__len == 2)\n    {\n        swap(*__first, *__last);\n        return __last;\n    }\n    if (__len == 3)\n    {\n        _BidirectionalIterator __m = __first;\n        if (__pred(*++__m))\n        {\n            swap(*__first, *__m);\n            swap(*__m, *__last);\n            return __last;\n        }\n        swap(*__m, *__last);\n        swap(*__first, *__m);\n        return __m;\n    }\n    if (__len <= __p.second)\n    {   // The buffer is big enough to use\n        typedef typename iterator_traits<_BidirectionalIterator>::value_type value_type;\n        __destruct_n __d(0);\n        unique_ptr<value_type, __destruct_n&> __h(__p.first, __d);\n        // Move the falses into the temporary buffer, and the trues to the front of the line\n        // Update __first to always point to the end of the trues\n        value_type* __t = __p.first;\n        ::new(__t) value_type(_VSTD::move(*__first));\n        __d.__incr((value_type*)0);\n        ++__t;\n        _BidirectionalIterator __i = __first;\n        while (++__i != __last)\n        {\n            if (__pred(*__i))\n            {\n                *__first = _VSTD::move(*__i);\n                ++__first;\n            }\n            else\n            {\n                ::new(__t) value_type(_VSTD::move(*__i));\n                __d.__incr((value_type*)0);\n                ++__t;\n            }\n        }\n        // move *__last, known to be true\n        *__first = _VSTD::move(*__i);\n        __i = ++__first;\n        // All trues now at start of range, all falses in buffer\n        // Move falses back into range, but don't mess up __first which points to first false\n        for (value_type* __t2 = __p.first; __t2 < __t; ++__t2, ++__i)\n            *__i = _VSTD::move(*__t2);\n        // __h destructs moved-from values out of the temp buffer, but doesn't deallocate buffer\n        return __first;\n    }\n    // Else not enough buffer, do in place\n    // __len >= 4\n    _BidirectionalIterator __m = __first;\n    _Distance __len2 = __len / 2;  // __len2 >= 2\n    _VSTD::advance(__m, __len2);\n    // recurse on [__first, __m-1], except reduce __m-1 until *(__m-1) is true, *__first know to be false\n    // F????????????????T\n    // f       m        l\n    _BidirectionalIterator __m1 = __m;\n    _BidirectionalIterator __first_false = __first;\n    _Distance __len_half = __len2;\n    while (!__pred(*--__m1))\n    {\n        if (__m1 == __first)\n            goto __first_half_done;\n        --__len_half;\n    }\n    // F???TFFF?????????T\n    // f   m1  m        l\n    typedef typename add_lvalue_reference<_Predicate>::type _PredRef;\n    __first_false = __stable_partition<_PredRef>(__first, __m1, __pred, __len_half, __p, __bit);\n__first_half_done:\n    // TTTFFFFF?????????T\n    // f  ff   m        l\n    // recurse on [__m, __last], except increase __m until *(__m) is false, *__last know to be true\n    __m1 = __m;\n    _BidirectionalIterator __second_false = __last;\n    ++__second_false;\n    __len_half = __len - __len2;\n    while (__pred(*__m1))\n    {\n        if (++__m1 == __last)\n            goto __second_half_done;\n        --__len_half;\n    }\n    // TTTFFFFFTTTF?????T\n    // f  ff   m  m1    l\n    __second_false = __stable_partition<_PredRef>(__m1, __last, __pred, __len_half, __p, __bit);\n__second_half_done:\n    // TTTFFFFFTTTTTFFFFF\n    // f  ff   m    sf  l\n    return _VSTD::rotate(__first_false, __m, __second_false);\n    // TTTTTTTTFFFFFFFFFF\n    //         |\n}\n\ntemplate <class _Predicate, class _BidirectionalIterator>\n_BidirectionalIterator\n__stable_partition(_BidirectionalIterator __first, _BidirectionalIterator __last, _Predicate __pred,\n                   bidirectional_iterator_tag)\n{\n    typedef typename iterator_traits<_BidirectionalIterator>::difference_type difference_type;\n    typedef typename iterator_traits<_BidirectionalIterator>::value_type value_type;\n    const difference_type __alloc_limit = 4;  // might want to make this a function of trivial assignment\n    // Either prove all true and return __first or point to first false\n    while (true)\n    {\n        if (__first == __last)\n            return __first;\n        if (!__pred(*__first))\n            break;\n        ++__first;\n    }\n    // __first points to first false, everything prior to __first is already set.\n    // Either prove [__first, __last) is all false and return __first, or point __last to last true\n    do\n    {\n        if (__first == --__last)\n            return __first;\n    } while (!__pred(*__last));\n    // We now have a reduced range [__first, __last]\n    // *__first is known to be false\n    // *__last is known to be true\n    // __len >= 2\n    difference_type __len = _VSTD::distance(__first, __last) + 1;\n    pair<value_type*, ptrdiff_t> __p(0, 0);\n    unique_ptr<value_type, __return_temporary_buffer> __h;\n    if (__len >= __alloc_limit)\n    {\n        __p = _VSTD::get_temporary_buffer<value_type>(__len);\n        __h.reset(__p.first);\n    }\n    return __stable_partition<typename add_lvalue_reference<_Predicate>::type>\n                             (__first, __last, __pred, __len, __p, bidirectional_iterator_tag());\n}\n\ntemplate <class _ForwardIterator, class _Predicate>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\nstable_partition(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred)\n{\n    return __stable_partition<typename add_lvalue_reference<_Predicate>::type>\n                             (__first, __last, __pred, typename iterator_traits<_ForwardIterator>::iterator_category());\n}\n\n// is_sorted_until\n\ntemplate <class _ForwardIterator, class _Compare>\n_ForwardIterator\nis_sorted_until(_ForwardIterator __first, _ForwardIterator __last, _Compare __comp)\n{\n    if (__first != __last)\n    {\n        _ForwardIterator __i = __first;\n        while (++__i != __last)\n        {\n            if (__comp(*__i, *__first))\n                return __i;\n            __first = __i;\n        }\n    }\n    return __last;\n}\n\ntemplate<class _ForwardIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\nis_sorted_until(_ForwardIterator __first, _ForwardIterator __last)\n{\n    return _VSTD::is_sorted_until(__first, __last, __less<typename iterator_traits<_ForwardIterator>::value_type>());\n}\n\n// is_sorted\n\ntemplate <class _ForwardIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nis_sorted(_ForwardIterator __first, _ForwardIterator __last, _Compare __comp)\n{\n    return _VSTD::is_sorted_until(__first, __last, __comp) == __last;\n}\n\ntemplate<class _ForwardIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nis_sorted(_ForwardIterator __first, _ForwardIterator __last)\n{\n    return _VSTD::is_sorted(__first, __last, __less<typename iterator_traits<_ForwardIterator>::value_type>());\n}\n\n// sort\n\n// stable, 2-3 compares, 0-2 swaps\n\ntemplate <class _Compare, class _ForwardIterator>\nunsigned\n__sort3(_ForwardIterator __x, _ForwardIterator __y, _ForwardIterator __z, _Compare __c)\n{\n    unsigned __r = 0;\n    if (!__c(*__y, *__x))          // if x <= y\n    {\n        if (!__c(*__z, *__y))      // if y <= z\n            return __r;            // x <= y && y <= z\n                                   // x <= y && y > z\n        swap(*__y, *__z);          // x <= z && y < z\n        __r = 1;\n        if (__c(*__y, *__x))       // if x > y\n        {\n            swap(*__x, *__y);      // x < y && y <= z\n            __r = 2;\n        }\n        return __r;                // x <= y && y < z\n    }\n    if (__c(*__z, *__y))           // x > y, if y > z\n    {\n        swap(*__x, *__z);          // x < y && y < z\n        __r = 1;\n        return __r;\n    }\n    swap(*__x, *__y);              // x > y && y <= z\n    __r = 1;                       // x < y && x <= z\n    if (__c(*__z, *__y))           // if y > z\n    {\n        swap(*__y, *__z);          // x <= y && y < z\n        __r = 2;\n    }\n    return __r;\n}                                  // x <= y && y <= z\n\n// stable, 3-6 compares, 0-5 swaps\n\ntemplate <class _Compare, class _ForwardIterator>\nunsigned\n__sort4(_ForwardIterator __x1, _ForwardIterator __x2, _ForwardIterator __x3,\n            _ForwardIterator __x4, _Compare __c)\n{\n    unsigned __r = __sort3<_Compare>(__x1, __x2, __x3, __c);\n    if (__c(*__x4, *__x3))\n    {\n        swap(*__x3, *__x4);\n        ++__r;\n        if (__c(*__x3, *__x2))\n        {\n            swap(*__x2, *__x3);\n            ++__r;\n            if (__c(*__x2, *__x1))\n            {\n                swap(*__x1, *__x2);\n                ++__r;\n            }\n        }\n    }\n    return __r;\n}\n\n// stable, 4-10 compares, 0-9 swaps\n\ntemplate <class _Compare, class _ForwardIterator>\nunsigned\n__sort5(_ForwardIterator __x1, _ForwardIterator __x2, _ForwardIterator __x3,\n            _ForwardIterator __x4, _ForwardIterator __x5, _Compare __c)\n{\n    unsigned __r = __sort4<_Compare>(__x1, __x2, __x3, __x4, __c);\n    if (__c(*__x5, *__x4))\n    {\n        swap(*__x4, *__x5);\n        ++__r;\n        if (__c(*__x4, *__x3))\n        {\n            swap(*__x3, *__x4);\n            ++__r;\n            if (__c(*__x3, *__x2))\n            {\n                swap(*__x2, *__x3);\n                ++__r;\n                if (__c(*__x2, *__x1))\n                {\n                    swap(*__x1, *__x2);\n                    ++__r;\n                }\n            }\n        }\n    }\n    return __r;\n}\n\n// Assumes size > 0\ntemplate <class _Compare, class _BirdirectionalIterator>\nvoid\n__selection_sort(_BirdirectionalIterator __first, _BirdirectionalIterator __last, _Compare __comp)\n{\n    _BirdirectionalIterator __lm1 = __last;\n    for (--__lm1; __first != __lm1; ++__first)\n    {\n        _BirdirectionalIterator __i = _VSTD::min_element<_BirdirectionalIterator,\n                                                        typename add_lvalue_reference<_Compare>::type>\n                                                       (__first, __last, __comp);\n        if (__i != __first)\n            swap(*__first, *__i);\n    }\n}\n\ntemplate <class _Compare, class _BirdirectionalIterator>\nvoid\n__insertion_sort(_BirdirectionalIterator __first, _BirdirectionalIterator __last, _Compare __comp)\n{\n    typedef typename iterator_traits<_BirdirectionalIterator>::value_type value_type;\n    if (__first != __last)\n    {\n        _BirdirectionalIterator __i = __first;\n        for (++__i; __i != __last; ++__i)\n        {\n            _BirdirectionalIterator __j = __i;\n            value_type __t(_VSTD::move(*__j));\n            for (_BirdirectionalIterator __k = __i; __k != __first && __comp(__t,  *--__k); --__j)\n                *__j = _VSTD::move(*__k);\n            *__j = _VSTD::move(__t);\n        }\n    }\n}\n\ntemplate <class _Compare, class _RandomAccessIterator>\nvoid\n__insertion_sort_3(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\n{\n    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;\n    _RandomAccessIterator __j = __first+2;\n    __sort3<_Compare>(__first, __first+1, __j, __comp);\n    for (_RandomAccessIterator __i = __j+1; __i != __last; ++__i)\n    {\n        if (__comp(*__i, *__j))\n        {\n            value_type __t(_VSTD::move(*__i));\n            _RandomAccessIterator __k = __j;\n            __j = __i;\n            do\n            {\n                *__j = _VSTD::move(*__k);\n                __j = __k;\n            } while (__j != __first && __comp(__t, *--__k));\n            *__j = _VSTD::move(__t);\n        }\n        __j = __i;\n    }\n}\n\ntemplate <class _Compare, class _RandomAccessIterator>\nbool\n__insertion_sort_incomplete(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\n{\n    switch (__last - __first)\n    {\n    case 0:\n    case 1:\n        return true;\n    case 2:\n        if (__comp(*--__last, *__first))\n            swap(*__first, *__last);\n        return true;\n    case 3:\n        _VSTD::__sort3<_Compare>(__first, __first+1, --__last, __comp);\n        return true;\n    case 4:\n        _VSTD::__sort4<_Compare>(__first, __first+1, __first+2, --__last, __comp);\n        return true;\n    case 5:\n        _VSTD::__sort5<_Compare>(__first, __first+1, __first+2, __first+3, --__last, __comp);\n        return true;\n    }\n    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;\n    _RandomAccessIterator __j = __first+2;\n    __sort3<_Compare>(__first, __first+1, __j, __comp);\n    const unsigned __limit = 8;\n    unsigned __count = 0;\n    for (_RandomAccessIterator __i = __j+1; __i != __last; ++__i)\n    {\n        if (__comp(*__i, *__j))\n        {\n            value_type __t(_VSTD::move(*__i));\n            _RandomAccessIterator __k = __j;\n            __j = __i;\n            do\n            {\n                *__j = _VSTD::move(*__k);\n                __j = __k;\n            } while (__j != __first && __comp(__t, *--__k));\n            *__j = _VSTD::move(__t);\n            if (++__count == __limit)\n                return ++__i == __last;\n        }\n        __j = __i;\n    }\n    return true;\n}\n\ntemplate <class _Compare, class _BirdirectionalIterator>\nvoid\n__insertion_sort_move(_BirdirectionalIterator __first1, _BirdirectionalIterator __last1,\n                      typename iterator_traits<_BirdirectionalIterator>::value_type* __first2, _Compare __comp)\n{\n    typedef typename iterator_traits<_BirdirectionalIterator>::value_type value_type;\n    if (__first1 != __last1)\n    {\n        __destruct_n __d(0);\n        unique_ptr<value_type, __destruct_n&> __h(__first2, __d);\n        value_type* __last2 = __first2;\n        ::new(__last2) value_type(_VSTD::move(*__first1));\n        __d.__incr((value_type*)0);\n        for (++__last2; ++__first1 != __last1; ++__last2)\n        {\n            value_type* __j2 = __last2;\n            value_type* __i2 = __j2;\n            if (__comp(*__first1, *--__i2))\n            {\n                ::new(__j2) value_type(_VSTD::move(*__i2));\n                __d.__incr((value_type*)0);\n                for (--__j2; __i2 != __first2 && __comp(*__first1,  *--__i2); --__j2)\n                    *__j2 = _VSTD::move(*__i2);\n                *__j2 = _VSTD::move(*__first1);\n            }\n            else\n            {\n                ::new(__j2) value_type(_VSTD::move(*__first1));\n                __d.__incr((value_type*)0);\n            }\n        }\n        __h.release();\n    }\n}\n\ntemplate <class _Compare, class _RandomAccessIterator>\nvoid\n__sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\n{\n    // _Compare is known to be a reference type\n    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;\n    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;\n    const difference_type __limit = is_trivially_copy_constructible<value_type>::value &&\n                                    is_trivially_copy_assignable<value_type>::value ? 30 : 6;\n    while (true)\n    {\n    __restart:\n        difference_type __len = __last - __first;\n        switch (__len)\n        {\n        case 0:\n        case 1:\n            return;\n        case 2:\n            if (__comp(*--__last, *__first))\n                swap(*__first, *__last);\n            return;\n        case 3:\n            _VSTD::__sort3<_Compare>(__first, __first+1, --__last, __comp);\n            return;\n        case 4:\n            _VSTD::__sort4<_Compare>(__first, __first+1, __first+2, --__last, __comp);\n            return;\n        case 5:\n            _VSTD::__sort5<_Compare>(__first, __first+1, __first+2, __first+3, --__last, __comp);\n            return;\n        }\n        if (__len <= __limit)\n        {\n            _VSTD::__insertion_sort_3<_Compare>(__first, __last, __comp);\n            return;\n        }\n        // __len > 5\n        _RandomAccessIterator __m = __first;\n        _RandomAccessIterator __lm1 = __last;\n        --__lm1;\n        unsigned __n_swaps;\n        {\n        difference_type __delta;\n        if (__len >= 1000)\n        {\n            __delta = __len/2;\n            __m += __delta;\n            __delta /= 2;\n            __n_swaps = _VSTD::__sort5<_Compare>(__first, __first + __delta, __m, __m+__delta, __lm1, __comp);\n        }\n        else\n        {\n            __delta = __len/2;\n            __m += __delta;\n            __n_swaps = _VSTD::__sort3<_Compare>(__first, __m, __lm1, __comp);\n        }\n        }\n        // *__m is median\n        // partition [__first, __m) < *__m and *__m <= [__m, __last)\n        // (this inhibits tossing elements equivalent to __m around unnecessarily)\n        _RandomAccessIterator __i = __first;\n        _RandomAccessIterator __j = __lm1;\n        // j points beyond range to be tested, *__m is known to be <= *__lm1\n        // The search going up is known to be guarded but the search coming down isn't.\n        // Prime the downward search with a guard.\n        if (!__comp(*__i, *__m))  // if *__first == *__m\n        {\n            // *__first == *__m, *__first doesn't go in first part\n            // manually guard downward moving __j against __i\n            while (true)\n            {\n                if (__i == --__j)\n                {\n                    // *__first == *__m, *__m <= all other elements\n                    // Parition instead into [__first, __i) == *__first and *__first < [__i, __last)\n                    ++__i;  // __first + 1\n                    __j = __last;\n                    if (!__comp(*__first, *--__j))  // we need a guard if *__first == *(__last-1)\n                    {\n                        while (true)\n                        {\n                            if (__i == __j)\n                                return;  // [__first, __last) all equivalent elements\n                            if (__comp(*__first, *__i))\n                            {\n                                swap(*__i, *__j);\n                                ++__n_swaps;\n                                ++__i;\n                                break;\n                            }\n                            ++__i;\n                        }\n                    }\n                    // [__first, __i) == *__first and *__first < [__j, __last) and __j == __last - 1\n                    if (__i == __j)\n                        return;\n                    while (true)\n                    {\n                        while (!__comp(*__first, *__i))\n                            ++__i;\n                        while (__comp(*__first, *--__j))\n                            ;\n                        if (__i >= __j)\n                            break;\n                        swap(*__i, *__j);\n                        ++__n_swaps;\n                        ++__i;\n                    }\n                    // [__first, __i) == *__first and *__first < [__i, __last)\n                    // The first part is sorted, sort the secod part\n                    // _VSTD::__sort<_Compare>(__i, __last, __comp);\n                    __first = __i;\n                    goto __restart;\n                }\n                if (__comp(*__j, *__m))\n                {\n                    swap(*__i, *__j);\n                    ++__n_swaps;\n                    break;  // found guard for downward moving __j, now use unguarded partition\n                }\n            }\n        }\n        // It is known that *__i < *__m\n        ++__i;\n        // j points beyond range to be tested, *__m is known to be <= *__lm1\n        // if not yet partitioned...\n        if (__i < __j)\n        {\n            // known that *(__i - 1) < *__m\n            // known that __i <= __m\n            while (true)\n            {\n                // __m still guards upward moving __i\n                while (__comp(*__i, *__m))\n                    ++__i;\n                // It is now known that a guard exists for downward moving __j\n                while (!__comp(*--__j, *__m))\n                    ;\n                if (__i > __j)\n                    break;\n                swap(*__i, *__j);\n                ++__n_swaps;\n                // It is known that __m != __j\n                // If __m just moved, follow it\n                if (__m == __i)\n                    __m = __j;\n                ++__i;\n            }\n        }\n        // [__first, __i) < *__m and *__m <= [__i, __last)\n        if (__i != __m && __comp(*__m, *__i))\n        {\n            swap(*__i, *__m);\n            ++__n_swaps;\n        }\n        // [__first, __i) < *__i and *__i <= [__i+1, __last)\n        // If we were given a perfect partition, see if insertion sort is quick...\n        if (__n_swaps == 0)\n        {\n            bool __fs = _VSTD::__insertion_sort_incomplete<_Compare>(__first, __i, __comp);\n            if (_VSTD::__insertion_sort_incomplete<_Compare>(__i+1, __last, __comp))\n            {\n                if (__fs)\n                    return;\n                __last = __i;\n                continue;\n            }\n            else\n            {\n                if (__fs)\n                {\n                    __first = ++__i;\n                    continue;\n                }\n            }\n        }\n        // sort smaller range with recursive call and larger with tail recursion elimination\n        if (__i - __first < __last - __i)\n        {\n            _VSTD::__sort<_Compare>(__first, __i, __comp);\n            // _VSTD::__sort<_Compare>(__i+1, __last, __comp);\n            __first = ++__i;\n        }\n        else\n        {\n            _VSTD::__sort<_Compare>(__i+1, __last, __comp);\n            // _VSTD::__sort<_Compare>(__first, __i, __comp);\n            __last = __i;\n        }\n    }\n}\n\n// This forwarder keeps the top call and the recursive calls using the same instantiation, forcing a reference _Compare\ntemplate <class _RandomAccessIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nsort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    __sort<_Comp_ref>(__first, __last, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    __sort<_Comp_ref>(__first, __last, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nsort(_RandomAccessIterator __first, _RandomAccessIterator __last)\n{\n    _VSTD::sort(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nsort(_Tp** __first, _Tp** __last)\n{\n    _VSTD::sort((size_t*)__first, (size_t*)__last, __less<size_t>());\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nsort(__wrap_iter<_Tp*> __first, __wrap_iter<_Tp*> __last)\n{\n    _VSTD::sort(__first.base(), __last.base());\n}\n\ntemplate <class _Tp, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nsort(__wrap_iter<_Tp*> __first, __wrap_iter<_Tp*> __last, _Compare __comp)\n{\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    _VSTD::sort<_Tp*, _Comp_ref>(__first.base(), __last.base(), __comp);\n}\n\n#ifdef _LIBCPP_MSVC\n#pragma warning( push )\n#pragma warning( disable: 4231)\n#endif // _LIBCPP_MSVC\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<char>&, char*>(char*, char*, __less<char>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<wchar_t>&, wchar_t*>(wchar_t*, wchar_t*, __less<wchar_t>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<signed char>&, signed char*>(signed char*, signed char*, __less<signed char>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<unsigned char>&, unsigned char*>(unsigned char*, unsigned char*, __less<unsigned char>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<short>&, short*>(short*, short*, __less<short>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<unsigned short>&, unsigned short*>(unsigned short*, unsigned short*, __less<unsigned short>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<int>&, int*>(int*, int*, __less<int>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<unsigned>&, unsigned*>(unsigned*, unsigned*, __less<unsigned>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<long>&, long*>(long*, long*, __less<long>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<unsigned long>&, unsigned long*>(unsigned long*, unsigned long*, __less<unsigned long>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<long long>&, long long*>(long long*, long long*, __less<long long>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<unsigned long long>&, unsigned long long*>(unsigned long long*, unsigned long long*, __less<unsigned long long>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<float>&, float*>(float*, float*, __less<float>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<double>&, double*>(double*, double*, __less<double>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<long double>&, long double*>(long double*, long double*, __less<long double>&))\n\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<char>&, char*>(char*, char*, __less<char>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<wchar_t>&, wchar_t*>(wchar_t*, wchar_t*, __less<wchar_t>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<signed char>&, signed char*>(signed char*, signed char*, __less<signed char>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<unsigned char>&, unsigned char*>(unsigned char*, unsigned char*, __less<unsigned char>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<short>&, short*>(short*, short*, __less<short>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<unsigned short>&, unsigned short*>(unsigned short*, unsigned short*, __less<unsigned short>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<int>&, int*>(int*, int*, __less<int>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<unsigned>&, unsigned*>(unsigned*, unsigned*, __less<unsigned>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<long>&, long*>(long*, long*, __less<long>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<unsigned long>&, unsigned long*>(unsigned long*, unsigned long*, __less<unsigned long>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<long long>&, long long*>(long long*, long long*, __less<long long>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<unsigned long long>&, unsigned long long*>(unsigned long long*, unsigned long long*, __less<unsigned long long>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<float>&, float*>(float*, float*, __less<float>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<double>&, double*>(double*, double*, __less<double>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<long double>&, long double*>(long double*, long double*, __less<long double>&))\n\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS unsigned __sort5<__less<long double>&, long double*>(long double*, long double*, long double*, long double*, long double*, __less<long double>&))\n#ifdef _LIBCPP_MSVC\n#pragma warning( pop )\n#endif  // _LIBCPP_MSVC\n\n// lower_bound\n\ntemplate <class _Compare, class _ForwardIterator, class _Tp>\n_ForwardIterator\n__lower_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp)\n{\n    typedef typename iterator_traits<_ForwardIterator>::difference_type difference_type;\n    difference_type __len = _VSTD::distance(__first, __last);\n    while (__len != 0)\n    {\n        difference_type __l2 = __len / 2;\n        _ForwardIterator __m = __first;\n        _VSTD::advance(__m, __l2);\n        if (__comp(*__m, __value_))\n        {\n            __first = ++__m;\n            __len -= __l2 + 1;\n        }\n        else\n            __len = __l2;\n    }\n    return __first;\n}\n\ntemplate <class _ForwardIterator, class _Tp, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\nlower_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return __lower_bound<_Comp_ref>(__first, __last, __value_, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return __lower_bound<_Comp_ref>(__first, __last, __value_, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _ForwardIterator, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\nlower_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_)\n{\n    return _VSTD::lower_bound(__first, __last, __value_,\n                             __less<typename iterator_traits<_ForwardIterator>::value_type, _Tp>());\n}\n\n// upper_bound\n\ntemplate <class _Compare, class _ForwardIterator, class _Tp>\n_ForwardIterator\n__upper_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp)\n{\n    typedef typename iterator_traits<_ForwardIterator>::difference_type difference_type;\n    difference_type __len = _VSTD::distance(__first, __last);\n    while (__len != 0)\n    {\n        difference_type __l2 = __len / 2;\n        _ForwardIterator __m = __first;\n        _VSTD::advance(__m, __l2);\n        if (__comp(__value_, *__m))\n            __len = __l2;\n        else\n        {\n            __first = ++__m;\n            __len -= __l2 + 1;\n        }\n    }\n    return __first;\n}\n\ntemplate <class _ForwardIterator, class _Tp, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\nupper_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return __upper_bound<_Comp_ref>(__first, __last, __value_, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return __upper_bound<_Comp_ref>(__first, __last, __value_, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _ForwardIterator, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\nupper_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_)\n{\n    return _VSTD::upper_bound(__first, __last, __value_,\n                             __less<_Tp, typename iterator_traits<_ForwardIterator>::value_type>());\n}\n\n// equal_range\n\ntemplate <class _Compare, class _ForwardIterator, class _Tp>\npair<_ForwardIterator, _ForwardIterator>\n__equal_range(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp)\n{\n    typedef typename iterator_traits<_ForwardIterator>::difference_type difference_type;\n    difference_type __len = _VSTD::distance(__first, __last);\n    while (__len != 0)\n    {\n        difference_type __l2 = __len / 2;\n        _ForwardIterator __m = __first;\n        _VSTD::advance(__m, __l2);\n        if (__comp(*__m, __value_))\n        {\n            __first = ++__m;\n            __len -= __l2 + 1;\n        }\n        else if (__comp(__value_, *__m))\n        {\n            __last = __m;\n            __len = __l2;\n        }\n        else\n        {\n            _ForwardIterator __mp1 = __m;\n            return pair<_ForwardIterator, _ForwardIterator>\n                   (\n                      __lower_bound<_Compare>(__first, __m, __value_, __comp),\n                      __upper_bound<_Compare>(++__mp1, __last, __value_, __comp)\n                   );\n        }\n    }\n    return pair<_ForwardIterator, _ForwardIterator>(__first, __first);\n}\n\ntemplate <class _ForwardIterator, class _Tp, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\npair<_ForwardIterator, _ForwardIterator>\nequal_range(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return __equal_range<_Comp_ref>(__first, __last, __value_, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return __equal_range<_Comp_ref>(__first, __last, __value_, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _ForwardIterator, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\npair<_ForwardIterator, _ForwardIterator>\nequal_range(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_)\n{\n    return _VSTD::equal_range(__first, __last, __value_,\n                             __less<typename iterator_traits<_ForwardIterator>::value_type, _Tp>());\n}\n\n// binary_search\n\ntemplate <class _Compare, class _ForwardIterator, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\n__binary_search(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp)\n{\n    __first = __lower_bound<_Compare>(__first, __last, __value_, __comp);\n    return __first != __last && !__comp(__value_, *__first);\n}\n\ntemplate <class _ForwardIterator, class _Tp, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nbinary_search(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return __binary_search<_Comp_ref>(__first, __last, __value_, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return __binary_search<_Comp_ref>(__first, __last, __value_, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _ForwardIterator, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nbinary_search(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_)\n{\n    return _VSTD::binary_search(__first, __last, __value_,\n                             __less<typename iterator_traits<_ForwardIterator>::value_type, _Tp>());\n}\n\n// merge\n\ntemplate <class _Compare, class _InputIterator1, class _InputIterator2, class _OutputIterator>\n_OutputIterator\n__merge(_InputIterator1 __first1, _InputIterator1 __last1,\n        _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)\n{\n    for (; __first1 != __last1; ++__result)\n    {\n        if (__first2 == __last2)\n            return _VSTD::copy(__first1, __last1, __result);\n        if (__comp(*__first2, *__first1))\n        {\n            *__result = *__first2;\n            ++__first2;\n        }\n        else\n        {\n            *__result = *__first1;\n            ++__first1;\n        }\n    }\n    return _VSTD::copy(__first2, __last2, __result);\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _OutputIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nmerge(_InputIterator1 __first1, _InputIterator1 __last1,\n      _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return _VSTD::__merge<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return _VSTD::__merge<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nmerge(_InputIterator1 __first1, _InputIterator1 __last1,\n      _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result)\n{\n    typedef typename iterator_traits<_InputIterator1>::value_type __v1;\n    typedef typename iterator_traits<_InputIterator2>::value_type __v2;\n    return merge(__first1, __last1, __first2, __last2, __result, __less<__v1, __v2>());\n}\n\n// inplace_merge\n\ntemplate <class _Compare, class _InputIterator1, class _InputIterator2,\n          class _OutputIterator>\nvoid __half_inplace_merge(_InputIterator1 __first1, _InputIterator1 __last1,\n                          _InputIterator2 __first2, _InputIterator2 __last2,\n                          _OutputIterator __result, _Compare __comp)\n{\n    for (; __first1 != __last1; ++__result)\n    {\n        if (__first2 == __last2)\n        {\n            _VSTD::move(__first1, __last1, __result);\n            return;\n        }\n\n        if (__comp(*__first2, *__first1))\n        {\n            *__result = _VSTD::move(*__first2);\n            ++__first2;\n        }\n        else\n        {\n            *__result = _VSTD::move(*__first1);\n            ++__first1;\n        }\n    }\n    // __first2 through __last2 are already in the right spot.\n}\n\ntemplate <class _Compare, class _BidirectionalIterator>\nvoid\n__buffered_inplace_merge(_BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last,\n                _Compare __comp, typename iterator_traits<_BidirectionalIterator>::difference_type __len1,\n                                 typename iterator_traits<_BidirectionalIterator>::difference_type __len2,\n                typename iterator_traits<_BidirectionalIterator>::value_type* __buff)\n{\n    typedef typename iterator_traits<_BidirectionalIterator>::value_type value_type;\n    __destruct_n __d(0);\n    unique_ptr<value_type, __destruct_n&> __h2(__buff, __d);\n    if (__len1 <= __len2)\n    {\n        value_type* __p = __buff;\n        for (_BidirectionalIterator __i = __first; __i != __middle; __d.__incr((value_type*)0), (void) ++__i, ++__p)\n            ::new(__p) value_type(_VSTD::move(*__i));\n        __half_inplace_merge(__buff, __p, __middle, __last, __first, __comp);\n    }\n    else\n    {\n        value_type* __p = __buff;\n        for (_BidirectionalIterator __i = __middle; __i != __last; __d.__incr((value_type*)0), (void) ++__i, ++__p)\n            ::new(__p) value_type(_VSTD::move(*__i));\n        typedef reverse_iterator<_BidirectionalIterator> _RBi;\n        typedef reverse_iterator<value_type*> _Rv;\n        __half_inplace_merge(_Rv(__p), _Rv(__buff),\n                             _RBi(__middle), _RBi(__first),\n                             _RBi(__last), __negate<_Compare>(__comp));\n    }\n}\n\ntemplate <class _Compare, class _BidirectionalIterator>\nvoid\n__inplace_merge(_BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last,\n                _Compare __comp, typename iterator_traits<_BidirectionalIterator>::difference_type __len1,\n                                 typename iterator_traits<_BidirectionalIterator>::difference_type __len2,\n                typename iterator_traits<_BidirectionalIterator>::value_type* __buff, ptrdiff_t __buff_size)\n{\n    typedef typename iterator_traits<_BidirectionalIterator>::difference_type difference_type;\n    while (true)\n    {\n        // if __middle == __last, we're done\n        if (__len2 == 0)\n            return;\n        if (__len1 <= __buff_size || __len2 <= __buff_size)\n            return __buffered_inplace_merge<_Compare>\n                   (__first, __middle, __last, __comp, __len1, __len2, __buff);\n        // shrink [__first, __middle) as much as possible (with no moves), returning if it shrinks to 0\n        for (; true; ++__first, (void) --__len1)\n        {\n            if (__len1 == 0)\n                return;\n            if (__comp(*__middle, *__first))\n                break;\n        }\n        // __first < __middle < __last\n        // *__first > *__middle\n        // partition [__first, __m1) [__m1, __middle) [__middle, __m2) [__m2, __last) such that\n        //     all elements in:\n        //         [__first, __m1)  <= [__middle, __m2)\n        //         [__middle, __m2) <  [__m1, __middle)\n        //         [__m1, __middle) <= [__m2, __last)\n        //     and __m1 or __m2 is in the middle of its range\n        _BidirectionalIterator __m1;  // \"median\" of [__first, __middle)\n        _BidirectionalIterator __m2;  // \"median\" of [__middle, __last)\n        difference_type __len11;      // distance(__first, __m1)\n        difference_type __len21;      // distance(__middle, __m2)\n        // binary search smaller range\n        if (__len1 < __len2)\n        {   // __len >= 1, __len2 >= 2\n            __len21 = __len2 / 2;\n            __m2 = __middle;\n            _VSTD::advance(__m2, __len21);\n            __m1 = __upper_bound<_Compare>(__first, __middle, *__m2, __comp);\n            __len11 = _VSTD::distance(__first, __m1);\n        }\n        else\n        {\n            if (__len1 == 1)\n            {   // __len1 >= __len2 && __len2 > 0, therefore __len2 == 1\n                // It is known *__first > *__middle\n                swap(*__first, *__middle);\n                return;\n            }\n            // __len1 >= 2, __len2 >= 1\n            __len11 = __len1 / 2;\n            __m1 = __first;\n            _VSTD::advance(__m1, __len11);\n            __m2 = __lower_bound<_Compare>(__middle, __last, *__m1, __comp);\n            __len21 = _VSTD::distance(__middle, __m2);\n        }\n        difference_type __len12 = __len1 - __len11;  // distance(__m1, __middle)\n        difference_type __len22 = __len2 - __len21;  // distance(__m2, __last)\n        // [__first, __m1) [__m1, __middle) [__middle, __m2) [__m2, __last)\n        // swap middle two partitions\n        __middle = _VSTD::rotate(__m1, __middle, __m2);\n        // __len12 and __len21 now have swapped meanings\n        // merge smaller range with recurisve call and larger with tail recursion elimination\n        if (__len11 + __len21 < __len12 + __len22)\n        {\n            __inplace_merge<_Compare>(__first, __m1, __middle, __comp, __len11, __len21, __buff, __buff_size);\n//          __inplace_merge<_Compare>(__middle, __m2, __last, __comp, __len12, __len22, __buff, __buff_size);\n            __first = __middle;\n            __middle = __m2;\n            __len1 = __len12;\n            __len2 = __len22;\n        }\n        else\n        {\n            __inplace_merge<_Compare>(__middle, __m2, __last, __comp, __len12, __len22, __buff, __buff_size);\n//          __inplace_merge<_Compare>(__first, __m1, __middle, __comp, __len11, __len21, __buff, __buff_size);\n            __last = __middle;\n            __middle = __m1;\n            __len1 = __len11;\n            __len2 = __len21;\n        }\n    }\n}\n\ntemplate <class _BidirectionalIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\ninplace_merge(_BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last,\n              _Compare __comp)\n{\n    typedef typename iterator_traits<_BidirectionalIterator>::value_type value_type;\n    typedef typename iterator_traits<_BidirectionalIterator>::difference_type difference_type;\n    difference_type __len1 = _VSTD::distance(__first, __middle);\n    difference_type __len2 = _VSTD::distance(__middle, __last);\n    difference_type __buf_size = _VSTD::min(__len1, __len2);\n    pair<value_type*, ptrdiff_t> __buf = _VSTD::get_temporary_buffer<value_type>(__buf_size);\n    unique_ptr<value_type, __return_temporary_buffer> __h(__buf.first);\n\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return _VSTD::__inplace_merge<_Comp_ref>(__first, __middle, __last, __c, __len1, __len2,\n                                            __buf.first, __buf.second);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return _VSTD::__inplace_merge<_Comp_ref>(__first, __middle, __last, __comp, __len1, __len2,\n                                            __buf.first, __buf.second);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _BidirectionalIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\ninplace_merge(_BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last)\n{\n    _VSTD::inplace_merge(__first, __middle, __last,\n                        __less<typename iterator_traits<_BidirectionalIterator>::value_type>());\n}\n\n// stable_sort\n\ntemplate <class _Compare, class _InputIterator1, class _InputIterator2>\nvoid\n__merge_move_construct(_InputIterator1 __first1, _InputIterator1 __last1,\n        _InputIterator2 __first2, _InputIterator2 __last2,\n        typename iterator_traits<_InputIterator1>::value_type* __result, _Compare __comp)\n{\n    typedef typename iterator_traits<_InputIterator1>::value_type value_type;\n    __destruct_n __d(0);\n    unique_ptr<value_type, __destruct_n&> __h(__result, __d);\n    for (; true; ++__result)\n    {\n        if (__first1 == __last1)\n        {\n            for (; __first2 != __last2; ++__first2, ++__result, __d.__incr((value_type*)0))\n                ::new (__result) value_type(_VSTD::move(*__first2));\n            __h.release();\n            return;\n        }\n        if (__first2 == __last2)\n        {\n            for (; __first1 != __last1; ++__first1, ++__result, __d.__incr((value_type*)0))\n                ::new (__result) value_type(_VSTD::move(*__first1));\n            __h.release();\n            return;\n        }\n        if (__comp(*__first2, *__first1))\n        {\n            ::new (__result) value_type(_VSTD::move(*__first2));\n            __d.__incr((value_type*)0);\n            ++__first2;\n        }\n        else\n        {\n            ::new (__result) value_type(_VSTD::move(*__first1));\n            __d.__incr((value_type*)0);\n            ++__first1;\n        }\n    }\n}\n\ntemplate <class _Compare, class _InputIterator1, class _InputIterator2, class _OutputIterator>\nvoid\n__merge_move_assign(_InputIterator1 __first1, _InputIterator1 __last1,\n        _InputIterator2 __first2, _InputIterator2 __last2,\n        _OutputIterator __result, _Compare __comp)\n{\n    for (; __first1 != __last1; ++__result)\n    {\n        if (__first2 == __last2)\n        {\n            for (; __first1 != __last1; ++__first1, ++__result)\n                *__result = _VSTD::move(*__first1);\n            return;\n        }\n        if (__comp(*__first2, *__first1))\n        {\n            *__result = _VSTD::move(*__first2);\n            ++__first2;\n        }\n        else\n        {\n            *__result = _VSTD::move(*__first1);\n            ++__first1;\n        }\n    }\n    for (; __first2 != __last2; ++__first2, ++__result)\n        *__result = _VSTD::move(*__first2);\n}\n\ntemplate <class _Compare, class _RandomAccessIterator>\nvoid\n__stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp,\n              typename iterator_traits<_RandomAccessIterator>::difference_type __len,\n              typename iterator_traits<_RandomAccessIterator>::value_type* __buff, ptrdiff_t __buff_size);\n\ntemplate <class _Compare, class _RandomAccessIterator>\nvoid\n__stable_sort_move(_RandomAccessIterator __first1, _RandomAccessIterator __last1, _Compare __comp,\n                   typename iterator_traits<_RandomAccessIterator>::difference_type __len,\n                   typename iterator_traits<_RandomAccessIterator>::value_type* __first2)\n{\n    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;\n    switch (__len)\n    {\n    case 0:\n        return;\n    case 1:\n        ::new(__first2) value_type(_VSTD::move(*__first1));\n        return;\n    case 2:\n       __destruct_n __d(0);\n        unique_ptr<value_type, __destruct_n&> __h2(__first2, __d);\n         if (__comp(*--__last1, *__first1))\n        {\n            ::new(__first2) value_type(_VSTD::move(*__last1));\n            __d.__incr((value_type*)0);\n            ++__first2;\n            ::new(__first2) value_type(_VSTD::move(*__first1));\n        }\n        else\n        {\n            ::new(__first2) value_type(_VSTD::move(*__first1));\n            __d.__incr((value_type*)0);\n            ++__first2;\n            ::new(__first2) value_type(_VSTD::move(*__last1));\n        }\n        __h2.release();\n        return;\n    }\n    if (__len <= 8)\n    {\n        __insertion_sort_move<_Compare>(__first1, __last1, __first2, __comp);\n        return;\n    }\n    typename iterator_traits<_RandomAccessIterator>::difference_type __l2 = __len / 2;\n    _RandomAccessIterator __m = __first1 + __l2;\n    __stable_sort<_Compare>(__first1, __m, __comp, __l2, __first2, __l2);\n    __stable_sort<_Compare>(__m, __last1, __comp, __len - __l2, __first2 + __l2, __len - __l2);\n    __merge_move_construct<_Compare>(__first1, __m, __m, __last1, __first2, __comp);\n}\n\ntemplate <class _Tp>\nstruct __stable_sort_switch\n{\n    static const unsigned value = 128*is_trivially_copy_assignable<_Tp>::value;\n};\n\ntemplate <class _Compare, class _RandomAccessIterator>\nvoid\n__stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp,\n              typename iterator_traits<_RandomAccessIterator>::difference_type __len,\n              typename iterator_traits<_RandomAccessIterator>::value_type* __buff, ptrdiff_t __buff_size)\n{\n    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;\n    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;\n    switch (__len)\n    {\n    case 0:\n    case 1:\n        return;\n    case 2:\n        if (__comp(*--__last, *__first))\n            swap(*__first, *__last);\n        return;\n    }\n    if (__len <= static_cast<difference_type>(__stable_sort_switch<value_type>::value))\n    {\n        __insertion_sort<_Compare>(__first, __last, __comp);\n        return;\n    }\n    typename iterator_traits<_RandomAccessIterator>::difference_type __l2 = __len / 2;\n    _RandomAccessIterator __m = __first + __l2;\n    if (__len <= __buff_size)\n    {\n        __destruct_n __d(0);\n        unique_ptr<value_type, __destruct_n&> __h2(__buff, __d);\n        __stable_sort_move<_Compare>(__first, __m, __comp, __l2, __buff);\n        __d.__set(__l2, (value_type*)0);\n        __stable_sort_move<_Compare>(__m, __last, __comp, __len - __l2, __buff + __l2);\n        __d.__set(__len, (value_type*)0);\n        __merge_move_assign<_Compare>(__buff, __buff + __l2, __buff + __l2, __buff + __len, __first, __comp);\n//         __merge<_Compare>(move_iterator<value_type*>(__buff),\n//                           move_iterator<value_type*>(__buff + __l2),\n//                           move_iterator<_RandomAccessIterator>(__buff + __l2),\n//                           move_iterator<_RandomAccessIterator>(__buff + __len),\n//                           __first, __comp);\n        return;\n    }\n    __stable_sort<_Compare>(__first, __m, __comp, __l2, __buff, __buff_size);\n    __stable_sort<_Compare>(__m, __last, __comp, __len - __l2, __buff, __buff_size);\n    __inplace_merge<_Compare>(__first, __m, __last, __comp, __l2, __len - __l2, __buff, __buff_size);\n}\n\ntemplate <class _RandomAccessIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nstable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\n{\n    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;\n    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;\n    difference_type __len = __last - __first;\n    pair<value_type*, ptrdiff_t> __buf(0, 0);\n    unique_ptr<value_type, __return_temporary_buffer> __h;\n    if (__len > static_cast<difference_type>(__stable_sort_switch<value_type>::value))\n    {\n        __buf = _VSTD::get_temporary_buffer<value_type>(__len);\n        __h.reset(__buf.first);\n    }\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    __stable_sort<_Comp_ref>(__first, __last, __c, __len, __buf.first, __buf.second);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    __stable_sort<_Comp_ref>(__first, __last, __comp, __len, __buf.first, __buf.second);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nstable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last)\n{\n    _VSTD::stable_sort(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());\n}\n\n// is_heap_until\n\ntemplate <class _RandomAccessIterator, class _Compare>\n_RandomAccessIterator\nis_heap_until(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\n{\n    typedef typename _VSTD::iterator_traits<_RandomAccessIterator>::difference_type difference_type;\n    difference_type __len = __last - __first;\n    difference_type __p = 0;\n    difference_type __c = 1;\n    _RandomAccessIterator __pp = __first;\n    while (__c < __len)\n    {\n        _RandomAccessIterator __cp = __first + __c;\n        if (__comp(*__pp, *__cp))\n            return __cp;\n        ++__c;\n        ++__cp;\n        if (__c == __len)\n            return __last;\n        if (__comp(*__pp, *__cp))\n            return __cp;\n        ++__p;\n        ++__pp;\n        __c = 2 * __p + 1;\n    }\n    return __last;\n}\n\ntemplate<class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_RandomAccessIterator\nis_heap_until(_RandomAccessIterator __first, _RandomAccessIterator __last)\n{\n    return _VSTD::is_heap_until(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());\n}\n\n// is_heap\n\ntemplate <class _RandomAccessIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nis_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\n{\n    return _VSTD::is_heap_until(__first, __last, __comp) == __last;\n}\n\ntemplate<class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nis_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)\n{\n    return _VSTD::is_heap(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());\n}\n\n// push_heap\n\ntemplate <class _Compare, class _RandomAccessIterator>\nvoid\n__sift_up(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp,\n          typename iterator_traits<_RandomAccessIterator>::difference_type __len)\n{\n    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;\n    if (__len > 1)\n    {\n        __len = (__len - 2) / 2;\n        _RandomAccessIterator __ptr = __first + __len;\n        if (__comp(*__ptr, *--__last))\n        {\n            value_type __t(_VSTD::move(*__last));\n            do\n            {\n                *__last = _VSTD::move(*__ptr);\n                __last = __ptr;\n                if (__len == 0)\n                    break;\n                __len = (__len - 1) / 2;\n                __ptr = __first + __len;\n            } while (__comp(*__ptr, __t));\n            *__last = _VSTD::move(__t);\n        }\n    }\n}\n\ntemplate <class _RandomAccessIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\npush_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    __sift_up<_Comp_ref>(__first, __last, __c, __last - __first);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    __sift_up<_Comp_ref>(__first, __last, __comp, __last - __first);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\npush_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)\n{\n    _VSTD::push_heap(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());\n}\n\n// pop_heap\n\ntemplate <class _Compare, class _RandomAccessIterator>\nvoid\n__sift_down(_RandomAccessIterator __first, _RandomAccessIterator /*__last*/,\n            _Compare __comp,\n            typename iterator_traits<_RandomAccessIterator>::difference_type __len,\n            _RandomAccessIterator __start)\n{\n    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;\n    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;\n    // left-child of __start is at 2 * __start + 1\n    // right-child of __start is at 2 * __start + 2\n    difference_type __child = __start - __first;\n\n    if (__len < 2 || (__len - 2) / 2 < __child)\n        return;\n\n    __child = 2 * __child + 1;\n    _RandomAccessIterator __child_i = __first + __child;\n\n    if ((__child + 1) < __len && __comp(*__child_i, *(__child_i + 1))) {\n        // right-child exists and is greater than left-child\n        ++__child_i;\n        ++__child;\n    }\n\n    // check if we are in heap-order\n    if (__comp(*__child_i, *__start))\n        // we are, __start is larger than it's largest child\n        return;\n\n    value_type __top(_VSTD::move(*__start));\n    do\n    {\n        // we are not in heap-order, swap the parent with it's largest child\n        *__start = _VSTD::move(*__child_i);\n        __start = __child_i;\n\n        if ((__len - 2) / 2 < __child)\n            break;\n\n        // recompute the child based off of the updated parent\n        __child = 2 * __child + 1;\n        __child_i = __first + __child;\n\n        if ((__child + 1) < __len && __comp(*__child_i, *(__child_i + 1))) {\n            // right-child exists and is greater than left-child\n            ++__child_i;\n            ++__child;\n        }\n\n        // check if we are in heap-order\n    } while (!__comp(*__child_i, __top));\n    *__start = _VSTD::move(__top);\n}\n\ntemplate <class _Compare, class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\n__pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp,\n           typename iterator_traits<_RandomAccessIterator>::difference_type __len)\n{\n    if (__len > 1)\n    {\n        swap(*__first, *--__last);\n        __sift_down<_Compare>(__first, __last, __comp, __len - 1, __first);\n    }\n}\n\ntemplate <class _RandomAccessIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\npop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    __pop_heap<_Comp_ref>(__first, __last, __c, __last - __first);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    __pop_heap<_Comp_ref>(__first, __last, __comp, __last - __first);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\npop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)\n{\n    _VSTD::pop_heap(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());\n}\n\n// make_heap\n\ntemplate <class _Compare, class _RandomAccessIterator>\nvoid\n__make_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\n{\n    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;\n    difference_type __n = __last - __first;\n    if (__n > 1)\n    {\n        // start from the first parent, there is no need to consider children\n        for (difference_type __start = (__n - 2) / 2; __start >= 0; --__start)\n        {\n            __sift_down<_Compare>(__first, __last, __comp, __n, __first + __start);\n        }\n    }\n}\n\ntemplate <class _RandomAccessIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nmake_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    __make_heap<_Comp_ref>(__first, __last, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    __make_heap<_Comp_ref>(__first, __last, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nmake_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)\n{\n    _VSTD::make_heap(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());\n}\n\n// sort_heap\n\ntemplate <class _Compare, class _RandomAccessIterator>\nvoid\n__sort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\n{\n    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;\n    for (difference_type __n = __last - __first; __n > 1; --__last, --__n)\n        __pop_heap<_Compare>(__first, __last, __comp, __n);\n}\n\ntemplate <class _RandomAccessIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nsort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    __sort_heap<_Comp_ref>(__first, __last, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    __sort_heap<_Comp_ref>(__first, __last, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nsort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)\n{\n    _VSTD::sort_heap(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());\n}\n\n// partial_sort\n\ntemplate <class _Compare, class _RandomAccessIterator>\nvoid\n__partial_sort(_RandomAccessIterator __first, _RandomAccessIterator __middle, _RandomAccessIterator __last,\n             _Compare __comp)\n{\n    __make_heap<_Compare>(__first, __middle, __comp);\n    typename iterator_traits<_RandomAccessIterator>::difference_type __len = __middle - __first;\n    for (_RandomAccessIterator __i = __middle; __i != __last; ++__i)\n    {\n        if (__comp(*__i, *__first))\n        {\n            swap(*__i, *__first);\n            __sift_down<_Compare>(__first, __middle, __comp, __len, __first);\n        }\n    }\n    __sort_heap<_Compare>(__first, __middle, __comp);\n}\n\ntemplate <class _RandomAccessIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\npartial_sort(_RandomAccessIterator __first, _RandomAccessIterator __middle, _RandomAccessIterator __last,\n             _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    __partial_sort<_Comp_ref>(__first, __middle, __last, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    __partial_sort<_Comp_ref>(__first, __middle, __last, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\npartial_sort(_RandomAccessIterator __first, _RandomAccessIterator __middle, _RandomAccessIterator __last)\n{\n    _VSTD::partial_sort(__first, __middle, __last,\n                       __less<typename iterator_traits<_RandomAccessIterator>::value_type>());\n}\n\n// partial_sort_copy\n\ntemplate <class _Compare, class _InputIterator, class _RandomAccessIterator>\n_RandomAccessIterator\n__partial_sort_copy(_InputIterator __first, _InputIterator __last,\n                    _RandomAccessIterator __result_first, _RandomAccessIterator __result_last, _Compare __comp)\n{\n    _RandomAccessIterator __r = __result_first;\n    if (__r != __result_last)\n    {\n        for (; __first != __last && __r != __result_last; (void) ++__first, ++__r)\n            *__r = *__first;\n        __make_heap<_Compare>(__result_first, __r, __comp);\n        typename iterator_traits<_RandomAccessIterator>::difference_type __len = __r - __result_first;\n        for (; __first != __last; ++__first)\n            if (__comp(*__first, *__result_first))\n            {\n                *__result_first = *__first;\n                __sift_down<_Compare>(__result_first, __r, __comp, __len, __result_first);\n            }\n        __sort_heap<_Compare>(__result_first, __r, __comp);\n    }\n    return __r;\n}\n\ntemplate <class _InputIterator, class _RandomAccessIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\n_RandomAccessIterator\npartial_sort_copy(_InputIterator __first, _InputIterator __last,\n                  _RandomAccessIterator __result_first, _RandomAccessIterator __result_last, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return __partial_sort_copy<_Comp_ref>(__first, __last, __result_first, __result_last, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return __partial_sort_copy<_Comp_ref>(__first, __last, __result_first, __result_last, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _InputIterator, class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_RandomAccessIterator\npartial_sort_copy(_InputIterator __first, _InputIterator __last,\n                  _RandomAccessIterator __result_first, _RandomAccessIterator __result_last)\n{\n    return _VSTD::partial_sort_copy(__first, __last, __result_first, __result_last,\n                                   __less<typename iterator_traits<_RandomAccessIterator>::value_type>());\n}\n\n// nth_element\n\ntemplate <class _Compare, class _RandomAccessIterator>\nvoid\n__nth_element(_RandomAccessIterator __first, _RandomAccessIterator __nth, _RandomAccessIterator __last, _Compare __comp)\n{\n    // _Compare is known to be a reference type\n    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;\n    const difference_type __limit = 7;\n    while (true)\n    {\n    __restart:\n        if (__nth == __last)\n            return;\n        difference_type __len = __last - __first;\n        switch (__len)\n        {\n        case 0:\n        case 1:\n            return;\n        case 2:\n            if (__comp(*--__last, *__first))\n                swap(*__first, *__last);\n            return;\n        case 3:\n            {\n            _RandomAccessIterator __m = __first;\n            _VSTD::__sort3<_Compare>(__first, ++__m, --__last, __comp);\n            return;\n            }\n        }\n        if (__len <= __limit)\n        {\n            __selection_sort<_Compare>(__first, __last, __comp);\n            return;\n        }\n        // __len > __limit >= 3\n        _RandomAccessIterator __m = __first + __len/2;\n        _RandomAccessIterator __lm1 = __last;\n        unsigned __n_swaps = _VSTD::__sort3<_Compare>(__first, __m, --__lm1, __comp);\n        // *__m is median\n        // partition [__first, __m) < *__m and *__m <= [__m, __last)\n        // (this inhibits tossing elements equivalent to __m around unnecessarily)\n        _RandomAccessIterator __i = __first;\n        _RandomAccessIterator __j = __lm1;\n        // j points beyond range to be tested, *__lm1 is known to be <= *__m\n        // The search going up is known to be guarded but the search coming down isn't.\n        // Prime the downward search with a guard.\n        if (!__comp(*__i, *__m))  // if *__first == *__m\n        {\n            // *__first == *__m, *__first doesn't go in first part\n            // manually guard downward moving __j against __i\n            while (true)\n            {\n                if (__i == --__j)\n                {\n                    // *__first == *__m, *__m <= all other elements\n                    // Parition instead into [__first, __i) == *__first and *__first < [__i, __last)\n                    ++__i;  // __first + 1\n                    __j = __last;\n                    if (!__comp(*__first, *--__j))  // we need a guard if *__first == *(__last-1)\n                    {\n                        while (true)\n                        {\n                            if (__i == __j)\n                                return;  // [__first, __last) all equivalent elements\n                            if (__comp(*__first, *__i))\n                            {\n                                swap(*__i, *__j);\n                                ++__n_swaps;\n                                ++__i;\n                                break;\n                            }\n                            ++__i;\n                        }\n                    }\n                    // [__first, __i) == *__first and *__first < [__j, __last) and __j == __last - 1\n                    if (__i == __j)\n                        return;\n                    while (true)\n                    {\n                        while (!__comp(*__first, *__i))\n                            ++__i;\n                        while (__comp(*__first, *--__j))\n                            ;\n                        if (__i >= __j)\n                            break;\n                        swap(*__i, *__j);\n                        ++__n_swaps;\n                        ++__i;\n                    }\n                    // [__first, __i) == *__first and *__first < [__i, __last)\n                    // The first part is sorted,\n                    if (__nth < __i)\n                        return;\n                    // __nth_element the secod part\n                    // __nth_element<_Compare>(__i, __nth, __last, __comp);\n                    __first = __i;\n                    goto __restart;\n                }\n                if (__comp(*__j, *__m))\n                {\n                    swap(*__i, *__j);\n                    ++__n_swaps;\n                    break;  // found guard for downward moving __j, now use unguarded partition\n                }\n            }\n        }\n        ++__i;\n        // j points beyond range to be tested, *__lm1 is known to be <= *__m\n        // if not yet partitioned...\n        if (__i < __j)\n        {\n            // known that *(__i - 1) < *__m\n            while (true)\n            {\n                // __m still guards upward moving __i\n                while (__comp(*__i, *__m))\n                    ++__i;\n                // It is now known that a guard exists for downward moving __j\n                while (!__comp(*--__j, *__m))\n                    ;\n                if (__i >= __j)\n                    break;\n                swap(*__i, *__j);\n                ++__n_swaps;\n                // It is known that __m != __j\n                // If __m just moved, follow it\n                if (__m == __i)\n                    __m = __j;\n                ++__i;\n            }\n        }\n        // [__first, __i) < *__m and *__m <= [__i, __last)\n        if (__i != __m && __comp(*__m, *__i))\n        {\n            swap(*__i, *__m);\n            ++__n_swaps;\n        }\n        // [__first, __i) < *__i and *__i <= [__i+1, __last)\n        if (__nth == __i)\n            return;\n        if (__n_swaps == 0)\n        {\n            // We were given a perfectly partitioned sequence.  Coincidence?\n            if (__nth < __i)\n            {\n                // Check for [__first, __i) already sorted\n                __j = __m = __first;\n                while (++__j != __i)\n                {\n                    if (__comp(*__j, *__m))\n                        // not yet sorted, so sort\n                        goto not_sorted;\n                    __m = __j;\n                }\n                // [__first, __i) sorted\n                return;\n            }\n            else\n            {\n                // Check for [__i, __last) already sorted\n                __j = __m = __i;\n                while (++__j != __last)\n                {\n                    if (__comp(*__j, *__m))\n                        // not yet sorted, so sort\n                        goto not_sorted;\n                    __m = __j;\n                }\n                // [__i, __last) sorted\n                return;\n            }\n        }\nnot_sorted:\n        // __nth_element on range containing __nth\n        if (__nth < __i)\n        {\n            // __nth_element<_Compare>(__first, __nth, __i, __comp);\n            __last = __i;\n        }\n        else\n        {\n            // __nth_element<_Compare>(__i+1, __nth, __last, __comp);\n            __first = ++__i;\n        }\n    }\n}\n\ntemplate <class _RandomAccessIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nnth_element(_RandomAccessIterator __first, _RandomAccessIterator __nth, _RandomAccessIterator __last, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    __nth_element<_Comp_ref>(__first, __nth, __last, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    __nth_element<_Comp_ref>(__first, __nth, __last, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nnth_element(_RandomAccessIterator __first, _RandomAccessIterator __nth, _RandomAccessIterator __last)\n{\n    _VSTD::nth_element(__first, __nth, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());\n}\n\n// includes\n\ntemplate <class _Compare, class _InputIterator1, class _InputIterator2>\nbool\n__includes(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2,\n           _Compare __comp)\n{\n    for (; __first2 != __last2; ++__first1)\n    {\n        if (__first1 == __last1 || __comp(*__first2, *__first1))\n            return false;\n        if (!__comp(*__first1, *__first2))\n            ++__first2;\n    }\n    return true;\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nincludes(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2,\n         _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return __includes<_Comp_ref>(__first1, __last1, __first2, __last2, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return __includes<_Comp_ref>(__first1, __last1, __first2, __last2, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _InputIterator1, class _InputIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nincludes(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2)\n{\n    return _VSTD::includes(__first1, __last1, __first2, __last2,\n                          __less<typename iterator_traits<_InputIterator1>::value_type,\n                                 typename iterator_traits<_InputIterator2>::value_type>());\n}\n\n// set_union\n\ntemplate <class _Compare, class _InputIterator1, class _InputIterator2, class _OutputIterator>\n_OutputIterator\n__set_union(_InputIterator1 __first1, _InputIterator1 __last1,\n            _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)\n{\n    for (; __first1 != __last1; ++__result)\n    {\n        if (__first2 == __last2)\n            return _VSTD::copy(__first1, __last1, __result);\n        if (__comp(*__first2, *__first1))\n        {\n            *__result = *__first2;\n            ++__first2;\n        }\n        else\n        {\n            *__result = *__first1;\n            if (!__comp(*__first1, *__first2))\n                ++__first2;\n            ++__first1;\n        }\n    }\n    return _VSTD::copy(__first2, __last2, __result);\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _OutputIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nset_union(_InputIterator1 __first1, _InputIterator1 __last1,\n          _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return __set_union<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return __set_union<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nset_union(_InputIterator1 __first1, _InputIterator1 __last1,\n          _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result)\n{\n    return _VSTD::set_union(__first1, __last1, __first2, __last2, __result,\n                          __less<typename iterator_traits<_InputIterator1>::value_type,\n                                 typename iterator_traits<_InputIterator2>::value_type>());\n}\n\n// set_intersection\n\ntemplate <class _Compare, class _InputIterator1, class _InputIterator2, class _OutputIterator>\n_OutputIterator\n__set_intersection(_InputIterator1 __first1, _InputIterator1 __last1,\n                   _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)\n{\n    while (__first1 != __last1 && __first2 != __last2)\n    {\n        if (__comp(*__first1, *__first2))\n            ++__first1;\n        else\n        {\n            if (!__comp(*__first2, *__first1))\n            {\n                *__result = *__first1;\n                ++__result;\n                ++__first1;\n            }\n            ++__first2;\n        }\n    }\n    return __result;\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _OutputIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nset_intersection(_InputIterator1 __first1, _InputIterator1 __last1,\n                 _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return __set_intersection<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return __set_intersection<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nset_intersection(_InputIterator1 __first1, _InputIterator1 __last1,\n                 _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result)\n{\n    return _VSTD::set_intersection(__first1, __last1, __first2, __last2, __result,\n                                  __less<typename iterator_traits<_InputIterator1>::value_type,\n                                         typename iterator_traits<_InputIterator2>::value_type>());\n}\n\n// set_difference\n\ntemplate <class _Compare, class _InputIterator1, class _InputIterator2, class _OutputIterator>\n_OutputIterator\n__set_difference(_InputIterator1 __first1, _InputIterator1 __last1,\n                 _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)\n{\n    while (__first1 != __last1)\n    {\n        if (__first2 == __last2)\n            return _VSTD::copy(__first1, __last1, __result);\n        if (__comp(*__first1, *__first2))\n        {\n            *__result = *__first1;\n            ++__result;\n            ++__first1;\n        }\n        else\n        {\n            if (!__comp(*__first2, *__first1))\n                ++__first1;\n            ++__first2;\n        }\n    }\n    return __result;\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _OutputIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nset_difference(_InputIterator1 __first1, _InputIterator1 __last1,\n               _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return __set_difference<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return __set_difference<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nset_difference(_InputIterator1 __first1, _InputIterator1 __last1,\n               _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result)\n{\n    return _VSTD::set_difference(__first1, __last1, __first2, __last2, __result,\n                                __less<typename iterator_traits<_InputIterator1>::value_type,\n                                       typename iterator_traits<_InputIterator2>::value_type>());\n}\n\n// set_symmetric_difference\n\ntemplate <class _Compare, class _InputIterator1, class _InputIterator2, class _OutputIterator>\n_OutputIterator\n__set_symmetric_difference(_InputIterator1 __first1, _InputIterator1 __last1,\n                           _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)\n{\n    while (__first1 != __last1)\n    {\n        if (__first2 == __last2)\n            return _VSTD::copy(__first1, __last1, __result);\n        if (__comp(*__first1, *__first2))\n        {\n            *__result = *__first1;\n            ++__result;\n            ++__first1;\n        }\n        else\n        {\n            if (__comp(*__first2, *__first1))\n            {\n                *__result = *__first2;\n                ++__result;\n            }\n            else\n                ++__first1;\n            ++__first2;\n        }\n    }\n    return _VSTD::copy(__first2, __last2, __result);\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _OutputIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nset_symmetric_difference(_InputIterator1 __first1, _InputIterator1 __last1,\n                         _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return __set_symmetric_difference<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return __set_symmetric_difference<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nset_symmetric_difference(_InputIterator1 __first1, _InputIterator1 __last1,\n                         _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result)\n{\n    return _VSTD::set_symmetric_difference(__first1, __last1, __first2, __last2, __result,\n                                          __less<typename iterator_traits<_InputIterator1>::value_type,\n                                                 typename iterator_traits<_InputIterator2>::value_type>());\n}\n\n// lexicographical_compare\n\ntemplate <class _Compare, class _InputIterator1, class _InputIterator2>\nbool\n__lexicographical_compare(_InputIterator1 __first1, _InputIterator1 __last1,\n                          _InputIterator2 __first2, _InputIterator2 __last2, _Compare __comp)\n{\n    for (; __first2 != __last2; ++__first1, (void) ++__first2)\n    {\n        if (__first1 == __last1 || __comp(*__first1, *__first2))\n            return true;\n        if (__comp(*__first2, *__first1))\n            return false;\n    }\n    return false;\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nlexicographical_compare(_InputIterator1 __first1, _InputIterator1 __last1,\n                        _InputIterator2 __first2, _InputIterator2 __last2, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return __lexicographical_compare<_Comp_ref>(__first1, __last1, __first2, __last2, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return __lexicographical_compare<_Comp_ref>(__first1, __last1, __first2, __last2, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _InputIterator1, class _InputIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nlexicographical_compare(_InputIterator1 __first1, _InputIterator1 __last1,\n                        _InputIterator2 __first2, _InputIterator2 __last2)\n{\n    return _VSTD::lexicographical_compare(__first1, __last1, __first2, __last2,\n                                         __less<typename iterator_traits<_InputIterator1>::value_type,\n                                                typename iterator_traits<_InputIterator2>::value_type>());\n}\n\n// next_permutation\n\ntemplate <class _Compare, class _BidirectionalIterator>\nbool\n__next_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last, _Compare __comp)\n{\n    _BidirectionalIterator __i = __last;\n    if (__first == __last || __first == --__i)\n        return false;\n    while (true)\n    {\n        _BidirectionalIterator __ip1 = __i;\n        if (__comp(*--__i, *__ip1))\n        {\n            _BidirectionalIterator __j = __last;\n            while (!__comp(*__i, *--__j))\n                ;\n            swap(*__i, *__j);\n            _VSTD::reverse(__ip1, __last);\n            return true;\n        }\n        if (__i == __first)\n        {\n            _VSTD::reverse(__first, __last);\n            return false;\n        }\n    }\n}\n\ntemplate <class _BidirectionalIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nnext_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return __next_permutation<_Comp_ref>(__first, __last, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return __next_permutation<_Comp_ref>(__first, __last, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _BidirectionalIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nnext_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last)\n{\n    return _VSTD::next_permutation(__first, __last,\n                                  __less<typename iterator_traits<_BidirectionalIterator>::value_type>());\n}\n\n// prev_permutation\n\ntemplate <class _Compare, class _BidirectionalIterator>\nbool\n__prev_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last, _Compare __comp)\n{\n    _BidirectionalIterator __i = __last;\n    if (__first == __last || __first == --__i)\n        return false;\n    while (true)\n    {\n        _BidirectionalIterator __ip1 = __i;\n        if (__comp(*__ip1, *--__i))\n        {\n            _BidirectionalIterator __j = __last;\n            while (!__comp(*--__j, *__i))\n                ;\n            swap(*__i, *__j);\n            _VSTD::reverse(__ip1, __last);\n            return true;\n        }\n        if (__i == __first)\n        {\n            _VSTD::reverse(__first, __last);\n            return false;\n        }\n    }\n}\n\ntemplate <class _BidirectionalIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nprev_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return __prev_permutation<_Comp_ref>(__first, __last, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return __prev_permutation<_Comp_ref>(__first, __last, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _BidirectionalIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nprev_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last)\n{\n    return _VSTD::prev_permutation(__first, __last,\n                                  __less<typename iterator_traits<_BidirectionalIterator>::value_type>());\n}\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_ALGORITHM\n","// -*- C++ -*-\n//===-------------------------- memory ------------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_MEMORY\n#define _LIBCPP_MEMORY\n\n/*\n    memory synopsis\n\nnamespace std\n{\n\nstruct allocator_arg_t { };\nconstexpr allocator_arg_t allocator_arg = allocator_arg_t();\n\ntemplate <class T, class Alloc> struct uses_allocator;\n\ntemplate <class Ptr>\nstruct pointer_traits\n{\n    typedef Ptr pointer;\n    typedef <details> element_type;\n    typedef <details> difference_type;\n\n    template <class U> using rebind = <details>;\n\n    static pointer pointer_to(<details>);\n};\n\ntemplate <class T>\nstruct pointer_traits<T*>\n{\n    typedef T* pointer;\n    typedef T element_type;\n    typedef ptrdiff_t difference_type;\n\n    template <class U> using rebind = U*;\n\n    static pointer pointer_to(<details>) noexcept;\n};\n\ntemplate <class Alloc>\nstruct allocator_traits\n{\n    typedef Alloc                        allocator_type;\n    typedef typename allocator_type::value_type\n                                         value_type;\n\n    typedef Alloc::pointer | value_type* pointer;\n    typedef Alloc::const_pointer\n          | pointer_traits<pointer>::rebind<const value_type>\n                                         const_pointer;\n    typedef Alloc::void_pointer\n          | pointer_traits<pointer>::rebind<void>\n                                         void_pointer;\n    typedef Alloc::const_void_pointer\n          | pointer_traits<pointer>::rebind<const void>\n                                         const_void_pointer;\n    typedef Alloc::difference_type\n          | pointer_traits<pointer>::difference_type\n                                         difference_type;\n    typedef Alloc::size_type\n          | make_unsigned<difference_type>::type\n                                         size_type;\n    typedef Alloc::propagate_on_container_copy_assignment\n          | false_type                   propagate_on_container_copy_assignment;\n    typedef Alloc::propagate_on_container_move_assignment\n          | false_type                   propagate_on_container_move_assignment;\n    typedef Alloc::propagate_on_container_swap\n          | false_type                   propagate_on_container_swap;\n    typedef Alloc::is_always_equal\n          | is_empty                     is_always_equal;\n\n    template <class T> using rebind_alloc  = Alloc::rebind<U>::other | Alloc<T, Args...>;\n    template <class T> using rebind_traits = allocator_traits<rebind_alloc<T>>;\n\n    static pointer allocate(allocator_type& a, size_type n);\n    static pointer allocate(allocator_type& a, size_type n, const_void_pointer hint);\n\n    static void deallocate(allocator_type& a, pointer p, size_type n) noexcept;\n\n    template <class T, class... Args>\n        static void construct(allocator_type& a, T* p, Args&&... args);\n\n    template <class T>\n        static void destroy(allocator_type& a, T* p);\n\n    static size_type max_size(const allocator_type& a); // noexcept in C++14\n\n    static allocator_type\n        select_on_container_copy_construction(const allocator_type& a);\n};\n\ntemplate <>\nclass allocator<void>\n{\npublic:\n    typedef void*                                 pointer;\n    typedef const void*                           const_pointer;\n    typedef void                                  value_type;\n\n    template <class _Up> struct rebind {typedef allocator<_Up> other;};\n};\n\ntemplate <class T>\nclass allocator\n{\npublic:\n    typedef size_t                                size_type;\n    typedef ptrdiff_t                             difference_type;\n    typedef T*                                    pointer;\n    typedef const T*                              const_pointer;\n    typedef typename add_lvalue_reference<T>::type       reference;\n    typedef typename add_lvalue_reference<const T>::type const_reference;\n    typedef T                                     value_type;\n\n    template <class U> struct rebind {typedef allocator<U> other;};\n\n    allocator() noexcept;\n    allocator(const allocator&) noexcept;\n    template <class U> allocator(const allocator<U>&) noexcept;\n    ~allocator();\n    pointer address(reference x) const noexcept;\n    const_pointer address(const_reference x) const noexcept;\n    pointer allocate(size_type, allocator<void>::const_pointer hint = 0);\n    void deallocate(pointer p, size_type n) noexcept;\n    size_type max_size() const noexcept;\n    template<class U, class... Args>\n        void construct(U* p, Args&&... args);\n    template <class U>\n        void destroy(U* p);\n};\n\ntemplate <class T, class U>\nbool operator==(const allocator<T>&, const allocator<U>&) noexcept;\n\ntemplate <class T, class U>\nbool operator!=(const allocator<T>&, const allocator<U>&) noexcept;\n\ntemplate <class OutputIterator, class T>\nclass raw_storage_iterator\n    : public iterator<output_iterator_tag,\n                      T,                               // purposefully not C++03\n                      ptrdiff_t,                       // purposefully not C++03\n                      T*,                              // purposefully not C++03\n                      raw_storage_iterator&>           // purposefully not C++03\n{\npublic:\n    explicit raw_storage_iterator(OutputIterator x);\n    raw_storage_iterator& operator*();\n    raw_storage_iterator& operator=(const T& element);\n    raw_storage_iterator& operator++();\n    raw_storage_iterator  operator++(int);\n};\n\ntemplate <class T> pair<T*,ptrdiff_t> get_temporary_buffer(ptrdiff_t n) noexcept;\ntemplate <class T> void               return_temporary_buffer(T* p) noexcept;\n\ntemplate <class T> T* addressof(T& r) noexcept;\ntemplate <class T> T* addressof(const T&& r) noexcept = delete;\n\ntemplate <class InputIterator, class ForwardIterator>\nForwardIterator\nuninitialized_copy(InputIterator first, InputIterator last, ForwardIterator result);\n\ntemplate <class InputIterator, class Size, class ForwardIterator>\nForwardIterator\nuninitialized_copy_n(InputIterator first, Size n, ForwardIterator result);\n\ntemplate <class ForwardIterator, class T>\nvoid uninitialized_fill(ForwardIterator first, ForwardIterator last, const T& x);\n\ntemplate <class ForwardIterator, class Size, class T>\nForwardIterator\nuninitialized_fill_n(ForwardIterator first, Size n, const T& x);\n\ntemplate <class T>\nvoid destroy_at(T* location);\n\ntemplate <class ForwardIterator>\n void destroy(ForwardIterator first, ForwardIterator last);\n\ntemplate <class ForwardIterator, class Size>\n ForwardIterator destroy_n(ForwardIterator first, Size n);\n\ntemplate <class InputIterator, class ForwardIterator>\n ForwardIterator uninitialized_move(InputIterator first, InputIterator last, ForwardIterator result);\n\ntemplate <class InputIterator, class Size, class ForwardIterator>\n pair<InputIterator,ForwardIterator> uninitialized_move_n(InputIterator first, Size n, ForwardIterator result);\n\ntemplate <class ForwardIterator>\n void uninitialized_value_construct(ForwardIterator first, ForwardIterator last);\n\ntemplate <class ForwardIterator, class Size>\n ForwardIterator uninitialized_value_construct_n(ForwardIterator first, Size n);\n\ntemplate <class ForwardIterator>\n void uninitialized_default_construct(ForwardIterator first, ForwardIterator last);\n\ntemplate <class ForwardIterator, class Size>\n ForwardIterator uninitialized_default_construct_n(ForwardIterator first, Size n);\n\ntemplate <class Y> struct auto_ptr_ref {};\n\ntemplate<class X>\nclass auto_ptr\n{\npublic:\n    typedef X element_type;\n\n    explicit auto_ptr(X* p =0) throw();\n    auto_ptr(auto_ptr&) throw();\n    template<class Y> auto_ptr(auto_ptr<Y>&) throw();\n    auto_ptr& operator=(auto_ptr&) throw();\n    template<class Y> auto_ptr& operator=(auto_ptr<Y>&) throw();\n    auto_ptr& operator=(auto_ptr_ref<X> r) throw();\n    ~auto_ptr() throw();\n\n    typename add_lvalue_reference<X>::type operator*() const throw();\n    X* operator->() const throw();\n    X* get() const throw();\n    X* release() throw();\n    void reset(X* p =0) throw();\n\n    auto_ptr(auto_ptr_ref<X>) throw();\n    template<class Y> operator auto_ptr_ref<Y>() throw();\n    template<class Y> operator auto_ptr<Y>() throw();\n};\n\ntemplate <class T>\nstruct default_delete\n{\n    constexpr default_delete() noexcept = default;\n    template <class U> default_delete(const default_delete<U>&) noexcept;\n\n    void operator()(T*) const noexcept;\n};\n\ntemplate <class T>\nstruct default_delete<T[]>\n{\n    constexpr default_delete() noexcept = default;\n    void operator()(T*) const noexcept;\n    template <class U> void operator()(U*) const = delete;\n};\n\ntemplate <class T, class D = default_delete<T>>\nclass unique_ptr\n{\npublic:\n    typedef see below pointer;\n    typedef T element_type;\n    typedef D deleter_type;\n\n    // constructors\n    constexpr unique_ptr() noexcept;\n    explicit unique_ptr(pointer p) noexcept;\n    unique_ptr(pointer p, see below d1) noexcept;\n    unique_ptr(pointer p, see below d2) noexcept;\n    unique_ptr(unique_ptr&& u) noexcept;\n    unique_ptr(nullptr_t) noexcept : unique_ptr() { }\n    template <class U, class E>\n        unique_ptr(unique_ptr<U, E>&& u) noexcept;\n    template <class U>\n        unique_ptr(auto_ptr<U>&& u) noexcept;\n\n    // destructor\n    ~unique_ptr();\n\n    // assignment\n    unique_ptr& operator=(unique_ptr&& u) noexcept;\n    template <class U, class E> unique_ptr& operator=(unique_ptr<U, E>&& u) noexcept;\n    unique_ptr& operator=(nullptr_t) noexcept;\n\n    // observers\n    typename add_lvalue_reference<T>::type operator*() const;\n    pointer operator->() const noexcept;\n    pointer get() const noexcept;\n    deleter_type& get_deleter() noexcept;\n    const deleter_type& get_deleter() const noexcept;\n    explicit operator bool() const noexcept;\n\n    // modifiers\n    pointer release() noexcept;\n    void reset(pointer p = pointer()) noexcept;\n    void swap(unique_ptr& u) noexcept;\n};\n\ntemplate <class T, class D>\nclass unique_ptr<T[], D>\n{\npublic:\n    typedef implementation-defined pointer;\n    typedef T element_type;\n    typedef D deleter_type;\n\n    // constructors\n    constexpr unique_ptr() noexcept;\n    explicit unique_ptr(pointer p) noexcept;\n    unique_ptr(pointer p, see below d) noexcept;\n    unique_ptr(pointer p, see below d) noexcept;\n    unique_ptr(unique_ptr&& u) noexcept;\n    unique_ptr(nullptr_t) noexcept : unique_ptr() { }\n\n    // destructor\n    ~unique_ptr();\n\n    // assignment\n    unique_ptr& operator=(unique_ptr&& u) noexcept;\n    unique_ptr& operator=(nullptr_t) noexcept;\n\n    // observers\n    T& operator[](size_t i) const;\n    pointer get() const noexcept;\n    deleter_type& get_deleter() noexcept;\n    const deleter_type& get_deleter() const noexcept;\n    explicit operator bool() const noexcept;\n\n    // modifiers\n    pointer release() noexcept;\n    void reset(pointer p = pointer()) noexcept;\n    void reset(nullptr_t) noexcept;\n    template <class U> void reset(U) = delete;\n    void swap(unique_ptr& u) noexcept;\n};\n\ntemplate <class T, class D>\n    void swap(unique_ptr<T, D>& x, unique_ptr<T, D>& y) noexcept;\n\ntemplate <class T1, class D1, class T2, class D2>\n    bool operator==(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);\ntemplate <class T1, class D1, class T2, class D2>\n    bool operator!=(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);\ntemplate <class T1, class D1, class T2, class D2>\n    bool operator<(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);\ntemplate <class T1, class D1, class T2, class D2>\n    bool operator<=(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);\ntemplate <class T1, class D1, class T2, class D2>\n    bool operator>(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);\ntemplate <class T1, class D1, class T2, class D2>\n    bool operator>=(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);\n\ntemplate <class T, class D>\n    bool operator==(const unique_ptr<T, D>& x, nullptr_t) noexcept;\ntemplate <class T, class D>\n    bool operator==(nullptr_t, const unique_ptr<T, D>& y) noexcept;\ntemplate <class T, class D>\n    bool operator!=(const unique_ptr<T, D>& x, nullptr_t) noexcept;\ntemplate <class T, class D>\n    bool operator!=(nullptr_t, const unique_ptr<T, D>& y) noexcept;\n\ntemplate <class T, class D>\n    bool operator<(const unique_ptr<T, D>& x, nullptr_t);\ntemplate <class T, class D>\n    bool operator<(nullptr_t, const unique_ptr<T, D>& y);\ntemplate <class T, class D>\n    bool operator<=(const unique_ptr<T, D>& x, nullptr_t);\ntemplate <class T, class D>\n    bool operator<=(nullptr_t, const unique_ptr<T, D>& y);\ntemplate <class T, class D>\n    bool operator>(const unique_ptr<T, D>& x, nullptr_t);\ntemplate <class T, class D>\n    bool operator>(nullptr_t, const unique_ptr<T, D>& y);\ntemplate <class T, class D>\n    bool operator>=(const unique_ptr<T, D>& x, nullptr_t);\ntemplate <class T, class D>\n    bool operator>=(nullptr_t, const unique_ptr<T, D>& y);\n\nclass bad_weak_ptr\n    : public std::exception\n{\n    bad_weak_ptr() noexcept;\n};\n\ntemplate<class T, class... Args> unique_ptr<T> make_unique(Args&&... args);     // C++14\ntemplate<class T>                unique_ptr<T> make_unique(size_t n);           // C++14\ntemplate<class T, class... Args> unspecified   make_unique(Args&&...) = delete; // C++14, T == U[N]\n\ntemplate<class T>\nclass shared_ptr\n{\npublic:\n    typedef T element_type;\n    typedef weak_ptr<T> weak_type; // C++17\n\n    // constructors:\n    constexpr shared_ptr() noexcept;\n    template<class Y> explicit shared_ptr(Y* p);\n    template<class Y, class D> shared_ptr(Y* p, D d);\n    template<class Y, class D, class A> shared_ptr(Y* p, D d, A a);\n    template <class D> shared_ptr(nullptr_t p, D d);\n    template <class D, class A> shared_ptr(nullptr_t p, D d, A a);\n    template<class Y> shared_ptr(const shared_ptr<Y>& r, T *p) noexcept;\n    shared_ptr(const shared_ptr& r) noexcept;\n    template<class Y> shared_ptr(const shared_ptr<Y>& r) noexcept;\n    shared_ptr(shared_ptr&& r) noexcept;\n    template<class Y> shared_ptr(shared_ptr<Y>&& r) noexcept;\n    template<class Y> explicit shared_ptr(const weak_ptr<Y>& r);\n    template<class Y> shared_ptr(auto_ptr<Y>&& r);\n    template <class Y, class D> shared_ptr(unique_ptr<Y, D>&& r);\n    shared_ptr(nullptr_t) : shared_ptr() { }\n\n    // destructor:\n    ~shared_ptr();\n\n    // assignment:\n    shared_ptr& operator=(const shared_ptr& r) noexcept;\n    template<class Y> shared_ptr& operator=(const shared_ptr<Y>& r) noexcept;\n    shared_ptr& operator=(shared_ptr&& r) noexcept;\n    template<class Y> shared_ptr& operator=(shared_ptr<Y>&& r);\n    template<class Y> shared_ptr& operator=(auto_ptr<Y>&& r);\n    template <class Y, class D> shared_ptr& operator=(unique_ptr<Y, D>&& r);\n\n    // modifiers:\n    void swap(shared_ptr& r) noexcept;\n    void reset() noexcept;\n    template<class Y> void reset(Y* p);\n    template<class Y, class D> void reset(Y* p, D d);\n    template<class Y, class D, class A> void reset(Y* p, D d, A a);\n\n    // observers:\n    T* get() const noexcept;\n    T& operator*() const noexcept;\n    T* operator->() const noexcept;\n    long use_count() const noexcept;\n    bool unique() const noexcept;\n    explicit operator bool() const noexcept;\n    template<class U> bool owner_before(shared_ptr<U> const& b) const;\n    template<class U> bool owner_before(weak_ptr<U> const& b) const;\n};\n\n// shared_ptr comparisons:\ntemplate<class T, class U>\n    bool operator==(shared_ptr<T> const& a, shared_ptr<U> const& b) noexcept;\ntemplate<class T, class U>\n    bool operator!=(shared_ptr<T> const& a, shared_ptr<U> const& b) noexcept;\ntemplate<class T, class U>\n    bool operator<(shared_ptr<T> const& a, shared_ptr<U> const& b) noexcept;\ntemplate<class T, class U>\n    bool operator>(shared_ptr<T> const& a, shared_ptr<U> const& b) noexcept;\ntemplate<class T, class U>\n    bool operator<=(shared_ptr<T> const& a, shared_ptr<U> const& b) noexcept;\ntemplate<class T, class U>\n    bool operator>=(shared_ptr<T> const& a, shared_ptr<U> const& b) noexcept;\n\ntemplate <class T>\n    bool operator==(const shared_ptr<T>& x, nullptr_t) noexcept;\ntemplate <class T>\n    bool operator==(nullptr_t, const shared_ptr<T>& y) noexcept;\ntemplate <class T>\n    bool operator!=(const shared_ptr<T>& x, nullptr_t) noexcept;\ntemplate <class T>\n    bool operator!=(nullptr_t, const shared_ptr<T>& y) noexcept;\ntemplate <class T>\n    bool operator<(const shared_ptr<T>& x, nullptr_t) noexcept;\ntemplate <class T>\nbool operator<(nullptr_t, const shared_ptr<T>& y) noexcept;\ntemplate <class T>\n    bool operator<=(const shared_ptr<T>& x, nullptr_t) noexcept;\ntemplate <class T>\n    bool operator<=(nullptr_t, const shared_ptr<T>& y) noexcept;\ntemplate <class T>\n    bool operator>(const shared_ptr<T>& x, nullptr_t) noexcept;\ntemplate <class T>\n    bool operator>(nullptr_t, const shared_ptr<T>& y) noexcept;\ntemplate <class T>\n    bool operator>=(const shared_ptr<T>& x, nullptr_t) noexcept;\ntemplate <class T>\n    bool operator>=(nullptr_t, const shared_ptr<T>& y) noexcept;\n\n// shared_ptr specialized algorithms:\ntemplate<class T> void swap(shared_ptr<T>& a, shared_ptr<T>& b) noexcept;\n\n// shared_ptr casts:\ntemplate<class T, class U>\n    shared_ptr<T> static_pointer_cast(shared_ptr<U> const& r) noexcept;\ntemplate<class T, class U>\n    shared_ptr<T> dynamic_pointer_cast(shared_ptr<U> const& r) noexcept;\ntemplate<class T, class U>\n    shared_ptr<T> const_pointer_cast(shared_ptr<U> const& r) noexcept;\n\n// shared_ptr I/O:\ntemplate<class E, class T, class Y>\n    basic_ostream<E, T>& operator<< (basic_ostream<E, T>& os, shared_ptr<Y> const& p);\n\n// shared_ptr get_deleter:\ntemplate<class D, class T> D* get_deleter(shared_ptr<T> const& p) noexcept;\n\ntemplate<class T, class... Args>\n    shared_ptr<T> make_shared(Args&&... args);\ntemplate<class T, class A, class... Args>\n    shared_ptr<T> allocate_shared(const A& a, Args&&... args);\n\ntemplate<class T>\nclass weak_ptr\n{\npublic:\n    typedef T element_type;\n\n    // constructors\n    constexpr weak_ptr() noexcept;\n    template<class Y> weak_ptr(shared_ptr<Y> const& r) noexcept;\n    weak_ptr(weak_ptr const& r) noexcept;\n    template<class Y> weak_ptr(weak_ptr<Y> const& r) noexcept;\n    weak_ptr(weak_ptr&& r) noexcept;                      // C++14\n    template<class Y> weak_ptr(weak_ptr<Y>&& r) noexcept; // C++14\n\n    // destructor\n    ~weak_ptr();\n\n    // assignment\n    weak_ptr& operator=(weak_ptr const& r) noexcept;\n    template<class Y> weak_ptr& operator=(weak_ptr<Y> const& r) noexcept;\n    template<class Y> weak_ptr& operator=(shared_ptr<Y> const& r) noexcept;\n    weak_ptr& operator=(weak_ptr&& r) noexcept;                      // C++14\n    template<class Y> weak_ptr& operator=(weak_ptr<Y>&& r) noexcept; // C++14\n\n    // modifiers\n    void swap(weak_ptr& r) noexcept;\n    void reset() noexcept;\n\n    // observers\n    long use_count() const noexcept;\n    bool expired() const noexcept;\n    shared_ptr<T> lock() const noexcept;\n    template<class U> bool owner_before(shared_ptr<U> const& b) const;\n    template<class U> bool owner_before(weak_ptr<U> const& b) const;\n};\n\n// weak_ptr specialized algorithms:\ntemplate<class T> void swap(weak_ptr<T>& a, weak_ptr<T>& b) noexcept;\n\n// class owner_less:\ntemplate<class T> struct owner_less;\n\ntemplate<class T>\nstruct owner_less<shared_ptr<T>>\n    : binary_function<shared_ptr<T>, shared_ptr<T>, bool>\n{\n    typedef bool result_type;\n    bool operator()(shared_ptr<T> const&, shared_ptr<T> const&) const;\n    bool operator()(shared_ptr<T> const&, weak_ptr<T> const&) const;\n    bool operator()(weak_ptr<T> const&, shared_ptr<T> const&) const;\n};\n\ntemplate<class T>\nstruct owner_less<weak_ptr<T>>\n    : binary_function<weak_ptr<T>, weak_ptr<T>, bool>\n{\n    typedef bool result_type;\n    bool operator()(weak_ptr<T> const&, weak_ptr<T> const&) const;\n    bool operator()(shared_ptr<T> const&, weak_ptr<T> const&) const;\n    bool operator()(weak_ptr<T> const&, shared_ptr<T> const&) const;\n};\n\ntemplate<class T>\nclass enable_shared_from_this\n{\nprotected:\n    constexpr enable_shared_from_this() noexcept;\n    enable_shared_from_this(enable_shared_from_this const&) noexcept;\n    enable_shared_from_this& operator=(enable_shared_from_this const&) noexcept;\n    ~enable_shared_from_this();\npublic:\n    shared_ptr<T> shared_from_this();\n    shared_ptr<T const> shared_from_this() const;\n};\n\ntemplate<class T>\n    bool atomic_is_lock_free(const shared_ptr<T>* p);\ntemplate<class T>\n    shared_ptr<T> atomic_load(const shared_ptr<T>* p);\ntemplate<class T>\n    shared_ptr<T> atomic_load_explicit(const shared_ptr<T>* p, memory_order mo);\ntemplate<class T>\n    void atomic_store(shared_ptr<T>* p, shared_ptr<T> r);\ntemplate<class T>\n    void atomic_store_explicit(shared_ptr<T>* p, shared_ptr<T> r, memory_order mo);\ntemplate<class T>\n    shared_ptr<T> atomic_exchange(shared_ptr<T>* p, shared_ptr<T> r);\ntemplate<class T>\n    shared_ptr<T>\n    atomic_exchange_explicit(shared_ptr<T>* p, shared_ptr<T> r, memory_order mo);\ntemplate<class T>\n    bool\n    atomic_compare_exchange_weak(shared_ptr<T>* p, shared_ptr<T>* v, shared_ptr<T> w);\ntemplate<class T>\n    bool\n    atomic_compare_exchange_strong( shared_ptr<T>* p, shared_ptr<T>* v, shared_ptr<T> w);\ntemplate<class T>\n    bool\n    atomic_compare_exchange_weak_explicit(shared_ptr<T>* p, shared_ptr<T>* v,\n                                          shared_ptr<T> w, memory_order success,\n                                          memory_order failure);\ntemplate<class T>\n    bool\n    atomic_compare_exchange_strong_explicit(shared_ptr<T>* p, shared_ptr<T>* v,\n                                            shared_ptr<T> w, memory_order success,\n                                            memory_order failure);\n// Hash support\ntemplate <class T> struct hash;\ntemplate <class T, class D> struct hash<unique_ptr<T, D> >;\ntemplate <class T> struct hash<shared_ptr<T> >;\n\n// Pointer safety\nenum class pointer_safety { relaxed, preferred, strict };\nvoid declare_reachable(void *p);\ntemplate <class T> T *undeclare_reachable(T *p);\nvoid declare_no_pointers(char *p, size_t n);\nvoid undeclare_no_pointers(char *p, size_t n);\npointer_safety get_pointer_safety() noexcept;\n\nvoid* align(size_t alignment, size_t size, void*& ptr, size_t& space);\n\n}  // std\n\n*/\n\n#include <__config>\n#include <type_traits>\n#include <typeinfo>\n#include <cstddef>\n#include <cstdint>\n#include <new>\n#include <utility>\n#include <limits>\n#include <iterator>\n#include <__functional_base>\n#include <iosfwd>\n#include <tuple>\n#include <stdexcept>\n#include <cstring>\n\n#if !defined(_LIBCPP_HAS_NO_ATOMIC_HEADER)\n#  include <atomic>\n#endif\n\n#include <__undef_min_max>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\ntemplate <class _ValueType>\ninline _LIBCPP_ALWAYS_INLINE\n_ValueType __libcpp_relaxed_load(_ValueType const* __value) {\n#if !defined(_LIBCPP_HAS_NO_THREADS) && \\\n    defined(__ATOMIC_RELAXED) &&        \\\n    (__has_builtin(__atomic_load_n) || _GNUC_VER >= 407)\n    return __atomic_load_n(__value, __ATOMIC_RELAXED);\n#else\n    return *__value;\n#endif\n}\n\ntemplate <class _ValueType>\ninline _LIBCPP_ALWAYS_INLINE\n_ValueType __libcpp_acquire_load(_ValueType const* __value) {\n#if !defined(_LIBCPP_HAS_NO_THREADS) && \\\n    defined(__ATOMIC_ACQUIRE) &&        \\\n    (__has_builtin(__atomic_load_n) || _GNUC_VER >= 407)\n    return __atomic_load_n(__value, __ATOMIC_ACQUIRE);\n#else\n    return *__value;\n#endif\n}\n\n// addressof moved to <type_traits>\n\ntemplate <class _Tp> class allocator;\n\ntemplate <>\nclass _LIBCPP_TEMPLATE_VIS allocator<void>\n{\npublic:\n    typedef void*             pointer;\n    typedef const void*       const_pointer;\n    typedef void              value_type;\n\n    template <class _Up> struct rebind {typedef allocator<_Up> other;};\n};\n\ntemplate <>\nclass _LIBCPP_TEMPLATE_VIS allocator<const void>\n{\npublic:\n    typedef const void*       pointer;\n    typedef const void*       const_pointer;\n    typedef const void        value_type;\n\n    template <class _Up> struct rebind {typedef allocator<_Up> other;};\n};\n\n// pointer_traits\n\ntemplate <class _Tp>\nstruct __has_element_type\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::element_type* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Ptr, bool = __has_element_type<_Ptr>::value>\nstruct __pointer_traits_element_type;\n\ntemplate <class _Ptr>\nstruct __pointer_traits_element_type<_Ptr, true>\n{\n    typedef typename _Ptr::element_type type;\n};\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <template <class, class...> class _Sp, class _Tp, class ..._Args>\nstruct __pointer_traits_element_type<_Sp<_Tp, _Args...>, true>\n{\n    typedef typename _Sp<_Tp, _Args...>::element_type type;\n};\n\ntemplate <template <class, class...> class _Sp, class _Tp, class ..._Args>\nstruct __pointer_traits_element_type<_Sp<_Tp, _Args...>, false>\n{\n    typedef _Tp type;\n};\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <template <class> class _Sp, class _Tp>\nstruct __pointer_traits_element_type<_Sp<_Tp>, true>\n{\n    typedef typename _Sp<_Tp>::element_type type;\n};\n\ntemplate <template <class> class _Sp, class _Tp>\nstruct __pointer_traits_element_type<_Sp<_Tp>, false>\n{\n    typedef _Tp type;\n};\n\ntemplate <template <class, class> class _Sp, class _Tp, class _A0>\nstruct __pointer_traits_element_type<_Sp<_Tp, _A0>, true>\n{\n    typedef typename _Sp<_Tp, _A0>::element_type type;\n};\n\ntemplate <template <class, class> class _Sp, class _Tp, class _A0>\nstruct __pointer_traits_element_type<_Sp<_Tp, _A0>, false>\n{\n    typedef _Tp type;\n};\n\ntemplate <template <class, class, class> class _Sp, class _Tp, class _A0, class _A1>\nstruct __pointer_traits_element_type<_Sp<_Tp, _A0, _A1>, true>\n{\n    typedef typename _Sp<_Tp, _A0, _A1>::element_type type;\n};\n\ntemplate <template <class, class, class> class _Sp, class _Tp, class _A0, class _A1>\nstruct __pointer_traits_element_type<_Sp<_Tp, _A0, _A1>, false>\n{\n    typedef _Tp type;\n};\n\ntemplate <template <class, class, class, class> class _Sp, class _Tp, class _A0,\n                                                           class _A1, class _A2>\nstruct __pointer_traits_element_type<_Sp<_Tp, _A0, _A1, _A2>, true>\n{\n    typedef typename _Sp<_Tp, _A0, _A1, _A2>::element_type type;\n};\n\ntemplate <template <class, class, class, class> class _Sp, class _Tp, class _A0,\n                                                           class _A1, class _A2>\nstruct __pointer_traits_element_type<_Sp<_Tp, _A0, _A1, _A2>, false>\n{\n    typedef _Tp type;\n};\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Tp>\nstruct __has_difference_type\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::difference_type* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Ptr, bool = __has_difference_type<_Ptr>::value>\nstruct __pointer_traits_difference_type\n{\n    typedef ptrdiff_t type;\n};\n\ntemplate <class _Ptr>\nstruct __pointer_traits_difference_type<_Ptr, true>\n{\n    typedef typename _Ptr::difference_type type;\n};\n\ntemplate <class _Tp, class _Up>\nstruct __has_rebind\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Xp> static __two __test(...);\n    template <class _Xp> static char __test(typename _Xp::template rebind<_Up>* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Tp, class _Up, bool = __has_rebind<_Tp, _Up>::value>\nstruct __pointer_traits_rebind\n{\n#ifndef _LIBCPP_CXX03_LANG\n    typedef typename _Tp::template rebind<_Up> type;\n#else\n    typedef typename _Tp::template rebind<_Up>::other type;\n#endif\n};\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <template <class, class...> class _Sp, class _Tp, class ..._Args, class _Up>\nstruct __pointer_traits_rebind<_Sp<_Tp, _Args...>, _Up, true>\n{\n#ifndef _LIBCPP_CXX03_LANG\n    typedef typename _Sp<_Tp, _Args...>::template rebind<_Up> type;\n#else\n    typedef typename _Sp<_Tp, _Args...>::template rebind<_Up>::other type;\n#endif\n};\n\ntemplate <template <class, class...> class _Sp, class _Tp, class ..._Args, class _Up>\nstruct __pointer_traits_rebind<_Sp<_Tp, _Args...>, _Up, false>\n{\n    typedef _Sp<_Up, _Args...> type;\n};\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <template <class> class _Sp, class _Tp, class _Up>\nstruct __pointer_traits_rebind<_Sp<_Tp>, _Up, true>\n{\n#ifndef _LIBCPP_CXX03_LANG\n    typedef typename _Sp<_Tp>::template rebind<_Up> type;\n#else\n    typedef typename _Sp<_Tp>::template rebind<_Up>::other type;\n#endif\n};\n\ntemplate <template <class> class _Sp, class _Tp, class _Up>\nstruct __pointer_traits_rebind<_Sp<_Tp>, _Up, false>\n{\n    typedef _Sp<_Up> type;\n};\n\ntemplate <template <class, class> class _Sp, class _Tp, class _A0, class _Up>\nstruct __pointer_traits_rebind<_Sp<_Tp, _A0>, _Up, true>\n{\n#ifndef _LIBCPP_CXX03_LANG\n    typedef typename _Sp<_Tp, _A0>::template rebind<_Up> type;\n#else\n    typedef typename _Sp<_Tp, _A0>::template rebind<_Up>::other type;\n#endif\n};\n\ntemplate <template <class, class> class _Sp, class _Tp, class _A0, class _Up>\nstruct __pointer_traits_rebind<_Sp<_Tp, _A0>, _Up, false>\n{\n    typedef _Sp<_Up, _A0> type;\n};\n\ntemplate <template <class, class, class> class _Sp, class _Tp, class _A0,\n                                         class _A1, class _Up>\nstruct __pointer_traits_rebind<_Sp<_Tp, _A0, _A1>, _Up, true>\n{\n#ifndef _LIBCPP_CXX03_LANG\n    typedef typename _Sp<_Tp, _A0, _A1>::template rebind<_Up> type;\n#else\n    typedef typename _Sp<_Tp, _A0, _A1>::template rebind<_Up>::other type;\n#endif\n};\n\ntemplate <template <class, class, class> class _Sp, class _Tp, class _A0,\n                                         class _A1, class _Up>\nstruct __pointer_traits_rebind<_Sp<_Tp, _A0, _A1>, _Up, false>\n{\n    typedef _Sp<_Up, _A0, _A1> type;\n};\n\ntemplate <template <class, class, class, class> class _Sp, class _Tp, class _A0,\n                                                class _A1, class _A2, class _Up>\nstruct __pointer_traits_rebind<_Sp<_Tp, _A0, _A1, _A2>, _Up, true>\n{\n#ifndef _LIBCPP_CXX03_LANG\n    typedef typename _Sp<_Tp, _A0, _A1, _A2>::template rebind<_Up> type;\n#else\n    typedef typename _Sp<_Tp, _A0, _A1, _A2>::template rebind<_Up>::other type;\n#endif\n};\n\ntemplate <template <class, class, class, class> class _Sp, class _Tp, class _A0,\n                                                class _A1, class _A2, class _Up>\nstruct __pointer_traits_rebind<_Sp<_Tp, _A0, _A1, _A2>, _Up, false>\n{\n    typedef _Sp<_Up, _A0, _A1, _A2> type;\n};\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Ptr>\nstruct _LIBCPP_TEMPLATE_VIS pointer_traits\n{\n    typedef _Ptr                                                     pointer;\n    typedef typename __pointer_traits_element_type<pointer>::type    element_type;\n    typedef typename __pointer_traits_difference_type<pointer>::type difference_type;\n\n#ifndef _LIBCPP_CXX03_LANG\n    template <class _Up> using rebind = typename __pointer_traits_rebind<pointer, _Up>::type;\n#else\n    template <class _Up> struct rebind\n        {typedef typename __pointer_traits_rebind<pointer, _Up>::type other;};\n#endif  // _LIBCPP_CXX03_LANG\n\nprivate:\n    struct __nat {};\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    static pointer pointer_to(typename conditional<is_void<element_type>::value,\n                                           __nat, element_type>::type& __r)\n        {return pointer::pointer_to(__r);}\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS pointer_traits<_Tp*>\n{\n    typedef _Tp*      pointer;\n    typedef _Tp       element_type;\n    typedef ptrdiff_t difference_type;\n\n#ifndef _LIBCPP_CXX03_LANG\n    template <class _Up> using rebind = _Up*;\n#else\n    template <class _Up> struct rebind {typedef _Up* other;};\n#endif\n\nprivate:\n    struct __nat {};\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    static pointer pointer_to(typename conditional<is_void<element_type>::value,\n                                      __nat, element_type>::type& __r) _NOEXCEPT\n        {return _VSTD::addressof(__r);}\n};\n\ntemplate <class _From, class _To>\nstruct __rebind_pointer {\n#ifndef _LIBCPP_CXX03_LANG\n    typedef typename pointer_traits<_From>::template rebind<_To>        type;\n#else\n    typedef typename pointer_traits<_From>::template rebind<_To>::other type;\n#endif\n};\n\n// allocator_traits\n\nnamespace __has_pointer_type_imp\n{\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::pointer* = 0);\n}\n\ntemplate <class _Tp>\nstruct __has_pointer_type\n    : public integral_constant<bool, sizeof(__has_pointer_type_imp::__test<_Tp>(0)) == 1>\n{\n};\n\nnamespace __pointer_type_imp\n{\n\ntemplate <class _Tp, class _Dp, bool = __has_pointer_type<_Dp>::value>\nstruct __pointer_type\n{\n    typedef typename _Dp::pointer type;\n};\n\ntemplate <class _Tp, class _Dp>\nstruct __pointer_type<_Tp, _Dp, false>\n{\n    typedef _Tp* type;\n};\n\n}  // __pointer_type_imp\n\ntemplate <class _Tp, class _Dp>\nstruct __pointer_type\n{\n    typedef typename __pointer_type_imp::__pointer_type<_Tp, typename remove_reference<_Dp>::type>::type type;\n};\n\ntemplate <class _Tp>\nstruct __has_const_pointer\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::const_pointer* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Tp, class _Ptr, class _Alloc, bool = __has_const_pointer<_Alloc>::value>\nstruct __const_pointer\n{\n    typedef typename _Alloc::const_pointer type;\n};\n\ntemplate <class _Tp, class _Ptr, class _Alloc>\nstruct __const_pointer<_Tp, _Ptr, _Alloc, false>\n{\n#ifndef _LIBCPP_CXX03_LANG\n    typedef typename pointer_traits<_Ptr>::template rebind<const _Tp> type;\n#else\n    typedef typename pointer_traits<_Ptr>::template rebind<const _Tp>::other type;\n#endif\n};\n\ntemplate <class _Tp>\nstruct __has_void_pointer\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::void_pointer* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Ptr, class _Alloc, bool = __has_void_pointer<_Alloc>::value>\nstruct __void_pointer\n{\n    typedef typename _Alloc::void_pointer type;\n};\n\ntemplate <class _Ptr, class _Alloc>\nstruct __void_pointer<_Ptr, _Alloc, false>\n{\n#ifndef _LIBCPP_CXX03_LANG\n    typedef typename pointer_traits<_Ptr>::template rebind<void> type;\n#else\n    typedef typename pointer_traits<_Ptr>::template rebind<void>::other type;\n#endif\n};\n\ntemplate <class _Tp>\nstruct __has_const_void_pointer\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::const_void_pointer* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Ptr, class _Alloc, bool = __has_const_void_pointer<_Alloc>::value>\nstruct __const_void_pointer\n{\n    typedef typename _Alloc::const_void_pointer type;\n};\n\ntemplate <class _Ptr, class _Alloc>\nstruct __const_void_pointer<_Ptr, _Alloc, false>\n{\n#ifndef _LIBCPP_CXX03_LANG\n    typedef typename pointer_traits<_Ptr>::template rebind<const void> type;\n#else\n    typedef typename pointer_traits<_Ptr>::template rebind<const void>::other type;\n#endif\n};\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_Tp*\n__to_raw_pointer(_Tp* __p) _NOEXCEPT\n{\n    return __p;\n}\n\ntemplate <class _Pointer>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename pointer_traits<_Pointer>::element_type*\n__to_raw_pointer(_Pointer __p) _NOEXCEPT\n{\n    return _VSTD::__to_raw_pointer(__p.operator->());\n}\n\ntemplate <class _Tp>\nstruct __has_size_type\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::size_type* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Alloc, class _DiffType, bool = __has_size_type<_Alloc>::value>\nstruct __size_type\n{\n    typedef typename make_unsigned<_DiffType>::type type;\n};\n\ntemplate <class _Alloc, class _DiffType>\nstruct __size_type<_Alloc, _DiffType, true>\n{\n    typedef typename _Alloc::size_type type;\n};\n\ntemplate <class _Tp>\nstruct __has_propagate_on_container_copy_assignment\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::propagate_on_container_copy_assignment* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Alloc, bool = __has_propagate_on_container_copy_assignment<_Alloc>::value>\nstruct __propagate_on_container_copy_assignment\n{\n    typedef false_type type;\n};\n\ntemplate <class _Alloc>\nstruct __propagate_on_container_copy_assignment<_Alloc, true>\n{\n    typedef typename _Alloc::propagate_on_container_copy_assignment type;\n};\n\ntemplate <class _Tp>\nstruct __has_propagate_on_container_move_assignment\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::propagate_on_container_move_assignment* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Alloc, bool = __has_propagate_on_container_move_assignment<_Alloc>::value>\nstruct __propagate_on_container_move_assignment\n{\n    typedef false_type type;\n};\n\ntemplate <class _Alloc>\nstruct __propagate_on_container_move_assignment<_Alloc, true>\n{\n    typedef typename _Alloc::propagate_on_container_move_assignment type;\n};\n\ntemplate <class _Tp>\nstruct __has_propagate_on_container_swap\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::propagate_on_container_swap* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Alloc, bool = __has_propagate_on_container_swap<_Alloc>::value>\nstruct __propagate_on_container_swap\n{\n    typedef false_type type;\n};\n\ntemplate <class _Alloc>\nstruct __propagate_on_container_swap<_Alloc, true>\n{\n    typedef typename _Alloc::propagate_on_container_swap type;\n};\n\ntemplate <class _Tp>\nstruct __has_is_always_equal\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::is_always_equal* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Alloc, bool = __has_is_always_equal<_Alloc>::value>\nstruct __is_always_equal\n{\n    typedef typename _VSTD::is_empty<_Alloc>::type type;\n};\n\ntemplate <class _Alloc>\nstruct __is_always_equal<_Alloc, true>\n{\n    typedef typename _Alloc::is_always_equal type;\n};\n\ntemplate <class _Tp, class _Up, bool = __has_rebind<_Tp, _Up>::value>\nstruct __has_rebind_other\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Xp> static __two __test(...);\n    template <class _Xp> static char __test(typename _Xp::template rebind<_Up>::other* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Tp, class _Up>\nstruct __has_rebind_other<_Tp, _Up, false>\n{\n    static const bool value = false;\n};\n\ntemplate <class _Tp, class _Up, bool = __has_rebind_other<_Tp, _Up>::value>\nstruct __allocator_traits_rebind\n{\n    typedef typename _Tp::template rebind<_Up>::other type;\n};\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <template <class, class...> class _Alloc, class _Tp, class ..._Args, class _Up>\nstruct __allocator_traits_rebind<_Alloc<_Tp, _Args...>, _Up, true>\n{\n    typedef typename _Alloc<_Tp, _Args...>::template rebind<_Up>::other type;\n};\n\ntemplate <template <class, class...> class _Alloc, class _Tp, class ..._Args, class _Up>\nstruct __allocator_traits_rebind<_Alloc<_Tp, _Args...>, _Up, false>\n{\n    typedef _Alloc<_Up, _Args...> type;\n};\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <template <class> class _Alloc, class _Tp, class _Up>\nstruct __allocator_traits_rebind<_Alloc<_Tp>, _Up, true>\n{\n    typedef typename _Alloc<_Tp>::template rebind<_Up>::other type;\n};\n\ntemplate <template <class> class _Alloc, class _Tp, class _Up>\nstruct __allocator_traits_rebind<_Alloc<_Tp>, _Up, false>\n{\n    typedef _Alloc<_Up> type;\n};\n\ntemplate <template <class, class> class _Alloc, class _Tp, class _A0, class _Up>\nstruct __allocator_traits_rebind<_Alloc<_Tp, _A0>, _Up, true>\n{\n    typedef typename _Alloc<_Tp, _A0>::template rebind<_Up>::other type;\n};\n\ntemplate <template <class, class> class _Alloc, class _Tp, class _A0, class _Up>\nstruct __allocator_traits_rebind<_Alloc<_Tp, _A0>, _Up, false>\n{\n    typedef _Alloc<_Up, _A0> type;\n};\n\ntemplate <template <class, class, class> class _Alloc, class _Tp, class _A0,\n                                         class _A1, class _Up>\nstruct __allocator_traits_rebind<_Alloc<_Tp, _A0, _A1>, _Up, true>\n{\n    typedef typename _Alloc<_Tp, _A0, _A1>::template rebind<_Up>::other type;\n};\n\ntemplate <template <class, class, class> class _Alloc, class _Tp, class _A0,\n                                         class _A1, class _Up>\nstruct __allocator_traits_rebind<_Alloc<_Tp, _A0, _A1>, _Up, false>\n{\n    typedef _Alloc<_Up, _A0, _A1> type;\n};\n\ntemplate <template <class, class, class, class> class _Alloc, class _Tp, class _A0,\n                                                class _A1, class _A2, class _Up>\nstruct __allocator_traits_rebind<_Alloc<_Tp, _A0, _A1, _A2>, _Up, true>\n{\n    typedef typename _Alloc<_Tp, _A0, _A1, _A2>::template rebind<_Up>::other type;\n};\n\ntemplate <template <class, class, class, class> class _Alloc, class _Tp, class _A0,\n                                                class _A1, class _A2, class _Up>\nstruct __allocator_traits_rebind<_Alloc<_Tp, _A0, _A1, _A2>, _Up, false>\n{\n    typedef _Alloc<_Up, _A0, _A1, _A2> type;\n};\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n#ifndef _LIBCPP_CXX03_LANG\n\ntemplate <class _Alloc, class _SizeType, class _ConstVoidPtr>\nauto\n__has_allocate_hint_test(_Alloc&& __a, _SizeType&& __sz, _ConstVoidPtr&& __p)\n    -> decltype(__a.allocate(__sz, __p), true_type());\n\ntemplate <class _Alloc, class _SizeType, class _ConstVoidPtr>\nauto\n__has_allocate_hint_test(const _Alloc& __a, _SizeType&& __sz, _ConstVoidPtr&& __p)\n    -> false_type;\n\ntemplate <class _Alloc, class _SizeType, class _ConstVoidPtr>\nstruct __has_allocate_hint\n    : integral_constant<bool,\n        is_same<\n            decltype(__has_allocate_hint_test(declval<_Alloc>(),\n                                          declval<_SizeType>(),\n                                          declval<_ConstVoidPtr>())),\n            true_type>::value>\n{\n};\n\n#else  // _LIBCPP_CXX03_LANG\n\ntemplate <class _Alloc, class _SizeType, class _ConstVoidPtr>\nstruct __has_allocate_hint\n    : true_type\n{\n};\n\n#endif  // _LIBCPP_CXX03_LANG\n\n#if !defined(_LIBCPP_CXX03_LANG)\n\ntemplate <class _Alloc, class _Tp, class ..._Args>\ndecltype(_VSTD::declval<_Alloc>().construct(_VSTD::declval<_Tp*>(),\n                                           _VSTD::declval<_Args>()...),\n                                           true_type())\n__has_construct_test(_Alloc&& __a, _Tp* __p, _Args&& ...__args);\n\ntemplate <class _Alloc, class _Pointer, class ..._Args>\nfalse_type\n__has_construct_test(const _Alloc& __a, _Pointer&& __p, _Args&& ...__args);\n\ntemplate <class _Alloc, class _Pointer, class ..._Args>\nstruct __has_construct\n    : integral_constant<bool,\n        is_same<\n            decltype(__has_construct_test(declval<_Alloc>(),\n                                          declval<_Pointer>(),\n                                          declval<_Args>()...)),\n            true_type>::value>\n{\n};\n\ntemplate <class _Alloc, class _Pointer>\nauto\n__has_destroy_test(_Alloc&& __a, _Pointer&& __p)\n    -> decltype(__a.destroy(__p), true_type());\n\ntemplate <class _Alloc, class _Pointer>\nauto\n__has_destroy_test(const _Alloc& __a, _Pointer&& __p)\n    -> false_type;\n\ntemplate <class _Alloc, class _Pointer>\nstruct __has_destroy\n    : integral_constant<bool,\n        is_same<\n            decltype(__has_destroy_test(declval<_Alloc>(),\n                                        declval<_Pointer>())),\n            true_type>::value>\n{\n};\n\ntemplate <class _Alloc>\nauto\n__has_max_size_test(_Alloc&& __a)\n    -> decltype(__a.max_size(), true_type());\n\ntemplate <class _Alloc>\nauto\n__has_max_size_test(const volatile _Alloc& __a)\n    -> false_type;\n\ntemplate <class _Alloc>\nstruct __has_max_size\n    : integral_constant<bool,\n        is_same<\n            decltype(__has_max_size_test(declval<_Alloc&>())),\n            true_type>::value>\n{\n};\n\ntemplate <class _Alloc>\nauto\n__has_select_on_container_copy_construction_test(_Alloc&& __a)\n    -> decltype(__a.select_on_container_copy_construction(), true_type());\n\ntemplate <class _Alloc>\nauto\n__has_select_on_container_copy_construction_test(const volatile _Alloc& __a)\n    -> false_type;\n\ntemplate <class _Alloc>\nstruct __has_select_on_container_copy_construction\n    : integral_constant<bool,\n        is_same<\n            decltype(__has_select_on_container_copy_construction_test(declval<_Alloc&>())),\n            true_type>::value>\n{\n};\n\n#else  // _LIBCPP_CXX03_LANG\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Alloc, class _Pointer, class ..._Args>\nstruct __has_construct\n    : false_type\n{\n};\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Alloc, class _Pointer, class _Args>\nstruct __has_construct\n    : false_type\n{\n};\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Alloc, class _Pointer>\nstruct __has_destroy\n    : false_type\n{\n};\n\ntemplate <class _Alloc>\nstruct __has_max_size\n    : true_type\n{\n};\n\ntemplate <class _Alloc>\nstruct __has_select_on_container_copy_construction\n    : false_type\n{\n};\n\n#endif  // _LIBCPP_CXX03_LANG\n\ntemplate <class _Alloc, class _Ptr, bool = __has_difference_type<_Alloc>::value>\nstruct __alloc_traits_difference_type\n{\n    typedef typename pointer_traits<_Ptr>::difference_type type;\n};\n\ntemplate <class _Alloc, class _Ptr>\nstruct __alloc_traits_difference_type<_Alloc, _Ptr, true>\n{\n    typedef typename _Alloc::difference_type type;\n};\n\ntemplate <class _Alloc>\nstruct _LIBCPP_TEMPLATE_VIS allocator_traits\n{\n    typedef _Alloc                              allocator_type;\n    typedef typename allocator_type::value_type value_type;\n\n    typedef typename __pointer_type<value_type, allocator_type>::type pointer;\n    typedef typename __const_pointer<value_type, pointer, allocator_type>::type const_pointer;\n    typedef typename __void_pointer<pointer, allocator_type>::type void_pointer;\n    typedef typename __const_void_pointer<pointer, allocator_type>::type const_void_pointer;\n\n    typedef typename __alloc_traits_difference_type<allocator_type, pointer>::type difference_type;\n    typedef typename __size_type<allocator_type, difference_type>::type size_type;\n\n    typedef typename __propagate_on_container_copy_assignment<allocator_type>::type\n                     propagate_on_container_copy_assignment;\n    typedef typename __propagate_on_container_move_assignment<allocator_type>::type\n                     propagate_on_container_move_assignment;\n    typedef typename __propagate_on_container_swap<allocator_type>::type\n                     propagate_on_container_swap;\n    typedef typename __is_always_equal<allocator_type>::type\n                     is_always_equal;\n\n#ifndef _LIBCPP_CXX03_LANG\n    template <class _Tp> using rebind_alloc =\n                  typename __allocator_traits_rebind<allocator_type, _Tp>::type;\n    template <class _Tp> using rebind_traits = allocator_traits<rebind_alloc<_Tp>>;\n#else  // _LIBCPP_CXX03_LANG\n    template <class _Tp> struct rebind_alloc\n        {typedef typename __allocator_traits_rebind<allocator_type, _Tp>::type other;};\n    template <class _Tp> struct rebind_traits\n        {typedef allocator_traits<typename rebind_alloc<_Tp>::other> other;};\n#endif  // _LIBCPP_CXX03_LANG\n\n    _LIBCPP_INLINE_VISIBILITY\n    static pointer allocate(allocator_type& __a, size_type __n)\n        {return __a.allocate(__n);}\n    _LIBCPP_INLINE_VISIBILITY\n    static pointer allocate(allocator_type& __a, size_type __n, const_void_pointer __hint)\n        {return allocate(__a, __n, __hint,\n            __has_allocate_hint<allocator_type, size_type, const_void_pointer>());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    static void deallocate(allocator_type& __a, pointer __p, size_type __n) _NOEXCEPT\n        {__a.deallocate(__p, __n);}\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n    template <class _Tp, class... _Args>\n        _LIBCPP_INLINE_VISIBILITY\n        static void construct(allocator_type& __a, _Tp* __p, _Args&&... __args)\n            {__construct(__has_construct<allocator_type, _Tp*, _Args...>(),\n                         __a, __p, _VSTD::forward<_Args>(__args)...);}\n#else  // _LIBCPP_HAS_NO_VARIADICS\n    template <class _Tp>\n        _LIBCPP_INLINE_VISIBILITY\n        static void construct(allocator_type& __a, _Tp* __p)\n            {\n                ::new ((void*)__p) _Tp();\n            }\n    template <class _Tp, class _A0>\n        _LIBCPP_INLINE_VISIBILITY\n        static void construct(allocator_type& __a, _Tp* __p, const _A0& __a0)\n            {\n                ::new ((void*)__p) _Tp(__a0);\n            }\n    template <class _Tp, class _A0, class _A1>\n        _LIBCPP_INLINE_VISIBILITY\n        static void construct(allocator_type& __a, _Tp* __p, const _A0& __a0,\n                              const _A1& __a1)\n            {\n                ::new ((void*)__p) _Tp(__a0, __a1);\n            }\n    template <class _Tp, class _A0, class _A1, class _A2>\n        _LIBCPP_INLINE_VISIBILITY\n        static void construct(allocator_type& __a, _Tp* __p, const _A0& __a0,\n                              const _A1& __a1, const _A2& __a2)\n            {\n                ::new ((void*)__p) _Tp(__a0, __a1, __a2);\n            }\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n    template <class _Tp>\n        _LIBCPP_INLINE_VISIBILITY\n        static void destroy(allocator_type& __a, _Tp* __p)\n            {__destroy(__has_destroy<allocator_type, _Tp*>(), __a, __p);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    static size_type max_size(const allocator_type& __a) _NOEXCEPT\n        {return __max_size(__has_max_size<const allocator_type>(), __a);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    static allocator_type\n        select_on_container_copy_construction(const allocator_type& __a)\n            {return select_on_container_copy_construction(\n                __has_select_on_container_copy_construction<const allocator_type>(),\n                __a);}\n\n    template <class _Ptr>\n        _LIBCPP_INLINE_VISIBILITY\n        static\n        void\n        __construct_forward(allocator_type& __a, _Ptr __begin1, _Ptr __end1, _Ptr& __begin2)\n        {\n            for (; __begin1 != __end1; ++__begin1, ++__begin2)\n                construct(__a, _VSTD::__to_raw_pointer(__begin2), _VSTD::move_if_noexcept(*__begin1));\n        }\n\n    template <class _Tp>\n        _LIBCPP_INLINE_VISIBILITY\n        static\n        typename enable_if\n        <\n            (is_same<allocator_type, allocator<_Tp> >::value\n                || !__has_construct<allocator_type, _Tp*, _Tp>::value) &&\n             is_trivially_move_constructible<_Tp>::value,\n            void\n        >::type\n        __construct_forward(allocator_type&, _Tp* __begin1, _Tp* __end1, _Tp*& __begin2)\n        {\n            ptrdiff_t _Np = __end1 - __begin1;\n            if (_Np > 0)\n            {\n                _VSTD::memcpy(__begin2, __begin1, _Np * sizeof(_Tp));\n                __begin2 += _Np;\n            }\n        }\n\n    template <class _Iter, class _Ptr>\n        _LIBCPP_INLINE_VISIBILITY\n        static\n        void\n        __construct_range_forward(allocator_type& __a, _Iter __begin1, _Iter __end1, _Ptr& __begin2)\n        {\n            for (; __begin1 != __end1; ++__begin1, (void) ++__begin2)\n                construct(__a, _VSTD::__to_raw_pointer(__begin2), *__begin1);\n        }\n\n    template <class _Tp>\n        _LIBCPP_INLINE_VISIBILITY\n        static\n        typename enable_if\n        <\n            (is_same<allocator_type, allocator<_Tp> >::value\n                || !__has_construct<allocator_type, _Tp*, _Tp>::value) &&\n             is_trivially_move_constructible<_Tp>::value,\n            void\n        >::type\n        __construct_range_forward(allocator_type&, _Tp* __begin1, _Tp* __end1, _Tp*& __begin2)\n        {\n            typedef typename remove_const<_Tp>::type _Vp;\n            ptrdiff_t _Np = __end1 - __begin1;\n            if (_Np > 0)\n            {\n                _VSTD::memcpy(const_cast<_Vp*>(__begin2), __begin1, _Np * sizeof(_Tp));\n                __begin2 += _Np;\n            }\n        }\n\n    template <class _Ptr>\n        _LIBCPP_INLINE_VISIBILITY\n        static\n        void\n        __construct_backward(allocator_type& __a, _Ptr __begin1, _Ptr __end1, _Ptr& __end2)\n        {\n            while (__end1 != __begin1)\n            {\n                construct(__a, _VSTD::__to_raw_pointer(__end2-1), _VSTD::move_if_noexcept(*--__end1));\n                --__end2;\n            }\n        }\n\n    template <class _Tp>\n        _LIBCPP_INLINE_VISIBILITY\n        static\n        typename enable_if\n        <\n            (is_same<allocator_type, allocator<_Tp> >::value\n                || !__has_construct<allocator_type, _Tp*, _Tp>::value) &&\n             is_trivially_move_constructible<_Tp>::value,\n            void\n        >::type\n        __construct_backward(allocator_type&, _Tp* __begin1, _Tp* __end1, _Tp*& __end2)\n        {\n            ptrdiff_t _Np = __end1 - __begin1;\n            __end2 -= _Np;\n            if (_Np > 0)\n                _VSTD::memcpy(__end2, __begin1, _Np * sizeof(_Tp));\n        }\n\nprivate:\n\n    _LIBCPP_INLINE_VISIBILITY\n    static pointer allocate(allocator_type& __a, size_type __n,\n        const_void_pointer __hint, true_type)\n        {return __a.allocate(__n, __hint);}\n    _LIBCPP_INLINE_VISIBILITY\n    static pointer allocate(allocator_type& __a, size_type __n,\n        const_void_pointer, false_type)\n        {return __a.allocate(__n);}\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n    template <class _Tp, class... _Args>\n        _LIBCPP_INLINE_VISIBILITY\n        static void __construct(true_type, allocator_type& __a, _Tp* __p, _Args&&... __args)\n            {__a.construct(__p, _VSTD::forward<_Args>(__args)...);}\n    template <class _Tp, class... _Args>\n        _LIBCPP_INLINE_VISIBILITY\n        static void __construct(false_type, allocator_type&, _Tp* __p, _Args&&... __args)\n            {\n                ::new ((void*)__p) _Tp(_VSTD::forward<_Args>(__args)...);\n            }\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n    template <class _Tp>\n        _LIBCPP_INLINE_VISIBILITY\n        static void __destroy(true_type, allocator_type& __a, _Tp* __p)\n            {__a.destroy(__p);}\n    template <class _Tp>\n        _LIBCPP_INLINE_VISIBILITY\n        static void __destroy(false_type, allocator_type&, _Tp* __p)\n            {\n                __p->~_Tp();\n            }\n\n    _LIBCPP_INLINE_VISIBILITY\n    static size_type __max_size(true_type, const allocator_type& __a)\n            {return __a.max_size();}\n    _LIBCPP_INLINE_VISIBILITY\n    static size_type __max_size(false_type, const allocator_type&)\n            {return numeric_limits<size_type>::max() / sizeof(value_type);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    static allocator_type\n        select_on_container_copy_construction(true_type, const allocator_type& __a)\n            {return __a.select_on_container_copy_construction();}\n    _LIBCPP_INLINE_VISIBILITY\n    static allocator_type\n        select_on_container_copy_construction(false_type, const allocator_type& __a)\n            {return __a;}\n};\n\ntemplate <class _Traits, class _Tp>\nstruct __rebind_alloc_helper\n{\n#ifndef _LIBCPP_CXX03_LANG\n    typedef typename _Traits::template rebind_alloc<_Tp>        type;\n#else\n    typedef typename _Traits::template rebind_alloc<_Tp>::other type;\n#endif\n};\n\n// allocator\n\ntemplate <class _Tp>\nclass _LIBCPP_TEMPLATE_VIS allocator\n{\npublic:\n    typedef size_t            size_type;\n    typedef ptrdiff_t         difference_type;\n    typedef _Tp*              pointer;\n    typedef const _Tp*        const_pointer;\n    typedef _Tp&              reference;\n    typedef const _Tp&        const_reference;\n    typedef _Tp               value_type;\n\n    typedef true_type propagate_on_container_move_assignment;\n    typedef true_type is_always_equal;\n\n    template <class _Up> struct rebind {typedef allocator<_Up> other;};\n\n    _LIBCPP_INLINE_VISIBILITY allocator() _NOEXCEPT {}\n    template <class _Up> _LIBCPP_INLINE_VISIBILITY allocator(const allocator<_Up>&) _NOEXCEPT {}\n    _LIBCPP_INLINE_VISIBILITY pointer address(reference __x) const _NOEXCEPT\n        {return _VSTD::addressof(__x);}\n    _LIBCPP_INLINE_VISIBILITY const_pointer address(const_reference __x) const _NOEXCEPT\n        {return _VSTD::addressof(__x);}\n    _LIBCPP_INLINE_VISIBILITY pointer allocate(size_type __n, allocator<void>::const_pointer = 0)\n        {\n        if (__n > max_size())\n            __throw_length_error(\"allocator<T>::allocate(size_t n)\"\n                                 \" 'n' exceeds maximum supported size\");\n        return static_cast<pointer>(_VSTD::__allocate(__n * sizeof(_Tp)));\n        }\n    _LIBCPP_INLINE_VISIBILITY void deallocate(pointer __p, size_type) _NOEXCEPT\n        {_VSTD::__libcpp_deallocate((void*)__p);}\n    _LIBCPP_INLINE_VISIBILITY size_type max_size() const _NOEXCEPT\n        {return size_type(~0) / sizeof(_Tp);}\n#if !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\n    template <class _Up, class... _Args>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(_Up* __p, _Args&&... __args)\n        {\n            ::new((void*)__p) _Up(_VSTD::forward<_Args>(__args)...);\n        }\n#else  // !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p)\n        {\n            ::new((void*)__p) _Tp();\n        }\n# if defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)\n\n    template <class _A0>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, _A0& __a0)\n        {\n            ::new((void*)__p) _Tp(__a0);\n        }\n    template <class _A0>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, const _A0& __a0)\n        {\n            ::new((void*)__p) _Tp(__a0);\n        }\n# endif  // defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)\n    template <class _A0, class _A1>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, _A0& __a0, _A1& __a1)\n        {\n            ::new((void*)__p) _Tp(__a0, __a1);\n        }\n    template <class _A0, class _A1>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, const _A0& __a0, _A1& __a1)\n        {\n            ::new((void*)__p) _Tp(__a0, __a1);\n        }\n    template <class _A0, class _A1>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, _A0& __a0, const _A1& __a1)\n        {\n            ::new((void*)__p) _Tp(__a0, __a1);\n        }\n    template <class _A0, class _A1>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, const _A0& __a0, const _A1& __a1)\n        {\n            ::new((void*)__p) _Tp(__a0, __a1);\n        }\n#endif  // !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\n    _LIBCPP_INLINE_VISIBILITY void destroy(pointer __p) {__p->~_Tp();}\n};\n\ntemplate <class _Tp>\nclass _LIBCPP_TEMPLATE_VIS allocator<const _Tp>\n{\npublic:\n    typedef size_t            size_type;\n    typedef ptrdiff_t         difference_type;\n    typedef const _Tp*        pointer;\n    typedef const _Tp*        const_pointer;\n    typedef const _Tp&        reference;\n    typedef const _Tp&        const_reference;\n    typedef const _Tp         value_type;\n\n    typedef true_type propagate_on_container_move_assignment;\n    typedef true_type is_always_equal;\n\n    template <class _Up> struct rebind {typedef allocator<_Up> other;};\n\n    _LIBCPP_INLINE_VISIBILITY allocator() _NOEXCEPT {}\n    template <class _Up> _LIBCPP_INLINE_VISIBILITY allocator(const allocator<_Up>&) _NOEXCEPT {}\n    _LIBCPP_INLINE_VISIBILITY const_pointer address(const_reference __x) const _NOEXCEPT\n        {return _VSTD::addressof(__x);}\n    _LIBCPP_INLINE_VISIBILITY pointer allocate(size_type __n, allocator<void>::const_pointer = 0)\n    {\n        if (__n > max_size())\n            __throw_length_error(\"allocator<const T>::allocate(size_t n)\"\n                                 \" 'n' exceeds maximum supported size\");\n        return static_cast<pointer>(_VSTD::__allocate(__n * sizeof(_Tp)));\n    }\n    _LIBCPP_INLINE_VISIBILITY void deallocate(pointer __p, size_type) _NOEXCEPT\n        {_VSTD::__libcpp_deallocate((void*)__p);}\n    _LIBCPP_INLINE_VISIBILITY size_type max_size() const _NOEXCEPT\n        {return size_type(~0) / sizeof(_Tp);}\n#if !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\n    template <class _Up, class... _Args>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(_Up* __p, _Args&&... __args)\n        {\n            ::new((void*)__p) _Up(_VSTD::forward<_Args>(__args)...);\n        }\n#else  // !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p)\n        {\n            ::new((void*)__p) _Tp();\n        }\n# if defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)\n\n    template <class _A0>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, _A0& __a0)\n        {\n            ::new((void*)__p) _Tp(__a0);\n        }\n    template <class _A0>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, const _A0& __a0)\n        {\n            ::new((void*)__p) _Tp(__a0);\n        }\n# endif  // defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)\n    template <class _A0, class _A1>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, _A0& __a0, _A1& __a1)\n        {\n            ::new((void*)__p) _Tp(__a0, __a1);\n        }\n    template <class _A0, class _A1>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, const _A0& __a0, _A1& __a1)\n        {\n            ::new((void*)__p) _Tp(__a0, __a1);\n        }\n    template <class _A0, class _A1>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, _A0& __a0, const _A1& __a1)\n        {\n            ::new((void*)__p) _Tp(__a0, __a1);\n        }\n    template <class _A0, class _A1>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, const _A0& __a0, const _A1& __a1)\n        {\n            ::new((void*)__p) _Tp(__a0, __a1);\n        }\n#endif  // !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\n    _LIBCPP_INLINE_VISIBILITY void destroy(pointer __p) {__p->~_Tp();}\n};\n\ntemplate <class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\nbool operator==(const allocator<_Tp>&, const allocator<_Up>&) _NOEXCEPT {return true;}\n\ntemplate <class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\nbool operator!=(const allocator<_Tp>&, const allocator<_Up>&) _NOEXCEPT {return false;}\n\ntemplate <class _OutputIterator, class _Tp>\nclass _LIBCPP_TEMPLATE_VIS raw_storage_iterator\n    : public iterator<output_iterator_tag,\n                      _Tp,                                         // purposefully not C++03\n                      ptrdiff_t,                                   // purposefully not C++03\n                      _Tp*,                                        // purposefully not C++03\n                      raw_storage_iterator<_OutputIterator, _Tp>&> // purposefully not C++03\n{\nprivate:\n    _OutputIterator __x_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY explicit raw_storage_iterator(_OutputIterator __x) : __x_(__x) {}\n    _LIBCPP_INLINE_VISIBILITY raw_storage_iterator& operator*() {return *this;}\n    _LIBCPP_INLINE_VISIBILITY raw_storage_iterator& operator=(const _Tp& __element)\n        {::new(&*__x_) _Tp(__element); return *this;}\n#if _LIBCPP_STD_VER >= 14\n    _LIBCPP_INLINE_VISIBILITY raw_storage_iterator& operator=(_Tp&& __element)\n        {::new(&*__x_) _Tp(_VSTD::move(__element)); return *this;}\n#endif\n    _LIBCPP_INLINE_VISIBILITY raw_storage_iterator& operator++() {++__x_; return *this;}\n    _LIBCPP_INLINE_VISIBILITY raw_storage_iterator  operator++(int)\n        {raw_storage_iterator __t(*this); ++__x_; return __t;}\n#if _LIBCPP_STD_VER >= 14\n    _LIBCPP_INLINE_VISIBILITY _OutputIterator base() const { return __x_; } \n#endif\n};\n\ntemplate <class _Tp>\npair<_Tp*, ptrdiff_t>\nget_temporary_buffer(ptrdiff_t __n) _NOEXCEPT\n{\n    pair<_Tp*, ptrdiff_t> __r(0, 0);\n    const ptrdiff_t __m = (~ptrdiff_t(0) ^\n                           ptrdiff_t(ptrdiff_t(1) << (sizeof(ptrdiff_t) * __CHAR_BIT__ - 1)))\n                           / sizeof(_Tp);\n    if (__n > __m)\n        __n = __m;\n    while (__n > 0)\n    {\n        __r.first = static_cast<_Tp*>(::operator new(__n * sizeof(_Tp), nothrow));\n        if (__r.first)\n        {\n            __r.second = __n;\n            break;\n        }\n        __n /= 2;\n    }\n    return __r;\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid return_temporary_buffer(_Tp* __p) _NOEXCEPT {::operator delete(__p);}\n\ntemplate <class _Tp>\nstruct auto_ptr_ref\n{\n    _Tp* __ptr_;\n};\n\ntemplate<class _Tp>\nclass _LIBCPP_TEMPLATE_VIS auto_ptr\n{\nprivate:\n    _Tp* __ptr_;\npublic:\n    typedef _Tp element_type;\n\n    _LIBCPP_INLINE_VISIBILITY explicit auto_ptr(_Tp* __p = 0) throw() : __ptr_(__p) {}\n    _LIBCPP_INLINE_VISIBILITY auto_ptr(auto_ptr& __p) throw() : __ptr_(__p.release()) {}\n    template<class _Up> _LIBCPP_INLINE_VISIBILITY auto_ptr(auto_ptr<_Up>& __p) throw()\n        : __ptr_(__p.release()) {}\n    _LIBCPP_INLINE_VISIBILITY auto_ptr& operator=(auto_ptr& __p) throw()\n        {reset(__p.release()); return *this;}\n    template<class _Up> _LIBCPP_INLINE_VISIBILITY auto_ptr& operator=(auto_ptr<_Up>& __p) throw()\n        {reset(__p.release()); return *this;}\n    _LIBCPP_INLINE_VISIBILITY auto_ptr& operator=(auto_ptr_ref<_Tp> __p) throw()\n        {reset(__p.__ptr_); return *this;}\n    _LIBCPP_INLINE_VISIBILITY ~auto_ptr() throw() {delete __ptr_;}\n\n    _LIBCPP_INLINE_VISIBILITY _Tp& operator*() const throw()\n        {return *__ptr_;}\n    _LIBCPP_INLINE_VISIBILITY _Tp* operator->() const throw() {return __ptr_;}\n    _LIBCPP_INLINE_VISIBILITY _Tp* get() const throw() {return __ptr_;}\n    _LIBCPP_INLINE_VISIBILITY _Tp* release() throw()\n    {\n        _Tp* __t = __ptr_;\n        __ptr_ = 0;\n        return __t;\n    }\n    _LIBCPP_INLINE_VISIBILITY void reset(_Tp* __p = 0) throw()\n    {\n        if (__ptr_ != __p)\n            delete __ptr_;\n        __ptr_ = __p;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY auto_ptr(auto_ptr_ref<_Tp> __p) throw() : __ptr_(__p.__ptr_) {}\n    template<class _Up> _LIBCPP_INLINE_VISIBILITY operator auto_ptr_ref<_Up>() throw()\n        {auto_ptr_ref<_Up> __t; __t.__ptr_ = release(); return __t;}\n    template<class _Up> _LIBCPP_INLINE_VISIBILITY operator auto_ptr<_Up>() throw()\n        {return auto_ptr<_Up>(release());}\n};\n\ntemplate <>\nclass _LIBCPP_TEMPLATE_VIS auto_ptr<void>\n{\npublic:\n    typedef void element_type;\n};\n\ntemplate <class _T1, class _T2, bool = is_same<typename remove_cv<_T1>::type,\n                                                     typename remove_cv<_T2>::type>::value,\n                                bool = is_empty<_T1>::value\n                                       && !__libcpp_is_final<_T1>::value,\n                                bool = is_empty<_T2>::value\n                                       && !__libcpp_is_final<_T2>::value\n         >\nstruct __libcpp_compressed_pair_switch;\n\ntemplate <class _T1, class _T2, bool IsSame>\nstruct __libcpp_compressed_pair_switch<_T1, _T2, IsSame, false, false> {enum {value = 0};};\n\ntemplate <class _T1, class _T2, bool IsSame>\nstruct __libcpp_compressed_pair_switch<_T1, _T2, IsSame, true, false>  {enum {value = 1};};\n\ntemplate <class _T1, class _T2, bool IsSame>\nstruct __libcpp_compressed_pair_switch<_T1, _T2, IsSame, false, true>  {enum {value = 2};};\n\ntemplate <class _T1, class _T2>\nstruct __libcpp_compressed_pair_switch<_T1, _T2, false, true, true>    {enum {value = 3};};\n\ntemplate <class _T1, class _T2>\nstruct __libcpp_compressed_pair_switch<_T1, _T2, true, true, true>     {enum {value = 1};};\n\ntemplate <class _T1, class _T2, unsigned = __libcpp_compressed_pair_switch<_T1, _T2>::value>\nclass __libcpp_compressed_pair_imp;\n\ntemplate <class _T1, class _T2>\nclass __libcpp_compressed_pair_imp<_T1, _T2, 0>\n{\nprivate:\n    _T1 __first_;\n    _T2 __second_;\npublic:\n    typedef _T1 _T1_param;\n    typedef _T2 _T2_param;\n\n    typedef typename remove_reference<_T1>::type& _T1_reference;\n    typedef typename remove_reference<_T2>::type& _T2_reference;\n\n    typedef const typename remove_reference<_T1>::type& _T1_const_reference;\n    typedef const typename remove_reference<_T2>::type& _T2_const_reference;\n\n    _LIBCPP_INLINE_VISIBILITY __libcpp_compressed_pair_imp() : __first_(), __second_() {}\n    _LIBCPP_INLINE_VISIBILITY explicit __libcpp_compressed_pair_imp(_T1_param __t1)\n        : __first_(_VSTD::forward<_T1_param>(__t1)), __second_() {}\n    _LIBCPP_INLINE_VISIBILITY explicit __libcpp_compressed_pair_imp(_T2_param __t2)\n        : __first_(), __second_(_VSTD::forward<_T2_param>(__t2)) {}\n    _LIBCPP_INLINE_VISIBILITY __libcpp_compressed_pair_imp(_T1_param __t1, _T2_param __t2)\n        : __first_(_VSTD::forward<_T1_param>(__t1)), __second_(_VSTD::forward<_T2_param>(__t2)) {}\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n    template <class... _Args1, class... _Args2, size_t... _I1, size_t... _I2>\n        _LIBCPP_INLINE_VISIBILITY\n        __libcpp_compressed_pair_imp(piecewise_construct_t,\n                                     tuple<_Args1...> __first_args,\n                                     tuple<_Args2...> __second_args,\n                                     __tuple_indices<_I1...>,\n                                     __tuple_indices<_I2...>)\n            : __first_(_VSTD::forward<_Args1>(_VSTD::get<_I1>(__first_args))...),\n              __second_(_VSTD::forward<_Args2>(_VSTD::get<_I2>(__second_args))...)\n            {}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n    _LIBCPP_INLINE_VISIBILITY _T1_reference       first() _NOEXCEPT       {return __first_;}\n    _LIBCPP_INLINE_VISIBILITY _T1_const_reference first() const _NOEXCEPT {return __first_;}\n\n    _LIBCPP_INLINE_VISIBILITY _T2_reference       second() _NOEXCEPT       {return __second_;}\n    _LIBCPP_INLINE_VISIBILITY _T2_const_reference second() const _NOEXCEPT {return __second_;}\n\n    _LIBCPP_INLINE_VISIBILITY void swap(__libcpp_compressed_pair_imp& __x)\n        _NOEXCEPT_(__is_nothrow_swappable<_T1>::value &&\n                   __is_nothrow_swappable<_T2>::value)\n    {\n        using _VSTD::swap;\n        swap(__first_, __x.__first_);\n        swap(__second_, __x.__second_);\n    }\n};\n\ntemplate <class _T1, class _T2>\nclass __libcpp_compressed_pair_imp<_T1, _T2, 1>\n    : private _T1\n{\nprivate:\n    _T2 __second_;\npublic:\n    typedef _T1 _T1_param;\n    typedef _T2 _T2_param;\n\n    typedef _T1&                                        _T1_reference;\n    typedef typename remove_reference<_T2>::type& _T2_reference;\n\n    typedef const _T1&                                        _T1_const_reference;\n    typedef const typename remove_reference<_T2>::type& _T2_const_reference;\n\n    _LIBCPP_INLINE_VISIBILITY __libcpp_compressed_pair_imp() : __second_() {}\n    _LIBCPP_INLINE_VISIBILITY explicit __libcpp_compressed_pair_imp(_T1_param __t1)\n        : _T1(_VSTD::forward<_T1_param>(__t1)), __second_() {}\n    _LIBCPP_INLINE_VISIBILITY explicit __libcpp_compressed_pair_imp(_T2_param __t2)\n        : __second_(_VSTD::forward<_T2_param>(__t2)) {}\n    _LIBCPP_INLINE_VISIBILITY __libcpp_compressed_pair_imp(_T1_param __t1, _T2_param __t2)\n        : _T1(_VSTD::forward<_T1_param>(__t1)), __second_(_VSTD::forward<_T2_param>(__t2)) {}\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n    template <class... _Args1, class... _Args2, size_t... _I1, size_t... _I2>\n        _LIBCPP_INLINE_VISIBILITY\n        __libcpp_compressed_pair_imp(piecewise_construct_t,\n                                     tuple<_Args1...> __first_args,\n                                     tuple<_Args2...> __second_args,\n                                     __tuple_indices<_I1...>,\n                                     __tuple_indices<_I2...>)\n            : _T1(_VSTD::forward<_Args1>(_VSTD::get<_I1>(__first_args))...),\n              __second_(_VSTD::forward<_Args2>(_VSTD::get<_I2>(__second_args))...)\n            {}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n    _LIBCPP_INLINE_VISIBILITY _T1_reference       first() _NOEXCEPT       {return *this;}\n    _LIBCPP_INLINE_VISIBILITY _T1_const_reference first() const _NOEXCEPT {return *this;}\n\n    _LIBCPP_INLINE_VISIBILITY _T2_reference       second() _NOEXCEPT       {return __second_;}\n    _LIBCPP_INLINE_VISIBILITY _T2_const_reference second() const _NOEXCEPT {return __second_;}\n\n    _LIBCPP_INLINE_VISIBILITY void swap(__libcpp_compressed_pair_imp& __x)\n        _NOEXCEPT_(__is_nothrow_swappable<_T1>::value &&\n                   __is_nothrow_swappable<_T2>::value)\n    {\n        using _VSTD::swap;\n        swap(__second_, __x.__second_);\n    }\n};\n\ntemplate <class _T1, class _T2>\nclass __libcpp_compressed_pair_imp<_T1, _T2, 2>\n    : private _T2\n{\nprivate:\n    _T1 __first_;\npublic:\n    typedef _T1 _T1_param;\n    typedef _T2 _T2_param;\n\n    typedef typename remove_reference<_T1>::type& _T1_reference;\n    typedef _T2&                                        _T2_reference;\n\n    typedef const typename remove_reference<_T1>::type& _T1_const_reference;\n    typedef const _T2&                                        _T2_const_reference;\n\n    _LIBCPP_INLINE_VISIBILITY __libcpp_compressed_pair_imp() : __first_() {}\n    _LIBCPP_INLINE_VISIBILITY explicit __libcpp_compressed_pair_imp(_T1_param __t1)\n        : __first_(_VSTD::forward<_T1_param>(__t1)) {}\n    _LIBCPP_INLINE_VISIBILITY explicit __libcpp_compressed_pair_imp(_T2_param __t2)\n        : _T2(_VSTD::forward<_T2_param>(__t2)), __first_() {}\n    _LIBCPP_INLINE_VISIBILITY __libcpp_compressed_pair_imp(_T1_param __t1, _T2_param __t2)\n        _NOEXCEPT_(is_nothrow_move_constructible<_T1>::value &&\n                   is_nothrow_move_constructible<_T2>::value)\n        : _T2(_VSTD::forward<_T2_param>(__t2)), __first_(_VSTD::forward<_T1_param>(__t1)) {}\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n    template <class... _Args1, class... _Args2, size_t... _I1, size_t... _I2>\n        _LIBCPP_INLINE_VISIBILITY\n        __libcpp_compressed_pair_imp(piecewise_construct_t,\n                                     tuple<_Args1...> __first_args,\n                                     tuple<_Args2...> __second_args,\n                                     __tuple_indices<_I1...>,\n                                     __tuple_indices<_I2...>)\n            : _T2(_VSTD::forward<_Args2>(_VSTD::get<_I2>(__second_args))...),\n              __first_(_VSTD::forward<_Args1>(_VSTD::get<_I1>(__first_args))...)\n              \n            {}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n    _LIBCPP_INLINE_VISIBILITY _T1_reference       first() _NOEXCEPT       {return __first_;}\n    _LIBCPP_INLINE_VISIBILITY _T1_const_reference first() const _NOEXCEPT {return __first_;}\n\n    _LIBCPP_INLINE_VISIBILITY _T2_reference       second() _NOEXCEPT       {return *this;}\n    _LIBCPP_INLINE_VISIBILITY _T2_const_reference second() const _NOEXCEPT {return *this;}\n\n    _LIBCPP_INLINE_VISIBILITY void swap(__libcpp_compressed_pair_imp& __x)\n        _NOEXCEPT_(__is_nothrow_swappable<_T1>::value &&\n                   __is_nothrow_swappable<_T2>::value)\n    {\n        using _VSTD::swap;\n        swap(__first_, __x.__first_);\n    }\n};\n\ntemplate <class _T1, class _T2>\nclass __libcpp_compressed_pair_imp<_T1, _T2, 3>\n    : private _T1,\n      private _T2\n{\npublic:\n    typedef _T1 _T1_param;\n    typedef _T2 _T2_param;\n\n    typedef _T1& _T1_reference;\n    typedef _T2& _T2_reference;\n\n    typedef const _T1& _T1_const_reference;\n    typedef const _T2& _T2_const_reference;\n\n    _LIBCPP_INLINE_VISIBILITY __libcpp_compressed_pair_imp() {}\n    _LIBCPP_INLINE_VISIBILITY explicit __libcpp_compressed_pair_imp(_T1_param __t1)\n        : _T1(_VSTD::forward<_T1_param>(__t1)) {}\n    _LIBCPP_INLINE_VISIBILITY explicit __libcpp_compressed_pair_imp(_T2_param __t2)\n        : _T2(_VSTD::forward<_T2_param>(__t2)) {}\n    _LIBCPP_INLINE_VISIBILITY __libcpp_compressed_pair_imp(_T1_param __t1, _T2_param __t2)\n        : _T1(_VSTD::forward<_T1_param>(__t1)), _T2(_VSTD::forward<_T2_param>(__t2)) {}\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n    template <class... _Args1, class... _Args2, size_t... _I1, size_t... _I2>\n        _LIBCPP_INLINE_VISIBILITY\n        __libcpp_compressed_pair_imp(piecewise_construct_t,\n                                     tuple<_Args1...> __first_args,\n                                     tuple<_Args2...> __second_args,\n                                     __tuple_indices<_I1...>,\n                                     __tuple_indices<_I2...>)\n            : _T1(_VSTD::forward<_Args1>(_VSTD::get<_I1>(__first_args))...),\n              _T2(_VSTD::forward<_Args2>(_VSTD::get<_I2>(__second_args))...)\n            {}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n    _LIBCPP_INLINE_VISIBILITY _T1_reference       first() _NOEXCEPT       {return *this;}\n    _LIBCPP_INLINE_VISIBILITY _T1_const_reference first() const _NOEXCEPT {return *this;}\n\n    _LIBCPP_INLINE_VISIBILITY _T2_reference       second() _NOEXCEPT       {return *this;}\n    _LIBCPP_INLINE_VISIBILITY _T2_const_reference second() const _NOEXCEPT {return *this;}\n\n    _LIBCPP_INLINE_VISIBILITY void swap(__libcpp_compressed_pair_imp&)\n        _NOEXCEPT_(__is_nothrow_swappable<_T1>::value &&\n                   __is_nothrow_swappable<_T2>::value)\n    {\n    }\n};\n\ntemplate <class _T1, class _T2>\nclass __compressed_pair\n    : private __libcpp_compressed_pair_imp<_T1, _T2>\n{\n    typedef __libcpp_compressed_pair_imp<_T1, _T2> base;\npublic:\n    typedef typename base::_T1_param _T1_param;\n    typedef typename base::_T2_param _T2_param;\n\n    typedef typename base::_T1_reference _T1_reference;\n    typedef typename base::_T2_reference _T2_reference;\n\n    typedef typename base::_T1_const_reference _T1_const_reference;\n    typedef typename base::_T2_const_reference _T2_const_reference;\n\n    _LIBCPP_INLINE_VISIBILITY __compressed_pair() {}\n    _LIBCPP_INLINE_VISIBILITY explicit __compressed_pair(_T1_param __t1)\n        : base(_VSTD::forward<_T1_param>(__t1)) {}\n    _LIBCPP_INLINE_VISIBILITY explicit __compressed_pair(_T2_param __t2)\n        : base(_VSTD::forward<_T2_param>(__t2)) {}\n    _LIBCPP_INLINE_VISIBILITY __compressed_pair(_T1_param __t1, _T2_param __t2)\n        : base(_VSTD::forward<_T1_param>(__t1), _VSTD::forward<_T2_param>(__t2)) {}\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n    template <class... _Args1, class... _Args2>\n        _LIBCPP_INLINE_VISIBILITY\n        __compressed_pair(piecewise_construct_t __pc, tuple<_Args1...> __first_args,\n                                                      tuple<_Args2...> __second_args)\n            : base(__pc, _VSTD::move(__first_args), _VSTD::move(__second_args),\n                   typename __make_tuple_indices<sizeof...(_Args1)>::type(),\n                   typename __make_tuple_indices<sizeof...(_Args2) >::type())\n            {}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n    _LIBCPP_INLINE_VISIBILITY _T1_reference       first() _NOEXCEPT       {return base::first();}\n    _LIBCPP_INLINE_VISIBILITY _T1_const_reference first() const _NOEXCEPT {return base::first();}\n\n    _LIBCPP_INLINE_VISIBILITY _T2_reference       second() _NOEXCEPT       {return base::second();}\n    _LIBCPP_INLINE_VISIBILITY _T2_const_reference second() const _NOEXCEPT {return base::second();}\n\n    _LIBCPP_INLINE_VISIBILITY void swap(__compressed_pair& __x)\n        _NOEXCEPT_(__is_nothrow_swappable<_T1>::value &&\n                   __is_nothrow_swappable<_T2>::value)\n        {base::swap(__x);}\n};\n\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(__compressed_pair<_T1, _T2>& __x, __compressed_pair<_T1, _T2>& __y)\n        _NOEXCEPT_(__is_nothrow_swappable<_T1>::value &&\n                   __is_nothrow_swappable<_T2>::value)\n    {__x.swap(__y);}\n\n// __same_or_less_cv_qualified\n\ntemplate <class _Ptr1, class _Ptr2,\n          bool = is_same<typename remove_cv<typename pointer_traits<_Ptr1>::element_type>::type,\n                         typename remove_cv<typename pointer_traits<_Ptr2>::element_type>::type\n                        >::value\n         >\nstruct __same_or_less_cv_qualified_imp\n    : is_convertible<_Ptr1, _Ptr2> {};\n\ntemplate <class _Ptr1, class _Ptr2>\nstruct __same_or_less_cv_qualified_imp<_Ptr1, _Ptr2, false>\n    : false_type {};\n\ntemplate <class _Ptr1, class _Ptr2, bool = is_pointer<_Ptr1>::value ||\n                                           is_same<_Ptr1, _Ptr2>::value ||\n                                           __has_element_type<_Ptr1>::value>\nstruct __same_or_less_cv_qualified\n    : __same_or_less_cv_qualified_imp<_Ptr1, _Ptr2> {};\n\ntemplate <class _Ptr1, class _Ptr2>\nstruct __same_or_less_cv_qualified<_Ptr1, _Ptr2, false>\n    : false_type {};\n\n// default_delete\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS default_delete\n{\n#ifndef _LIBCPP_CXX03_LANG\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR default_delete() _NOEXCEPT = default;\n#else\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR default_delete() _NOEXCEPT {}\n#endif\n    template <class _Up>\n        _LIBCPP_INLINE_VISIBILITY default_delete(const default_delete<_Up>&,\n             typename enable_if<is_convertible<_Up*, _Tp*>::value>::type* = 0) _NOEXCEPT {}\n    _LIBCPP_INLINE_VISIBILITY void operator() (_Tp* __ptr) const _NOEXCEPT\n        {\n            static_assert(sizeof(_Tp) > 0, \"default_delete can not delete incomplete type\");\n            static_assert(!is_void<_Tp>::value, \"default_delete can not delete incomplete type\");\n            delete __ptr;\n        }\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS default_delete<_Tp[]>\n{\npublic:\n#ifndef _LIBCPP_CXX03_LANG\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR default_delete() _NOEXCEPT = default;\n#else\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR default_delete() _NOEXCEPT {}\n#endif\n    template <class _Up>\n        _LIBCPP_INLINE_VISIBILITY default_delete(const default_delete<_Up[]>&,\n             typename enable_if<__same_or_less_cv_qualified<_Up*, _Tp*>::value>::type* = 0) _NOEXCEPT {}\n    template <class _Up>\n        _LIBCPP_INLINE_VISIBILITY\n        void operator() (_Up* __ptr,\n                         typename enable_if<__same_or_less_cv_qualified<_Up*, _Tp*>::value>::type* = 0) const _NOEXCEPT\n        {\n            static_assert(sizeof(_Tp) > 0, \"default_delete can not delete incomplete type\");\n            static_assert(!is_void<_Tp>::value, \"default_delete can not delete void type\");\n            delete [] __ptr;\n        }\n};\n\ntemplate <class _Tp, class _Dp = default_delete<_Tp> >\nclass _LIBCPP_TEMPLATE_VIS unique_ptr\n{\npublic:\n    typedef _Tp element_type;\n    typedef _Dp deleter_type;\n    typedef typename __pointer_type<_Tp, deleter_type>::type pointer;\nprivate:\n    __compressed_pair<pointer, deleter_type> __ptr_;\n\n#ifdef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    unique_ptr(unique_ptr&);\n    template <class _Up, class _Ep>\n        unique_ptr(unique_ptr<_Up, _Ep>&);\n    unique_ptr& operator=(unique_ptr&);\n    template <class _Up, class _Ep>\n        unique_ptr& operator=(unique_ptr<_Up, _Ep>&);\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    struct __nat {int __for_bool_;};\n\n    typedef       typename remove_reference<deleter_type>::type& _Dp_reference;\n    typedef const typename remove_reference<deleter_type>::type& _Dp_const_reference;\npublic:\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR unique_ptr() _NOEXCEPT\n        : __ptr_(pointer())\n        {\n            static_assert(!is_pointer<deleter_type>::value,\n                \"unique_ptr constructed with null function pointer deleter\");\n        }\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR unique_ptr(nullptr_t) _NOEXCEPT\n        : __ptr_(pointer())\n        {\n            static_assert(!is_pointer<deleter_type>::value,\n                \"unique_ptr constructed with null function pointer deleter\");\n        }\n    _LIBCPP_INLINE_VISIBILITY explicit unique_ptr(pointer __p) _NOEXCEPT\n        : __ptr_(_VSTD::move(__p))\n        {\n            static_assert(!is_pointer<deleter_type>::value,\n                \"unique_ptr constructed with null function pointer deleter\");\n        }\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(pointer __p, typename conditional<\n                                        is_reference<deleter_type>::value,\n                                        deleter_type,\n                                        typename add_lvalue_reference<const deleter_type>::type>::type __d)\n             _NOEXCEPT\n        : __ptr_(__p, __d) {}\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(pointer __p, typename remove_reference<deleter_type>::type&& __d)\n             _NOEXCEPT\n        : __ptr_(__p, _VSTD::move(__d))\n        {\n            static_assert(!is_reference<deleter_type>::value, \"rvalue deleter bound to reference\");\n        }\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(unique_ptr&& __u) _NOEXCEPT\n        : __ptr_(__u.release(), _VSTD::forward<deleter_type>(__u.get_deleter())) {}\n    template <class _Up, class _Ep>\n        _LIBCPP_INLINE_VISIBILITY\n        unique_ptr(unique_ptr<_Up, _Ep>&& __u,\n                   typename enable_if\n                      <\n                        !is_array<_Up>::value &&\n                         is_convertible<typename unique_ptr<_Up, _Ep>::pointer, pointer>::value &&\n                         is_convertible<_Ep, deleter_type>::value &&\n                         (\n                            !is_reference<deleter_type>::value ||\n                            is_same<deleter_type, _Ep>::value\n                         ),\n                         __nat\n                      >::type = __nat()) _NOEXCEPT\n            : __ptr_(__u.release(), _VSTD::forward<_Ep>(__u.get_deleter())) {}\n\n    template <class _Up>\n        _LIBCPP_INLINE_VISIBILITY unique_ptr(auto_ptr<_Up>&& __p,\n                typename enable_if<\n                                      is_convertible<_Up*, _Tp*>::value &&\n                                      is_same<_Dp, default_delete<_Tp> >::value,\n                                      __nat\n                                  >::type = __nat()) _NOEXCEPT\n            : __ptr_(__p.release())\n            {\n            }\n\n        _LIBCPP_INLINE_VISIBILITY unique_ptr& operator=(unique_ptr&& __u) _NOEXCEPT\n            {\n                reset(__u.release());\n                __ptr_.second() = _VSTD::forward<deleter_type>(__u.get_deleter());\n                return *this;\n            }\n\n        template <class _Up, class _Ep>\n            _LIBCPP_INLINE_VISIBILITY\n            typename enable_if\n            <\n                !is_array<_Up>::value &&\n                is_convertible<typename unique_ptr<_Up, _Ep>::pointer, pointer>::value &&\n                is_assignable<deleter_type&, _Ep&&>::value,\n                unique_ptr&\n            >::type\n            operator=(unique_ptr<_Up, _Ep>&& __u) _NOEXCEPT\n            {\n                reset(__u.release());\n                __ptr_.second() = _VSTD::forward<_Ep>(__u.get_deleter());\n                return *this;\n            }\n#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    _LIBCPP_INLINE_VISIBILITY operator __rv<unique_ptr>()\n    {\n        return __rv<unique_ptr>(*this);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(__rv<unique_ptr> __u)\n        : __ptr_(__u->release(), _VSTD::forward<deleter_type>(__u->get_deleter())) {}\n\n    template <class _Up, class _Ep>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<\n        !is_array<_Up>::value &&\n        is_convertible<typename unique_ptr<_Up, _Ep>::pointer, pointer>::value &&\n        is_assignable<deleter_type&, _Ep&>::value,\n        unique_ptr&\n    >::type\n    operator=(unique_ptr<_Up, _Ep> __u)\n    {\n        reset(__u.release());\n        __ptr_.second() = _VSTD::forward<_Ep>(__u.get_deleter());\n        return *this;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(pointer __p, deleter_type __d)\n        : __ptr_(_VSTD::move(__p), _VSTD::move(__d)) {}\n\n    template <class _Up>\n        _LIBCPP_INLINE_VISIBILITY\n                typename enable_if<\n                                      is_convertible<_Up*, _Tp*>::value &&\n                                      is_same<_Dp, default_delete<_Tp> >::value,\n                                      unique_ptr&\n                                  >::type\n        operator=(auto_ptr<_Up> __p)\n            {reset(__p.release()); return *this;}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY ~unique_ptr() {reset();}\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr& operator=(nullptr_t) _NOEXCEPT\n    {\n        reset();\n        return *this;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY typename add_lvalue_reference<_Tp>::type operator*() const\n        {return *__ptr_.first();}\n    _LIBCPP_INLINE_VISIBILITY pointer operator->() const _NOEXCEPT {return __ptr_.first();}\n    _LIBCPP_INLINE_VISIBILITY pointer get() const _NOEXCEPT {return __ptr_.first();}\n    _LIBCPP_INLINE_VISIBILITY       _Dp_reference get_deleter() _NOEXCEPT\n        {return __ptr_.second();}\n    _LIBCPP_INLINE_VISIBILITY _Dp_const_reference get_deleter() const _NOEXCEPT\n        {return __ptr_.second();}\n    _LIBCPP_INLINE_VISIBILITY\n        _LIBCPP_EXPLICIT operator bool() const _NOEXCEPT\n        {return __ptr_.first() != nullptr;}\n\n    _LIBCPP_INLINE_VISIBILITY pointer release() _NOEXCEPT\n    {\n        pointer __t = __ptr_.first();\n        __ptr_.first() = pointer();\n        return __t;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY void reset(pointer __p = pointer()) _NOEXCEPT\n    {\n        pointer __tmp = __ptr_.first();\n        __ptr_.first() = __p;\n        if (__tmp)\n            __ptr_.second()(__tmp);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY void swap(unique_ptr& __u) _NOEXCEPT\n        {__ptr_.swap(__u.__ptr_);}\n};\n\ntemplate <class _Tp, class _Dp>\nclass _LIBCPP_TEMPLATE_VIS unique_ptr<_Tp[], _Dp>\n{\npublic:\n    typedef _Tp element_type;\n    typedef _Dp deleter_type;\n    typedef typename __pointer_type<_Tp, deleter_type>::type pointer;\nprivate:\n    __compressed_pair<pointer, deleter_type> __ptr_;\n\n#ifdef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    unique_ptr(unique_ptr&);\n    template <class _Up>\n        unique_ptr(unique_ptr<_Up>&);\n    unique_ptr& operator=(unique_ptr&);\n    template <class _Up>\n        unique_ptr& operator=(unique_ptr<_Up>&);\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    struct __nat {int __for_bool_;};\n\n    typedef       typename remove_reference<deleter_type>::type& _Dp_reference;\n    typedef const typename remove_reference<deleter_type>::type& _Dp_const_reference;\npublic:\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR unique_ptr() _NOEXCEPT\n        : __ptr_(pointer())\n        {\n            static_assert(!is_pointer<deleter_type>::value,\n                \"unique_ptr constructed with null function pointer deleter\");\n        }\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR unique_ptr(nullptr_t) _NOEXCEPT\n        : __ptr_(pointer())\n        {\n            static_assert(!is_pointer<deleter_type>::value,\n                \"unique_ptr constructed with null function pointer deleter\");\n        }\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    template <class _Pp>\n    _LIBCPP_INLINE_VISIBILITY explicit unique_ptr(_Pp __p,\n            typename enable_if<__same_or_less_cv_qualified<_Pp, pointer>::value, __nat>::type = __nat()) _NOEXCEPT\n        : __ptr_(__p)\n        {\n            static_assert(!is_pointer<deleter_type>::value,\n                \"unique_ptr constructed with null function pointer deleter\");\n        }\n\n    template <class _Pp>\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(_Pp __p, typename conditional<\n                                       is_reference<deleter_type>::value,\n                                       deleter_type,\n                                       typename add_lvalue_reference<const deleter_type>::type>::type __d,\n                                       typename enable_if<__same_or_less_cv_qualified<_Pp, pointer>::value, __nat>::type = __nat())\n             _NOEXCEPT\n        : __ptr_(__p, __d) {}\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(nullptr_t, typename conditional<\n                                       is_reference<deleter_type>::value,\n                                       deleter_type,\n                                       typename add_lvalue_reference<const deleter_type>::type>::type __d)\n             _NOEXCEPT\n        : __ptr_(pointer(), __d) {}\n\n    template <class _Pp>\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(_Pp __p,\n                                         typename remove_reference<deleter_type>::type&& __d,\n                                         typename enable_if<__same_or_less_cv_qualified<_Pp, pointer>::value, __nat>::type = __nat())\n             _NOEXCEPT\n        : __ptr_(__p, _VSTD::move(__d))\n        {\n            static_assert(!is_reference<deleter_type>::value, \"rvalue deleter bound to reference\");\n        }\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(nullptr_t, typename remove_reference<deleter_type>::type&& __d)\n             _NOEXCEPT\n        : __ptr_(pointer(), _VSTD::move(__d))\n        {\n            static_assert(!is_reference<deleter_type>::value, \"rvalue deleter bound to reference\");\n        }\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(unique_ptr&& __u) _NOEXCEPT\n        : __ptr_(__u.release(), _VSTD::forward<deleter_type>(__u.get_deleter())) {}\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr& operator=(unique_ptr&& __u) _NOEXCEPT\n        {\n            reset(__u.release());\n            __ptr_.second() = _VSTD::forward<deleter_type>(__u.get_deleter());\n            return *this;\n        }\n\n    template <class _Up, class _Ep>\n        _LIBCPP_INLINE_VISIBILITY\n        unique_ptr(unique_ptr<_Up, _Ep>&& __u,\n                   typename enable_if\n                            <\n                                is_array<_Up>::value &&\n                                __same_or_less_cv_qualified<typename unique_ptr<_Up, _Ep>::pointer, pointer>::value\n                                && is_convertible<_Ep, deleter_type>::value &&\n                                (\n                                    !is_reference<deleter_type>::value ||\n                                    is_same<deleter_type, _Ep>::value\n                                ),\n                                __nat\n                            >::type = __nat()\n                  ) _NOEXCEPT\n        : __ptr_(__u.release(), _VSTD::forward<deleter_type>(__u.get_deleter())) {}\n\n\n        template <class _Up, class _Ep>\n            _LIBCPP_INLINE_VISIBILITY\n            typename enable_if\n            <\n                is_array<_Up>::value &&\n                __same_or_less_cv_qualified<typename unique_ptr<_Up, _Ep>::pointer, pointer>::value &&\n                is_assignable<deleter_type&, _Ep&&>::value,\n                unique_ptr&\n            >::type\n            operator=(unique_ptr<_Up, _Ep>&& __u) _NOEXCEPT\n            {\n                reset(__u.release());\n                __ptr_.second() = _VSTD::forward<_Ep>(__u.get_deleter());\n                return *this;\n            }\n#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    _LIBCPP_INLINE_VISIBILITY explicit unique_ptr(pointer __p)\n        : __ptr_(__p)\n        {\n            static_assert(!is_pointer<deleter_type>::value,\n                \"unique_ptr constructed with null function pointer deleter\");\n        }\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(pointer __p, deleter_type __d)\n        : __ptr_(__p, _VSTD::forward<deleter_type>(__d)) {}\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(nullptr_t, deleter_type __d)\n        : __ptr_(pointer(), _VSTD::forward<deleter_type>(__d)) {}\n\n    _LIBCPP_INLINE_VISIBILITY operator __rv<unique_ptr>()\n    {\n        return __rv<unique_ptr>(*this);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(__rv<unique_ptr> __u)\n        : __ptr_(__u->release(), _VSTD::forward<deleter_type>(__u->get_deleter())) {}\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr& operator=(__rv<unique_ptr> __u)\n    {\n        reset(__u->release());\n        __ptr_.second() = _VSTD::forward<deleter_type>(__u->get_deleter());\n        return *this;\n    }\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY ~unique_ptr() {reset();}\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr& operator=(nullptr_t) _NOEXCEPT\n    {\n        reset();\n        return *this;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY typename add_lvalue_reference<_Tp>::type operator[](size_t __i) const\n        {return __ptr_.first()[__i];}\n    _LIBCPP_INLINE_VISIBILITY pointer get() const _NOEXCEPT {return __ptr_.first();}\n    _LIBCPP_INLINE_VISIBILITY       _Dp_reference get_deleter() _NOEXCEPT\n        {return __ptr_.second();}\n    _LIBCPP_INLINE_VISIBILITY _Dp_const_reference get_deleter() const _NOEXCEPT\n        {return __ptr_.second();}\n    _LIBCPP_INLINE_VISIBILITY\n        _LIBCPP_EXPLICIT operator bool() const _NOEXCEPT\n        {return __ptr_.first() != nullptr;}\n\n    _LIBCPP_INLINE_VISIBILITY pointer release() _NOEXCEPT\n    {\n        pointer __t = __ptr_.first();\n        __ptr_.first() = pointer();\n        return __t;\n    }\n\n    template <class _Pp>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__same_or_less_cv_qualified<_Pp, pointer>::value, void>::type\n    reset(_Pp __p) _NOEXCEPT\n    {\n        pointer __tmp = __ptr_.first();\n        __ptr_.first() = __p;\n        if (__tmp)\n            __ptr_.second()(__tmp);\n    }\n    _LIBCPP_INLINE_VISIBILITY void reset(nullptr_t = nullptr) _NOEXCEPT\n    {\n        pointer __tmp = __ptr_.first();\n        __ptr_.first() = nullptr;\n        if (__tmp)\n            __ptr_.second()(__tmp);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY void swap(unique_ptr& __u) {__ptr_.swap(__u.__ptr_);}\nprivate:\n\n#ifdef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    template <class _Up>\n        explicit unique_ptr(_Up);\n    template <class _Up>\n        unique_ptr(_Up __u,\n                   typename conditional<\n                                       is_reference<deleter_type>::value,\n                                       deleter_type,\n                                       typename add_lvalue_reference<const deleter_type>::type>::type,\n                   typename enable_if\n                      <\n                         is_convertible<_Up, pointer>::value,\n                         __nat\n                      >::type = __nat());\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n};\n\ntemplate <class _Tp, class _Dp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<\n    __is_swappable<_Dp>::value,\n    void\n>::type\nswap(unique_ptr<_Tp, _Dp>& __x, unique_ptr<_Tp, _Dp>& __y) _NOEXCEPT {__x.swap(__y);}\n\ntemplate <class _T1, class _D1, class _T2, class _D2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y) {return __x.get() == __y.get();}\n\ntemplate <class _T1, class _D1, class _T2, class _D2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y) {return !(__x == __y);}\n\ntemplate <class _T1, class _D1, class _T2, class _D2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator< (const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y)\n{\n    typedef typename unique_ptr<_T1, _D1>::pointer _P1;\n    typedef typename unique_ptr<_T2, _D2>::pointer _P2;\n    typedef typename common_type<_P1, _P2>::type _Vp;\n    return less<_Vp>()(__x.get(), __y.get());\n}\n\ntemplate <class _T1, class _D1, class _T2, class _D2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator> (const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y) {return __y < __x;}\n\ntemplate <class _T1, class _D1, class _T2, class _D2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y) {return !(__y < __x);}\n\ntemplate <class _T1, class _D1, class _T2, class _D2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y) {return !(__x < __y);}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const unique_ptr<_T1, _D1>& __x, nullptr_t) _NOEXCEPT\n{\n    return !__x;\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(nullptr_t, const unique_ptr<_T1, _D1>& __x) _NOEXCEPT\n{\n    return !__x;\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const unique_ptr<_T1, _D1>& __x, nullptr_t) _NOEXCEPT\n{\n    return static_cast<bool>(__x);\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(nullptr_t, const unique_ptr<_T1, _D1>& __x) _NOEXCEPT\n{\n    return static_cast<bool>(__x);\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<(const unique_ptr<_T1, _D1>& __x, nullptr_t)\n{\n    typedef typename unique_ptr<_T1, _D1>::pointer _P1;\n    return less<_P1>()(__x.get(), nullptr);\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<(nullptr_t, const unique_ptr<_T1, _D1>& __x)\n{\n    typedef typename unique_ptr<_T1, _D1>::pointer _P1;\n    return less<_P1>()(nullptr, __x.get());\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>(const unique_ptr<_T1, _D1>& __x, nullptr_t)\n{\n    return nullptr < __x;\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>(nullptr_t, const unique_ptr<_T1, _D1>& __x)\n{\n    return __x < nullptr;\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const unique_ptr<_T1, _D1>& __x, nullptr_t)\n{\n    return !(nullptr < __x);\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(nullptr_t, const unique_ptr<_T1, _D1>& __x)\n{\n    return !(__x < nullptr);\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const unique_ptr<_T1, _D1>& __x, nullptr_t)\n{\n    return !(__x < nullptr);\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(nullptr_t, const unique_ptr<_T1, _D1>& __x)\n{\n    return !(nullptr < __x);\n}\n\n#ifdef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Dp>\ninline _LIBCPP_INLINE_VISIBILITY\nunique_ptr<_Tp, _Dp>\nmove(unique_ptr<_Tp, _Dp>& __t)\n{\n    return unique_ptr<_Tp, _Dp>(__rv<unique_ptr<_Tp, _Dp> >(__t));\n}\n\n#endif\n\n#if _LIBCPP_STD_VER > 11\n\ntemplate<class _Tp>\nstruct __unique_if\n{\n    typedef unique_ptr<_Tp> __unique_single;\n};\n\ntemplate<class _Tp>\nstruct __unique_if<_Tp[]>\n{\n    typedef unique_ptr<_Tp[]> __unique_array_unknown_bound;\n};\n\ntemplate<class _Tp, size_t _Np>\nstruct __unique_if<_Tp[_Np]>\n{\n    typedef void __unique_array_known_bound;\n};\n\ntemplate<class _Tp, class... _Args>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename __unique_if<_Tp>::__unique_single\nmake_unique(_Args&&... __args)\n{\n    return unique_ptr<_Tp>(new _Tp(_VSTD::forward<_Args>(__args)...));\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename __unique_if<_Tp>::__unique_array_unknown_bound\nmake_unique(size_t __n)\n{\n    typedef typename remove_extent<_Tp>::type _Up;\n    return unique_ptr<_Tp>(new _Up[__n]());\n}\n\ntemplate<class _Tp, class... _Args>\n    typename __unique_if<_Tp>::__unique_array_known_bound\n    make_unique(_Args&&...) = delete;\n\n#endif  // _LIBCPP_STD_VER > 11\n\ntemplate <class _Size>\ninline _LIBCPP_INLINE_VISIBILITY\n_Size\n__loadword(const void* __p)\n{\n    _Size __r;\n    std::memcpy(&__r, __p, sizeof(__r));\n    return __r;\n}\n\n// We use murmur2 when size_t is 32 bits, and cityhash64 when size_t\n// is 64 bits.  This is because cityhash64 uses 64bit x 64bit\n// multiplication, which can be very slow on 32-bit systems.\ntemplate <class _Size, size_t = sizeof(_Size)*__CHAR_BIT__>\nstruct __murmur2_or_cityhash;\n\ntemplate <class _Size>\nstruct __murmur2_or_cityhash<_Size, 32>\n{\n    _Size operator()(const void* __key, _Size __len);\n};\n\n// murmur2\ntemplate <class _Size>\n_Size\n__murmur2_or_cityhash<_Size, 32>::operator()(const void* __key, _Size __len) _LIBCPP_DISABLE_UBSAN_UNSIGNED_INTEGER_CHECK \n{\n    const _Size __m = 0x5bd1e995;\n    const _Size __r = 24;\n    _Size __h = __len;\n    const unsigned char* __data = static_cast<const unsigned char*>(__key);\n    for (; __len >= 4; __data += 4, __len -= 4)\n    {\n        _Size __k = __loadword<_Size>(__data);\n        __k *= __m;\n        __k ^= __k >> __r;\n        __k *= __m;\n        __h *= __m;\n        __h ^= __k;\n    }\n    switch (__len)\n    {\n    case 3:\n        __h ^= __data[2] << 16;\n    case 2:\n        __h ^= __data[1] << 8;\n    case 1:\n        __h ^= __data[0];\n        __h *= __m;\n    }\n    __h ^= __h >> 13;\n    __h *= __m;\n    __h ^= __h >> 15;\n    return __h;\n}\n\ntemplate <class _Size>\nstruct __murmur2_or_cityhash<_Size, 64>\n{\n    _Size operator()(const void* __key, _Size __len);\n\n private:\n  // Some primes between 2^63 and 2^64.\n  static const _Size __k0 = 0xc3a5c85c97cb3127ULL;\n  static const _Size __k1 = 0xb492b66fbe98f273ULL;\n  static const _Size __k2 = 0x9ae16a3b2f90404fULL;\n  static const _Size __k3 = 0xc949d7c7509e6557ULL;\n\n  static _Size __rotate(_Size __val, int __shift) {\n    return __shift == 0 ? __val : ((__val >> __shift) | (__val << (64 - __shift)));\n  }\n\n  static _Size __rotate_by_at_least_1(_Size __val, int __shift) {\n    return (__val >> __shift) | (__val << (64 - __shift));\n  }\n\n  static _Size __shift_mix(_Size __val) {\n    return __val ^ (__val >> 47);\n  }\n\n  static _Size __hash_len_16(_Size __u, _Size __v) {\n    const _Size __mul = 0x9ddfea08eb382d69ULL;\n    _Size __a = (__u ^ __v) * __mul;\n    __a ^= (__a >> 47);\n    _Size __b = (__v ^ __a) * __mul;\n    __b ^= (__b >> 47);\n    __b *= __mul;\n    return __b;\n  }\n\n  static _Size __hash_len_0_to_16(const char* __s, _Size __len) {\n    if (__len > 8) {\n      const _Size __a = __loadword<_Size>(__s);\n      const _Size __b = __loadword<_Size>(__s + __len - 8);\n      return __hash_len_16(__a, __rotate_by_at_least_1(__b + __len, __len)) ^ __b;\n    }\n    if (__len >= 4) {\n      const uint32_t __a = __loadword<uint32_t>(__s);\n      const uint32_t __b = __loadword<uint32_t>(__s + __len - 4);\n      return __hash_len_16(__len + (__a << 3), __b);\n    }\n    if (__len > 0) {\n      const unsigned char __a = __s[0];\n      const unsigned char __b = __s[__len >> 1];\n      const unsigned char __c = __s[__len - 1];\n      const uint32_t __y = static_cast<uint32_t>(__a) +\n                           (static_cast<uint32_t>(__b) << 8);\n      const uint32_t __z = __len + (static_cast<uint32_t>(__c) << 2);\n      return __shift_mix(__y * __k2 ^ __z * __k3) * __k2;\n    }\n    return __k2;\n  }\n\n  static _Size __hash_len_17_to_32(const char *__s, _Size __len) {\n    const _Size __a = __loadword<_Size>(__s) * __k1;\n    const _Size __b = __loadword<_Size>(__s + 8);\n    const _Size __c = __loadword<_Size>(__s + __len - 8) * __k2;\n    const _Size __d = __loadword<_Size>(__s + __len - 16) * __k0;\n    return __hash_len_16(__rotate(__a - __b, 43) + __rotate(__c, 30) + __d,\n                         __a + __rotate(__b ^ __k3, 20) - __c + __len);\n  }\n\n  // Return a 16-byte hash for 48 bytes.  Quick and dirty.\n  // Callers do best to use \"random-looking\" values for a and b.\n  static pair<_Size, _Size> __weak_hash_len_32_with_seeds(\n      _Size __w, _Size __x, _Size __y, _Size __z, _Size __a, _Size __b) {\n    __a += __w;\n    __b = __rotate(__b + __a + __z, 21);\n    const _Size __c = __a;\n    __a += __x;\n    __a += __y;\n    __b += __rotate(__a, 44);\n    return pair<_Size, _Size>(__a + __z, __b + __c);\n  }\n\n  // Return a 16-byte hash for s[0] ... s[31], a, and b.  Quick and dirty.\n  static pair<_Size, _Size> __weak_hash_len_32_with_seeds(\n      const char* __s, _Size __a, _Size __b) {\n    return __weak_hash_len_32_with_seeds(__loadword<_Size>(__s),\n                                         __loadword<_Size>(__s + 8),\n                                         __loadword<_Size>(__s + 16),\n                                         __loadword<_Size>(__s + 24),\n                                         __a,\n                                         __b);\n  }\n\n  // Return an 8-byte hash for 33 to 64 bytes.\n  static _Size __hash_len_33_to_64(const char *__s, size_t __len) {\n    _Size __z = __loadword<_Size>(__s + 24);\n    _Size __a = __loadword<_Size>(__s) +\n                (__len + __loadword<_Size>(__s + __len - 16)) * __k0;\n    _Size __b = __rotate(__a + __z, 52);\n    _Size __c = __rotate(__a, 37);\n    __a += __loadword<_Size>(__s + 8);\n    __c += __rotate(__a, 7);\n    __a += __loadword<_Size>(__s + 16);\n    _Size __vf = __a + __z;\n    _Size __vs = __b + __rotate(__a, 31) + __c;\n    __a = __loadword<_Size>(__s + 16) + __loadword<_Size>(__s + __len - 32);\n    __z += __loadword<_Size>(__s + __len - 8);\n    __b = __rotate(__a + __z, 52);\n    __c = __rotate(__a, 37);\n    __a += __loadword<_Size>(__s + __len - 24);\n    __c += __rotate(__a, 7);\n    __a += __loadword<_Size>(__s + __len - 16);\n    _Size __wf = __a + __z;\n    _Size __ws = __b + __rotate(__a, 31) + __c;\n    _Size __r = __shift_mix((__vf + __ws) * __k2 + (__wf + __vs) * __k0);\n    return __shift_mix(__r * __k0 + __vs) * __k2;\n  }\n};\n\n// cityhash64\ntemplate <class _Size>\n_Size\n__murmur2_or_cityhash<_Size, 64>::operator()(const void* __key, _Size __len) _LIBCPP_DISABLE_UBSAN_UNSIGNED_INTEGER_CHECK \n{\n  const char* __s = static_cast<const char*>(__key);\n  if (__len <= 32) {\n    if (__len <= 16) {\n      return __hash_len_0_to_16(__s, __len);\n    } else {\n      return __hash_len_17_to_32(__s, __len);\n    }\n  } else if (__len <= 64) {\n    return __hash_len_33_to_64(__s, __len);\n  }\n\n  // For strings over 64 bytes we hash the end first, and then as we\n  // loop we keep 56 bytes of state: v, w, x, y, and z.\n  _Size __x = __loadword<_Size>(__s + __len - 40);\n  _Size __y = __loadword<_Size>(__s + __len - 16) +\n              __loadword<_Size>(__s + __len - 56);\n  _Size __z = __hash_len_16(__loadword<_Size>(__s + __len - 48) + __len,\n                          __loadword<_Size>(__s + __len - 24));\n  pair<_Size, _Size> __v = __weak_hash_len_32_with_seeds(__s + __len - 64, __len, __z);\n  pair<_Size, _Size> __w = __weak_hash_len_32_with_seeds(__s + __len - 32, __y + __k1, __x);\n  __x = __x * __k1 + __loadword<_Size>(__s);\n\n  // Decrease len to the nearest multiple of 64, and operate on 64-byte chunks.\n  __len = (__len - 1) & ~static_cast<_Size>(63);\n  do {\n    __x = __rotate(__x + __y + __v.first + __loadword<_Size>(__s + 8), 37) * __k1;\n    __y = __rotate(__y + __v.second + __loadword<_Size>(__s + 48), 42) * __k1;\n    __x ^= __w.second;\n    __y += __v.first + __loadword<_Size>(__s + 40);\n    __z = __rotate(__z + __w.first, 33) * __k1;\n    __v = __weak_hash_len_32_with_seeds(__s, __v.second * __k1, __x + __w.first);\n    __w = __weak_hash_len_32_with_seeds(__s + 32, __z + __w.second,\n                                        __y + __loadword<_Size>(__s + 16));\n    std::swap(__z, __x);\n    __s += 64;\n    __len -= 64;\n  } while (__len != 0);\n  return __hash_len_16(\n      __hash_len_16(__v.first, __w.first) + __shift_mix(__y) * __k1 + __z,\n      __hash_len_16(__v.second, __w.second) + __x);\n}\n\ntemplate <class _Tp, size_t = sizeof(_Tp) / sizeof(size_t)>\nstruct __scalar_hash;\n\ntemplate <class _Tp>\nstruct __scalar_hash<_Tp, 0>\n    : public unary_function<_Tp, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(_Tp __v) const _NOEXCEPT\n    {\n        union\n        {\n            _Tp    __t;\n            size_t __a;\n        } __u;\n        __u.__a = 0;\n        __u.__t = __v;\n        return __u.__a;\n    }\n};\n\ntemplate <class _Tp>\nstruct __scalar_hash<_Tp, 1>\n    : public unary_function<_Tp, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(_Tp __v) const _NOEXCEPT\n    {\n        union\n        {\n            _Tp    __t;\n            size_t __a;\n        } __u;\n        __u.__t = __v;\n        return __u.__a;\n    }\n};\n\ntemplate <class _Tp>\nstruct __scalar_hash<_Tp, 2>\n    : public unary_function<_Tp, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(_Tp __v) const _NOEXCEPT\n    {\n        union\n        {\n            _Tp __t;\n            struct\n            {\n                size_t __a;\n                size_t __b;\n            } __s;\n        } __u;\n        __u.__t = __v;\n        return __murmur2_or_cityhash<size_t>()(&__u, sizeof(__u));\n    }\n};\n\ntemplate <class _Tp>\nstruct __scalar_hash<_Tp, 3>\n    : public unary_function<_Tp, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(_Tp __v) const _NOEXCEPT\n    {\n        union\n        {\n            _Tp __t;\n            struct\n            {\n                size_t __a;\n                size_t __b;\n                size_t __c;\n            } __s;\n        } __u;\n        __u.__t = __v;\n        return __murmur2_or_cityhash<size_t>()(&__u, sizeof(__u));\n    }\n};\n\ntemplate <class _Tp>\nstruct __scalar_hash<_Tp, 4>\n    : public unary_function<_Tp, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(_Tp __v) const _NOEXCEPT\n    {\n        union\n        {\n            _Tp __t;\n            struct\n            {\n                size_t __a;\n                size_t __b;\n                size_t __c;\n                size_t __d;\n            } __s;\n        } __u;\n        __u.__t = __v;\n        return __murmur2_or_cityhash<size_t>()(&__u, sizeof(__u));\n    }\n};\n\nstruct _PairT {\n  size_t first;\n  size_t second;\n};\n\n_LIBCPP_INLINE_VISIBILITY\ninline size_t __hash_combine(size_t __lhs, size_t __rhs) _NOEXCEPT {\n    typedef __scalar_hash<_PairT> _HashT;\n    const _PairT __p = {__lhs, __rhs};\n    return _HashT()(__p);\n}\n\ntemplate<class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS hash<_Tp*>\n    : public unary_function<_Tp*, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(_Tp* __v) const _NOEXCEPT\n    {\n        union\n        {\n            _Tp* __t;\n            size_t __a;\n        } __u;\n        __u.__t = __v;\n        return __murmur2_or_cityhash<size_t>()(&__u, sizeof(__u));\n    }\n};\n\ntemplate <class _Tp, class _Dp>\nstruct _LIBCPP_TEMPLATE_VIS hash<unique_ptr<_Tp, _Dp> >\n{\n    typedef unique_ptr<_Tp, _Dp> argument_type;\n    typedef size_t               result_type;\n    _LIBCPP_INLINE_VISIBILITY\n    result_type operator()(const argument_type& __ptr) const _NOEXCEPT\n    {\n        typedef typename argument_type::pointer pointer;\n        return hash<pointer>()(__ptr.get());\n    }\n};\n\nstruct __destruct_n\n{\nprivate:\n    size_t size;\n\n    template <class _Tp>\n    _LIBCPP_INLINE_VISIBILITY void __process(_Tp* __p, false_type) _NOEXCEPT\n        {for (size_t __i = 0; __i < size; ++__i, ++__p) __p->~_Tp();}\n\n    template <class _Tp>\n    _LIBCPP_INLINE_VISIBILITY void __process(_Tp*, true_type) _NOEXCEPT\n        {}\n\n    _LIBCPP_INLINE_VISIBILITY void __incr(false_type) _NOEXCEPT\n        {++size;}\n    _LIBCPP_INLINE_VISIBILITY void __incr(true_type) _NOEXCEPT\n        {}\n\n    _LIBCPP_INLINE_VISIBILITY void __set(size_t __s, false_type) _NOEXCEPT\n        {size = __s;}\n    _LIBCPP_INLINE_VISIBILITY void __set(size_t, true_type) _NOEXCEPT\n        {}\npublic:\n    _LIBCPP_INLINE_VISIBILITY explicit __destruct_n(size_t __s) _NOEXCEPT\n        : size(__s) {}\n\n    template <class _Tp>\n    _LIBCPP_INLINE_VISIBILITY void __incr(_Tp*) _NOEXCEPT\n        {__incr(integral_constant<bool, is_trivially_destructible<_Tp>::value>());}\n\n    template <class _Tp>\n    _LIBCPP_INLINE_VISIBILITY void __set(size_t __s, _Tp*) _NOEXCEPT\n        {__set(__s, integral_constant<bool, is_trivially_destructible<_Tp>::value>());}\n\n    template <class _Tp>\n    _LIBCPP_INLINE_VISIBILITY void operator()(_Tp* __p) _NOEXCEPT\n        {__process(__p, integral_constant<bool, is_trivially_destructible<_Tp>::value>());}\n};\n\ntemplate <class _Alloc>\nclass __allocator_destructor\n{\n    typedef allocator_traits<_Alloc> __alloc_traits;\npublic:\n    typedef typename __alloc_traits::pointer pointer;\n    typedef typename __alloc_traits::size_type size_type;\nprivate:\n    _Alloc& __alloc_;\n    size_type __s_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY __allocator_destructor(_Alloc& __a, size_type __s)\n             _NOEXCEPT\n        : __alloc_(__a), __s_(__s) {}\n    _LIBCPP_INLINE_VISIBILITY\n    void operator()(pointer __p) _NOEXCEPT\n        {__alloc_traits::deallocate(__alloc_, __p, __s_);}\n};\n\ntemplate <class _InputIterator, class _ForwardIterator>\n_ForwardIterator\nuninitialized_copy(_InputIterator __f, _InputIterator __l, _ForwardIterator __r)\n{\n    typedef typename iterator_traits<_ForwardIterator>::value_type value_type;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    _ForwardIterator __s = __r;\n    try\n    {\n#endif\n        for (; __f != __l; ++__f, (void) ++__r)\n            ::new (static_cast<void*>(_VSTD::addressof(*__r))) value_type(*__f);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        for (; __s != __r; ++__s)\n            __s->~value_type();\n        throw;\n    }\n#endif\n    return __r;\n}\n\ntemplate <class _InputIterator, class _Size, class _ForwardIterator>\n_ForwardIterator\nuninitialized_copy_n(_InputIterator __f, _Size __n, _ForwardIterator __r)\n{\n    typedef typename iterator_traits<_ForwardIterator>::value_type value_type;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    _ForwardIterator __s = __r;\n    try\n    {\n#endif\n        for (; __n > 0; ++__f, (void) ++__r, (void) --__n)\n            ::new (static_cast<void*>(_VSTD::addressof(*__r))) value_type(*__f);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        for (; __s != __r; ++__s)\n            __s->~value_type();\n        throw;\n    }\n#endif\n    return __r;\n}\n\ntemplate <class _ForwardIterator, class _Tp>\nvoid\nuninitialized_fill(_ForwardIterator __f, _ForwardIterator __l, const _Tp& __x)\n{\n    typedef typename iterator_traits<_ForwardIterator>::value_type value_type;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    _ForwardIterator __s = __f;\n    try\n    {\n#endif\n        for (; __f != __l; ++__f)\n            ::new (static_cast<void*>(_VSTD::addressof(*__f))) value_type(__x);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        for (; __s != __f; ++__s)\n            __s->~value_type();\n        throw;\n    }\n#endif\n}\n\ntemplate <class _ForwardIterator, class _Size, class _Tp>\n_ForwardIterator\nuninitialized_fill_n(_ForwardIterator __f, _Size __n, const _Tp& __x)\n{\n    typedef typename iterator_traits<_ForwardIterator>::value_type value_type;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    _ForwardIterator __s = __f;\n    try\n    {\n#endif\n        for (; __n > 0; ++__f, (void) --__n)\n            ::new (static_cast<void*>(_VSTD::addressof(*__f))) value_type(__x);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        for (; __s != __f; ++__s)\n            __s->~value_type();\n        throw;\n    }\n#endif\n    return __f;\n}\n\n#if _LIBCPP_STD_VER > 14\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid destroy_at(_Tp* __loc) {\n    _LIBCPP_ASSERT(__loc, \"null pointer given to destroy_at\");\n    __loc->~_Tp();\n}\n\ntemplate <class _ForwardIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid destroy(_ForwardIterator __first, _ForwardIterator __last) {\n    for (; __first != __last; ++__first)\n        _VSTD::destroy_at(_VSTD::addressof(*__first));\n}\n\ntemplate <class _ForwardIterator, class _Size>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator destroy_n(_ForwardIterator __first, _Size __n) {\n    for (; __n > 0; (void)++__first, --__n)\n        _VSTD::destroy_at(_VSTD::addressof(*__first));\n    return __first;\n}\n\ntemplate <class _ForwardIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid uninitialized_default_construct(_ForwardIterator __first, _ForwardIterator __last) {\n    using _Vt = typename iterator_traits<_ForwardIterator>::value_type;\n    auto __idx = __first;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try {\n#endif\n    for (; __idx != __last; ++__idx)\n        ::new((void*)_VSTD::addressof(*__idx)) _Vt;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    } catch (...) {\n        _VSTD::destroy(__first, __idx);\n        throw;\n    }\n#endif\n}\n\ntemplate <class _ForwardIterator, class _Size>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator uninitialized_default_construct_n(_ForwardIterator __first, _Size __n) {\n    using _Vt = typename iterator_traits<_ForwardIterator>::value_type;\n    auto __idx = __first;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try {\n#endif\n    for (; __n > 0; (void)++__idx, --__n)\n        ::new((void*)_VSTD::addressof(*__idx)) _Vt;\n    return __idx;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    } catch (...) {\n        _VSTD::destroy(__first, __idx);\n        throw;\n    }\n#endif\n}\n\n\ntemplate <class _ForwardIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid uninitialized_value_construct(_ForwardIterator __first, _ForwardIterator __last) {\n    using _Vt = typename iterator_traits<_ForwardIterator>::value_type;\n    auto __idx = __first;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try {\n#endif\n    for (; __idx != __last; ++__idx)\n        ::new((void*)_VSTD::addressof(*__idx)) _Vt();\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    } catch (...) {\n        _VSTD::destroy(__first, __idx);\n        throw;\n    }\n#endif\n}\n\ntemplate <class _ForwardIterator, class _Size>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator uninitialized_value_construct_n(_ForwardIterator __first, _Size __n) {\n    using _Vt = typename iterator_traits<_ForwardIterator>::value_type;\n    auto __idx = __first;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try {\n#endif\n    for (; __n > 0; (void)++__idx, --__n)\n        ::new((void*)_VSTD::addressof(*__idx)) _Vt();\n    return __idx;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    } catch (...) {\n        _VSTD::destroy(__first, __idx);\n        throw;\n    }\n#endif\n}\n\n\ntemplate <class _InputIt, class _ForwardIt>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIt uninitialized_move(_InputIt __first, _InputIt __last, _ForwardIt __first_res) {\n    using _Vt = typename iterator_traits<_ForwardIt>::value_type;\n    auto __idx = __first_res;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try {\n#endif\n    for (; __first != __last; (void)++__idx, ++__first)\n        ::new((void*)_VSTD::addressof(*__idx)) _Vt(std::move(*__first));\n    return __idx;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    } catch (...) {\n        _VSTD::destroy(__first_res, __idx);\n        throw;\n    }\n#endif\n}\n\ntemplate <class _InputIt, class _Size, class _ForwardIt>\ninline _LIBCPP_INLINE_VISIBILITY\npair<_InputIt, _ForwardIt>\nuninitialized_move_n(_InputIt __first, _Size __n, _ForwardIt __first_res) {\n    using _Vt = typename iterator_traits<_ForwardIt>::value_type;\n    auto __idx = __first_res;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try {\n#endif\n    for (; __n > 0; ++__idx, (void)++__first, --__n)\n        ::new((void*)_VSTD::addressof(*__idx)) _Vt(std::move(*__first));\n    return {__first, __idx};\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    } catch (...) {\n        _VSTD::destroy(__first_res, __idx);\n        throw;\n    }\n#endif\n}\n\n\n#endif // _LIBCPP_STD_VER > 14\n\nclass _LIBCPP_EXCEPTION_ABI bad_weak_ptr\n    : public std::exception\n{\npublic:\n    virtual ~bad_weak_ptr() _NOEXCEPT;\n    virtual const char* what() const  _NOEXCEPT;\n};\n\n_LIBCPP_NORETURN inline _LIBCPP_ALWAYS_INLINE\nvoid __throw_bad_weak_ptr()\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    throw bad_weak_ptr();\n#else\n    _VSTD::abort();\n#endif\n}\n\ntemplate<class _Tp> class _LIBCPP_TEMPLATE_VIS weak_ptr;\n\nclass _LIBCPP_TYPE_VIS __shared_count\n{\n    __shared_count(const __shared_count&);\n    __shared_count& operator=(const __shared_count&);\n\nprotected:\n    long __shared_owners_;\n    virtual ~__shared_count();\nprivate:\n    virtual void __on_zero_shared() _NOEXCEPT = 0;\n\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __shared_count(long __refs = 0) _NOEXCEPT\n        : __shared_owners_(__refs) {}\n\n    void __add_shared() _NOEXCEPT;\n    bool __release_shared() _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    long use_count() const _NOEXCEPT {\n        return __libcpp_relaxed_load(&__shared_owners_) + 1;\n    }\n};\n\nclass _LIBCPP_TYPE_VIS __shared_weak_count\n    : private __shared_count\n{\n    long __shared_weak_owners_;\n\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __shared_weak_count(long __refs = 0) _NOEXCEPT\n        : __shared_count(__refs),\n          __shared_weak_owners_(__refs) {}\nprotected:\n    virtual ~__shared_weak_count();\n\npublic:\n    void __add_shared() _NOEXCEPT;\n    void __add_weak() _NOEXCEPT;\n    void __release_shared() _NOEXCEPT;\n    void __release_weak() _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    long use_count() const _NOEXCEPT {return __shared_count::use_count();}\n    __shared_weak_count* lock() _NOEXCEPT;\n\n    // Define the function out only if we build static libc++ without RTTI.\n    // Otherwise we may break clients who need to compile their projects with\n    // -fno-rtti and yet link against a libc++.dylib compiled\n    // without -fno-rtti.\n#if !defined(_LIBCPP_NO_RTTI) || !defined(_LIBCPP_BUILD_STATIC)\n    virtual const void* __get_deleter(const type_info&) const _NOEXCEPT;\n#endif\nprivate:\n    virtual void __on_zero_shared_weak() _NOEXCEPT = 0;\n};\n\ntemplate <class _Tp, class _Dp, class _Alloc>\nclass __shared_ptr_pointer\n    : public __shared_weak_count\n{\n    __compressed_pair<__compressed_pair<_Tp, _Dp>, _Alloc> __data_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    __shared_ptr_pointer(_Tp __p, _Dp __d, _Alloc __a)\n        :  __data_(__compressed_pair<_Tp, _Dp>(__p, _VSTD::move(__d)), _VSTD::move(__a)) {}\n\n#ifndef _LIBCPP_NO_RTTI\n    virtual const void* __get_deleter(const type_info&) const _NOEXCEPT;\n#endif\n\nprivate:\n    virtual void __on_zero_shared() _NOEXCEPT;\n    virtual void __on_zero_shared_weak() _NOEXCEPT;\n};\n\n#ifndef _LIBCPP_NO_RTTI\n\ntemplate <class _Tp, class _Dp, class _Alloc>\nconst void*\n__shared_ptr_pointer<_Tp, _Dp, _Alloc>::__get_deleter(const type_info& __t) const _NOEXCEPT\n{\n    return __t == typeid(_Dp) ? _VSTD::addressof(__data_.first().second()) : 0;\n}\n\n#endif  // _LIBCPP_NO_RTTI\n\ntemplate <class _Tp, class _Dp, class _Alloc>\nvoid\n__shared_ptr_pointer<_Tp, _Dp, _Alloc>::__on_zero_shared() _NOEXCEPT\n{\n    __data_.first().second()(__data_.first().first());\n    __data_.first().second().~_Dp();\n}\n\ntemplate <class _Tp, class _Dp, class _Alloc>\nvoid\n__shared_ptr_pointer<_Tp, _Dp, _Alloc>::__on_zero_shared_weak() _NOEXCEPT\n{\n    typedef typename __allocator_traits_rebind<_Alloc, __shared_ptr_pointer>::type _Al;\n    typedef allocator_traits<_Al> _ATraits;\n    typedef pointer_traits<typename _ATraits::pointer> _PTraits;\n\n    _Al __a(__data_.second());\n    __data_.second().~_Alloc();\n    __a.deallocate(_PTraits::pointer_to(*this), 1);\n}\n\ntemplate <class _Tp, class _Alloc>\nclass __shared_ptr_emplace\n    : public __shared_weak_count\n{\n    __compressed_pair<_Alloc, _Tp> __data_;\npublic:\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n    _LIBCPP_INLINE_VISIBILITY\n    __shared_ptr_emplace(_Alloc __a)\n        :  __data_(_VSTD::move(__a)) {}\n\n    template <class ..._Args>\n        _LIBCPP_INLINE_VISIBILITY\n        __shared_ptr_emplace(_Alloc __a, _Args&& ...__args)\n            :  __data_(piecewise_construct, _VSTD::forward_as_tuple(__a),\n                   _VSTD::forward_as_tuple(_VSTD::forward<_Args>(__args)...)) {}\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\n    _LIBCPP_INLINE_VISIBILITY\n    __shared_ptr_emplace(_Alloc __a)\n        :  __data_(__a) {}\n\n    template <class _A0>\n        _LIBCPP_INLINE_VISIBILITY\n        __shared_ptr_emplace(_Alloc __a, _A0& __a0)\n            :  __data_(__a, _Tp(__a0)) {}\n\n    template <class _A0, class _A1>\n        _LIBCPP_INLINE_VISIBILITY\n        __shared_ptr_emplace(_Alloc __a, _A0& __a0, _A1& __a1)\n            :  __data_(__a, _Tp(__a0, __a1)) {}\n\n    template <class _A0, class _A1, class _A2>\n        _LIBCPP_INLINE_VISIBILITY\n        __shared_ptr_emplace(_Alloc __a, _A0& __a0, _A1& __a1, _A2& __a2)\n            :  __data_(__a, _Tp(__a0, __a1, __a2)) {}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\nprivate:\n    virtual void __on_zero_shared() _NOEXCEPT;\n    virtual void __on_zero_shared_weak() _NOEXCEPT;\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    _Tp* get() _NOEXCEPT {return &__data_.second();}\n};\n\ntemplate <class _Tp, class _Alloc>\nvoid\n__shared_ptr_emplace<_Tp, _Alloc>::__on_zero_shared() _NOEXCEPT\n{\n    __data_.second().~_Tp();\n}\n\ntemplate <class _Tp, class _Alloc>\nvoid\n__shared_ptr_emplace<_Tp, _Alloc>::__on_zero_shared_weak() _NOEXCEPT\n{\n    typedef typename __allocator_traits_rebind<_Alloc, __shared_ptr_emplace>::type _Al;\n    typedef allocator_traits<_Al> _ATraits;\n    typedef pointer_traits<typename _ATraits::pointer> _PTraits;\n    _Al __a(__data_.first());\n    __data_.first().~_Alloc();\n    __a.deallocate(_PTraits::pointer_to(*this), 1);\n}\n\ntemplate<class _Tp> class _LIBCPP_TEMPLATE_VIS enable_shared_from_this;\n\ntemplate<class _Tp>\nclass _LIBCPP_TEMPLATE_VIS shared_ptr\n{\npublic:\n    typedef _Tp element_type;\n\n#if _LIBCPP_STD_VER > 14\n    typedef weak_ptr<_Tp> weak_type;\n#endif\nprivate:\n    element_type*      __ptr_;\n    __shared_weak_count* __cntrl_;\n\n    struct __nat {int __for_bool_;};\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    _LIBCPP_CONSTEXPR shared_ptr() _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    _LIBCPP_CONSTEXPR shared_ptr(nullptr_t) _NOEXCEPT;\n    template<class _Yp>\n        explicit shared_ptr(_Yp* __p,\n                            typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type = __nat());\n    template<class _Yp, class _Dp>\n        shared_ptr(_Yp* __p, _Dp __d,\n                   typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type = __nat());\n    template<class _Yp, class _Dp, class _Alloc>\n        shared_ptr(_Yp* __p, _Dp __d, _Alloc __a,\n                   typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type = __nat());\n    template <class _Dp> shared_ptr(nullptr_t __p, _Dp __d);\n    template <class _Dp, class _Alloc> shared_ptr(nullptr_t __p, _Dp __d, _Alloc __a);\n    template<class _Yp> _LIBCPP_INLINE_VISIBILITY shared_ptr(const shared_ptr<_Yp>& __r, element_type* __p) _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    shared_ptr(const shared_ptr& __r) _NOEXCEPT;\n    template<class _Yp>\n        _LIBCPP_INLINE_VISIBILITY\n        shared_ptr(const shared_ptr<_Yp>& __r,\n                   typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type = __nat())\n                       _NOEXCEPT;\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    shared_ptr(shared_ptr&& __r) _NOEXCEPT;\n    template<class _Yp> _LIBCPP_INLINE_VISIBILITY  shared_ptr(shared_ptr<_Yp>&& __r,\n                   typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type = __nat())\n                       _NOEXCEPT;\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    template<class _Yp> explicit shared_ptr(const weak_ptr<_Yp>& __r,\n                   typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type= __nat());\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    template<class _Yp>\n        shared_ptr(auto_ptr<_Yp>&& __r,\n                   typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type = __nat());\n#else\n    template<class _Yp>\n        shared_ptr(auto_ptr<_Yp> __r,\n                   typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type = __nat());\n#endif\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    template <class _Yp, class _Dp>\n        shared_ptr(unique_ptr<_Yp, _Dp>&&,\n                   typename enable_if\n                   <\n                       !is_lvalue_reference<_Dp>::value &&\n                       !is_array<_Yp>::value &&\n                       is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type*>::value,\n                       __nat\n                   >::type = __nat());\n    template <class _Yp, class _Dp>\n        shared_ptr(unique_ptr<_Yp, _Dp>&&,\n                   typename enable_if\n                   <\n                       is_lvalue_reference<_Dp>::value &&\n                       !is_array<_Yp>::value &&\n                       is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type*>::value,\n                       __nat\n                   >::type = __nat());\n#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    template <class _Yp, class _Dp>\n        shared_ptr(unique_ptr<_Yp, _Dp>,\n                   typename enable_if\n                   <\n                       !is_lvalue_reference<_Dp>::value &&\n                       !is_array<_Yp>::value &&\n                       is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type*>::value,\n                       __nat\n                   >::type = __nat());\n    template <class _Yp, class _Dp>\n        shared_ptr(unique_ptr<_Yp, _Dp>,\n                   typename enable_if\n                   <\n                       is_lvalue_reference<_Dp>::value &&\n                       !is_array<_Yp>::value &&\n                       is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type*>::value,\n                       __nat\n                   >::type = __nat());\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    ~shared_ptr();\n\n    _LIBCPP_INLINE_VISIBILITY\n    shared_ptr& operator=(const shared_ptr& __r) _NOEXCEPT;\n    template<class _Yp>\n        typename enable_if\n        <\n            is_convertible<_Yp*, element_type*>::value,\n            shared_ptr&\n        >::type\n        _LIBCPP_INLINE_VISIBILITY\n        operator=(const shared_ptr<_Yp>& __r) _NOEXCEPT;\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    shared_ptr& operator=(shared_ptr&& __r) _NOEXCEPT;\n    template<class _Yp>\n        typename enable_if\n        <\n            is_convertible<_Yp*, element_type*>::value,\n            shared_ptr<_Tp>&\n        >::type\n        _LIBCPP_INLINE_VISIBILITY\n        operator=(shared_ptr<_Yp>&& __r);\n    template<class _Yp>\n        _LIBCPP_INLINE_VISIBILITY\n        typename enable_if\n        <\n            !is_array<_Yp>::value &&\n            is_convertible<_Yp*, element_type*>::value,\n            shared_ptr\n        >::type&\n        operator=(auto_ptr<_Yp>&& __r);\n#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    template<class _Yp>\n        _LIBCPP_INLINE_VISIBILITY\n        typename enable_if\n        <\n            !is_array<_Yp>::value &&\n            is_convertible<_Yp*, element_type*>::value,\n            shared_ptr&\n        >::type\n        operator=(auto_ptr<_Yp> __r);\n#endif\n    template <class _Yp, class _Dp>\n        typename enable_if\n        <\n            !is_array<_Yp>::value &&\n            is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type*>::value,\n            shared_ptr&\n        >::type\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n        _LIBCPP_INLINE_VISIBILITY\n        operator=(unique_ptr<_Yp, _Dp>&& __r);\n#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n        _LIBCPP_INLINE_VISIBILITY\n        operator=(unique_ptr<_Yp, _Dp> __r);\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    void swap(shared_ptr& __r) _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    void reset() _NOEXCEPT;\n    template<class _Yp>\n        typename enable_if\n        <\n            is_convertible<_Yp*, element_type*>::value,\n            void\n        >::type\n        _LIBCPP_INLINE_VISIBILITY\n        reset(_Yp* __p);\n    template<class _Yp, class _Dp>\n        typename enable_if\n        <\n            is_convertible<_Yp*, element_type*>::value,\n            void\n        >::type\n        _LIBCPP_INLINE_VISIBILITY\n        reset(_Yp* __p, _Dp __d);\n    template<class _Yp, class _Dp, class _Alloc>\n        typename enable_if\n        <\n            is_convertible<_Yp*, element_type*>::value,\n            void\n        >::type\n        _LIBCPP_INLINE_VISIBILITY\n        reset(_Yp* __p, _Dp __d, _Alloc __a);\n\n    _LIBCPP_INLINE_VISIBILITY\n    element_type* get() const _NOEXCEPT {return __ptr_;}\n    _LIBCPP_INLINE_VISIBILITY\n    typename add_lvalue_reference<element_type>::type operator*() const _NOEXCEPT\n        {return *__ptr_;}\n    _LIBCPP_INLINE_VISIBILITY\n    element_type* operator->() const _NOEXCEPT {return __ptr_;}\n    _LIBCPP_INLINE_VISIBILITY\n    long use_count() const _NOEXCEPT {return __cntrl_ ? __cntrl_->use_count() : 0;}\n    _LIBCPP_INLINE_VISIBILITY\n    bool unique() const _NOEXCEPT {return use_count() == 1;}\n    _LIBCPP_INLINE_VISIBILITY\n    _LIBCPP_EXPLICIT operator bool() const _NOEXCEPT {return get() != 0;}\n    template <class _Up>\n        _LIBCPP_INLINE_VISIBILITY\n        bool owner_before(shared_ptr<_Up> const& __p) const\n        {return __cntrl_ < __p.__cntrl_;}\n    template <class _Up>\n        _LIBCPP_INLINE_VISIBILITY\n        bool owner_before(weak_ptr<_Up> const& __p) const\n        {return __cntrl_ < __p.__cntrl_;}\n    _LIBCPP_INLINE_VISIBILITY\n    bool\n    __owner_equivalent(const shared_ptr& __p) const\n        {return __cntrl_ == __p.__cntrl_;}\n\n#ifndef _LIBCPP_NO_RTTI\n    template <class _Dp>\n        _LIBCPP_INLINE_VISIBILITY\n        _Dp* __get_deleter() const _NOEXCEPT\n            {return (_Dp*)(__cntrl_ ? __cntrl_->__get_deleter(typeid(_Dp)) : 0);}\n#endif  // _LIBCPP_NO_RTTI\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n    template<class ..._Args>\n        static\n        shared_ptr<_Tp>\n        make_shared(_Args&& ...__args);\n\n    template<class _Alloc, class ..._Args>\n        static\n        shared_ptr<_Tp>\n        allocate_shared(const _Alloc& __a, _Args&& ...__args);\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\n    static shared_ptr<_Tp> make_shared();\n\n    template<class _A0>\n        static shared_ptr<_Tp> make_shared(_A0&);\n\n    template<class _A0, class _A1>\n        static shared_ptr<_Tp> make_shared(_A0&, _A1&);\n\n    template<class _A0, class _A1, class _A2>\n        static shared_ptr<_Tp> make_shared(_A0&, _A1&, _A2&);\n\n    template<class _Alloc>\n        static shared_ptr<_Tp>\n        allocate_shared(const _Alloc& __a);\n\n    template<class _Alloc, class _A0>\n        static shared_ptr<_Tp>\n        allocate_shared(const _Alloc& __a, _A0& __a0);\n\n    template<class _Alloc, class _A0, class _A1>\n        static shared_ptr<_Tp>\n        allocate_shared(const _Alloc& __a, _A0& __a0, _A1& __a1);\n\n    template<class _Alloc, class _A0, class _A1, class _A2>\n        static shared_ptr<_Tp>\n        allocate_shared(const _Alloc& __a, _A0& __a0, _A1& __a1, _A2& __a2);\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\nprivate:\n\n    template <class _Yp, class _OrigPtr>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        __enable_weak_this(const enable_shared_from_this<_Yp>* __e,\n                           _OrigPtr* __ptr) _NOEXCEPT\n        {\n            typedef typename remove_cv<_Yp>::type _RawYp;\n            if (__e && __e->__weak_this_.expired())\n            {\n                __e->__weak_this_ = shared_ptr<_RawYp>(*this,\n                    const_cast<_RawYp*>(static_cast<const _Yp*>(__ptr)));\n            }\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __enable_weak_this(const volatile void*, const volatile void*) _NOEXCEPT {}\n\n    template <class _Up> friend class _LIBCPP_TEMPLATE_VIS shared_ptr;\n    template <class _Up> friend class _LIBCPP_TEMPLATE_VIS weak_ptr;\n};\n\ntemplate<class _Tp>\ninline\n_LIBCPP_CONSTEXPR\nshared_ptr<_Tp>::shared_ptr() _NOEXCEPT\n    : __ptr_(0),\n      __cntrl_(0)\n{\n}\n\ntemplate<class _Tp>\ninline\n_LIBCPP_CONSTEXPR\nshared_ptr<_Tp>::shared_ptr(nullptr_t) _NOEXCEPT\n    : __ptr_(0),\n      __cntrl_(0)\n{\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\nshared_ptr<_Tp>::shared_ptr(_Yp* __p,\n                            typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type)\n    : __ptr_(__p)\n{\n    unique_ptr<_Yp> __hold(__p);\n    typedef __shared_ptr_pointer<_Yp*, default_delete<_Yp>, allocator<_Yp> > _CntrlBlk;\n    __cntrl_ = new _CntrlBlk(__p, default_delete<_Yp>(), allocator<_Yp>());\n    __hold.release();\n    __enable_weak_this(__p, __p);\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp, class _Dp>\nshared_ptr<_Tp>::shared_ptr(_Yp* __p, _Dp __d,\n                            typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type)\n    : __ptr_(__p)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        typedef __shared_ptr_pointer<_Yp*, _Dp, allocator<_Yp> > _CntrlBlk;\n        __cntrl_ = new _CntrlBlk(__p, __d, allocator<_Yp>());\n        __enable_weak_this(__p, __p);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        __d(__p);\n        throw;\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n}\n\ntemplate<class _Tp>\ntemplate<class _Dp>\nshared_ptr<_Tp>::shared_ptr(nullptr_t __p, _Dp __d)\n    : __ptr_(0)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        typedef __shared_ptr_pointer<nullptr_t, _Dp, allocator<_Tp> > _CntrlBlk;\n        __cntrl_ = new _CntrlBlk(__p, __d, allocator<_Tp>());\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        __d(__p);\n        throw;\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp, class _Dp, class _Alloc>\nshared_ptr<_Tp>::shared_ptr(_Yp* __p, _Dp __d, _Alloc __a,\n                            typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type)\n    : __ptr_(__p)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        typedef __shared_ptr_pointer<_Yp*, _Dp, _Alloc> _CntrlBlk;\n        typedef typename __allocator_traits_rebind<_Alloc, _CntrlBlk>::type _A2;\n        typedef __allocator_destructor<_A2> _D2;\n        _A2 __a2(__a);\n        unique_ptr<_CntrlBlk, _D2> __hold2(__a2.allocate(1), _D2(__a2, 1));\n        ::new(static_cast<void*>(_VSTD::addressof(*__hold2.get())))\n            _CntrlBlk(__p, __d, __a);\n        __cntrl_ = _VSTD::addressof(*__hold2.release());\n        __enable_weak_this(__p, __p);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        __d(__p);\n        throw;\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n}\n\ntemplate<class _Tp>\ntemplate<class _Dp, class _Alloc>\nshared_ptr<_Tp>::shared_ptr(nullptr_t __p, _Dp __d, _Alloc __a)\n    : __ptr_(0)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        typedef __shared_ptr_pointer<nullptr_t, _Dp, _Alloc> _CntrlBlk;\n        typedef typename __allocator_traits_rebind<_Alloc, _CntrlBlk>::type _A2;\n        typedef __allocator_destructor<_A2> _D2;\n        _A2 __a2(__a);\n        unique_ptr<_CntrlBlk, _D2> __hold2(__a2.allocate(1), _D2(__a2, 1));\n        ::new(static_cast<void*>(_VSTD::addressof(*__hold2.get())))\n            _CntrlBlk(__p, __d, __a);\n        __cntrl_ = _VSTD::addressof(*__hold2.release());\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        __d(__p);\n        throw;\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline\nshared_ptr<_Tp>::shared_ptr(const shared_ptr<_Yp>& __r, element_type *__p) _NOEXCEPT\n    : __ptr_(__p),\n      __cntrl_(__r.__cntrl_)\n{\n    if (__cntrl_)\n        __cntrl_->__add_shared();\n}\n\ntemplate<class _Tp>\ninline\nshared_ptr<_Tp>::shared_ptr(const shared_ptr& __r) _NOEXCEPT\n    : __ptr_(__r.__ptr_),\n      __cntrl_(__r.__cntrl_)\n{\n    if (__cntrl_)\n        __cntrl_->__add_shared();\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline\nshared_ptr<_Tp>::shared_ptr(const shared_ptr<_Yp>& __r,\n                            typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type)\n         _NOEXCEPT\n    : __ptr_(__r.__ptr_),\n      __cntrl_(__r.__cntrl_)\n{\n    if (__cntrl_)\n        __cntrl_->__add_shared();\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _Tp>\ninline\nshared_ptr<_Tp>::shared_ptr(shared_ptr&& __r) _NOEXCEPT\n    : __ptr_(__r.__ptr_),\n      __cntrl_(__r.__cntrl_)\n{\n    __r.__ptr_ = 0;\n    __r.__cntrl_ = 0;\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline\nshared_ptr<_Tp>::shared_ptr(shared_ptr<_Yp>&& __r,\n                            typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type)\n         _NOEXCEPT\n    : __ptr_(__r.__ptr_),\n      __cntrl_(__r.__cntrl_)\n{\n    __r.__ptr_ = 0;\n    __r.__cntrl_ = 0;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _Tp>\ntemplate<class _Yp>\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\nshared_ptr<_Tp>::shared_ptr(auto_ptr<_Yp>&& __r,\n#else\nshared_ptr<_Tp>::shared_ptr(auto_ptr<_Yp> __r,\n#endif\n                            typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type)\n    : __ptr_(__r.get())\n{\n    typedef __shared_ptr_pointer<_Yp*, default_delete<_Yp>, allocator<_Yp> > _CntrlBlk;\n    __cntrl_ = new _CntrlBlk(__r.get(), default_delete<_Yp>(), allocator<_Yp>());\n    __enable_weak_this(__r.get(), __r.get());\n    __r.release();\n}\n\ntemplate<class _Tp>\ntemplate <class _Yp, class _Dp>\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\nshared_ptr<_Tp>::shared_ptr(unique_ptr<_Yp, _Dp>&& __r,\n#else\nshared_ptr<_Tp>::shared_ptr(unique_ptr<_Yp, _Dp> __r,\n#endif\n                            typename enable_if\n                            <\n                                !is_lvalue_reference<_Dp>::value &&\n                                !is_array<_Yp>::value &&\n                                is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type*>::value,\n                                __nat\n                            >::type)\n    : __ptr_(__r.get())\n{\n#if _LIBCPP_STD_VER > 11\n    if (__ptr_ == nullptr)\n        __cntrl_ = nullptr;\n    else\n#endif\n    {\n        typedef __shared_ptr_pointer<_Yp*, _Dp, allocator<_Yp> > _CntrlBlk;\n        __cntrl_ = new _CntrlBlk(__r.get(), __r.get_deleter(), allocator<_Yp>());\n        __enable_weak_this(__r.get(), __r.get());\n    }\n    __r.release();\n}\n\ntemplate<class _Tp>\ntemplate <class _Yp, class _Dp>\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\nshared_ptr<_Tp>::shared_ptr(unique_ptr<_Yp, _Dp>&& __r,\n#else\nshared_ptr<_Tp>::shared_ptr(unique_ptr<_Yp, _Dp> __r,\n#endif\n                            typename enable_if\n                            <\n                                is_lvalue_reference<_Dp>::value &&\n                                !is_array<_Yp>::value &&\n                                is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type*>::value,\n                                __nat\n                            >::type)\n    : __ptr_(__r.get())\n{\n#if _LIBCPP_STD_VER > 11\n    if (__ptr_ == nullptr)\n        __cntrl_ = nullptr;\n    else\n#endif\n    {\n        typedef __shared_ptr_pointer<_Yp*,\n                                     reference_wrapper<typename remove_reference<_Dp>::type>,\n                                     allocator<_Yp> > _CntrlBlk;\n        __cntrl_ = new _CntrlBlk(__r.get(), ref(__r.get_deleter()), allocator<_Yp>());\n        __enable_weak_this(__r.get(), __r.get());\n    }\n    __r.release();\n}\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate<class _Tp>\ntemplate<class ..._Args>\nshared_ptr<_Tp>\nshared_ptr<_Tp>::make_shared(_Args&& ...__args)\n{\n    typedef __shared_ptr_emplace<_Tp, allocator<_Tp> > _CntrlBlk;\n    typedef allocator<_CntrlBlk> _A2;\n    typedef __allocator_destructor<_A2> _D2;\n    _A2 __a2;\n    unique_ptr<_CntrlBlk, _D2> __hold2(__a2.allocate(1), _D2(__a2, 1));\n    ::new(__hold2.get()) _CntrlBlk(__a2, _VSTD::forward<_Args>(__args)...);\n    shared_ptr<_Tp> __r;\n    __r.__ptr_ = __hold2.get()->get();\n    __r.__cntrl_ = __hold2.release();\n    __r.__enable_weak_this(__r.__ptr_, __r.__ptr_);\n    return __r;\n}\n\ntemplate<class _Tp>\ntemplate<class _Alloc, class ..._Args>\nshared_ptr<_Tp>\nshared_ptr<_Tp>::allocate_shared(const _Alloc& __a, _Args&& ...__args)\n{\n    typedef __shared_ptr_emplace<_Tp, _Alloc> _CntrlBlk;\n    typedef typename __allocator_traits_rebind<_Alloc, _CntrlBlk>::type _A2;\n    typedef __allocator_destructor<_A2> _D2;\n    _A2 __a2(__a);\n    unique_ptr<_CntrlBlk, _D2> __hold2(__a2.allocate(1), _D2(__a2, 1));\n    ::new(static_cast<void*>(_VSTD::addressof(*__hold2.get())))\n        _CntrlBlk(__a, _VSTD::forward<_Args>(__args)...);\n    shared_ptr<_Tp> __r;\n    __r.__ptr_ = __hold2.get()->get();\n    __r.__cntrl_ = _VSTD::addressof(*__hold2.release());\n    __r.__enable_weak_this(__r.__ptr_, __r.__ptr_);\n    return __r;\n}\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate<class _Tp>\nshared_ptr<_Tp>\nshared_ptr<_Tp>::make_shared()\n{\n    typedef __shared_ptr_emplace<_Tp, allocator<_Tp> > _CntrlBlk;\n    typedef allocator<_CntrlBlk> _Alloc2;\n    typedef __allocator_destructor<_Alloc2> _D2;\n    _Alloc2 __alloc2;\n    unique_ptr<_CntrlBlk, _D2> __hold2(__alloc2.allocate(1), _D2(__alloc2, 1));\n    ::new(__hold2.get()) _CntrlBlk(__alloc2);\n    shared_ptr<_Tp> __r;\n    __r.__ptr_ = __hold2.get()->get();\n    __r.__cntrl_ = __hold2.release();\n    __r.__enable_weak_this(__r.__ptr_, __r.__ptr_);\n    return __r;\n}\n\ntemplate<class _Tp>\ntemplate<class _A0>\nshared_ptr<_Tp>\nshared_ptr<_Tp>::make_shared(_A0& __a0)\n{\n    typedef __shared_ptr_emplace<_Tp, allocator<_Tp> > _CntrlBlk;\n    typedef allocator<_CntrlBlk> _Alloc2;\n    typedef __allocator_destructor<_Alloc2> _D2;\n    _Alloc2 __alloc2;\n    unique_ptr<_CntrlBlk, _D2> __hold2(__alloc2.allocate(1), _D2(__alloc2, 1));\n    ::new(__hold2.get()) _CntrlBlk(__alloc2, __a0);\n    shared_ptr<_Tp> __r;\n    __r.__ptr_ = __hold2.get()->get();\n    __r.__cntrl_ = __hold2.release();\n    __r.__enable_weak_this(__r.__ptr_, __r.__ptr_);\n    return __r;\n}\n\ntemplate<class _Tp>\ntemplate<class _A0, class _A1>\nshared_ptr<_Tp>\nshared_ptr<_Tp>::make_shared(_A0& __a0, _A1& __a1)\n{\n    typedef __shared_ptr_emplace<_Tp, allocator<_Tp> > _CntrlBlk;\n    typedef allocator<_CntrlBlk> _Alloc2;\n    typedef __allocator_destructor<_Alloc2> _D2;\n    _Alloc2 __alloc2;\n    unique_ptr<_CntrlBlk, _D2> __hold2(__alloc2.allocate(1), _D2(__alloc2, 1));\n    ::new(__hold2.get()) _CntrlBlk(__alloc2, __a0, __a1);\n    shared_ptr<_Tp> __r;\n    __r.__ptr_ = __hold2.get()->get();\n    __r.__cntrl_ = __hold2.release();\n    __r.__enable_weak_this(__r.__ptr_, __r.__ptr_);\n    return __r;\n}\n\ntemplate<class _Tp>\ntemplate<class _A0, class _A1, class _A2>\nshared_ptr<_Tp>\nshared_ptr<_Tp>::make_shared(_A0& __a0, _A1& __a1, _A2& __a2)\n{\n    typedef __shared_ptr_emplace<_Tp, allocator<_Tp> > _CntrlBlk;\n    typedef allocator<_CntrlBlk> _Alloc2;\n    typedef __allocator_destructor<_Alloc2> _D2;\n    _Alloc2 __alloc2;\n    unique_ptr<_CntrlBlk, _D2> __hold2(__alloc2.allocate(1), _D2(__alloc2, 1));\n    ::new(__hold2.get()) _CntrlBlk(__alloc2, __a0, __a1, __a2);\n    shared_ptr<_Tp> __r;\n    __r.__ptr_ = __hold2.get()->get();\n    __r.__cntrl_ = __hold2.release();\n    __r.__enable_weak_this(__r.__ptr_, __r.__ptr_);\n    return __r;\n}\n\ntemplate<class _Tp>\ntemplate<class _Alloc>\nshared_ptr<_Tp>\nshared_ptr<_Tp>::allocate_shared(const _Alloc& __a)\n{\n    typedef __shared_ptr_emplace<_Tp, _Alloc> _CntrlBlk;\n    typedef typename __allocator_traits_rebind<_Alloc, _CntrlBlk>::type _Alloc2;\n    typedef __allocator_destructor<_Alloc2> _D2;\n    _Alloc2 __alloc2(__a);\n    unique_ptr<_CntrlBlk, _D2> __hold2(__alloc2.allocate(1), _D2(__alloc2, 1));\n    ::new(static_cast<void*>(_VSTD::addressof(*__hold2.get())))\n        _CntrlBlk(__a);\n    shared_ptr<_Tp> __r;\n    __r.__ptr_ = __hold2.get()->get();\n    __r.__cntrl_ = _VSTD::addressof(*__hold2.release());\n    __r.__enable_weak_this(__r.__ptr_, __r.__ptr_);\n    return __r;\n}\n\ntemplate<class _Tp>\ntemplate<class _Alloc, class _A0>\nshared_ptr<_Tp>\nshared_ptr<_Tp>::allocate_shared(const _Alloc& __a, _A0& __a0)\n{\n    typedef __shared_ptr_emplace<_Tp, _Alloc> _CntrlBlk;\n    typedef typename __allocator_traits_rebind<_Alloc, _CntrlBlk>::type _Alloc2;\n    typedef __allocator_destructor<_Alloc2> _D2;\n    _Alloc2 __alloc2(__a);\n    unique_ptr<_CntrlBlk, _D2> __hold2(__alloc2.allocate(1), _D2(__alloc2, 1));\n    ::new(static_cast<void*>(_VSTD::addressof(*__hold2.get())))\n        _CntrlBlk(__a, __a0);\n    shared_ptr<_Tp> __r;\n    __r.__ptr_ = __hold2.get()->get();\n    __r.__cntrl_ = _VSTD::addressof(*__hold2.release());\n    __r.__enable_weak_this(__r.__ptr_, __r.__ptr_);\n    return __r;\n}\n\ntemplate<class _Tp>\ntemplate<class _Alloc, class _A0, class _A1>\nshared_ptr<_Tp>\nshared_ptr<_Tp>::allocate_shared(const _Alloc& __a, _A0& __a0, _A1& __a1)\n{\n    typedef __shared_ptr_emplace<_Tp, _Alloc> _CntrlBlk;\n    typedef typename __allocator_traits_rebind<_Alloc, _CntrlBlk>::type _Alloc2;\n    typedef __allocator_destructor<_Alloc2> _D2;\n    _Alloc2 __alloc2(__a);\n    unique_ptr<_CntrlBlk, _D2> __hold2(__alloc2.allocate(1), _D2(__alloc2, 1));\n    ::new(static_cast<void*>(_VSTD::addressof(*__hold2.get())))\n        _CntrlBlk(__a, __a0, __a1);\n    shared_ptr<_Tp> __r;\n    __r.__ptr_ = __hold2.get()->get();\n    __r.__cntrl_ = _VSTD::addressof(*__hold2.release());\n    __r.__enable_weak_this(__r.__ptr_, __r.__ptr_);\n    return __r;\n}\n\ntemplate<class _Tp>\ntemplate<class _Alloc, class _A0, class _A1, class _A2>\nshared_ptr<_Tp>\nshared_ptr<_Tp>::allocate_shared(const _Alloc& __a, _A0& __a0, _A1& __a1, _A2& __a2)\n{\n    typedef __shared_ptr_emplace<_Tp, _Alloc> _CntrlBlk;\n    typedef typename __allocator_traits_rebind<_Alloc, _CntrlBlk>::type _Alloc2;\n    typedef __allocator_destructor<_Alloc2> _D2;\n    _Alloc2 __alloc2(__a);\n    unique_ptr<_CntrlBlk, _D2> __hold2(__alloc2.allocate(1), _D2(__alloc2, 1));\n    ::new(static_cast<void*>(_VSTD::addressof(*__hold2.get())))\n        _CntrlBlk(__a, __a0, __a1, __a2);\n    shared_ptr<_Tp> __r;\n    __r.__ptr_ = __hold2.get()->get();\n    __r.__cntrl_ = _VSTD::addressof(*__hold2.release());\n    __r.__enable_weak_this(__r.__ptr_, __r.__ptr_);\n    return __r;\n}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate<class _Tp>\nshared_ptr<_Tp>::~shared_ptr()\n{\n    if (__cntrl_)\n        __cntrl_->__release_shared();\n}\n\ntemplate<class _Tp>\ninline\nshared_ptr<_Tp>&\nshared_ptr<_Tp>::operator=(const shared_ptr& __r) _NOEXCEPT\n{\n    shared_ptr(__r).swap(*this);\n    return *this;\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline\ntypename enable_if\n<\n    is_convertible<_Yp*, typename shared_ptr<_Tp>::element_type*>::value,\n    shared_ptr<_Tp>&\n>::type\nshared_ptr<_Tp>::operator=(const shared_ptr<_Yp>& __r) _NOEXCEPT\n{\n    shared_ptr(__r).swap(*this);\n    return *this;\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _Tp>\ninline\nshared_ptr<_Tp>&\nshared_ptr<_Tp>::operator=(shared_ptr&& __r) _NOEXCEPT\n{\n    shared_ptr(_VSTD::move(__r)).swap(*this);\n    return *this;\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline\ntypename enable_if\n<\n    is_convertible<_Yp*, typename shared_ptr<_Tp>::element_type*>::value,\n    shared_ptr<_Tp>&\n>::type\nshared_ptr<_Tp>::operator=(shared_ptr<_Yp>&& __r)\n{\n    shared_ptr(_VSTD::move(__r)).swap(*this);\n    return *this;\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline\ntypename enable_if\n<\n    !is_array<_Yp>::value &&\n    is_convertible<_Yp*, typename shared_ptr<_Tp>::element_type*>::value,\n    shared_ptr<_Tp>\n>::type&\nshared_ptr<_Tp>::operator=(auto_ptr<_Yp>&& __r)\n{\n    shared_ptr(_VSTD::move(__r)).swap(*this);\n    return *this;\n}\n\ntemplate<class _Tp>\ntemplate <class _Yp, class _Dp>\ninline\ntypename enable_if\n<\n    !is_array<_Yp>::value &&\n    is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, \n                   typename shared_ptr<_Tp>::element_type*>::value,\n    shared_ptr<_Tp>&\n>::type\nshared_ptr<_Tp>::operator=(unique_ptr<_Yp, _Dp>&& __r)\n{\n    shared_ptr(_VSTD::move(__r)).swap(*this);\n    return *this;\n}\n\n#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    !is_array<_Yp>::value &&\n    is_convertible<_Yp*, typename shared_ptr<_Tp>::element_type*>::value,\n    shared_ptr<_Tp>&\n>::type\nshared_ptr<_Tp>::operator=(auto_ptr<_Yp> __r)\n{\n    shared_ptr(__r).swap(*this);\n    return *this;\n}\n\ntemplate<class _Tp>\ntemplate <class _Yp, class _Dp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    !is_array<_Yp>::value &&\n    is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, \n                   typename shared_ptr<_Tp>::element_type*>::value,\n    shared_ptr<_Tp>&\n>::type\nshared_ptr<_Tp>::operator=(unique_ptr<_Yp, _Dp> __r)\n{\n    shared_ptr(_VSTD::move(__r)).swap(*this);\n    return *this;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _Tp>\ninline\nvoid\nshared_ptr<_Tp>::swap(shared_ptr& __r) _NOEXCEPT\n{\n    _VSTD::swap(__ptr_, __r.__ptr_);\n    _VSTD::swap(__cntrl_, __r.__cntrl_);\n}\n\ntemplate<class _Tp>\ninline\nvoid\nshared_ptr<_Tp>::reset() _NOEXCEPT\n{\n    shared_ptr().swap(*this);\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline\ntypename enable_if\n<\n    is_convertible<_Yp*, typename shared_ptr<_Tp>::element_type*>::value,\n    void\n>::type\nshared_ptr<_Tp>::reset(_Yp* __p)\n{\n    shared_ptr(__p).swap(*this);\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp, class _Dp>\ninline\ntypename enable_if\n<\n    is_convertible<_Yp*, typename shared_ptr<_Tp>::element_type*>::value,\n    void\n>::type\nshared_ptr<_Tp>::reset(_Yp* __p, _Dp __d)\n{\n    shared_ptr(__p, __d).swap(*this);\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp, class _Dp, class _Alloc>\ninline\ntypename enable_if\n<\n    is_convertible<_Yp*, typename shared_ptr<_Tp>::element_type*>::value,\n    void\n>::type\nshared_ptr<_Tp>::reset(_Yp* __p, _Dp __d, _Alloc __a)\n{\n    shared_ptr(__p, __d, __a).swap(*this);\n}\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate<class _Tp, class ..._Args>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    !is_array<_Tp>::value,\n    shared_ptr<_Tp>\n>::type\nmake_shared(_Args&& ...__args)\n{\n    return shared_ptr<_Tp>::make_shared(_VSTD::forward<_Args>(__args)...);\n}\n\ntemplate<class _Tp, class _Alloc, class ..._Args>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    !is_array<_Tp>::value,\n    shared_ptr<_Tp>\n>::type\nallocate_shared(const _Alloc& __a, _Args&& ...__args)\n{\n    return shared_ptr<_Tp>::allocate_shared(__a, _VSTD::forward<_Args>(__args)...);\n}\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>\nmake_shared()\n{\n    return shared_ptr<_Tp>::make_shared();\n}\n\ntemplate<class _Tp, class _A0>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>\nmake_shared(_A0& __a0)\n{\n    return shared_ptr<_Tp>::make_shared(__a0);\n}\n\ntemplate<class _Tp, class _A0, class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>\nmake_shared(_A0& __a0, _A1& __a1)\n{\n    return shared_ptr<_Tp>::make_shared(__a0, __a1);\n}\n\ntemplate<class _Tp, class _A0, class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>\nmake_shared(_A0& __a0, _A1& __a1, _A2& __a2)\n{\n    return shared_ptr<_Tp>::make_shared(__a0, __a1, __a2);\n}\n\ntemplate<class _Tp, class _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>\nallocate_shared(const _Alloc& __a)\n{\n    return shared_ptr<_Tp>::allocate_shared(__a);\n}\n\ntemplate<class _Tp, class _Alloc, class _A0>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>\nallocate_shared(const _Alloc& __a, _A0& __a0)\n{\n    return shared_ptr<_Tp>::allocate_shared(__a, __a0);\n}\n\ntemplate<class _Tp, class _Alloc, class _A0, class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>\nallocate_shared(const _Alloc& __a, _A0& __a0, _A1& __a1)\n{\n    return shared_ptr<_Tp>::allocate_shared(__a, __a0, __a1);\n}\n\ntemplate<class _Tp, class _Alloc, class _A0, class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>\nallocate_shared(const _Alloc& __a, _A0& __a0, _A1& __a1, _A2& __a2)\n{\n    return shared_ptr<_Tp>::allocate_shared(__a, __a0, __a1, __a2);\n}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate<class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const shared_ptr<_Tp>& __x, const shared_ptr<_Up>& __y) _NOEXCEPT\n{\n    return __x.get() == __y.get();\n}\n\ntemplate<class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const shared_ptr<_Tp>& __x, const shared_ptr<_Up>& __y) _NOEXCEPT\n{\n    return !(__x == __y);\n}\n\ntemplate<class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<(const shared_ptr<_Tp>& __x, const shared_ptr<_Up>& __y) _NOEXCEPT\n{\n    typedef typename common_type<_Tp*, _Up*>::type _Vp;\n    return less<_Vp>()(__x.get(), __y.get());\n}\n\ntemplate<class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>(const shared_ptr<_Tp>& __x, const shared_ptr<_Up>& __y) _NOEXCEPT\n{\n    return __y < __x;\n}\n\ntemplate<class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const shared_ptr<_Tp>& __x, const shared_ptr<_Up>& __y) _NOEXCEPT\n{\n    return !(__y < __x);\n}\n\ntemplate<class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const shared_ptr<_Tp>& __x, const shared_ptr<_Up>& __y) _NOEXCEPT\n{\n    return !(__x < __y);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const shared_ptr<_Tp>& __x, nullptr_t) _NOEXCEPT\n{\n    return !__x;\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(nullptr_t, const shared_ptr<_Tp>& __x) _NOEXCEPT\n{\n    return !__x;\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const shared_ptr<_Tp>& __x, nullptr_t) _NOEXCEPT\n{\n    return static_cast<bool>(__x);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(nullptr_t, const shared_ptr<_Tp>& __x) _NOEXCEPT\n{\n    return static_cast<bool>(__x);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<(const shared_ptr<_Tp>& __x, nullptr_t) _NOEXCEPT\n{\n    return less<_Tp*>()(__x.get(), nullptr);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<(nullptr_t, const shared_ptr<_Tp>& __x) _NOEXCEPT\n{\n    return less<_Tp*>()(nullptr, __x.get());\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>(const shared_ptr<_Tp>& __x, nullptr_t) _NOEXCEPT\n{\n    return nullptr < __x;\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>(nullptr_t, const shared_ptr<_Tp>& __x) _NOEXCEPT\n{\n    return __x < nullptr;\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const shared_ptr<_Tp>& __x, nullptr_t) _NOEXCEPT\n{\n    return !(nullptr < __x);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(nullptr_t, const shared_ptr<_Tp>& __x) _NOEXCEPT\n{\n    return !(__x < nullptr);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const shared_ptr<_Tp>& __x, nullptr_t) _NOEXCEPT\n{\n    return !(__x < nullptr);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(nullptr_t, const shared_ptr<_Tp>& __x) _NOEXCEPT\n{\n    return !(nullptr < __x);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(shared_ptr<_Tp>& __x, shared_ptr<_Tp>& __y) _NOEXCEPT\n{\n    __x.swap(__y);\n}\n\ntemplate<class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    !is_array<_Tp>::value && !is_array<_Up>::value,\n    shared_ptr<_Tp>\n>::type\nstatic_pointer_cast(const shared_ptr<_Up>& __r) _NOEXCEPT\n{\n    return shared_ptr<_Tp>(__r, static_cast<_Tp*>(__r.get()));\n}\n\ntemplate<class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    !is_array<_Tp>::value && !is_array<_Up>::value,\n    shared_ptr<_Tp>\n>::type\ndynamic_pointer_cast(const shared_ptr<_Up>& __r) _NOEXCEPT\n{\n    _Tp* __p = dynamic_cast<_Tp*>(__r.get());\n    return __p ? shared_ptr<_Tp>(__r, __p) : shared_ptr<_Tp>();\n}\n\ntemplate<class _Tp, class _Up>\ntypename enable_if\n<\n    is_array<_Tp>::value == is_array<_Up>::value,\n    shared_ptr<_Tp>\n>::type\nconst_pointer_cast(const shared_ptr<_Up>& __r) _NOEXCEPT\n{\n    typedef typename remove_extent<_Tp>::type _RTp;\n    return shared_ptr<_Tp>(__r, const_cast<_RTp*>(__r.get()));\n}\n\n#ifndef _LIBCPP_NO_RTTI\n\ntemplate<class _Dp, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_Dp*\nget_deleter(const shared_ptr<_Tp>& __p) _NOEXCEPT\n{\n    return __p.template __get_deleter<_Dp>();\n}\n\n#endif  // _LIBCPP_NO_RTTI\n\ntemplate<class _Tp>\nclass _LIBCPP_TEMPLATE_VIS weak_ptr\n{\npublic:\n    typedef _Tp element_type;\nprivate:\n    element_type*        __ptr_;\n    __shared_weak_count* __cntrl_;\n\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    _LIBCPP_CONSTEXPR weak_ptr() _NOEXCEPT;\n    template<class _Yp> _LIBCPP_INLINE_VISIBILITY weak_ptr(shared_ptr<_Yp> const& __r,\n                   typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat*>::type = 0)\n                        _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    weak_ptr(weak_ptr const& __r) _NOEXCEPT;\n    template<class _Yp> _LIBCPP_INLINE_VISIBILITY weak_ptr(weak_ptr<_Yp> const& __r,\n                   typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat*>::type = 0)\n                         _NOEXCEPT;\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    weak_ptr(weak_ptr&& __r) _NOEXCEPT;\n    template<class _Yp> _LIBCPP_INLINE_VISIBILITY weak_ptr(weak_ptr<_Yp>&& __r,\n                   typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat*>::type = 0)\n                         _NOEXCEPT;\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    ~weak_ptr();\n\n    _LIBCPP_INLINE_VISIBILITY\n    weak_ptr& operator=(weak_ptr const& __r) _NOEXCEPT;\n    template<class _Yp>\n        typename enable_if\n        <\n            is_convertible<_Yp*, element_type*>::value,\n            weak_ptr&\n        >::type\n        _LIBCPP_INLINE_VISIBILITY\n        operator=(weak_ptr<_Yp> const& __r) _NOEXCEPT;\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    _LIBCPP_INLINE_VISIBILITY\n    weak_ptr& operator=(weak_ptr&& __r) _NOEXCEPT;\n    template<class _Yp>\n        typename enable_if\n        <\n            is_convertible<_Yp*, element_type*>::value,\n            weak_ptr&\n        >::type\n        _LIBCPP_INLINE_VISIBILITY\n        operator=(weak_ptr<_Yp>&& __r) _NOEXCEPT;\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    template<class _Yp>\n        typename enable_if\n        <\n            is_convertible<_Yp*, element_type*>::value,\n            weak_ptr&\n        >::type\n        _LIBCPP_INLINE_VISIBILITY\n        operator=(shared_ptr<_Yp> const& __r) _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    void swap(weak_ptr& __r) _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    void reset() _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    long use_count() const _NOEXCEPT\n        {return __cntrl_ ? __cntrl_->use_count() : 0;}\n    _LIBCPP_INLINE_VISIBILITY\n    bool expired() const _NOEXCEPT\n        {return __cntrl_ == 0 || __cntrl_->use_count() == 0;}\n    shared_ptr<_Tp> lock() const _NOEXCEPT;\n    template<class _Up>\n        _LIBCPP_INLINE_VISIBILITY\n        bool owner_before(const shared_ptr<_Up>& __r) const\n        {return __cntrl_ < __r.__cntrl_;}\n    template<class _Up>\n        _LIBCPP_INLINE_VISIBILITY\n        bool owner_before(const weak_ptr<_Up>& __r) const\n        {return __cntrl_ < __r.__cntrl_;}\n\n    template <class _Up> friend class _LIBCPP_TEMPLATE_VIS weak_ptr;\n    template <class _Up> friend class _LIBCPP_TEMPLATE_VIS shared_ptr;\n};\n\ntemplate<class _Tp>\ninline\n_LIBCPP_CONSTEXPR\nweak_ptr<_Tp>::weak_ptr() _NOEXCEPT\n    : __ptr_(0),\n      __cntrl_(0)\n{\n}\n\ntemplate<class _Tp>\ninline\nweak_ptr<_Tp>::weak_ptr(weak_ptr const& __r) _NOEXCEPT\n    : __ptr_(__r.__ptr_),\n      __cntrl_(__r.__cntrl_)\n{\n    if (__cntrl_)\n        __cntrl_->__add_weak();\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline\nweak_ptr<_Tp>::weak_ptr(shared_ptr<_Yp> const& __r,\n                        typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat*>::type)\n                         _NOEXCEPT\n    : __ptr_(__r.__ptr_),\n      __cntrl_(__r.__cntrl_)\n{\n    if (__cntrl_)\n        __cntrl_->__add_weak();\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline\nweak_ptr<_Tp>::weak_ptr(weak_ptr<_Yp> const& __r,\n                        typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat*>::type)\n         _NOEXCEPT\n    : __ptr_(__r.__ptr_),\n      __cntrl_(__r.__cntrl_)\n{\n    if (__cntrl_)\n        __cntrl_->__add_weak();\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _Tp>\ninline\nweak_ptr<_Tp>::weak_ptr(weak_ptr&& __r) _NOEXCEPT\n    : __ptr_(__r.__ptr_),\n      __cntrl_(__r.__cntrl_)\n{\n    __r.__ptr_ = 0;\n    __r.__cntrl_ = 0;\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline\nweak_ptr<_Tp>::weak_ptr(weak_ptr<_Yp>&& __r,\n                        typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat*>::type)\n         _NOEXCEPT\n    : __ptr_(__r.__ptr_),\n      __cntrl_(__r.__cntrl_)\n{\n    __r.__ptr_ = 0;\n    __r.__cntrl_ = 0;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _Tp>\nweak_ptr<_Tp>::~weak_ptr()\n{\n    if (__cntrl_)\n        __cntrl_->__release_weak();\n}\n\ntemplate<class _Tp>\ninline\nweak_ptr<_Tp>&\nweak_ptr<_Tp>::operator=(weak_ptr const& __r) _NOEXCEPT\n{\n    weak_ptr(__r).swap(*this);\n    return *this;\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline\ntypename enable_if\n<\n    is_convertible<_Yp*, _Tp*>::value,\n    weak_ptr<_Tp>&\n>::type\nweak_ptr<_Tp>::operator=(weak_ptr<_Yp> const& __r) _NOEXCEPT\n{\n    weak_ptr(__r).swap(*this);\n    return *this;\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _Tp>\ninline\nweak_ptr<_Tp>&\nweak_ptr<_Tp>::operator=(weak_ptr&& __r) _NOEXCEPT\n{\n    weak_ptr(_VSTD::move(__r)).swap(*this);\n    return *this;\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline\ntypename enable_if\n<\n    is_convertible<_Yp*, _Tp*>::value,\n    weak_ptr<_Tp>&\n>::type\nweak_ptr<_Tp>::operator=(weak_ptr<_Yp>&& __r) _NOEXCEPT\n{\n    weak_ptr(_VSTD::move(__r)).swap(*this);\n    return *this;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline\ntypename enable_if\n<\n    is_convertible<_Yp*, _Tp*>::value,\n    weak_ptr<_Tp>&\n>::type\nweak_ptr<_Tp>::operator=(shared_ptr<_Yp> const& __r) _NOEXCEPT\n{\n    weak_ptr(__r).swap(*this);\n    return *this;\n}\n\ntemplate<class _Tp>\ninline\nvoid\nweak_ptr<_Tp>::swap(weak_ptr& __r) _NOEXCEPT\n{\n    _VSTD::swap(__ptr_, __r.__ptr_);\n    _VSTD::swap(__cntrl_, __r.__cntrl_);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(weak_ptr<_Tp>& __x, weak_ptr<_Tp>& __y) _NOEXCEPT\n{\n    __x.swap(__y);\n}\n\ntemplate<class _Tp>\ninline\nvoid\nweak_ptr<_Tp>::reset() _NOEXCEPT\n{\n    weak_ptr().swap(*this);\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\nshared_ptr<_Tp>::shared_ptr(const weak_ptr<_Yp>& __r,\n                            typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type)\n    : __ptr_(__r.__ptr_),\n      __cntrl_(__r.__cntrl_ ? __r.__cntrl_->lock() : __r.__cntrl_)\n{\n    if (__cntrl_ == 0)\n        __throw_bad_weak_ptr();\n}\n\ntemplate<class _Tp>\nshared_ptr<_Tp>\nweak_ptr<_Tp>::lock() const _NOEXCEPT\n{\n    shared_ptr<_Tp> __r;\n    __r.__cntrl_ = __cntrl_ ? __cntrl_->lock() : __cntrl_;\n    if (__r.__cntrl_)\n        __r.__ptr_ = __ptr_;\n    return __r;\n}\n\n#if _LIBCPP_STD_VER > 14\ntemplate <class _Tp = void> struct owner_less;\n#else\ntemplate <class _Tp> struct owner_less;\n#endif\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS owner_less<shared_ptr<_Tp> >\n    : binary_function<shared_ptr<_Tp>, shared_ptr<_Tp>, bool>\n{\n    typedef bool result_type;\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(shared_ptr<_Tp> const& __x, shared_ptr<_Tp> const& __y) const\n        {return __x.owner_before(__y);}\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(shared_ptr<_Tp> const& __x,   weak_ptr<_Tp> const& __y) const\n        {return __x.owner_before(__y);}\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(  weak_ptr<_Tp> const& __x, shared_ptr<_Tp> const& __y) const\n        {return __x.owner_before(__y);}\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS owner_less<weak_ptr<_Tp> >\n    : binary_function<weak_ptr<_Tp>, weak_ptr<_Tp>, bool>\n{\n    typedef bool result_type;\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(  weak_ptr<_Tp> const& __x,   weak_ptr<_Tp> const& __y) const\n        {return __x.owner_before(__y);}\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(shared_ptr<_Tp> const& __x,   weak_ptr<_Tp> const& __y) const\n        {return __x.owner_before(__y);}\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(  weak_ptr<_Tp> const& __x, shared_ptr<_Tp> const& __y) const\n        {return __x.owner_before(__y);}\n};\n\n#if _LIBCPP_STD_VER > 14\ntemplate <>\nstruct _LIBCPP_TEMPLATE_VIS owner_less<void>\n{\n    template <class _Tp, class _Up>\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()( shared_ptr<_Tp> const& __x, shared_ptr<_Up> const& __y) const\n        {return __x.owner_before(__y);}\n    template <class _Tp, class _Up>\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()( shared_ptr<_Tp> const& __x,  weak_ptr<_Up> const& __y) const\n        {return __x.owner_before(__y);}\n    template <class _Tp, class _Up>\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(   weak_ptr<_Tp> const& __x, shared_ptr<_Up> const& __y) const\n        {return __x.owner_before(__y);}\n    template <class _Tp, class _Up>\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(   weak_ptr<_Tp> const& __x,   weak_ptr<_Up> const& __y) const\n        {return __x.owner_before(__y);}\n    typedef void is_transparent;\n};\n#endif\n\ntemplate<class _Tp>\nclass _LIBCPP_TEMPLATE_VIS enable_shared_from_this\n{\n    mutable weak_ptr<_Tp> __weak_this_;\nprotected:\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR\n    enable_shared_from_this() _NOEXCEPT {}\n    _LIBCPP_INLINE_VISIBILITY\n    enable_shared_from_this(enable_shared_from_this const&) _NOEXCEPT {}\n    _LIBCPP_INLINE_VISIBILITY\n    enable_shared_from_this& operator=(enable_shared_from_this const&) _NOEXCEPT\n        {return *this;}\n    _LIBCPP_INLINE_VISIBILITY\n    ~enable_shared_from_this() {}\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    shared_ptr<_Tp> shared_from_this()\n        {return shared_ptr<_Tp>(__weak_this_);}\n    _LIBCPP_INLINE_VISIBILITY\n    shared_ptr<_Tp const> shared_from_this() const\n        {return shared_ptr<const _Tp>(__weak_this_);}\n\n#if _LIBCPP_STD_VER > 14\n    _LIBCPP_INLINE_VISIBILITY\n    weak_ptr<_Tp> weak_from_this() _NOEXCEPT\n       { return __weak_this_; }\n\n    _LIBCPP_INLINE_VISIBILITY\n    weak_ptr<const _Tp> weak_from_this() const _NOEXCEPT\n        { return __weak_this_; }\n#endif // _LIBCPP_STD_VER > 14\n\n    template <class _Up> friend class shared_ptr;\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS hash<shared_ptr<_Tp> >\n{\n    typedef shared_ptr<_Tp>      argument_type;\n    typedef size_t               result_type;\n    _LIBCPP_INLINE_VISIBILITY\n    result_type operator()(const argument_type& __ptr) const _NOEXCEPT\n    {\n        return hash<_Tp*>()(__ptr.get());\n    }\n};\n\ntemplate<class _CharT, class _Traits, class _Yp>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_ostream<_CharT, _Traits>&\noperator<<(basic_ostream<_CharT, _Traits>& __os, shared_ptr<_Yp> const& __p);\n\n\n#if !defined(_LIBCPP_HAS_NO_ATOMIC_HEADER)\n\nclass _LIBCPP_TYPE_VIS __sp_mut\n{\n    void* __lx;\npublic:\n    void lock() _NOEXCEPT;\n    void unlock() _NOEXCEPT;\n\nprivate:\n    _LIBCPP_CONSTEXPR __sp_mut(void*) _NOEXCEPT;\n    __sp_mut(const __sp_mut&);\n    __sp_mut& operator=(const __sp_mut&);\n\n    friend _LIBCPP_FUNC_VIS __sp_mut& __get_sp_mut(const void*);\n};\n\n_LIBCPP_FUNC_VIS __sp_mut& __get_sp_mut(const void*);\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\natomic_is_lock_free(const shared_ptr<_Tp>*)\n{\n    return false;\n}\n\ntemplate <class _Tp>\nshared_ptr<_Tp>\natomic_load(const shared_ptr<_Tp>* __p)\n{\n    __sp_mut& __m = __get_sp_mut(__p);\n    __m.lock();\n    shared_ptr<_Tp> __q = *__p;\n    __m.unlock();\n    return __q;\n}\n  \ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>\natomic_load_explicit(const shared_ptr<_Tp>* __p, memory_order)\n{\n    return atomic_load(__p);\n}\n\ntemplate <class _Tp>\nvoid\natomic_store(shared_ptr<_Tp>* __p, shared_ptr<_Tp> __r)\n{\n    __sp_mut& __m = __get_sp_mut(__p);\n    __m.lock();\n    __p->swap(__r);\n    __m.unlock();\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\natomic_store_explicit(shared_ptr<_Tp>* __p, shared_ptr<_Tp> __r, memory_order)\n{\n    atomic_store(__p, __r);\n}\n\ntemplate <class _Tp>\nshared_ptr<_Tp>\natomic_exchange(shared_ptr<_Tp>* __p, shared_ptr<_Tp> __r)\n{\n    __sp_mut& __m = __get_sp_mut(__p);\n    __m.lock();\n    __p->swap(__r);\n    __m.unlock();\n    return __r;\n}\n  \ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>\natomic_exchange_explicit(shared_ptr<_Tp>* __p, shared_ptr<_Tp> __r, memory_order)\n{\n    return atomic_exchange(__p, __r);\n}\n\ntemplate <class _Tp>\nbool\natomic_compare_exchange_strong(shared_ptr<_Tp>* __p, shared_ptr<_Tp>* __v, shared_ptr<_Tp> __w)\n{\n    shared_ptr<_Tp> __temp;\n    __sp_mut& __m = __get_sp_mut(__p);\n    __m.lock();\n    if (__p->__owner_equivalent(*__v))\n    {\n        _VSTD::swap(__temp, *__p);\n        *__p = __w;\n        __m.unlock();\n        return true;\n    }\n    _VSTD::swap(__temp, *__v);\n    *__v = *__p;\n    __m.unlock();\n    return false;\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\natomic_compare_exchange_weak(shared_ptr<_Tp>* __p, shared_ptr<_Tp>* __v, shared_ptr<_Tp> __w)\n{\n    return atomic_compare_exchange_strong(__p, __v, __w);\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\natomic_compare_exchange_strong_explicit(shared_ptr<_Tp>* __p, shared_ptr<_Tp>* __v,\n                                        shared_ptr<_Tp> __w, memory_order, memory_order)\n{\n    return atomic_compare_exchange_strong(__p, __v, __w);\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\natomic_compare_exchange_weak_explicit(shared_ptr<_Tp>* __p, shared_ptr<_Tp>* __v,\n                                      shared_ptr<_Tp> __w, memory_order, memory_order)\n{\n    return atomic_compare_exchange_weak(__p, __v, __w);\n}\n\n#endif  // !defined(_LIBCPP_HAS_NO_ATOMIC_HEADER)\n\n//enum class\n#if defined(_LIBCPP_ABI_POINTER_SAFETY_ENUM_TYPE)\n# ifndef _LIBCPP_CXX03_LANG\nenum class pointer_safety : unsigned char {\n  relaxed,\n  preferred,\n  strict\n};\n# endif\n#else\nstruct _LIBCPP_TYPE_VIS pointer_safety\n{\n    enum __lx\n    {\n        relaxed,\n        preferred,\n        strict\n    };\n\n    __lx __v_;\n\n    _LIBCPP_INLINE_VISIBILITY\n    pointer_safety() : __v_() {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    pointer_safety(__lx __v) : __v_(__v) {}\n    _LIBCPP_INLINE_VISIBILITY\n    operator int() const {return __v_;}\n};\n#endif\n\n#if !defined(_LIBCPP_ABI_POINTER_SAFETY_ENUM_TYPE) && \\\n    defined(_LIBCPP_BUILDING_MEMORY)\n_LIBCPP_FUNC_VIS pointer_safety get_pointer_safety() _NOEXCEPT;\n#else\n// This function is only offered in C++03 under ABI v1.\n# if !defined(_LIBCPP_ABI_POINTER_SAFETY_ENUM_TYPE) || !defined(_LIBCPP_CXX03_LANG)\ninline _LIBCPP_INLINE_VISIBILITY\npointer_safety get_pointer_safety() _NOEXCEPT {\n  return pointer_safety::relaxed;\n}\n# endif\n#endif\n\n\n_LIBCPP_FUNC_VIS void declare_reachable(void* __p);\n_LIBCPP_FUNC_VIS void declare_no_pointers(char* __p, size_t __n);\n_LIBCPP_FUNC_VIS void undeclare_no_pointers(char* __p, size_t __n);\n_LIBCPP_FUNC_VIS void* __undeclare_reachable(void* __p);\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_Tp*\nundeclare_reachable(_Tp* __p)\n{\n    return static_cast<_Tp*>(__undeclare_reachable(__p));\n}\n\n_LIBCPP_FUNC_VIS void* align(size_t __align, size_t __sz, void*& __ptr, size_t& __space);\n\n// --- Helper for container swap --\ntemplate <typename _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid __swap_allocator(_Alloc & __a1, _Alloc & __a2)\n#if _LIBCPP_STD_VER >= 14\n    _NOEXCEPT\n#else\n    _NOEXCEPT_(__is_nothrow_swappable<_Alloc>::value)\n#endif\n{\n    __swap_allocator(__a1, __a2, \n      integral_constant<bool, _VSTD::allocator_traits<_Alloc>::propagate_on_container_swap::value>());\n}\n\ntemplate <typename _Alloc>\n_LIBCPP_INLINE_VISIBILITY\nvoid __swap_allocator(_Alloc & __a1, _Alloc & __a2, true_type)\n#if _LIBCPP_STD_VER >= 14\n    _NOEXCEPT\n#else\n    _NOEXCEPT_(__is_nothrow_swappable<_Alloc>::value)\n#endif\n{\n    using _VSTD::swap;\n    swap(__a1, __a2);\n}\n\ntemplate <typename _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid __swap_allocator(_Alloc &, _Alloc &, false_type) _NOEXCEPT {}\n\ntemplate <typename _Alloc, typename _Traits=allocator_traits<_Alloc> >\nstruct __noexcept_move_assign_container : public integral_constant<bool, \n    _Traits::propagate_on_container_move_assignment::value\n#if _LIBCPP_STD_VER > 14\n        || _Traits::is_always_equal::value\n#else\n        && is_nothrow_move_assignable<_Alloc>::value\n#endif\n    > {};\n\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\ntemplate <class _Tp, class _Alloc>\nstruct __temp_value {\n    typedef allocator_traits<_Alloc> _Traits;\n    \n    typename aligned_storage<sizeof(_Tp), alignof(_Tp)>::type __v;\n    _Alloc &__a;\n\n    _Tp *__addr() { return reinterpret_cast<_Tp *>(addressof(__v)); }\n    _Tp &   get() { return *__addr(); }\n        \n    template<class... _Args>\n    __temp_value(_Alloc &__alloc, _Args&& ... __args) : __a(__alloc)\n    { _Traits::construct(__a, __addr(), _VSTD::forward<_Args>(__args)...); }\n    \n    ~__temp_value() { _Traits::destroy(__a, __addr()); }\n    };\n#endif\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_MEMORY\n","// -*- C++ -*-\n#ifndef _LIBCPP_SPLIT_BUFFER\n#define _LIBCPP_SPLIT_BUFFER\n\n#include <__config>\n#include <type_traits>\n#include <algorithm>\n\n#include <__undef_min_max>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\ntemplate <bool>\nclass __split_buffer_common\n{\nprotected:\n    void __throw_length_error() const;\n    void __throw_out_of_range() const;\n};\n\ntemplate <class _Tp, class _Allocator = allocator<_Tp> >\nstruct __split_buffer\n    : private __split_buffer_common<true>\n{\nprivate:\n    __split_buffer(const __split_buffer&);\n    __split_buffer& operator=(const __split_buffer&);\npublic:\n    typedef _Tp                                             value_type;\n    typedef _Allocator                                      allocator_type;\n    typedef typename remove_reference<allocator_type>::type __alloc_rr;\n    typedef allocator_traits<__alloc_rr>                    __alloc_traits;\n    typedef value_type&                                     reference;\n    typedef const value_type&                               const_reference;\n    typedef typename __alloc_traits::size_type              size_type;\n    typedef typename __alloc_traits::difference_type        difference_type;\n    typedef typename __alloc_traits::pointer                pointer;\n    typedef typename __alloc_traits::const_pointer          const_pointer;\n    typedef pointer                                         iterator;\n    typedef const_pointer                                   const_iterator;\n\n    pointer                                         __first_;\n    pointer                                         __begin_;\n    pointer                                         __end_;\n    __compressed_pair<pointer, allocator_type> __end_cap_;\n\n    typedef typename add_lvalue_reference<allocator_type>::type __alloc_ref;\n    typedef typename add_lvalue_reference<allocator_type>::type __alloc_const_ref;\n\n    _LIBCPP_INLINE_VISIBILITY __alloc_rr&           __alloc() _NOEXCEPT         {return __end_cap_.second();}\n    _LIBCPP_INLINE_VISIBILITY const __alloc_rr&     __alloc() const _NOEXCEPT   {return __end_cap_.second();}\n    _LIBCPP_INLINE_VISIBILITY pointer&              __end_cap() _NOEXCEPT       {return __end_cap_.first();}\n    _LIBCPP_INLINE_VISIBILITY const pointer&        __end_cap() const _NOEXCEPT {return __end_cap_.first();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __split_buffer()\n        _NOEXCEPT_(is_nothrow_default_constructible<allocator_type>::value);\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __split_buffer(__alloc_rr& __a);\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __split_buffer(const __alloc_rr& __a);\n    __split_buffer(size_type __cap, size_type __start, __alloc_rr& __a);\n    ~__split_buffer();\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    __split_buffer(__split_buffer&& __c)\n        _NOEXCEPT_(is_nothrow_move_constructible<allocator_type>::value);\n    __split_buffer(__split_buffer&& __c, const __alloc_rr& __a);\n    __split_buffer& operator=(__split_buffer&& __c)\n        _NOEXCEPT_((__alloc_traits::propagate_on_container_move_assignment::value &&\n                is_nothrow_move_assignable<allocator_type>::value) ||\n               !__alloc_traits::propagate_on_container_move_assignment::value);\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    _LIBCPP_INLINE_VISIBILITY       iterator begin() _NOEXCEPT       {return __begin_;}\n    _LIBCPP_INLINE_VISIBILITY const_iterator begin() const _NOEXCEPT {return __begin_;}\n    _LIBCPP_INLINE_VISIBILITY       iterator end() _NOEXCEPT         {return __end_;}\n    _LIBCPP_INLINE_VISIBILITY const_iterator end() const _NOEXCEPT   {return __end_;}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void clear() _NOEXCEPT\n        {__destruct_at_end(__begin_);}\n    _LIBCPP_INLINE_VISIBILITY size_type size() const {return static_cast<size_type>(__end_ - __begin_);}\n    _LIBCPP_INLINE_VISIBILITY bool empty()     const {return __end_ == __begin_;}\n    _LIBCPP_INLINE_VISIBILITY size_type capacity() const {return static_cast<size_type>(__end_cap() - __first_);}\n    _LIBCPP_INLINE_VISIBILITY size_type __front_spare() const {return static_cast<size_type>(__begin_ - __first_);}\n    _LIBCPP_INLINE_VISIBILITY size_type __back_spare() const {return static_cast<size_type>(__end_cap() - __end_);}\n\n    _LIBCPP_INLINE_VISIBILITY       reference front()       {return *__begin_;}\n    _LIBCPP_INLINE_VISIBILITY const_reference front() const {return *__begin_;}\n    _LIBCPP_INLINE_VISIBILITY       reference back()        {return *(__end_ - 1);}\n    _LIBCPP_INLINE_VISIBILITY const_reference back() const  {return *(__end_ - 1);}\n\n    void reserve(size_type __n);\n    void shrink_to_fit() _NOEXCEPT;\n    void push_front(const_reference __x);\n    _LIBCPP_INLINE_VISIBILITY void push_back(const_reference __x);\n#if !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)\n    void push_front(value_type&& __x);\n    void push_back(value_type&& __x);\n#if !defined(_LIBCPP_HAS_NO_VARIADICS)\n    template <class... _Args>\n        void emplace_back(_Args&&... __args);\n#endif  // !defined(_LIBCPP_HAS_NO_VARIADICS)\n#endif  // !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)\n\n    _LIBCPP_INLINE_VISIBILITY void pop_front() {__destruct_at_begin(__begin_+1);}\n    _LIBCPP_INLINE_VISIBILITY void pop_back() {__destruct_at_end(__end_-1);}\n\n    void __construct_at_end(size_type __n);\n    void __construct_at_end(size_type __n, const_reference __x);\n    template <class _InputIter>\n        typename enable_if\n        <\n            __is_input_iterator<_InputIter>::value &&\n           !__is_forward_iterator<_InputIter>::value,\n            void\n        >::type\n        __construct_at_end(_InputIter __first, _InputIter __last);\n    template <class _ForwardIterator>\n        typename enable_if\n        <\n            __is_forward_iterator<_ForwardIterator>::value,\n            void\n        >::type\n        __construct_at_end(_ForwardIterator __first, _ForwardIterator __last);\n\n    _LIBCPP_INLINE_VISIBILITY void __destruct_at_begin(pointer __new_begin)\n        {__destruct_at_begin(__new_begin, is_trivially_destructible<value_type>());}\n        _LIBCPP_INLINE_VISIBILITY\n        void __destruct_at_begin(pointer __new_begin, false_type);\n        _LIBCPP_INLINE_VISIBILITY\n        void __destruct_at_begin(pointer __new_begin, true_type);\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __destruct_at_end(pointer __new_last) _NOEXCEPT\n        {__destruct_at_end(__new_last, false_type());}\n    _LIBCPP_INLINE_VISIBILITY\n        void __destruct_at_end(pointer __new_last, false_type) _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n        void __destruct_at_end(pointer __new_last, true_type) _NOEXCEPT;\n\n    void swap(__split_buffer& __x)\n        _NOEXCEPT_(!__alloc_traits::propagate_on_container_swap::value||\n                   __is_nothrow_swappable<__alloc_rr>::value);\n\n    bool __invariants() const;\n\nprivate:\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign_alloc(__split_buffer& __c, true_type)\n        _NOEXCEPT_(is_nothrow_move_assignable<allocator_type>::value)\n        {\n            __alloc() = _VSTD::move(__c.__alloc());\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign_alloc(__split_buffer&, false_type) _NOEXCEPT\n        {}\n};\n\ntemplate <class _Tp, class _Allocator>\nbool\n__split_buffer<_Tp, _Allocator>::__invariants() const\n{\n    if (__first_ == nullptr)\n    {\n        if (__begin_ != nullptr)\n            return false;\n        if (__end_ != nullptr)\n            return false;\n        if (__end_cap() != nullptr)\n            return false;\n    }\n    else\n    {\n        if (__begin_ < __first_)\n            return false;\n        if (__end_ < __begin_)\n            return false;\n        if (__end_cap() < __end_)\n            return false;\n    }\n    return true;\n}\n\n//  Default constructs __n objects starting at __end_\n//  throws if construction throws\n//  Precondition:  __n > 0\n//  Precondition:  size() + __n <= capacity()\n//  Postcondition:  size() == size() + __n\ntemplate <class _Tp, class _Allocator>\nvoid\n__split_buffer<_Tp, _Allocator>::__construct_at_end(size_type __n)\n{\n    __alloc_rr& __a = this->__alloc();\n    do\n    {\n        __alloc_traits::construct(__a, _VSTD::__to_raw_pointer(this->__end_));\n        ++this->__end_;\n        --__n;\n    } while (__n > 0);\n}\n\n//  Copy constructs __n objects starting at __end_ from __x\n//  throws if construction throws\n//  Precondition:  __n > 0\n//  Precondition:  size() + __n <= capacity()\n//  Postcondition:  size() == old size() + __n\n//  Postcondition:  [i] == __x for all i in [size() - __n, __n)\ntemplate <class _Tp, class _Allocator>\nvoid\n__split_buffer<_Tp, _Allocator>::__construct_at_end(size_type __n, const_reference __x)\n{\n    __alloc_rr& __a = this->__alloc();\n    do\n    {\n        __alloc_traits::construct(__a, _VSTD::__to_raw_pointer(this->__end_), __x);\n        ++this->__end_;\n        --__n;\n    } while (__n > 0);\n}\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class _InputIter>\ntypename enable_if\n<\n     __is_input_iterator<_InputIter>::value &&\n    !__is_forward_iterator<_InputIter>::value,\n    void\n>::type\n__split_buffer<_Tp, _Allocator>::__construct_at_end(_InputIter __first, _InputIter __last)\n{\n    __alloc_rr& __a = this->__alloc();\n    for (; __first != __last; ++__first)\n    {\n        if (__end_ == __end_cap())\n        {\n            size_type __old_cap = __end_cap() - __first_;\n            size_type __new_cap = _VSTD::max<size_type>(2 * __old_cap, 8);\n            __split_buffer __buf(__new_cap, 0, __a);\n            for (pointer __p = __begin_; __p != __end_; ++__p, ++__buf.__end_)\n                __alloc_traits::construct(__buf.__alloc(),\n                        _VSTD::__to_raw_pointer(__buf.__end_), _VSTD::move(*__p));\n            swap(__buf);\n        }\n        __alloc_traits::construct(__a, _VSTD::__to_raw_pointer(this->__end_), *__first);\n        ++this->__end_;\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class _ForwardIterator>\ntypename enable_if\n<\n    __is_forward_iterator<_ForwardIterator>::value,\n    void\n>::type\n__split_buffer<_Tp, _Allocator>::__construct_at_end(_ForwardIterator __first, _ForwardIterator __last)\n{\n    __alloc_rr& __a = this->__alloc();\n    for (; __first != __last; ++__first)\n    {\n        __alloc_traits::construct(__a, _VSTD::__to_raw_pointer(this->__end_), *__first);\n        ++this->__end_;\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\ninline\nvoid\n__split_buffer<_Tp, _Allocator>::__destruct_at_begin(pointer __new_begin, false_type)\n{\n    while (__begin_ != __new_begin)\n        __alloc_traits::destroy(__alloc(), __to_raw_pointer(__begin_++));\n}\n\ntemplate <class _Tp, class _Allocator>\ninline\nvoid\n__split_buffer<_Tp, _Allocator>::__destruct_at_begin(pointer __new_begin, true_type)\n{\n    __begin_ = __new_begin;\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\n__split_buffer<_Tp, _Allocator>::__destruct_at_end(pointer __new_last, false_type) _NOEXCEPT\n{\n    while (__new_last != __end_)\n        __alloc_traits::destroy(__alloc(), __to_raw_pointer(--__end_));\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\n__split_buffer<_Tp, _Allocator>::__destruct_at_end(pointer __new_last, true_type) _NOEXCEPT\n{\n    __end_ = __new_last;\n}\n\ntemplate <class _Tp, class _Allocator>\n__split_buffer<_Tp, _Allocator>::__split_buffer(size_type __cap, size_type __start, __alloc_rr& __a)\n    : __end_cap_(nullptr, __a)\n{\n    __first_ = __cap != 0 ? __alloc_traits::allocate(__alloc(), __cap) : nullptr;\n    __begin_ = __end_ = __first_ + __start;\n    __end_cap() = __first_ + __cap;\n}\n\ntemplate <class _Tp, class _Allocator>\ninline\n__split_buffer<_Tp, _Allocator>::__split_buffer()\n    _NOEXCEPT_(is_nothrow_default_constructible<allocator_type>::value)\n    : __first_(nullptr), __begin_(nullptr), __end_(nullptr), __end_cap_(nullptr)\n{\n}\n\ntemplate <class _Tp, class _Allocator>\ninline\n__split_buffer<_Tp, _Allocator>::__split_buffer(__alloc_rr& __a)\n    : __first_(nullptr), __begin_(nullptr), __end_(nullptr), __end_cap_(nullptr, __a)\n{\n}\n\ntemplate <class _Tp, class _Allocator>\ninline\n__split_buffer<_Tp, _Allocator>::__split_buffer(const __alloc_rr& __a)\n    : __first_(nullptr), __begin_(nullptr), __end_(nullptr), __end_cap_(nullptr, __a)\n{\n}\n\ntemplate <class _Tp, class _Allocator>\n__split_buffer<_Tp, _Allocator>::~__split_buffer()\n{\n    clear();\n    if (__first_)\n        __alloc_traits::deallocate(__alloc(), __first_, capacity());\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Allocator>\n__split_buffer<_Tp, _Allocator>::__split_buffer(__split_buffer&& __c)\n    _NOEXCEPT_(is_nothrow_move_constructible<allocator_type>::value)\n    : __first_(_VSTD::move(__c.__first_)),\n      __begin_(_VSTD::move(__c.__begin_)),\n      __end_(_VSTD::move(__c.__end_)),\n      __end_cap_(_VSTD::move(__c.__end_cap_))\n{\n    __c.__first_ = nullptr;\n    __c.__begin_ = nullptr;\n    __c.__end_ = nullptr;\n    __c.__end_cap() = nullptr;\n}\n\ntemplate <class _Tp, class _Allocator>\n__split_buffer<_Tp, _Allocator>::__split_buffer(__split_buffer&& __c, const __alloc_rr& __a)\n    : __end_cap_(__a)\n{\n    if (__a == __c.__alloc())\n    {\n        __first_ = __c.__first_;\n        __begin_ = __c.__begin_;\n        __end_ = __c.__end_;\n        __end_cap() = __c.__end_cap();\n        __c.__first_ = nullptr;\n        __c.__begin_ = nullptr;\n        __c.__end_ = nullptr;\n        __c.__end_cap() = nullptr;\n    }\n    else\n    {\n        size_type __cap = __c.size();\n        __first_ = __alloc_traits::allocate(__alloc(), __cap);\n        __begin_ = __end_ = __first_;\n        __end_cap() = __first_ + __cap;\n        typedef move_iterator<iterator> _Ip;\n        __construct_at_end(_Ip(__c.begin()), _Ip(__c.end()));\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\n__split_buffer<_Tp, _Allocator>&\n__split_buffer<_Tp, _Allocator>::operator=(__split_buffer&& __c)\n    _NOEXCEPT_((__alloc_traits::propagate_on_container_move_assignment::value &&\n                is_nothrow_move_assignable<allocator_type>::value) ||\n               !__alloc_traits::propagate_on_container_move_assignment::value)\n{\n    clear();\n    shrink_to_fit();\n    __first_ = __c.__first_;\n    __begin_ = __c.__begin_;\n    __end_ = __c.__end_;\n    __end_cap() = __c.__end_cap();\n    __move_assign_alloc(__c,\n        integral_constant<bool,\n                          __alloc_traits::propagate_on_container_move_assignment::value>());\n    __c.__first_ = __c.__begin_ = __c.__end_ = __c.__end_cap() = nullptr;\n    return *this;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Allocator>\nvoid\n__split_buffer<_Tp, _Allocator>::swap(__split_buffer& __x)\n        _NOEXCEPT_(!__alloc_traits::propagate_on_container_swap::value||\n                   __is_nothrow_swappable<__alloc_rr>::value)\n{\n    _VSTD::swap(__first_, __x.__first_);\n    _VSTD::swap(__begin_, __x.__begin_);\n    _VSTD::swap(__end_, __x.__end_);\n    _VSTD::swap(__end_cap(), __x.__end_cap());\n    __swap_allocator(__alloc(), __x.__alloc());\n}\n\ntemplate <class _Tp, class _Allocator>\nvoid\n__split_buffer<_Tp, _Allocator>::reserve(size_type __n)\n{\n    if (__n < capacity())\n    {\n        __split_buffer<value_type, __alloc_rr&> __t(__n, 0, __alloc());\n        __t.__construct_at_end(move_iterator<pointer>(__begin_),\n                               move_iterator<pointer>(__end_));\n        _VSTD::swap(__first_, __t.__first_);\n        _VSTD::swap(__begin_, __t.__begin_);\n        _VSTD::swap(__end_, __t.__end_);\n        _VSTD::swap(__end_cap(), __t.__end_cap());\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\nvoid\n__split_buffer<_Tp, _Allocator>::shrink_to_fit() _NOEXCEPT\n{\n    if (capacity() > size())\n    {\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        try\n        {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n            __split_buffer<value_type, __alloc_rr&> __t(size(), 0, __alloc());\n            __t.__construct_at_end(move_iterator<pointer>(__begin_),\n                                   move_iterator<pointer>(__end_));\n            __t.__end_ = __t.__begin_ + (__end_ - __begin_);\n            _VSTD::swap(__first_, __t.__first_);\n            _VSTD::swap(__begin_, __t.__begin_);\n            _VSTD::swap(__end_, __t.__end_);\n            _VSTD::swap(__end_cap(), __t.__end_cap());\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        }\n        catch (...)\n        {\n        }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\nvoid\n__split_buffer<_Tp, _Allocator>::push_front(const_reference __x)\n{\n    if (__begin_ == __first_)\n    {\n        if (__end_ < __end_cap())\n        {\n            difference_type __d = __end_cap() - __end_;\n            __d = (__d + 1) / 2;\n            __begin_ = _VSTD::move_backward(__begin_, __end_, __end_ + __d);\n            __end_ += __d;\n        }\n        else\n        {\n            size_type __c = max<size_type>(2 * static_cast<size_t>(__end_cap() - __first_), 1);\n            __split_buffer<value_type, __alloc_rr&> __t(__c, (__c + 3) / 4, __alloc());\n            __t.__construct_at_end(move_iterator<pointer>(__begin_),\n                                   move_iterator<pointer>(__end_));\n            _VSTD::swap(__first_, __t.__first_);\n            _VSTD::swap(__begin_, __t.__begin_);\n            _VSTD::swap(__end_, __t.__end_);\n            _VSTD::swap(__end_cap(), __t.__end_cap());\n        }\n    }\n    __alloc_traits::construct(__alloc(), _VSTD::__to_raw_pointer(__begin_-1), __x);\n    --__begin_;\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Allocator>\nvoid\n__split_buffer<_Tp, _Allocator>::push_front(value_type&& __x)\n{\n    if (__begin_ == __first_)\n    {\n        if (__end_ < __end_cap())\n        {\n            difference_type __d = __end_cap() - __end_;\n            __d = (__d + 1) / 2;\n            __begin_ = _VSTD::move_backward(__begin_, __end_, __end_ + __d);\n            __end_ += __d;\n        }\n        else\n        {\n            size_type __c = max<size_type>(2 * static_cast<size_t>(__end_cap() - __first_), 1);\n            __split_buffer<value_type, __alloc_rr&> __t(__c, (__c + 3) / 4, __alloc());\n            __t.__construct_at_end(move_iterator<pointer>(__begin_),\n                                   move_iterator<pointer>(__end_));\n            _VSTD::swap(__first_, __t.__first_);\n            _VSTD::swap(__begin_, __t.__begin_);\n            _VSTD::swap(__end_, __t.__end_);\n            _VSTD::swap(__end_cap(), __t.__end_cap());\n        }\n    }\n    __alloc_traits::construct(__alloc(), _VSTD::__to_raw_pointer(__begin_-1),\n            _VSTD::move(__x));\n    --__begin_;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\n__split_buffer<_Tp, _Allocator>::push_back(const_reference __x)\n{\n    if (__end_ == __end_cap())\n    {\n        if (__begin_ > __first_)\n        {\n            difference_type __d = __begin_ - __first_;\n            __d = (__d + 1) / 2;\n            __end_ = _VSTD::move(__begin_, __end_, __begin_ - __d);\n            __begin_ -= __d;\n        }\n        else\n        {\n            size_type __c = max<size_type>(2 * static_cast<size_t>(__end_cap() - __first_), 1);\n            __split_buffer<value_type, __alloc_rr&> __t(__c, __c / 4, __alloc());\n            __t.__construct_at_end(move_iterator<pointer>(__begin_),\n                                   move_iterator<pointer>(__end_));\n            _VSTD::swap(__first_, __t.__first_);\n            _VSTD::swap(__begin_, __t.__begin_);\n            _VSTD::swap(__end_, __t.__end_);\n            _VSTD::swap(__end_cap(), __t.__end_cap());\n        }\n    }\n    __alloc_traits::construct(__alloc(), _VSTD::__to_raw_pointer(__end_), __x);\n    ++__end_;\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Allocator>\nvoid\n__split_buffer<_Tp, _Allocator>::push_back(value_type&& __x)\n{\n    if (__end_ == __end_cap())\n    {\n        if (__begin_ > __first_)\n        {\n            difference_type __d = __begin_ - __first_;\n            __d = (__d + 1) / 2;\n            __end_ = _VSTD::move(__begin_, __end_, __begin_ - __d);\n            __begin_ -= __d;\n        }\n        else\n        {\n            size_type __c = max<size_type>(2 * static_cast<size_t>(__end_cap() - __first_), 1);\n            __split_buffer<value_type, __alloc_rr&> __t(__c, __c / 4, __alloc());\n            __t.__construct_at_end(move_iterator<pointer>(__begin_),\n                                   move_iterator<pointer>(__end_));\n            _VSTD::swap(__first_, __t.__first_);\n            _VSTD::swap(__begin_, __t.__begin_);\n            _VSTD::swap(__end_, __t.__end_);\n            _VSTD::swap(__end_cap(), __t.__end_cap());\n        }\n    }\n    __alloc_traits::construct(__alloc(), _VSTD::__to_raw_pointer(__end_),\n            _VSTD::move(__x));\n    ++__end_;\n}\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class... _Args>\nvoid\n__split_buffer<_Tp, _Allocator>::emplace_back(_Args&&... __args)\n{\n    if (__end_ == __end_cap())\n    {\n        if (__begin_ > __first_)\n        {\n            difference_type __d = __begin_ - __first_;\n            __d = (__d + 1) / 2;\n            __end_ = _VSTD::move(__begin_, __end_, __begin_ - __d);\n            __begin_ -= __d;\n        }\n        else\n        {\n            size_type __c = max<size_type>(2 * static_cast<size_t>(__end_cap() - __first_), 1);\n            __split_buffer<value_type, __alloc_rr&> __t(__c, __c / 4, __alloc());\n            __t.__construct_at_end(move_iterator<pointer>(__begin_),\n                                   move_iterator<pointer>(__end_));\n            _VSTD::swap(__first_, __t.__first_);\n            _VSTD::swap(__begin_, __t.__begin_);\n            _VSTD::swap(__end_, __t.__end_);\n            _VSTD::swap(__end_cap(), __t.__end_cap());\n        }\n    }\n    __alloc_traits::construct(__alloc(), _VSTD::__to_raw_pointer(__end_),\n                              _VSTD::forward<_Args>(__args)...);\n    ++__end_;\n}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(__split_buffer<_Tp, _Allocator>& __x, __split_buffer<_Tp, _Allocator>& __y)\n        _NOEXCEPT_(_NOEXCEPT_(__x.swap(__y)))\n{\n    __x.swap(__y);\n}\n\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_SPLIT_BUFFER\n","//\n//  DoG_scale_invariant_detector.h\n//  ARToolKit5\n//\n//  This file is part of ARToolKit.\n//\n//  ARToolKit is free software: you can redistribute it and/or modify\n//  it under the terms of the GNU Lesser General Public License as published by\n//  the Free Software Foundation, either version 3 of the License, or\n//  (at your option) any later version.\n//\n//  ARToolKit is distributed in the hope that it will be useful,\n//  but WITHOUT ANY WARRANTY; without even the implied warranty of\n//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n//  GNU Lesser General Public License for more details.\n//\n//  You should have received a copy of the GNU Lesser General Public License\n//  along with ARToolKit.  If not, see <http://www.gnu.org/licenses/>.\n//\n//  As a special exception, the copyright holders of this library give you\n//  permission to link this library with independent modules to produce an\n//  executable, regardless of the license terms of these independent modules, and to\n//  copy and distribute the resulting executable under terms of your choice,\n//  provided that you also meet, for each linked independent module, the terms and\n//  conditions of the license of that module. An independent module is a module\n//  which is neither derived from nor based on this library. If you modify this\n//  library, you may extend this exception to your version of the library, but you\n//  are not obligated to do so. If you do not wish to do so, delete this exception\n//  statement from your version.\n//\n//  Copyright 2013-2015 Daqri, LLC.\n//\n//  Author(s): Chris Broaddus\n//\n\n#pragma once\n\n#include \"gaussian_scale_space_pyramid.h\"\n#include \"orientation_assignment.h\"\n#include \"interpolate.h\"\n#include \"utils/point.h\"\n#include <framework/error.h>\n#include <math/math_utils.h>\n\nnamespace vision {\n    \n    /**\n     * Computes a Difference-of-Gaussian Pyramid from a Gaussian Pyramid.\n     */\n    class DoGPyramid {\n    public:\n        \n        DoGPyramid();\n        ~DoGPyramid() {}\n        \n        /**\n         * Allocate the pyramid.\n         */\n        void alloc(const GaussianScaleSpacePyramid* pyramid);\n        \n        /**\n         * Compute the Difference-of-Gaussian from a Gaussian Pyramid.\n         */\n        void compute(const GaussianScaleSpacePyramid* pyramid);\n        \n        /**\n         * Get a Laplacian image at a level in the pyramid.\n         */\n        inline Image& get(size_t octave, size_t scale) { return mImages[octave*mNumScalesPerOctave+scale]; }\n        inline const Image& get(size_t octave, size_t scale) const { return mImages[octave*mNumScalesPerOctave+scale]; }\n        \n        /**\n         * Get vector of images.\n         */\n        inline const std::vector<Image>& images() const { return mImages; }\n        \n        /**\n         * Get a Laplacian image at an index.\n         */\n        inline Image& get(size_t index) { return mImages[index]; }\n        inline const Image& get(size_t index) const { return mImages[index]; }\n        \n        /**\n         * Get the number of octaves and scales.\n         */\n        inline int numOctaves() const { return mNumOctaves; }\n        inline int numScalePerOctave() const { return mNumScalesPerOctave; }\n        inline size_t size() const { return mImages.size(); }\n        \n        /**\n         * Get the octave from the Laplacian image index.\n         */\n        inline int octaveFromIndex(int index) const {\n            ASSERT(index < mImages.size(), \"Index is out of range\");\n            return vision::round(vision::log2((float)(mImages[0].width()/mImages[index].width())));\n        }\n        \n        /**\n         * Get the scale from the Laplacian image index.\n         */\n        inline int scaleFromIndex(int index) const { return index%mNumScalesPerOctave; }\n        \n    private:\n        \n        // DoG images\n        std::vector<Image> mImages;\n        \n        // Number of octaves and scales\n        int mNumOctaves;\n        int mNumScalesPerOctave;\n        \n        /**\n         * Compute the difference image.\n         *\n         * d = im1 - im2\n         */\n        void difference_image_binomial(Image& d, const Image& im1, const Image& im2);\n    };\n    \n    class DoGScaleInvariantDetector {\n    public:\n        \n        static const size_t kMaxNumFeaturePoints = 5000;\n        static const int kMaxNumOrientations = 36;\n        \n        struct FeaturePoint {\n            float x, y;\n            float angle;\n            int octave;\n            int scale;\n            float sp_scale;\n            float score;\n            float sigma;\n            float edge_score;\n        }; // FeaturePoint\n        \n        DoGScaleInvariantDetector();\n        ~DoGScaleInvariantDetector();\n        \n        /**\n         * Allocate memory.\n         */\n        void alloc(const GaussianScaleSpacePyramid* pyramid);\n        \n        /**\n         * @return Width/Height of configured image\n         */\n        inline size_t width() const { return mWidth; }\n        inline size_t height() const { return mHeight; }\n        \n        /**\n         * Detect scale-invariant feature points given a pyramid.\n         */\n        void detect(const GaussianScaleSpacePyramid* pyramid);\n        \n        /**\n         * Get/Set the Laplacian absolute threshold.\n         */\n        float laplacianThreshold() const {\n            return mLaplacianThreshold;\n        }\n        void setLaplacianThreshold(float tr) {\n            mLaplacianThreshold = tr;\n        }\n        \n        /**\n         * Get/Set the maximum number of feature point.\n         */\n        size_t maxNumFeaturePoints() const {\n            return mMaxNumFeaturePoints;\n        }\n        void setMaxNumFeaturePoints(size_t n) {\n            mMaxNumFeaturePoints = n;\n            mFeaturePoints.reserve(n);\n        }\n        \n        /**\n         * Get/Set the edge threshold.\n         */\n        float edgeThreshold() const {\n            return mEdgeThreshold;\n        }\n        void setEdgeThreshold(float tr) {\n            mEdgeThreshold = tr;\n        }\n        \n        /**\n         * Set/Get find orientations.\n         */\n        void setFindOrientation(bool b) {\n            mFindOrientation = b;\n        }\n        bool findOrientation() const {\n            return mFindOrientation;\n        }\n        \n        /**\n         * @return Feature points\n         */\n        inline const std::vector<FeaturePoint>& features() const { return mFeaturePoints; }\n        \n        /**\n         * @return DoG Pyramid\n         */\n        inline const DoGPyramid& dogPyramid() const { return mLaplacianPyramid; }\n        \n    private:\n        \n        // Width/Height of configured image\n        size_t mWidth;\n        size_t mHeight;\n        \n        // Number of buckets in X/Y\n        size_t mNumBucketsX;\n        size_t mNumBucketsY;\n        \n        // Buckets for pruning points\n        std::vector<std::vector<std::vector<std::pair<float, size_t> > > > mBuckets;\n        \n        // True if the orientation should be assigned\n        bool mFindOrientation;\n        \n        // DoG pyramid\n        DoGPyramid mLaplacianPyramid;\n        \n        // Laplacian score threshold\n        float mLaplacianThreshold;\n        \n        // Edge threshold \n        float mEdgeThreshold;\n        \n        // Vector of extracted feature points\n        std::vector<FeaturePoint> mFeaturePoints;\n        \n        // Tmp vector of extracted feature points that have orientation values\n        std::vector<FeaturePoint> mTmpOrientatedFeaturePoints;\n        \n        // Maximum number of feature points\n        size_t mMaxNumFeaturePoints;\n        \n        // Maximum update allowed for sub-pixel refinement\n        float mMaxSubpixelDistanceSqr;\n        \n        // Orientation assignment\n        OrientationAssignment mOrientationAssignment;\n        \n        // Vector of orientations. Pre-allocated to the maximum\n        // number of orientations per feature point.\n        std::vector<float> mOrientations;\n        \n        /**\n         * Extract the minima/maxima.\n         */\n        void extractFeatures(const GaussianScaleSpacePyramid* pyramid,\n                             const DoGPyramid* laplacian);\n        \n        /**\n         * Sub-pixel refinement.\n         */\n        void findSubpixelLocations(const GaussianScaleSpacePyramid* pyramid);\n        \n        /**\n         * Prune the number of features.\n         */\n        void pruneFeatures();\n        \n        /**\n         * Find feature orientations.\n         */\n        void findFeatureOrientations(const GaussianScaleSpacePyramid* pyramid);\n        \n    }; // DoGScaleInvariantDetector\n    \n    inline void ComputeSubpixelDerivatives(float& Dx,\n                                           float& Dy,\n                                           float& Dxx,\n                                           float& Dyy,\n                                           float& Dxy,\n                                           const Image& im,\n                                           int x,\n                                           int y)\n    {\n        // Sanity checks\n        ASSERT((x-1) >= 0 && (x+1) < im.width(), \"x out of bounds\");\n        ASSERT((y-1) >= 0 && (y+1) < im.height(), \"y out of bounds\");\n        \n        const float* pm1 = &im.get<float>(y-1)[x];\n        const float* p   = &im.get<float>(y)[x];\n        const float* pp1 = &im.get<float>(y+1)[x];\n        \n        Dx  = 0.5f*(p[1]-p[-1]);\n        Dy  = 0.5f*(pp1[0]-pm1[0]);\n        Dxx = p[-1] + (-2.f*p[0]) + p[1];\n        Dyy = pm1[0] + (-2.f*p[0]) + pp1[0];\n        Dxy = 0.25f*((pm1[-1] + pp1[1]) - (pm1[1] + pp1[-1]));\n    }\n    \n    inline void ComputeSubpixelHessianSameOctave(float H[9],\n                                                 float b[3],\n                                                 const Image& lap0,\n                                                 const Image& lap1,\n                                                 const Image& lap2,\n                                                 int x,\n                                                 int y) {\n        float Dx, Dy, Ds;\n        float Dxx, Dyy, Dxy;\n        float Dss, Dxs, Dys;\n        \n        ASSERT((x-1) >= 0 && (x+1) < lap1.width(), \"x out of bounds\");\n        ASSERT((y-1) >= 0 && (y+1) < lap1.height(), \"y out of bounds\");\n        ASSERT(lap0.width() == lap1.width(), \"Image dimensions inconsistent\");\n        ASSERT(lap0.width() == lap2.width(), \"Image dimensions inconsistent\");\n        ASSERT(lap0.height() == lap1.height(), \"Image dimensions inconsistent\");\n        ASSERT(lap0.height() == lap2.height(), \"Image dimensions inconsistent\");\n        \n        const float* lap0_pm1 = &lap0.get<float>(y-1)[x];\n        const float* lap0_p   = &lap0.get<float>(y)[x];\n        const float* lap0_pp1 = &lap0.get<float>(y+1)[x];\n        \n        const float* lap1_p   = &lap1.get<float>(y)[x];\n        \n        const float* lap2_pm1 = &lap2.get<float>(y-1)[x];\n        const float* lap2_p   = &lap2.get<float>(y)[x];\n        const float* lap2_pp1 = &lap2.get<float>(y+1)[x];\n        \n        // Compute spatial derivatives\n        ComputeSubpixelDerivatives(Dx, Dy, Dxx, Dyy, Dxy, lap1, x, y);\n        \n        // Compute scale derivates\n        Ds  = 0.5f*(lap2_p[0] - lap0_p[0]);\n        Dss = lap0_p[0] + (-2.f*lap1_p[0]) + lap2_p[0];\n        Dxs = 0.25f*((lap0_p[-1] - lap0_p[1]) + (-lap2_p[-1] + lap2_p[1]));\n        Dys = 0.25f*((lap0_pm1[0] - lap0_pp1[0]) + (-lap2_pm1[0] + lap2_pp1[0]));\n        \n        // H\n        H[0] = Dxx; H[1] = Dxy; H[2] = Dxs;\n        H[3] = Dxy; H[4] = Dyy; H[5] = Dys;\n        H[6] = Dxs; H[7] = Dys; H[8] = Dss;\n        \n        // b\n        b[0] = -Dx;\n        b[1] = -Dy;\n        b[2] = -Ds;\n    }\n    \n    inline void ComputeSubpixelHessianCoarseOctavePair(float H[9],\n                                                       float b[3],\n                                                       const Image& lap0,\n                                                       const Image& lap1,\n                                                       const Image& lap2,\n                                                       int x,\n                                                       int y) {\n        float val;\n        float x_mul_2, y_mul_2;\n        float Dx, Dy, Ds;\n        float Dxx, Dyy, Dxy;\n        float Dss, Dxs, Dys;\n        \n        ASSERT((x-1) >= 0 && (x+1) < lap1.width(), \"x out of bounds\");\n        ASSERT((y-1) >= 0 && (y+1) < lap1.height(), \"y out of bounds\");\n        ASSERT((lap0.width()>>1) == lap1.width(), \"Image dimensions inconsistent\");\n        ASSERT((lap0.width()>>1) == lap2.width(), \"Image dimensions inconsistent\");\n        ASSERT((lap0.height()>>1) == lap1.height(), \"Image dimensions inconsistent\");\n        ASSERT((lap0.height()>>1) == lap2.height(), \"Image dimensions inconsistent\");\n\n        const float* lap1_p   = &lap1.get<float>(y)[x];;\n        \n        const float* lap2_pm1 = &lap2.get<float>(y-1)[x];\n        const float* lap2_p   = &lap2.get<float>(y)[x];\n        const float* lap2_pp1 = &lap2.get<float>(y+1)[x];\n        \n        // Upsample the point to the higher octave\n        bilinear_upsample_point(x_mul_2, y_mul_2, x, y, 1);\n        \n        // Compute spatial derivatives\n        ComputeSubpixelDerivatives(Dx, Dy, Dxx, Dyy, Dxy, lap1, x, y);\n        \n        // Interpolate the VALUE at the finer octave\n        val = bilinear_interpolation<float>(lap0, x_mul_2, y_mul_2);\n        \n        Ds  = 0.5f*(lap2_p[0] - val);\n        Dss = val + (-2.f*lap1_p[0]) + lap2_p[0];\n        Dxs = 0.25f*((bilinear_interpolation<float>(lap0, x_mul_2-2, y_mul_2) + lap2_p[1]) -\n                     (bilinear_interpolation<float>(lap0, x_mul_2+2, y_mul_2) + lap2_p[-1]));\n        Dys = 0.25f*((bilinear_interpolation<float>(lap0, x_mul_2, y_mul_2-2) + lap2_pp1[0]) -\n                     (bilinear_interpolation<float>(lap0, x_mul_2, y_mul_2+2) + lap2_pm1[0]));\n        \n        // H\n        H[0] = Dxx; H[1] = Dxy; H[2] = Dxs;\n        H[3] = Dxy; H[4] = Dyy; H[5] = Dys;\n        H[6] = Dxs; H[7] = Dys; H[8] = Dss;\n        \n        // h\n        b[0] = -Dx;\n        b[1] = -Dy;\n        b[2] = -Ds;\n    }\n    \n    inline void ComputeSubpixelHessianFineOctavePair(float H[9],\n                                                     float b[3],\n                                                     const Image& lap0,\n                                                     const Image& lap1,\n                                                     const Image& lap2,\n                                                     int x,\n                                                     int y)\n    {\n        float x_div_2, y_div_2;\n        float val;\n        float Dx, Dy, Ds;\n        float Dxx, Dyy, Dxy;\n        float Dss, Dxs, Dys;\n        \n        ASSERT((x-1) >= 0 && (x+1) < lap1.width(), \"x out of bounds\");\n        ASSERT((y-1) >= 0 && (y+1) < lap1.height(), \"y out of bounds\");\n        ASSERT(lap0.width() == lap1.width(), \"Image dimensions inconsistent\");\n        ASSERT((lap0.width()>>1) == lap2.width(), \"Image dimensions inconsistent\");\n        ASSERT(lap0.height() == lap1.height(), \"Image dimensions inconsistent\");\n        ASSERT((lap0.height()>>1) == lap2.height(), \"Image dimensions inconsistent\");\n        \n        const float* lap0_pm1 = &lap0.get<float>(y-1)[x];\n        const float* lap0_p   = &lap0.get<float>(y)[x];\n        const float* lap0_pp1 = &lap0.get<float>(y+1)[x];\n        \n        const float* lap1_p   = &lap1.get<float>(y)[x];\n        \n        bilinear_downsample_point(x_div_2, y_div_2, x, y, 1);\n        \n        ASSERT(x_div_2-0.5f >= 0, \"x_div_2 out of bounds out of bounds for interpolation\");\n        ASSERT(y_div_2-0.5f >= 0, \"y_div_2 out of bounds out of bounds for interpolation\");\n        ASSERT(x_div_2+0.5f < lap2.width(), \"x_div_2 out of bounds out of bounds for interpolation\");\n        ASSERT(y_div_2+0.5f < lap2.height(), \"y_div_2 out of bounds out of bounds for interpolation\");\n        \n        // Compute spatial derivatives\n        ComputeSubpixelDerivatives(Dx, Dy, Dxx, Dyy, Dxy, lap1, x, y);\n        \n        // Interpolate the VALUE at the coarser octave\n        val = bilinear_interpolation<float>(lap2, x_div_2, y_div_2);\n        \n        Ds = 0.5f*(val - lap0_p[0]);\n        Dss = lap0_p[0] + (-2.f*lap1_p[0]) + val;\n        Dxs = 0.25f*((lap0_p[-1]  + bilinear_interpolation<float>(lap2, x_div_2+.5f, y_div_2)) -\n                     (lap0_p[ 1]  + bilinear_interpolation<float>(lap2, x_div_2-.5f, y_div_2)));\n        Dys = 0.25f*((lap0_pm1[0] + bilinear_interpolation<float>(lap2, x_div_2,     y_div_2+.5f)) -\n                     (lap0_pp1[0] + bilinear_interpolation<float>(lap2, x_div_2,     y_div_2-.5f)));\n        \n        // H\n        H[0] = Dxx; H[1] = Dxy; H[2] = Dxs;\n        H[3] = Dxy; H[4] = Dyy; H[5] = Dys;\n        H[6] = Dxs; H[7] = Dys; H[8] = Dss;\n        \n        // b\n        b[0] = -Dx;\n        b[1] = -Dy;\n        b[2] = -Ds;\n    }\n    \n    inline bool ComputeSubpixelHessian(float H[9],\n                                       float b[3],\n                                       const Image& lap0,\n                                       const Image& lap1,\n                                       const Image& lap2,\n                                       int x,\n                                       int y) {\n\n        if(lap0.width() == lap1.width() == lap2.width()) {\n            ASSERT(lap0.height() == lap1.height() == lap2.height(), \"Width/height are not consistent\");\n            ComputeSubpixelHessianSameOctave(H, b, lap0, lap1, lap2, x, y);\n        } else if((lap0.width() == lap1.width()) && ((lap1.width()>>1) == lap2.width())) {\n            ASSERT((lap0.height() == lap1.height()) && ((lap1.height()>>1) == lap2.height()), \"Width/height are not consistent\");\n            ComputeSubpixelHessianFineOctavePair(H, b, lap0, lap1, lap2, x, y);\n        } else if(((lap0.width()>>1) == lap1.width()) && (lap1.width() == lap2.width())) {\n            ASSERT(((lap0.width()>>1) == lap1.width()) && (lap1.width() == lap2.width()), \"Width/height are not consistent\");\n            ComputeSubpixelHessianCoarseOctavePair(H, b, lap0, lap1, lap2, x, y);\n        } else {\n            ASSERT(0, \"Image sizes are inconsistent\");\n            return false;\n        }\n        \n        return true;\n    }\n    \n    inline bool ComputeEdgeScore(float& score, const float H[9]) {\n        float det;\n        \n        const float& Dxx = H[0];\n        const float& Dyy = H[4];\n        const float& Dxy = H[1];\n        \n        det = (Dxx*Dyy)-sqr(Dxy);\n        \n        // The determinant cannot be zero\n        if(det == 0) {\n            return false;\n        }\n        \n        // Compute a score based on the local curvature\n        score = sqr(Dxx+Dyy)/det;\n        \n        return true;\n    }\n    \n    void PruneDoGFeatures(std::vector<std::vector<std::vector<std::pair<float, size_t> > > >& buckets,\n                          std::vector<DoGScaleInvariantDetector::FeaturePoint>& outPoints,\n                          const std::vector<DoGScaleInvariantDetector::FeaturePoint>& inPoints,\n                          int num_buckets_X,\n                          int num_buckets_Y,\n                          int width,\n                          int height,\n                          int max_points);\n    \n} // vision","// -*- C++ -*-\n//===---------------------------- math.h ----------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_MATH_H\n#define _LIBCPP_MATH_H\n\n/*\n    math.h synopsis\n\nMacros:\n\n    HUGE_VAL\n    HUGE_VALF               // C99\n    HUGE_VALL               // C99\n    INFINITY                // C99\n    NAN                     // C99\n    FP_INFINITE             // C99\n    FP_NAN                  // C99\n    FP_NORMAL               // C99\n    FP_SUBNORMAL            // C99\n    FP_ZERO                 // C99\n    FP_FAST_FMA             // C99\n    FP_FAST_FMAF            // C99\n    FP_FAST_FMAL            // C99\n    FP_ILOGB0               // C99\n    FP_ILOGBNAN             // C99\n    MATH_ERRNO              // C99\n    MATH_ERREXCEPT          // C99\n    math_errhandling        // C99\n\nTypes:\n\n    float_t                 // C99\n    double_t                // C99\n\n// C90\n\nfloating_point abs(floating_point x);\n\nfloating_point acos (arithmetic x);\nfloat          acosf(float x);\nlong double    acosl(long double x);\n\nfloating_point asin (arithmetic x);\nfloat          asinf(float x);\nlong double    asinl(long double x);\n\nfloating_point atan (arithmetic x);\nfloat          atanf(float x);\nlong double    atanl(long double x);\n\nfloating_point atan2 (arithmetic y, arithmetic x);\nfloat          atan2f(float y, float x);\nlong double    atan2l(long double y, long double x);\n\nfloating_point ceil (arithmetic x);\nfloat          ceilf(float x);\nlong double    ceill(long double x);\n\nfloating_point cos (arithmetic x);\nfloat          cosf(float x);\nlong double    cosl(long double x);\n\nfloating_point cosh (arithmetic x);\nfloat          coshf(float x);\nlong double    coshl(long double x);\n\nfloating_point exp (arithmetic x);\nfloat          expf(float x);\nlong double    expl(long double x);\n\nfloating_point fabs (arithmetic x);\nfloat          fabsf(float x);\nlong double    fabsl(long double x);\n\nfloating_point floor (arithmetic x);\nfloat          floorf(float x);\nlong double    floorl(long double x);\n\nfloating_point fmod (arithmetic x, arithmetic y);\nfloat          fmodf(float x, float y);\nlong double    fmodl(long double x, long double y);\n\nfloating_point frexp (arithmetic value, int* exp);\nfloat          frexpf(float value, int* exp);\nlong double    frexpl(long double value, int* exp);\n\nfloating_point ldexp (arithmetic value, int exp);\nfloat          ldexpf(float value, int exp);\nlong double    ldexpl(long double value, int exp);\n\nfloating_point log (arithmetic x);\nfloat          logf(float x);\nlong double    logl(long double x);\n\nfloating_point log10 (arithmetic x);\nfloat          log10f(float x);\nlong double    log10l(long double x);\n\nfloating_point modf (floating_point value, floating_point* iptr);\nfloat          modff(float value, float* iptr);\nlong double    modfl(long double value, long double* iptr);\n\nfloating_point pow (arithmetic x, arithmetic y);\nfloat          powf(float x, float y);\nlong double    powl(long double x, long double y);\n\nfloating_point sin (arithmetic x);\nfloat          sinf(float x);\nlong double    sinl(long double x);\n\nfloating_point sinh (arithmetic x);\nfloat          sinhf(float x);\nlong double    sinhl(long double x);\n\nfloating_point sqrt (arithmetic x);\nfloat          sqrtf(float x);\nlong double    sqrtl(long double x);\n\nfloating_point tan (arithmetic x);\nfloat          tanf(float x);\nlong double    tanl(long double x);\n\nfloating_point tanh (arithmetic x);\nfloat          tanhf(float x);\nlong double    tanhl(long double x);\n\n//  C99\n\nbool signbit(arithmetic x);\n\nint fpclassify(arithmetic x);\n\nbool isfinite(arithmetic x);\nbool isinf(arithmetic x);\nbool isnan(arithmetic x);\nbool isnormal(arithmetic x);\n\nbool isgreater(arithmetic x, arithmetic y);\nbool isgreaterequal(arithmetic x, arithmetic y);\nbool isless(arithmetic x, arithmetic y);\nbool islessequal(arithmetic x, arithmetic y);\nbool islessgreater(arithmetic x, arithmetic y);\nbool isunordered(arithmetic x, arithmetic y);\n\nfloating_point acosh (arithmetic x);\nfloat          acoshf(float x);\nlong double    acoshl(long double x);\n\nfloating_point asinh (arithmetic x);\nfloat          asinhf(float x);\nlong double    asinhl(long double x);\n\nfloating_point atanh (arithmetic x);\nfloat          atanhf(float x);\nlong double    atanhl(long double x);\n\nfloating_point cbrt (arithmetic x);\nfloat          cbrtf(float x);\nlong double    cbrtl(long double x);\n\nfloating_point copysign (arithmetic x, arithmetic y);\nfloat          copysignf(float x, float y);\nlong double    copysignl(long double x, long double y);\n\nfloating_point erf (arithmetic x);\nfloat          erff(float x);\nlong double    erfl(long double x);\n\nfloating_point erfc (arithmetic x);\nfloat          erfcf(float x);\nlong double    erfcl(long double x);\n\nfloating_point exp2 (arithmetic x);\nfloat          exp2f(float x);\nlong double    exp2l(long double x);\n\nfloating_point expm1 (arithmetic x);\nfloat          expm1f(float x);\nlong double    expm1l(long double x);\n\nfloating_point fdim (arithmetic x, arithmetic y);\nfloat          fdimf(float x, float y);\nlong double    fdiml(long double x, long double y);\n\nfloating_point fma (arithmetic x, arithmetic y, arithmetic z);\nfloat          fmaf(float x, float y, float z);\nlong double    fmal(long double x, long double y, long double z);\n\nfloating_point fmax (arithmetic x, arithmetic y);\nfloat          fmaxf(float x, float y);\nlong double    fmaxl(long double x, long double y);\n\nfloating_point fmin (arithmetic x, arithmetic y);\nfloat          fminf(float x, float y);\nlong double    fminl(long double x, long double y);\n\nfloating_point hypot (arithmetic x, arithmetic y);\nfloat          hypotf(float x, float y);\nlong double    hypotl(long double x, long double y);\n\nint ilogb (arithmetic x);\nint ilogbf(float x);\nint ilogbl(long double x);\n\nfloating_point lgamma (arithmetic x);\nfloat          lgammaf(float x);\nlong double    lgammal(long double x);\n\nlong long llrint (arithmetic x);\nlong long llrintf(float x);\nlong long llrintl(long double x);\n\nlong long llround (arithmetic x);\nlong long llroundf(float x);\nlong long llroundl(long double x);\n\nfloating_point log1p (arithmetic x);\nfloat          log1pf(float x);\nlong double    log1pl(long double x);\n\nfloating_point log2 (arithmetic x);\nfloat          log2f(float x);\nlong double    log2l(long double x);\n\nfloating_point logb (arithmetic x);\nfloat          logbf(float x);\nlong double    logbl(long double x);\n\nlong lrint (arithmetic x);\nlong lrintf(float x);\nlong lrintl(long double x);\n\nlong lround (arithmetic x);\nlong lroundf(float x);\nlong lroundl(long double x);\n\ndouble      nan (const char* str);\nfloat       nanf(const char* str);\nlong double nanl(const char* str);\n\nfloating_point nearbyint (arithmetic x);\nfloat          nearbyintf(float x);\nlong double    nearbyintl(long double x);\n\nfloating_point nextafter (arithmetic x, arithmetic y);\nfloat          nextafterf(float x, float y);\nlong double    nextafterl(long double x, long double y);\n\nfloating_point nexttoward (arithmetic x, long double y);\nfloat          nexttowardf(float x, long double y);\nlong double    nexttowardl(long double x, long double y);\n\nfloating_point remainder (arithmetic x, arithmetic y);\nfloat          remainderf(float x, float y);\nlong double    remainderl(long double x, long double y);\n\nfloating_point remquo (arithmetic x, arithmetic y, int* pquo);\nfloat          remquof(float x, float y, int* pquo);\nlong double    remquol(long double x, long double y, int* pquo);\n\nfloating_point rint (arithmetic x);\nfloat          rintf(float x);\nlong double    rintl(long double x);\n\nfloating_point round (arithmetic x);\nfloat          roundf(float x);\nlong double    roundl(long double x);\n\nfloating_point scalbln (arithmetic x, long ex);\nfloat          scalblnf(float x, long ex);\nlong double    scalblnl(long double x, long ex);\n\nfloating_point scalbn (arithmetic x, int ex);\nfloat          scalbnf(float x, int ex);\nlong double    scalbnl(long double x, int ex);\n\nfloating_point tgamma (arithmetic x);\nfloat          tgammaf(float x);\nlong double    tgammal(long double x);\n\nfloating_point trunc (arithmetic x);\nfloat          truncf(float x);\nlong double    truncl(long double x);\n\n*/\n\n#include <__config>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n#include_next <math.h>\n\n#ifdef __cplusplus\n\n// We support including .h headers inside 'extern \"C\"' contexts, so switch\n// back to C++ linkage before including these C++ headers.\nextern \"C++\" {\n\n#include <type_traits>\n\n// signbit\n\n#ifdef signbit\n\ntemplate <class _A1>\n_LIBCPP_ALWAYS_INLINE\nbool\n__libcpp_signbit(_A1 __lcpp_x) _NOEXCEPT\n{\n    return signbit(__lcpp_x);\n}\n\n#undef signbit\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_arithmetic<_A1>::value, bool>::type\nsignbit(_A1 __lcpp_x) _NOEXCEPT\n{\n    return __libcpp_signbit((typename std::__promote<_A1>::type)__lcpp_x);\n}\n\n#endif  // signbit\n\n// fpclassify\n\n#ifdef fpclassify\n\ntemplate <class _A1>\n_LIBCPP_ALWAYS_INLINE\nint\n__libcpp_fpclassify(_A1 __lcpp_x) _NOEXCEPT\n{\n    return fpclassify(__lcpp_x);\n}\n\n#undef fpclassify\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_arithmetic<_A1>::value, int>::type\nfpclassify(_A1 __lcpp_x) _NOEXCEPT\n{\n    return __libcpp_fpclassify((typename std::__promote<_A1>::type)__lcpp_x);\n}\n\n#endif  // fpclassify\n\n// isfinite\n\n#ifdef isfinite\n\ntemplate <class _A1>\n_LIBCPP_ALWAYS_INLINE\nbool\n__libcpp_isfinite(_A1 __lcpp_x) _NOEXCEPT\n{\n    return isfinite(__lcpp_x);\n}\n\n#undef isfinite\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_arithmetic<_A1>::value, bool>::type\nisfinite(_A1 __lcpp_x) _NOEXCEPT\n{\n    return __libcpp_isfinite((typename std::__promote<_A1>::type)__lcpp_x);\n}\n\n#endif  // isfinite\n\n// isinf\n\n#ifdef isinf\n\ntemplate <class _A1>\n_LIBCPP_ALWAYS_INLINE\nbool\n__libcpp_isinf(_A1 __lcpp_x) _NOEXCEPT\n{\n    return isinf(__lcpp_x);\n}\n\n#undef isinf\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_arithmetic<_A1>::value, bool>::type\nisinf(_A1 __lcpp_x) _NOEXCEPT\n{\n    return __libcpp_isinf((typename std::__promote<_A1>::type)__lcpp_x);\n}\n\n#endif  // isinf\n\n// isnan\n\n#ifdef isnan\n\ntemplate <class _A1>\n_LIBCPP_ALWAYS_INLINE\nbool\n__libcpp_isnan(_A1 __lcpp_x) _NOEXCEPT\n{\n    return isnan(__lcpp_x);\n}\n\n#undef isnan\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_arithmetic<_A1>::value, bool>::type\nisnan(_A1 __lcpp_x) _NOEXCEPT\n{\n    return __libcpp_isnan((typename std::__promote<_A1>::type)__lcpp_x);\n}\n\n#endif  // isnan\n\n// isnormal\n\n#ifdef isnormal\n\ntemplate <class _A1>\n_LIBCPP_ALWAYS_INLINE\nbool\n__libcpp_isnormal(_A1 __lcpp_x) _NOEXCEPT\n{\n    return isnormal(__lcpp_x);\n}\n\n#undef isnormal\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_arithmetic<_A1>::value, bool>::type\nisnormal(_A1 __lcpp_x) _NOEXCEPT\n{\n    return __libcpp_isnormal((typename std::__promote<_A1>::type)__lcpp_x);\n}\n\n#endif  // isnormal\n\n// isgreater\n\n#ifdef isgreater\n\ntemplate <class _A1, class _A2>\n_LIBCPP_ALWAYS_INLINE\nbool\n__libcpp_isgreater(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    return isgreater(__lcpp_x, __lcpp_y);\n}\n\n#undef isgreater\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if\n<\n    std::is_arithmetic<_A1>::value &&\n    std::is_arithmetic<_A2>::value,\n    bool\n>::type\nisgreater(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    typedef typename std::__promote<_A1, _A2>::type type;\n    return __libcpp_isgreater((type)__lcpp_x, (type)__lcpp_y);\n}\n\n#endif  // isgreater\n\n// isgreaterequal\n\n#ifdef isgreaterequal\n\ntemplate <class _A1, class _A2>\n_LIBCPP_ALWAYS_INLINE\nbool\n__libcpp_isgreaterequal(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    return isgreaterequal(__lcpp_x, __lcpp_y);\n}\n\n#undef isgreaterequal\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if\n<\n    std::is_arithmetic<_A1>::value &&\n    std::is_arithmetic<_A2>::value,\n    bool\n>::type\nisgreaterequal(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    typedef typename std::__promote<_A1, _A2>::type type;\n    return __libcpp_isgreaterequal((type)__lcpp_x, (type)__lcpp_y);\n}\n\n#endif  // isgreaterequal\n\n// isless\n\n#ifdef isless\n\ntemplate <class _A1, class _A2>\n_LIBCPP_ALWAYS_INLINE\nbool\n__libcpp_isless(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    return isless(__lcpp_x, __lcpp_y);\n}\n\n#undef isless\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if\n<\n    std::is_arithmetic<_A1>::value &&\n    std::is_arithmetic<_A2>::value,\n    bool\n>::type\nisless(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    typedef typename std::__promote<_A1, _A2>::type type;\n    return __libcpp_isless((type)__lcpp_x, (type)__lcpp_y);\n}\n\n#endif  // isless\n\n// islessequal\n\n#ifdef islessequal\n\ntemplate <class _A1, class _A2>\n_LIBCPP_ALWAYS_INLINE\nbool\n__libcpp_islessequal(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    return islessequal(__lcpp_x, __lcpp_y);\n}\n\n#undef islessequal\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if\n<\n    std::is_arithmetic<_A1>::value &&\n    std::is_arithmetic<_A2>::value,\n    bool\n>::type\nislessequal(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    typedef typename std::__promote<_A1, _A2>::type type;\n    return __libcpp_islessequal((type)__lcpp_x, (type)__lcpp_y);\n}\n\n#endif  // islessequal\n\n// islessgreater\n\n#ifdef islessgreater\n\ntemplate <class _A1, class _A2>\n_LIBCPP_ALWAYS_INLINE\nbool\n__libcpp_islessgreater(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    return islessgreater(__lcpp_x, __lcpp_y);\n}\n\n#undef islessgreater\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if\n<\n    std::is_arithmetic<_A1>::value &&\n    std::is_arithmetic<_A2>::value,\n    bool\n>::type\nislessgreater(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    typedef typename std::__promote<_A1, _A2>::type type;\n    return __libcpp_islessgreater((type)__lcpp_x, (type)__lcpp_y);\n}\n\n#endif  // islessgreater\n\n// isunordered\n\n#ifdef isunordered\n\ntemplate <class _A1, class _A2>\n_LIBCPP_ALWAYS_INLINE\nbool\n__libcpp_isunordered(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    return isunordered(__lcpp_x, __lcpp_y);\n}\n\n#undef isunordered\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if\n<\n    std::is_arithmetic<_A1>::value &&\n    std::is_arithmetic<_A2>::value,\n    bool\n>::type\nisunordered(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    typedef typename std::__promote<_A1, _A2>::type type;\n    return __libcpp_isunordered((type)__lcpp_x, (type)__lcpp_y);\n}\n\n#endif  // isunordered\n\n// abs\n\n#if !(defined(_AIX) || defined(__sun__))\ninline _LIBCPP_INLINE_VISIBILITY\nfloat\nabs(float __lcpp_x) _NOEXCEPT {return fabsf(__lcpp_x);}\n\ninline _LIBCPP_INLINE_VISIBILITY\ndouble\nabs(double __lcpp_x) _NOEXCEPT {return fabs(__lcpp_x);}\n\ninline _LIBCPP_INLINE_VISIBILITY\nlong double\nabs(long double __lcpp_x) _NOEXCEPT {return fabsl(__lcpp_x);}\n#endif // !(defined(_AIX) || defined(__sun__))\n\n// acos\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX) || defined(__sun__))\ninline _LIBCPP_INLINE_VISIBILITY float       acos(float __lcpp_x) _NOEXCEPT       {return acosf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double acos(long double __lcpp_x) _NOEXCEPT {return acosl(__lcpp_x);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nacos(_A1 __lcpp_x) _NOEXCEPT {return acos((double)__lcpp_x);}\n\n// asin\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX) || defined(__sun__))\ninline _LIBCPP_INLINE_VISIBILITY float       asin(float __lcpp_x) _NOEXCEPT       {return asinf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double asin(long double __lcpp_x) _NOEXCEPT {return asinl(__lcpp_x);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nasin(_A1 __lcpp_x) _NOEXCEPT {return asin((double)__lcpp_x);}\n\n// atan\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX) || defined(__sun__))\ninline _LIBCPP_INLINE_VISIBILITY float       atan(float __lcpp_x) _NOEXCEPT       {return atanf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double atan(long double __lcpp_x) _NOEXCEPT {return atanl(__lcpp_x);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\natan(_A1 __lcpp_x) _NOEXCEPT {return atan((double)__lcpp_x);}\n\n// atan2\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX) || defined(__sun__))\ninline _LIBCPP_INLINE_VISIBILITY float       atan2(float __lcpp_y, float __lcpp_x) _NOEXCEPT             {return atan2f(__lcpp_y, __lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double atan2(long double __lcpp_y, long double __lcpp_x) _NOEXCEPT {return atan2l(__lcpp_y, __lcpp_x);}\n#endif\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::__lazy_enable_if\n<\n    std::is_arithmetic<_A1>::value &&\n    std::is_arithmetic<_A2>::value,\n    std::__promote<_A1, _A2>\n>::type\natan2(_A1 __lcpp_y, _A2 __lcpp_x) _NOEXCEPT\n{\n    typedef typename std::__promote<_A1, _A2>::type __result_type;\n    static_assert((!(std::is_same<_A1, __result_type>::value &&\n                     std::is_same<_A2, __result_type>::value)), \"\");\n    return atan2((__result_type)__lcpp_y, (__result_type)__lcpp_x);\n}\n\n// ceil\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX) || defined(__sun__))\ninline _LIBCPP_INLINE_VISIBILITY float       ceil(float __lcpp_x) _NOEXCEPT       {return ceilf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double ceil(long double __lcpp_x) _NOEXCEPT {return ceill(__lcpp_x);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nceil(_A1 __lcpp_x) _NOEXCEPT {return ceil((double)__lcpp_x);}\n\n// cos\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX) || defined(__sun__))\ninline _LIBCPP_INLINE_VISIBILITY float       cos(float __lcpp_x) _NOEXCEPT       {return cosf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double cos(long double __lcpp_x) _NOEXCEPT {return cosl(__lcpp_x);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\ncos(_A1 __lcpp_x) _NOEXCEPT {return cos((double)__lcpp_x);}\n\n// cosh\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX) || defined(__sun__))\ninline _LIBCPP_INLINE_VISIBILITY float       cosh(float __lcpp_x) _NOEXCEPT       {return coshf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double cosh(long double __lcpp_x) _NOEXCEPT {return coshl(__lcpp_x);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\ncosh(_A1 __lcpp_x) _NOEXCEPT {return cosh((double)__lcpp_x);}\n\n// exp\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX) || defined(__sun__))\ninline _LIBCPP_INLINE_VISIBILITY float       exp(float __lcpp_x) _NOEXCEPT       {return expf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double exp(long double __lcpp_x) _NOEXCEPT {return expl(__lcpp_x);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nexp(_A1 __lcpp_x) _NOEXCEPT {return exp((double)__lcpp_x);}\n\n// fabs\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX) || defined(__sun__))\ninline _LIBCPP_INLINE_VISIBILITY float       fabs(float __lcpp_x) _NOEXCEPT       {return fabsf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double fabs(long double __lcpp_x) _NOEXCEPT {return fabsl(__lcpp_x);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nfabs(_A1 __lcpp_x) _NOEXCEPT {return fabs((double)__lcpp_x);}\n\n// floor\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX) || defined(__sun__))\ninline _LIBCPP_INLINE_VISIBILITY float       floor(float __lcpp_x) _NOEXCEPT       {return floorf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double floor(long double __lcpp_x) _NOEXCEPT {return floorl(__lcpp_x);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nfloor(_A1 __lcpp_x) _NOEXCEPT {return floor((double)__lcpp_x);}\n\n// fmod\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX) || defined(__sun__))\ninline _LIBCPP_INLINE_VISIBILITY float       fmod(float __lcpp_x, float __lcpp_y) _NOEXCEPT             {return fmodf(__lcpp_x, __lcpp_y);}\ninline _LIBCPP_INLINE_VISIBILITY long double fmod(long double __lcpp_x, long double __lcpp_y) _NOEXCEPT {return fmodl(__lcpp_x, __lcpp_y);}\n#endif\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::__lazy_enable_if\n<\n    std::is_arithmetic<_A1>::value &&\n    std::is_arithmetic<_A2>::value,\n    std::__promote<_A1, _A2>\n>::type\nfmod(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    typedef typename std::__promote<_A1, _A2>::type __result_type;\n    static_assert((!(std::is_same<_A1, __result_type>::value &&\n                     std::is_same<_A2, __result_type>::value)), \"\");\n    return fmod((__result_type)__lcpp_x, (__result_type)__lcpp_y);\n}\n\n// frexp\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX) || defined(__sun__))\ninline _LIBCPP_INLINE_VISIBILITY float       frexp(float __lcpp_x, int* __lcpp_e) _NOEXCEPT       {return frexpf(__lcpp_x, __lcpp_e);}\ninline _LIBCPP_INLINE_VISIBILITY long double frexp(long double __lcpp_x, int* __lcpp_e) _NOEXCEPT {return frexpl(__lcpp_x, __lcpp_e);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nfrexp(_A1 __lcpp_x, int* __lcpp_e) _NOEXCEPT {return frexp((double)__lcpp_x, __lcpp_e);}\n\n// ldexp\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX) || defined(__sun__))\ninline _LIBCPP_INLINE_VISIBILITY float       ldexp(float __lcpp_x, int __lcpp_e) _NOEXCEPT       {return ldexpf(__lcpp_x, __lcpp_e);}\ninline _LIBCPP_INLINE_VISIBILITY long double ldexp(long double __lcpp_x, int __lcpp_e) _NOEXCEPT {return ldexpl(__lcpp_x, __lcpp_e);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nldexp(_A1 __lcpp_x, int __lcpp_e) _NOEXCEPT {return ldexp((double)__lcpp_x, __lcpp_e);}\n\n// log\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX) || defined(__sun__))\ninline _LIBCPP_INLINE_VISIBILITY float       log(float __lcpp_x) _NOEXCEPT       {return logf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double log(long double __lcpp_x) _NOEXCEPT {return logl(__lcpp_x);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nlog(_A1 __lcpp_x) _NOEXCEPT {return log((double)__lcpp_x);}\n\n// log10\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX) || defined(__sun__))\ninline _LIBCPP_INLINE_VISIBILITY float       log10(float __lcpp_x) _NOEXCEPT       {return log10f(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double log10(long double __lcpp_x) _NOEXCEPT {return log10l(__lcpp_x);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nlog10(_A1 __lcpp_x) _NOEXCEPT {return log10((double)__lcpp_x);}\n\n// modf\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX) || defined(__sun__))\ninline _LIBCPP_INLINE_VISIBILITY float       modf(float __lcpp_x, float* __lcpp_y) _NOEXCEPT             {return modff(__lcpp_x, __lcpp_y);}\ninline _LIBCPP_INLINE_VISIBILITY long double modf(long double __lcpp_x, long double* __lcpp_y) _NOEXCEPT {return modfl(__lcpp_x, __lcpp_y);}\n#endif\n\n// pow\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX) || defined(__sun__))\ninline _LIBCPP_INLINE_VISIBILITY float       pow(float __lcpp_x, float __lcpp_y) _NOEXCEPT             {return powf(__lcpp_x, __lcpp_y);}\ninline _LIBCPP_INLINE_VISIBILITY long double pow(long double __lcpp_x, long double __lcpp_y) _NOEXCEPT {return powl(__lcpp_x, __lcpp_y);}\n#endif\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::__lazy_enable_if\n<\n    std::is_arithmetic<_A1>::value &&\n    std::is_arithmetic<_A2>::value,\n    std::__promote<_A1, _A2>\n>::type\npow(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    typedef typename std::__promote<_A1, _A2>::type __result_type;\n    static_assert((!(std::is_same<_A1, __result_type>::value &&\n                     std::is_same<_A2, __result_type>::value)), \"\");\n    return pow((__result_type)__lcpp_x, (__result_type)__lcpp_y);\n}\n\n// sin\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX) || defined(__sun__))\ninline _LIBCPP_INLINE_VISIBILITY float       sin(float __lcpp_x) _NOEXCEPT       {return sinf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double sin(long double __lcpp_x) _NOEXCEPT {return sinl(__lcpp_x);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nsin(_A1 __lcpp_x) _NOEXCEPT {return sin((double)__lcpp_x);}\n\n// sinh\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX) || defined(__sun__))\ninline _LIBCPP_INLINE_VISIBILITY float       sinh(float __lcpp_x) _NOEXCEPT       {return sinhf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double sinh(long double __lcpp_x) _NOEXCEPT {return sinhl(__lcpp_x);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nsinh(_A1 __lcpp_x) _NOEXCEPT {return sinh((double)__lcpp_x);}\n\n// sqrt\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX) || defined(__sun__))\ninline _LIBCPP_INLINE_VISIBILITY float       sqrt(float __lcpp_x) _NOEXCEPT       {return sqrtf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double sqrt(long double __lcpp_x) _NOEXCEPT {return sqrtl(__lcpp_x);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nsqrt(_A1 __lcpp_x) _NOEXCEPT {return sqrt((double)__lcpp_x);}\n\n// tan\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX) || defined(__sun__))\ninline _LIBCPP_INLINE_VISIBILITY float       tan(float __lcpp_x) _NOEXCEPT       {return tanf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double tan(long double __lcpp_x) _NOEXCEPT {return tanl(__lcpp_x);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\ntan(_A1 __lcpp_x) _NOEXCEPT {return tan((double)__lcpp_x);}\n\n// tanh\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX) || defined(__sun__))\ninline _LIBCPP_INLINE_VISIBILITY float       tanh(float __lcpp_x) _NOEXCEPT       {return tanhf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double tanh(long double __lcpp_x) _NOEXCEPT {return tanhl(__lcpp_x);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\ntanh(_A1 __lcpp_x) _NOEXCEPT {return tanh((double)__lcpp_x);}\n\n// acosh\n\n#ifndef _LIBCPP_MSVCRT\ninline _LIBCPP_INLINE_VISIBILITY float       acosh(float __lcpp_x) _NOEXCEPT       {return acoshf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double acosh(long double __lcpp_x) _NOEXCEPT {return acoshl(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nacosh(_A1 __lcpp_x) _NOEXCEPT {return acosh((double)__lcpp_x);}\n#endif\n\n// asinh\n\n#ifndef _LIBCPP_MSVCRT\ninline _LIBCPP_INLINE_VISIBILITY float       asinh(float __lcpp_x) _NOEXCEPT       {return asinhf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double asinh(long double __lcpp_x) _NOEXCEPT {return asinhl(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nasinh(_A1 __lcpp_x) _NOEXCEPT {return asinh((double)__lcpp_x);}\n#endif\n\n// atanh\n\n#ifndef _LIBCPP_MSVCRT\ninline _LIBCPP_INLINE_VISIBILITY float       atanh(float __lcpp_x) _NOEXCEPT       {return atanhf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double atanh(long double __lcpp_x) _NOEXCEPT {return atanhl(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\natanh(_A1 __lcpp_x) _NOEXCEPT {return atanh((double)__lcpp_x);}\n#endif\n\n// cbrt\n\n#ifndef _LIBCPP_MSVCRT\ninline _LIBCPP_INLINE_VISIBILITY float       cbrt(float __lcpp_x) _NOEXCEPT       {return cbrtf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double cbrt(long double __lcpp_x) _NOEXCEPT {return cbrtl(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\ncbrt(_A1 __lcpp_x) _NOEXCEPT {return cbrt((double)__lcpp_x);}\n#endif\n\n// copysign\n\n#if !defined(_VC_CRT_MAJOR_VERSION) || (_VC_CRT_MAJOR_VERSION < 12)\ninline _LIBCPP_INLINE_VISIBILITY float copysign(float __lcpp_x,\n                                                float __lcpp_y) _NOEXCEPT {\n  return copysignf(__lcpp_x, __lcpp_y);\n}\ninline _LIBCPP_INLINE_VISIBILITY long double\ncopysign(long double __lcpp_x, long double __lcpp_y) _NOEXCEPT {\n  return copysignl(__lcpp_x, __lcpp_y);\n}\n#endif\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::__lazy_enable_if\n<\n    std::is_arithmetic<_A1>::value &&\n    std::is_arithmetic<_A2>::value,\n    std::__promote<_A1, _A2>\n>::type\ncopysign(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    typedef typename std::__promote<_A1, _A2>::type __result_type;\n    static_assert((!(std::is_same<_A1, __result_type>::value &&\n                     std::is_same<_A2, __result_type>::value)), \"\");\n    return copysign((__result_type)__lcpp_x, (__result_type)__lcpp_y);\n}\n\n#ifndef _LIBCPP_MSVCRT\n\n// erf\n\ninline _LIBCPP_INLINE_VISIBILITY float       erf(float __lcpp_x) _NOEXCEPT       {return erff(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double erf(long double __lcpp_x) _NOEXCEPT {return erfl(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nerf(_A1 __lcpp_x) _NOEXCEPT {return erf((double)__lcpp_x);}\n\n// erfc\n\ninline _LIBCPP_INLINE_VISIBILITY float       erfc(float __lcpp_x) _NOEXCEPT       {return erfcf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double erfc(long double __lcpp_x) _NOEXCEPT {return erfcl(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nerfc(_A1 __lcpp_x) _NOEXCEPT {return erfc((double)__lcpp_x);}\n\n// exp2\n\ninline _LIBCPP_INLINE_VISIBILITY float       exp2(float __lcpp_x) _NOEXCEPT       {return exp2f(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double exp2(long double __lcpp_x) _NOEXCEPT {return exp2l(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nexp2(_A1 __lcpp_x) _NOEXCEPT {return exp2((double)__lcpp_x);}\n\n// expm1\n\ninline _LIBCPP_INLINE_VISIBILITY float       expm1(float __lcpp_x) _NOEXCEPT       {return expm1f(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double expm1(long double __lcpp_x) _NOEXCEPT {return expm1l(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nexpm1(_A1 __lcpp_x) _NOEXCEPT {return expm1((double)__lcpp_x);}\n\n// fdim\n\ninline _LIBCPP_INLINE_VISIBILITY float       fdim(float __lcpp_x, float __lcpp_y) _NOEXCEPT             {return fdimf(__lcpp_x, __lcpp_y);}\ninline _LIBCPP_INLINE_VISIBILITY long double fdim(long double __lcpp_x, long double __lcpp_y) _NOEXCEPT {return fdiml(__lcpp_x, __lcpp_y);}\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::__lazy_enable_if\n<\n    std::is_arithmetic<_A1>::value &&\n    std::is_arithmetic<_A2>::value,\n    std::__promote<_A1, _A2>\n>::type\nfdim(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    typedef typename std::__promote<_A1, _A2>::type __result_type;\n    static_assert((!(std::is_same<_A1, __result_type>::value &&\n                     std::is_same<_A2, __result_type>::value)), \"\");\n    return fdim((__result_type)__lcpp_x, (__result_type)__lcpp_y);\n}\n\n// fma\n\ninline _LIBCPP_INLINE_VISIBILITY float       fma(float __lcpp_x, float __lcpp_y, float __lcpp_z) _NOEXCEPT                   {return fmaf(__lcpp_x, __lcpp_y, __lcpp_z);}\ninline _LIBCPP_INLINE_VISIBILITY long double fma(long double __lcpp_x, long double __lcpp_y, long double __lcpp_z) _NOEXCEPT {return fmal(__lcpp_x, __lcpp_y, __lcpp_z);}\n\ntemplate <class _A1, class _A2, class _A3>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::__lazy_enable_if\n<\n    std::is_arithmetic<_A1>::value &&\n    std::is_arithmetic<_A2>::value &&\n    std::is_arithmetic<_A3>::value,\n    std::__promote<_A1, _A2, _A3>\n>::type\nfma(_A1 __lcpp_x, _A2 __lcpp_y, _A3 __lcpp_z) _NOEXCEPT\n{\n    typedef typename std::__promote<_A1, _A2, _A3>::type __result_type;\n    static_assert((!(std::is_same<_A1, __result_type>::value &&\n                     std::is_same<_A2, __result_type>::value &&\n                     std::is_same<_A3, __result_type>::value)), \"\");\n    return fma((__result_type)__lcpp_x, (__result_type)__lcpp_y, (__result_type)__lcpp_z);\n}\n\n// fmax\n\ninline _LIBCPP_INLINE_VISIBILITY float       fmax(float __lcpp_x, float __lcpp_y) _NOEXCEPT             {return fmaxf(__lcpp_x, __lcpp_y);}\ninline _LIBCPP_INLINE_VISIBILITY long double fmax(long double __lcpp_x, long double __lcpp_y) _NOEXCEPT {return fmaxl(__lcpp_x, __lcpp_y);}\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::__lazy_enable_if\n<\n    std::is_arithmetic<_A1>::value &&\n    std::is_arithmetic<_A2>::value,\n    std::__promote<_A1, _A2>\n>::type\nfmax(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    typedef typename std::__promote<_A1, _A2>::type __result_type;\n    static_assert((!(std::is_same<_A1, __result_type>::value &&\n                     std::is_same<_A2, __result_type>::value)), \"\");\n    return fmax((__result_type)__lcpp_x, (__result_type)__lcpp_y);\n}\n\n// fmin\n\ninline _LIBCPP_INLINE_VISIBILITY float       fmin(float __lcpp_x, float __lcpp_y) _NOEXCEPT             {return fminf(__lcpp_x, __lcpp_y);}\ninline _LIBCPP_INLINE_VISIBILITY long double fmin(long double __lcpp_x, long double __lcpp_y) _NOEXCEPT {return fminl(__lcpp_x, __lcpp_y);}\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::__lazy_enable_if\n<\n    std::is_arithmetic<_A1>::value &&\n    std::is_arithmetic<_A2>::value,\n    std::__promote<_A1, _A2>\n>::type\nfmin(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    typedef typename std::__promote<_A1, _A2>::type __result_type;\n    static_assert((!(std::is_same<_A1, __result_type>::value &&\n                     std::is_same<_A2, __result_type>::value)), \"\");\n    return fmin((__result_type)__lcpp_x, (__result_type)__lcpp_y);\n}\n\n// hypot\n\ninline _LIBCPP_INLINE_VISIBILITY float       hypot(float __lcpp_x, float __lcpp_y) _NOEXCEPT             {return hypotf(__lcpp_x, __lcpp_y);}\ninline _LIBCPP_INLINE_VISIBILITY long double hypot(long double __lcpp_x, long double __lcpp_y) _NOEXCEPT {return hypotl(__lcpp_x, __lcpp_y);}\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::__lazy_enable_if\n<\n    std::is_arithmetic<_A1>::value &&\n    std::is_arithmetic<_A2>::value,\n    std::__promote<_A1, _A2>\n>::type\nhypot(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    typedef typename std::__promote<_A1, _A2>::type __result_type;\n    static_assert((!(std::is_same<_A1, __result_type>::value &&\n                     std::is_same<_A2, __result_type>::value)), \"\");\n    return hypot((__result_type)__lcpp_x, (__result_type)__lcpp_y);\n}\n\n// ilogb\n\ninline _LIBCPP_INLINE_VISIBILITY int ilogb(float __lcpp_x) _NOEXCEPT       {return ilogbf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY int ilogb(long double __lcpp_x) _NOEXCEPT {return ilogbl(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, int>::type\nilogb(_A1 __lcpp_x) _NOEXCEPT {return ilogb((double)__lcpp_x);}\n\n// lgamma\n\ninline _LIBCPP_INLINE_VISIBILITY float       lgamma(float __lcpp_x) _NOEXCEPT       {return lgammaf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double lgamma(long double __lcpp_x) _NOEXCEPT {return lgammal(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nlgamma(_A1 __lcpp_x) _NOEXCEPT {return lgamma((double)__lcpp_x);}\n\n// llrint\n\ninline _LIBCPP_INLINE_VISIBILITY long long llrint(float __lcpp_x) _NOEXCEPT       {return llrintf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long long llrint(long double __lcpp_x) _NOEXCEPT {return llrintl(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, long long>::type\nllrint(_A1 __lcpp_x) _NOEXCEPT {return llrint((double)__lcpp_x);}\n\n// llround\n\ninline _LIBCPP_INLINE_VISIBILITY long long llround(float __lcpp_x) _NOEXCEPT       {return llroundf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long long llround(long double __lcpp_x) _NOEXCEPT {return llroundl(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, long long>::type\nllround(_A1 __lcpp_x) _NOEXCEPT {return llround((double)__lcpp_x);}\n\n// log1p\n\ninline _LIBCPP_INLINE_VISIBILITY float       log1p(float __lcpp_x) _NOEXCEPT       {return log1pf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double log1p(long double __lcpp_x) _NOEXCEPT {return log1pl(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nlog1p(_A1 __lcpp_x) _NOEXCEPT {return log1p((double)__lcpp_x);}\n\n// log2\n\ninline _LIBCPP_INLINE_VISIBILITY float       log2(float __lcpp_x) _NOEXCEPT       {return log2f(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double log2(long double __lcpp_x) _NOEXCEPT {return log2l(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nlog2(_A1 __lcpp_x) _NOEXCEPT {return log2((double)__lcpp_x);}\n\n// logb\n\ninline _LIBCPP_INLINE_VISIBILITY float       logb(float __lcpp_x) _NOEXCEPT       {return logbf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double logb(long double __lcpp_x) _NOEXCEPT {return logbl(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nlogb(_A1 __lcpp_x) _NOEXCEPT {return logb((double)__lcpp_x);}\n\n// lrint\n\ninline _LIBCPP_INLINE_VISIBILITY long lrint(float __lcpp_x) _NOEXCEPT       {return lrintf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long lrint(long double __lcpp_x) _NOEXCEPT {return lrintl(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, long>::type\nlrint(_A1 __lcpp_x) _NOEXCEPT {return lrint((double)__lcpp_x);}\n\n// lround\n\ninline _LIBCPP_INLINE_VISIBILITY long lround(float __lcpp_x) _NOEXCEPT       {return lroundf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long lround(long double __lcpp_x) _NOEXCEPT {return lroundl(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, long>::type\nlround(_A1 __lcpp_x) _NOEXCEPT {return lround((double)__lcpp_x);}\n\n// nan\n\n// nearbyint\n\ninline _LIBCPP_INLINE_VISIBILITY float       nearbyint(float __lcpp_x) _NOEXCEPT       {return nearbyintf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double nearbyint(long double __lcpp_x) _NOEXCEPT {return nearbyintl(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nnearbyint(_A1 __lcpp_x) _NOEXCEPT {return nearbyint((double)__lcpp_x);}\n\n// nextafter\n\ninline _LIBCPP_INLINE_VISIBILITY float       nextafter(float __lcpp_x, float __lcpp_y) _NOEXCEPT             {return nextafterf(__lcpp_x, __lcpp_y);}\ninline _LIBCPP_INLINE_VISIBILITY long double nextafter(long double __lcpp_x, long double __lcpp_y) _NOEXCEPT {return nextafterl(__lcpp_x, __lcpp_y);}\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::__lazy_enable_if\n<\n    std::is_arithmetic<_A1>::value &&\n    std::is_arithmetic<_A2>::value,\n    std::__promote<_A1, _A2>\n>::type\nnextafter(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    typedef typename std::__promote<_A1, _A2>::type __result_type;\n    static_assert((!(std::is_same<_A1, __result_type>::value &&\n                     std::is_same<_A2, __result_type>::value)), \"\");\n    return nextafter((__result_type)__lcpp_x, (__result_type)__lcpp_y);\n}\n\n// nexttoward\n\ninline _LIBCPP_INLINE_VISIBILITY float       nexttoward(float __lcpp_x, long double __lcpp_y) _NOEXCEPT       {return nexttowardf(__lcpp_x, __lcpp_y);}\ninline _LIBCPP_INLINE_VISIBILITY long double nexttoward(long double __lcpp_x, long double __lcpp_y) _NOEXCEPT {return nexttowardl(__lcpp_x, __lcpp_y);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nnexttoward(_A1 __lcpp_x, long double __lcpp_y) _NOEXCEPT {return nexttoward((double)__lcpp_x, __lcpp_y);}\n\n// remainder\n\ninline _LIBCPP_INLINE_VISIBILITY float       remainder(float __lcpp_x, float __lcpp_y) _NOEXCEPT             {return remainderf(__lcpp_x, __lcpp_y);}\ninline _LIBCPP_INLINE_VISIBILITY long double remainder(long double __lcpp_x, long double __lcpp_y) _NOEXCEPT {return remainderl(__lcpp_x, __lcpp_y);}\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::__lazy_enable_if\n<\n    std::is_arithmetic<_A1>::value &&\n    std::is_arithmetic<_A2>::value,\n    std::__promote<_A1, _A2>\n>::type\nremainder(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    typedef typename std::__promote<_A1, _A2>::type __result_type;\n    static_assert((!(std::is_same<_A1, __result_type>::value &&\n                     std::is_same<_A2, __result_type>::value)), \"\");\n    return remainder((__result_type)__lcpp_x, (__result_type)__lcpp_y);\n}\n\n// remquo\n\ninline _LIBCPP_INLINE_VISIBILITY float       remquo(float __lcpp_x, float __lcpp_y, int* __lcpp_z) _NOEXCEPT             {return remquof(__lcpp_x, __lcpp_y, __lcpp_z);}\ninline _LIBCPP_INLINE_VISIBILITY long double remquo(long double __lcpp_x, long double __lcpp_y, int* __lcpp_z) _NOEXCEPT {return remquol(__lcpp_x, __lcpp_y, __lcpp_z);}\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::__lazy_enable_if\n<\n    std::is_arithmetic<_A1>::value &&\n    std::is_arithmetic<_A2>::value,\n    std::__promote<_A1, _A2>\n>::type\nremquo(_A1 __lcpp_x, _A2 __lcpp_y, int* __lcpp_z) _NOEXCEPT\n{\n    typedef typename std::__promote<_A1, _A2>::type __result_type;\n    static_assert((!(std::is_same<_A1, __result_type>::value &&\n                     std::is_same<_A2, __result_type>::value)), \"\");\n    return remquo((__result_type)__lcpp_x, (__result_type)__lcpp_y, __lcpp_z);\n}\n\n// rint\n\ninline _LIBCPP_INLINE_VISIBILITY float       rint(float __lcpp_x) _NOEXCEPT       {return rintf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double rint(long double __lcpp_x) _NOEXCEPT {return rintl(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nrint(_A1 __lcpp_x) _NOEXCEPT {return rint((double)__lcpp_x);}\n\n// round\n\ninline _LIBCPP_INLINE_VISIBILITY float       round(float __lcpp_x) _NOEXCEPT       {return roundf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double round(long double __lcpp_x) _NOEXCEPT {return roundl(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nround(_A1 __lcpp_x) _NOEXCEPT {return round((double)__lcpp_x);}\n\n// scalbln\n\ninline _LIBCPP_INLINE_VISIBILITY float       scalbln(float __lcpp_x, long __lcpp_y) _NOEXCEPT       {return scalblnf(__lcpp_x, __lcpp_y);}\ninline _LIBCPP_INLINE_VISIBILITY long double scalbln(long double __lcpp_x, long __lcpp_y) _NOEXCEPT {return scalblnl(__lcpp_x, __lcpp_y);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nscalbln(_A1 __lcpp_x, long __lcpp_y) _NOEXCEPT {return scalbln((double)__lcpp_x, __lcpp_y);}\n\n// scalbn\n\ninline _LIBCPP_INLINE_VISIBILITY float       scalbn(float __lcpp_x, int __lcpp_y) _NOEXCEPT       {return scalbnf(__lcpp_x, __lcpp_y);}\ninline _LIBCPP_INLINE_VISIBILITY long double scalbn(long double __lcpp_x, int __lcpp_y) _NOEXCEPT {return scalbnl(__lcpp_x, __lcpp_y);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nscalbn(_A1 __lcpp_x, int __lcpp_y) _NOEXCEPT {return scalbn((double)__lcpp_x, __lcpp_y);}\n\n// tgamma\n\ninline _LIBCPP_INLINE_VISIBILITY float       tgamma(float __lcpp_x) _NOEXCEPT       {return tgammaf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double tgamma(long double __lcpp_x) _NOEXCEPT {return tgammal(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\ntgamma(_A1 __lcpp_x) _NOEXCEPT {return tgamma((double)__lcpp_x);}\n\n// trunc\n\ninline _LIBCPP_INLINE_VISIBILITY float       trunc(float __lcpp_x) _NOEXCEPT       {return truncf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double trunc(long double __lcpp_x) _NOEXCEPT {return truncl(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\ntrunc(_A1 __lcpp_x) _NOEXCEPT {return trunc((double)__lcpp_x);}\n\n#endif // !_LIBCPP_MSVCRT\n\n} // extern \"C++\"\n\n#endif // __cplusplus\n\n#endif  // _LIBCPP_MATH_H\n","//\n//  math_utils.h\n//  ARToolKit5\n//\n//  This file is part of ARToolKit.\n//\n//  ARToolKit is free software: you can redistribute it and/or modify\n//  it under the terms of the GNU Lesser General Public License as published by\n//  the Free Software Foundation, either version 3 of the License, or\n//  (at your option) any later version.\n//\n//  ARToolKit is distributed in the hope that it will be useful,\n//  but WITHOUT ANY WARRANTY; without even the implied warranty of\n//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n//  GNU Lesser General Public License for more details.\n//\n//  You should have received a copy of the GNU Lesser General Public License\n//  along with ARToolKit.  If not, see <http://www.gnu.org/licenses/>.\n//\n//  As a special exception, the copyright holders of this library give you\n//  permission to link this library with independent modules to produce an\n//  executable, regardless of the license terms of these independent modules, and to\n//  copy and distribute the resulting executable under terms of your choice,\n//  provided that you also meet, for each linked independent module, the terms and\n//  conditions of the license of that module. An independent module is a module\n//  which is neither derived from nor based on this library. If you modify this\n//  library, you may extend this exception to your version of the library, but you\n//  are not obligated to do so. If you do not wish to do so, delete this exception\n//  statement from your version.\n//\n//  Copyright 2013-2015 Daqri, LLC.\n//\n//  Author(s): Chris Broaddus\n//\n\n#pragma once\n\n#include <cmath>\n\nnamespace vision {\n    \n#define PI                  3.1415926535897932384626433832795\n#define ONE_OVER_2PI        0.159154943091895\n#define SQRT2               1.41421356237309504880\n    \n    /**\n     * @return x*x\n     */\n    template<typename T>\n    inline T sqr(T x) { return x*x; }\n    \n    /**\n     * @return nearest rounding of x\n     */\n    template<typename T>\n    inline T round(T x) { return std::floor((x+(T)0.5)); }\n    \n    /**\n     * Base 2 log\n     */\n    template<typename T>\n    inline T log2(T x) {\n        return std::log(x) / std::log((T)2);\n    }\n    \n    /**\n     * Base \"b\" log\n     */\n    template<typename T>\n    inline T logb(T x, T b) {\n        return std::log(x) / std::log(b);\n    }\n    \n    /**\n     * Safe reciprical (1/x).\n     */\n    template<typename T>\n    inline T SafeReciprical(T x) {\n        return 1/(x == 0 ? 1 : x);\n    }\n    \n    /**\n     * Safe division (x/y).\n     */\n    template<typename T>\n    inline T SafeDivision(T x, T y) {\n        return x/(y == 0 ? 1 : y);\n    }\n    \n    /**\n     * Fast atan2 [-pi,pi]\n     */\n    inline float fastatan2(float y, float x) {\n        float angle, r;\n        float abs_y = std::abs(y)+1e-7;\n        \n        if(x == 0 && y == 0) {\n            return 0;\n        }\n        else if(x > 0) {\n            r = (x - abs_y) / (x + abs_y);\n            angle = PI/4;\n        }\n        else {\n            r = (x + abs_y) / (abs_y - x);\n            angle = 3*PI/4;\n        }\n        \n        angle += (0.1821f*r*r - 0.9675f)*r;\n        return (y < 0) ? - angle : angle;\n    }\n    \n    /**\n     * Fast atan2 in range [0,360]\n     */\n    inline float fastatan2_360(float y, float x) {\n        float angle, r;\n        float abs_y = std::abs(y)+1e-7;\n        \n        if(x == 0 && y == 0) {\n            return 0;\n        }\n        else if(x > 0) {\n            r = (x - abs_y) / (x + abs_y);\n            angle = PI/4;\n        }\n        else {\n            r = (x + abs_y) / (abs_y - x);\n            angle = 3*PI/4;\n        }\n        \n        angle += (0.1821f*r*r - 0.9675f)*r;\n        \n        return angle;\n    }\n    \n    /**\n     * Fast square-root. \n     *\n     * http://en.wikipedia.org/wiki/Fast_inverse_square_root\n     */\n    inline float fastsqrt1(float x) {\n        union {\n            float x;\n            int  i;\n        } u;\n        \n        float xhalf = 0.5f*x;\n        \n        // Cast FLOAT to INT\n        u.x = (int)x;\n        \n        // Initial guess\n        u.i = 0x5f3759df - (u.i >> 1);\n        \n        // Newton iteration\n        u.x = u.x * (1.5f - xhalf*u.x*u.x);\n        \n        return x*u.x;\n    }\n    \n    //////////////////////////////////////////////////////////////////////////////////////////\n    //\n    // Fast exponential functions.\n    //\n    //////////////////////////////////////////////////////////////////////////////////////////\n    \n    /**\n     * 0.01% error at 1.030\n     * 0.10% error at 1.520\n     * 1.00% error at 2.330\n     * 5.00% error at 3.285\n     */\n    template<typename T>\n    inline T fastexp6(T x) {\n        return (720+x*(720+x*(360+x*(120+x*(30+x*(6+x))))))*0.0013888888;\n    }\n\n    /**\n     * Clip a scalar to be within a range.\n     */\n    template<typename T>\n    inline T ClipScalar(T x, T min, T max) {\n        if(x < min) {\n            x = min;\n        } else if(x > max) {\n            x = max;\n        }\n        return x;\n    }\n    \n    template<typename T>\n    inline T deg2rad(T deg) {\n        return deg*(PI/180);\n    }\n\n} // vision","//\n//  gaussian_scale_space_pyramid.cpp\n//  ARToolKit5\n//\n//  This file is part of ARToolKit.\n//\n//  ARToolKit is free software: you can redistribute it and/or modify\n//  it under the terms of the GNU Lesser General Public License as published by\n//  the Free Software Foundation, either version 3 of the License, or\n//  (at your option) any later version.\n//\n//  ARToolKit is distributed in the hope that it will be useful,\n//  but WITHOUT ANY WARRANTY; without even the implied warranty of\n//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n//  GNU Lesser General Public License for more details.\n//\n//  You should have received a copy of the GNU Lesser General Public License\n//  along with ARToolKit.  If not, see <http://www.gnu.org/licenses/>.\n//\n//  As a special exception, the copyright holders of this library give you\n//  permission to link this library with independent modules to produce an\n//  executable, regardless of the license terms of these independent modules, and to\n//  copy and distribute the resulting executable under terms of your choice,\n//  provided that you also meet, for each linked independent module, the terms and\n//  conditions of the license of that module. An independent module is a module\n//  which is neither derived from nor based on this library. If you modify this\n//  library, you may extend this exception to your version of the library, but you\n//  are not obligated to do so. If you do not wish to do so, delete this exception\n//  statement from your version.\n//\n//  Copyright 2013-2015 Daqri, LLC.\n//\n//  Author(s): Chris Broaddus\n//\n\n#include \"gaussian_scale_space_pyramid.h\"\n#include <framework/error.h>\n//#include <framework/logger.h>\n\nusing namespace vision;\n\nnamespace vision {\n\n    void binomial_4th_order(float* dst,\n                            unsigned short* tmp,\n                            const unsigned char* src,\n                            size_t width,\n                            size_t height) {\n        unsigned short* tmp_ptr;\n        float* dst_ptr;\n        \n        size_t width_minus_1, width_minus_2;\n        size_t height_minus_2;\n        \n        ASSERT(width >= 5, \"Image is too small\");\n        ASSERT(height >= 5, \"Image is too small\");\n        \n        width_minus_1 = width-1;\n        width_minus_2 = width-2;\n        height_minus_2 = height-2;\n        \n        tmp_ptr = tmp;\n        \n        // Apply horizontal filter\n        for(size_t row = 0; row < height; row++) {\n            const unsigned char* src_ptr = &src[row*width];\n            \n            // Left border is computed by extending the border pixel beyond the image\n            *(tmp_ptr++) = ((src_ptr[0]<<1)+(src_ptr[0]<<2)) + ((src_ptr[0]+src_ptr[1])<<2) + (src_ptr[0]+src_ptr[2]);\n            *(tmp_ptr++) = ((src_ptr[1]<<1)+(src_ptr[1]<<2)) + ((src_ptr[0]+src_ptr[2])<<2) + (src_ptr[0]+src_ptr[3]);\n            \n            // Compute non-border pixels\n            for(size_t col = 2; col < width_minus_2; col++, tmp_ptr++) {\n                *tmp_ptr = ((src_ptr[col]<<1)+(src_ptr[col]<<2)) + ((src_ptr[col-1]+src_ptr[col+1])<<2) + (src_ptr[col-2]+src_ptr[col+2]);\n            }\n            \n            // Right border. Computed similarily as the left border.\n            *(tmp_ptr++) = ((src_ptr[width_minus_2]<<1)+(src_ptr[width_minus_2]<<2)) + ((src_ptr[width_minus_2-1]+src_ptr[width_minus_2+1])<<2) + (src_ptr[width_minus_2-2]+src_ptr[width_minus_2+1]);\n            *(tmp_ptr++) = ((src_ptr[width_minus_1]<<1)+(src_ptr[width_minus_1]<<2)) + ((src_ptr[width_minus_1-1]+src_ptr[width_minus_1])<<2)   + (src_ptr[width_minus_1-2]+src_ptr[width_minus_1]);\n        }\n        \n        const unsigned short* pm2;\n        const unsigned short* pm1;\n        const unsigned short* p;\n        const unsigned short* pp1;\n        const unsigned short* pp2;\n        \n        // Apply vertical filter along top border. This is applied twice as there are two\n        // border pixels.\n        pm2     = tmp;\n        pm1     = tmp;\n        p       = tmp;\n        pp1     = p+width;\n        pp2     = pp1+width;\n        dst_ptr = dst;\n        \n        for(size_t col = 0; col < width; col++, dst_ptr++, pm2++, pm1++, p++, pp1++, pp2++) {\n            *dst_ptr = (((*p<<1)+(*p<<2)) + ((*pm1+*pp1)<<2) + (*pm2+*pp2))*(1.f/256.f);\n        }\n        \n        pm2     = tmp;\n        pm1     = tmp;\n        p       = tmp+width;\n        pp1     = p+width;\n        pp2     = pp1+width;\n        dst_ptr = dst+width;\n        \n        for(size_t col = 0; col < width; col++, dst_ptr++, pm2++, pm1++, p++, pp1++, pp2++) {\n            *dst_ptr = (((*p<<1)+(*p<<2)) + ((*pm1+*pp1)<<2) + (*pm2+*pp2))*(1.f/256.f);\n        }\n        \n        // Apply vertical filter for non-border pixels.\n        pm2 = tmp;\n        pm1 = pm2+width;\n        p   = pm1+width;\n        pp1 = p+width;\n        pp2 = pp1+width;\n        \n        for(size_t row = 2; row < height_minus_2; row++) {\n            pm2 = &tmp[(row-2)*width];\n            pm1 = pm2+width;\n            p   = pm1+width;\n            pp1 = p+width;\n            pp2 = pp1+width;\n            \n            dst_ptr = &dst[row*width];\n            \n            for(size_t col = 0; col < width; col++, dst_ptr++, pm2++, pm1++, p++, pp1++, pp2++) {\n                *dst_ptr = (((*p<<1)+(*p<<2)) + ((*pm1+*pp1)<<2) + (*pm2+*pp2))*(1.f/256.f);\n            }\n        }\n        \n        // Apply vertical filter for bottom border. Similar to top border.\n        pm2     = tmp+(height-4)*width;\n        pm1     = pm2+width;\n        p       = pm1+width;\n        pp1     = p+width;\n        pp2     = pp1;\n        dst_ptr = dst+(height-2)*width;\n        \n        for(size_t col = 0; col < width; col++, dst_ptr++, pm2++, pm1++, p++, pp1++, pp2++) {\n            *dst_ptr = (((*p<<1)+(*p<<2)) + ((*pm1+*pp1)<<2) + (*pm2+*pp2))*(1.f/256.f);\n        }\n        \n        pm2     = tmp+(height-3)*width;\n        pm1     = pm2+width;\n        p       = pm1+width;\n        pp1     = p;\n        pp2     = p;\n        dst_ptr = dst+(height-1)*width;\n        \n        for(size_t col = 0; col < width; col++, dst_ptr++, pm2++, pm1++, p++, pp1++, pp2++) {\n            *dst_ptr = (((*p<<1)+(*p<<2)) + ((*pm1+*pp1)<<2) + (*pm2+*pp2))*(1.f/256.f);\n        }\n    }\n    \n    void binomial_4th_order(float* dst,\n                            float* tmp,\n                            const float* src,\n                            size_t width,\n                            size_t height) {\n        float* tmp_ptr;\n        float* dst_ptr;\n        \n        size_t width_minus_1, width_minus_2;\n        size_t height_minus_2;\n        \n        ASSERT(width >= 5, \"Image is too small\");\n        ASSERT(height >= 5, \"Image is too small\");\n        \n        width_minus_1 = width-1;\n        width_minus_2 = width-2;\n        height_minus_2 = height-2;\n        \n        tmp_ptr = tmp;\n        \n        // Apply horizontal filter\n        for(size_t row = 0; row < height; row++) {\n            const float* src_ptr = &src[row*width];\n            \n            // Left border is computed by extending the border pixel beyond the image\n            *(tmp_ptr++) = 6.f*src_ptr[0] + 4.f*(src_ptr[0]+src_ptr[1]) + src_ptr[0] + src_ptr[2];\n            *(tmp_ptr++) = 6.f*src_ptr[1] + 4.f*(src_ptr[0]+src_ptr[2]) + src_ptr[0] + src_ptr[3];\n            \n            // Compute non-border pixels\n            for(size_t col = 2; col < width_minus_2; col++, tmp_ptr++) {\n                *tmp_ptr = (6.f*src_ptr[col] + 4.f*(src_ptr[col-1]+src_ptr[col+1]) + src_ptr[col-2] + src_ptr[col+2]);\n            }\n            \n            // Right border. Computed similarily as the left border.\n            *(tmp_ptr++) = 6.f*src_ptr[width_minus_2] + 4.f*(src_ptr[width_minus_2-1]+src_ptr[width_minus_2+1]) + src_ptr[width_minus_2-2] + src_ptr[width_minus_2+1];\n            *(tmp_ptr++) = 6.f*src_ptr[width_minus_1] + 4.f*(src_ptr[width_minus_1-1]+src_ptr[width_minus_1])   + src_ptr[width_minus_1-2] + src_ptr[width_minus_1];\n        }\n        \n        const float* pm2;\n        const float* pm1;\n        const float* p;\n        const float* pp1;\n        const float* pp2;\n        \n        // Apply vertical filter along top border. This is applied twice as there are two\n        // border pixels.\n        pm2     = tmp;\n        pm1     = tmp;\n        p       = tmp;\n        pp1     = p+width;\n        pp2     = pp1+width;\n        dst_ptr = dst;\n        \n        for(size_t col = 0; col < width; col++, dst_ptr++, pm2++, pm1++, p++, pp1++, pp2++) {\n            *dst_ptr = (6.f*(*p) + 4.f*(*pm1+*pp1) + (*pm2) + (*pp2))*(1.f/256.f);;\n        }\n        \n        pm2     = tmp;\n        pm1     = tmp;\n        p       = tmp+width;\n        pp1     = p+width;\n        pp2     = pp1+width;\n        dst_ptr = dst+width;\n        \n        for(size_t col = 0; col < width; col++, dst_ptr++, pm2++, pm1++, p++, pp1++, pp2++) {\n            *dst_ptr = (6.f*(*p) + 4.f*(*pm1+*pp1) + (*pm2) + (*pp2))*(1.f/256.f);;\n        }\n        \n        // Apply vertical filter for non-border pixels.\n        for(size_t row = 2; row < height_minus_2; row++) {\n            pm2 = &tmp[(row-2)*width];\n            pm1 = pm2+width;\n            p   = pm1+width;\n            pp1 = p+width;\n            pp2 = pp1+width;\n            \n            dst_ptr = &dst[row*width];\n            \n            for(size_t col = 0; col < width; col++, dst_ptr++, pm2++, pm1++, p++, pp1++, pp2++) {\n                *dst_ptr = (6.f*(*p) + 4.f*(*pm1+*pp1) + (*pm2) + (*pp2))*(1.f/256.f);;\n            }\n        }\n        \n        // Apply vertical filter for bottom border. Similar to top border.\n        pm2     = tmp+(height-4)*width;\n        pm1     = pm2+width;\n        p       = pm1+width;\n        pp1     = p+width;\n        pp2     = pp1;\n        dst_ptr = dst+(height-2)*width;\n        \n        for(size_t col = 0; col < width; col++, dst_ptr++, pm2++, pm1++, p++, pp1++, pp2++) {\n            *dst_ptr = (6.f*(*p) + 4.f*(*pm1+*pp1) + (*pm2) + (*pp2))*(1.f/256.f);;\n        }\n        \n        pm2     = tmp+(height-3)*width;\n        pm1     = pm2+width;\n        p       = pm1+width;\n        pp1     = p;\n        pp2     = p;\n        dst_ptr = dst+(height-1)*width;\n        \n        for(size_t col = 0; col < width; col++, dst_ptr++, pm2++, pm1++, p++, pp1++, pp2++) {\n            *dst_ptr = (6.f*(*p) + 4.f*(*pm1+*pp1) + (*pm2) + (*pp2))*(1.f/256.f);;\n        }\n    }\n    \n    void downsample_bilinear(float* dst, const float* src, size_t src_width, size_t src_height) {\n        size_t dst_width;\n        size_t dst_height;\n        const float* src_ptr1;\n        const float* src_ptr2;\n        \n        dst_width = src_width>>1;\n        dst_height = src_height>>1;\n        \n        for(size_t row = 0; row < dst_height; row++) {\n            src_ptr1 = &src[(row<<1)*src_width];\n            src_ptr2 = src_ptr1 + src_width;\n            for(size_t col = 0; col < dst_width; col++, src_ptr1+=2, src_ptr2+=2) {\n                *(dst++) = (src_ptr1[0]+src_ptr1[1]+src_ptr2[0]+src_ptr2[1])*0.25f;\n            }\n        }\n    }\n    \n}\n\nGaussianScaleSpacePyramid::GaussianScaleSpacePyramid()\n: mNumOctaves(0)\n, mNumScalesPerOctave(0)\n, mK(0)\n, mOneOverLogK(0)\n{}\n\nvoid GaussianScaleSpacePyramid::configure(int num_octaves, int num_scales_per_octaves) {\n    mNumOctaves = num_octaves;\n    mNumScalesPerOctave = num_scales_per_octaves;\n    mK = std::pow(2.f, 1.f/(mNumScalesPerOctave-1));\n    mOneOverLogK = 1.f/std::log(mK);\n}\n\nBinomialPyramid32f::BinomialPyramid32f() {\n}\n\nBinomialPyramid32f::~BinomialPyramid32f()\n{}\n\nvoid BinomialPyramid32f::alloc(size_t width,\n                               size_t height,\n                               int num_octaves) {\n    //LOG_DEBUG(\"Binomial pyramid allocating memory for: w = %u, h = %u, levels = %u\",              width, height, num_octaves);\n    \n    GaussianScaleSpacePyramid::configure(num_octaves, 3);\n    \n    // Allocate the pyramid memory\n    mPyramid.resize(num_octaves*mNumScalesPerOctave);\n    for(int i = 0; i < num_octaves; i++) {\n        for(size_t j = 0; j < mNumScalesPerOctave; j++) {\n            mPyramid[i*mNumScalesPerOctave+j].alloc(IMAGE_F32, width>>i, height>>i, AUTO_STEP, 1);\n        }\n    }\n    \n    mTemp_us16.resize(width*height);\n    mTemp_f32_1.resize(width*height);\n    mTemp_f32_2.resize(width*height);\n    \n}\n\nvoid BinomialPyramid32f::release() {\n    mPyramid.clear();\n}\n\nvoid BinomialPyramid32f::build(const Image& image) {\n    ASSERT(image.type() == IMAGE_UINT8, \"Image must be grayscale\");\n    ASSERT(image.channels() == 1, \"Image must have 1 channel\");\n    \n    ASSERT(mPyramid.size() == mNumOctaves*mNumScalesPerOctave, \"Pyramid has not been allocated yet\");\n    ASSERT(image.width() == mPyramid[0].width(), \"Image of wrong size for pyramid\");\n    ASSERT(image.height() == mPyramid[0].height(), \"Image of wrong size for pyramid\");\n    \n    // First octave\n    apply_filter(mPyramid[0], image);\n    apply_filter(mPyramid[1], mPyramid[0]);\n    apply_filter_twice(mPyramid[2], mPyramid[1]);\n    \n    // Remaining octaves\n    for(size_t i = 1; i < mNumOctaves; i++) {\n        // Downsample\n        downsample_bilinear((float*)mPyramid[i*mNumScalesPerOctave].get(),\n                            (const float*)mPyramid[i*mNumScalesPerOctave-1].get(),\n                            mPyramid[i*mNumScalesPerOctave-1].width(),\n                            mPyramid[i*mNumScalesPerOctave-1].height());\n        \n        // Apply binomial filters\n        apply_filter(mPyramid[i*mNumScalesPerOctave+1], mPyramid[i*mNumScalesPerOctave]);\n        apply_filter_twice(mPyramid[i*mNumScalesPerOctave+2], mPyramid[i*mNumScalesPerOctave+1]);\n    }\n}\n\nvoid BinomialPyramid32f::apply_filter(Image& dst, const Image& src) {\n    ASSERT(dst.type() == IMAGE_F32, \"Destination image should be a float\");\n    \n    switch(src.type()) {\n        case IMAGE_UINT8:\n            binomial_4th_order((float*)dst.get(),\n                               &mTemp_us16[0],\n                               (const unsigned char*)src.get(),\n                               src.width(),\n                               src.height());\n            break;\n        case IMAGE_F32:\n            binomial_4th_order((float*)dst.get(),\n                               &mTemp_f32_1[0],\n                               (const float*)src.get(),\n                               src.width(),\n                               src.height());\n            break;\n        case IMAGE_UNKNOWN:\n            throw EXCEPTION(\"Unknown image type\");\n        default:\n            throw EXCEPTION(\"Unsupported image type\");\n    }\n}\n\nvoid BinomialPyramid32f::apply_filter_twice(Image& dst, const Image& src) {\n    Image tmp((unsigned char*)&mTemp_f32_2[0], src.type(), src.width(), src.height(), (int)src.step(), 1);\n    apply_filter(tmp, src);\n    apply_filter(dst, tmp);\n}\n","//\n//  gaussian_scale_space_pyramid.h\n//  ARToolKit5\n//\n//  This file is part of ARToolKit.\n//\n//  ARToolKit is free software: you can redistribute it and/or modify\n//  it under the terms of the GNU Lesser General Public License as published by\n//  the Free Software Foundation, either version 3 of the License, or\n//  (at your option) any later version.\n//\n//  ARToolKit is distributed in the hope that it will be useful,\n//  but WITHOUT ANY WARRANTY; without even the implied warranty of\n//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n//  GNU Lesser General Public License for more details.\n//\n//  You should have received a copy of the GNU Lesser General Public License\n//  along with ARToolKit.  If not, see <http://www.gnu.org/licenses/>.\n//\n//  As a special exception, the copyright holders of this library give you\n//  permission to link this library with independent modules to produce an\n//  executable, regardless of the license terms of these independent modules, and to\n//  copy and distribute the resulting executable under terms of your choice,\n//  provided that you also meet, for each linked independent module, the terms and\n//  conditions of the license of that module. An independent module is a module\n//  which is neither derived from nor based on this library. If you modify this\n//  library, you may extend this exception to your version of the library, but you\n//  are not obligated to do so. If you do not wish to do so, delete this exception\n//  statement from your version.\n//\n//  Copyright 2013-2015 Daqri, LLC.\n//\n//  Author(s): Chris Broaddus\n//\n\n#pragma once\n\n#include <vector>\n#include <framework/image.h>\n#include <math/math_utils.h>\n#include <cmath>\n\n// added for debug\n#include <AR/ar.h>\n\nnamespace vision {\n    \n    /**\n     * Use this function to upsample a point that has been found from a\n     * bilinear downsample pyramid.\n     *\n     * xp = x*2^n + 2^(n-1) - 0.5\n     * yp = y*2^n + 2^(n-1) - 0.5\n     *\n     * n: Octave that the point was detected on.\n     \n     * @param[out] xp Upsampled x location\n     * @param[out] yp Upsampled y location\n     * @param[in] x X location on detected image\n     * @param[in] y Y location on detected image\n     * @param[in] octave The octave of the detected image\n     */\n    inline void bilinear_upsample_point(float& xp,\n                                        float& yp,\n                                        float x,\n                                        float y,\n                                        int octave) {\n        float a, b;\n        a = std::pow(2.f, octave-1)-0.5f;\n        b = (1<<octave);\n        xp = (x*b)+a;\n        yp = (y*b)+a;\n    }\n    \n    /**\n     * Use this function to upsample a point that has been found from a\n     * bilinear downsample pyramid.\n     *\n     * xp = x*2^n + 2^(n-1) - 0.5\n     * yp = y*2^n + 2^(n-1) - 0.5\n     *\n     * n: Octave that the point was detected on.\n     \n     * @param[out] xp Upsampled x location\n     * @param[out] yp Upsampled y location\n     * @param[in] x X location on detected image\n     * @param[in] y Y location on detected image\n     * @param[in] octave The octave of the detected image\n     */\n    inline void bilinear_upsample_point(float& xp,\n                                        float& yp,\n                                        float& sp,\n                                        float x,\n                                        float y,\n                                        float s,\n                                        int octave) {\n        float a, b;\n        a = std::pow(2.f, octave-1)-0.5f;\n        b = (1<<octave);\n        xp = (x*b)+a;\n        yp = (y*b)+a;\n        sp = s*b;\n    }\n    \n    /**\n     * Use this function to downsample a point to an octave that was found from\n     * a bilinear downsampled pyramid.\n     *\n     * @param[out] xp Downsampled x location\n     * @param[out] yp Downsampled y location\n     * @param[in] x X location on fine image\n     * @param[in] y Y location on fine image\n     * @param[in] octave The octave to downsample (x,y) to\n     */\n    inline void bilinear_downsample_point(float& xp,\n                                          float& yp,\n                                          float x,\n                                          float y,\n                                          int octave) {\n        float a, b;\n        a = 1.f/(1<<octave);\n        b = 0.5f*a-0.5f;\n        xp = x*a+b;\n        yp = y*a+b;\n    }\n    \n    /**\n     * Use this function to downsample a point to an octave that was found from\n     * a bilinear downsampled pyramid.\n     *\n     * @param[out] xp Downsampled x location\n     * @param[out] yp Downsampled y location\n     * @param[out] sp Downsampled sigma\n     * @param[in] x X location on fine image\n     * @param[in] y Y location on fine image\n     * @param[in] s Sigma on fine image\n     * @param[in] octave The octave to downsample (x,y) to\n     */\n    inline void bilinear_downsample_point(float& xp,\n                                          float& yp,\n                                          float& sp,\n                                          float x,\n                                          float y,\n                                          float s,\n                                          int octave) {\n        float a, b;\n        a = 1.f/(1<<octave);\n        b = 0.5f*a-0.5f;\n        xp = x*a+b;\n        yp = y*a+b;\n        sp = s*a;\n    }\n    \n    /**\n     * Apply a 2D binomial filter to a source image.\n     *\n     * @param[out] dst Destination image\n     * @param[in] tmp Temporary memory of same size as source\n     * @param[in] src Source image\n     * @param[in] width Width of image\n     * @param[in] height Height of image\n     */\n    void binomial_4th_order(float* dst,\n                            unsigned short* tmp,\n                            const unsigned char* src,\n                            size_t width,\n                            size_t height);\n    void binomial_4th_order(float* dst,\n                            float* tmp,\n                            const float* src,\n                            size_t width,\n                            size_t height);\n    \n    /**\n     * The mean of the first pixel quad, and then every other pixel quad afterwards.\n     *\n     * @param[out] dst Destination image\n     * @param[in] src Source image\n     * @param[in] src_width Source width\n     * @param[in] src_height Source height\n     */\n    void downsample_bilinear(float* dst, const float* src, size_t src_width, size_t src_height);\n    \n    class GaussianScaleSpacePyramid {\n    public:\n        \n        GaussianScaleSpacePyramid();\n        virtual ~GaussianScaleSpacePyramid() {}\n        \n        /**\n         * Configure the pyramid.\n         */\n        void configure(int num_octaves, int num_scales_per_octaves);\n        \n        /**\n         * Get the number of octaves and scales.\n         */\n        inline int numOctaves() const { return mNumOctaves; }\n        inline int numScalesPerOctave() const { return mNumScalesPerOctave; }\n        \n        /**\n         * @return Get the number of images in the pyramid.\n         */\n        inline size_t size() const { return mPyramid.size(); }\n        \n        /**\n         * @return Get the vector of images.\n         */\n        inline std::vector<Image>& images() { return mPyramid; }\n        inline const std::vector<Image>& images() const { return mPyramid; }\n        \n        /**\n         * Get a pyramid image.\n         */\n        inline Image& get(size_t octave, size_t scale) {\n            ASSERT(octave < mNumOctaves, \"Octave out of range\");\n            ASSERT(scale < mNumScalesPerOctave, \"Scale out of range\");\n            return mPyramid[octave*mNumScalesPerOctave+scale];\n        }\n        inline const Image& get(size_t octave, size_t scale) const {\n            ASSERT(octave < mNumOctaves, \"Octave out of range\");\n            ASSERT(scale < mNumScalesPerOctave, \"Scale out of range\");\n            return mPyramid[octave*mNumScalesPerOctave+scale];\n        }\n        \n        /**\n         * Get the constant k-factor.\n         */\n        inline float kfactor() const { return mK; }\n        \n        /**\n         * Get the effective sigma given the octave and sub-pixel scale.\n         */\n        inline float effectiveSigma(size_t octave, float scale) const {\n            ASSERT(scale >= 0, \"Scale must be positive\");\n            ASSERT(scale < mNumScalesPerOctave, \"Scale must be less than number of scale per octave\");\n            return std::pow(mK, scale)*(1<<octave);\n        }\n        \n        /**\n         * Locate a SIGMA on the pyramid.\n         */\n        inline void locate(int& octave,\n                           int& scale,\n                           float sigma) const {\n            //ARLOGe(\"in locateA %f\\n\", sigma);\n            // octave = floor(log2(s))\n            octave = (int)std::floor(vision::log2<float>(sigma));\n            if(octave < 0) {\n                octave = 0;\n            }\n            //ARLOGe(\"in locateB %d\\n\", octave);\n\n            // scale = logk(s/2^octave)\n            // Here we ROUND the scale to an integer value\n            float fscale = std::log(sigma/(float)(1<<octave))*mOneOverLogK;\n            //ARLOGe(\"in locateC %f\\n\", fscale);\n\n            scale = (int)vision::round(fscale);\n            //ARLOGe(\"in locateD %d\\n\", scale);\n            if(scale < 0) {\n                scale = 0;\n            }\n\n            \n            // The last scale in an octave has the same sigma as the first scale\n            // of the next octave. We prefer coarser octaves for efficiency.\n            if(scale == mNumScalesPerOctave-1) {\n                // If this octave is out of range, then it will be clipped to\n                // be in range on the next step below.\n                octave = octave+1;\n                scale = 0;\n            }\n            \n            // Clip the octave/scale to be in range of the pyramid\n            if(octave < 0) {\n                octave = 0;\n                scale = 0;\n            } else if(octave >= mNumOctaves) {\n                octave = mNumOctaves-1;\n                scale = mNumScalesPerOctave-1;\n            }\n\n            \n            ASSERT(octave >= 0, \"Octave must be positive\");\n            ASSERT(octave < mNumOctaves, \"Octave must be less than number of octaves\");\n            ASSERT(scale >= 0, \"Scale must be positive\");\n            ASSERT(scale < mNumScalesPerOctave, \"Scale must be less than number of scale per octave\");\n        }\n        \n        /**\n         * Locate an (x,y,sigma) specified at the highest resolution on the pyramid.\n         */\n        inline void locate(float& xp,\n                           float& yp,\n                           float& sigmap,\n                           int& octave,\n                           int& scale,\n                           float x,\n                           float y,\n                           float sigma) const {\n            // Locate the SIGMA on the pyramid\n            locate(octave, scale, sigma);\n            // Downsample the point\n            bilinear_downsample_point(xp, yp, sigmap, x, y, sigma, octave);\n        }\n        \n    protected:\n        \n        // Vector of pyramid images\n        std::vector<Image> mPyramid;\n        \n        // Number of octaves\n        int mNumOctaves;\n        int mNumScalesPerOctave;\n        \n        float mK; // = 2^(1/(mNumScalesPerOctave-1))\n        float mOneOverLogK; // 1/log(k) precomputed for efficiency\n    };\n    \n    /**\n     * Build a Binomial Gaussian Scale Space Pyramid represented represented as 32-bit floats.\n     */\n    class BinomialPyramid32f : public GaussianScaleSpacePyramid {\n    public:\n        \n        BinomialPyramid32f();\n        ~BinomialPyramid32f();\n        \n        /**\n         * Allocate memory for the pyramid.\n         */\n        void alloc(size_t width,\n                   size_t height,\n                   int num_octaves);\n        \n        /**\n         * Release the pyramid memory.\n         */\n        void release();\n        \n        /**\n         * Build the pyramid.\n         */\n        void build(const Image& image);\n        \n    private:\n        \n        // Temporary space for binomial filter\n        std::vector<unsigned short> mTemp_us16;\n        std::vector<float> mTemp_f32_1;\n        std::vector<float> mTemp_f32_2;\n        \n        void apply_filter(Image& dst, const Image& src);\n        void apply_filter_twice(Image& dst, const Image& src);\n    };\n    \n    /**\n     * Compute the number of octaves for a width/height from the minimum size\n     * at the coarsest octave.\n     */\n    inline int numOctaves(int width, int height, int min_size) {\n        int num_octaves = 0;\n        while(width >= min_size &&\n              height >= min_size) {\n            width >>= 1;\n            height >>= 1;\n            num_octaves++;\n        }\n        return num_octaves;\n    }\n    \n} // vision","// -*- C++ -*-\n//===--------------------------- stdexcept --------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_STDEXCEPT\n#define _LIBCPP_STDEXCEPT\n\n/*\n    stdexcept synopsis\n\nnamespace std\n{\n\nclass logic_error;\n    class domain_error;\n    class invalid_argument;\n    class length_error;\n    class out_of_range;\nclass runtime_error;\n    class range_error;\n    class overflow_error;\n    class underflow_error;\n\nfor each class xxx_error:\n\nclass xxx_error : public exception // at least indirectly\n{\npublic:\n    explicit xxx_error(const string& what_arg);\n    explicit xxx_error(const char*   what_arg);\n\n    virtual const char* what() const noexcept // returns what_arg\n};\n\n}  // std\n\n*/\n\n#include <__config>\n#include <exception>\n#include <iosfwd>  // for string forward decl\n#ifdef _LIBCPP_NO_EXCEPTIONS\n#include <cstdlib>\n#endif\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\nclass _LIBCPP_HIDDEN __libcpp_refstring\n{\n    const char* __imp_;\n\n    bool __uses_refcount() const;\npublic:\n    explicit __libcpp_refstring(const char* msg);\n    __libcpp_refstring(const __libcpp_refstring& s) _NOEXCEPT;\n    __libcpp_refstring& operator=(const __libcpp_refstring& s) _NOEXCEPT;\n    ~__libcpp_refstring();\n\n    const char* c_str() const _NOEXCEPT {return __imp_;}\n};\n\n_LIBCPP_END_NAMESPACE_STD\n\nnamespace std  // purposefully not using versioning namespace\n{\n\nclass _LIBCPP_EXCEPTION_ABI logic_error\n    : public exception\n{\nprivate:\n    _VSTD::__libcpp_refstring __imp_;\npublic:\n    explicit logic_error(const string&);\n    explicit logic_error(const char*);\n\n    logic_error(const logic_error&) _NOEXCEPT;\n    logic_error& operator=(const logic_error&) _NOEXCEPT;\n\n    virtual ~logic_error() _NOEXCEPT;\n\n    virtual const char* what() const _NOEXCEPT;\n};\n\nclass _LIBCPP_EXCEPTION_ABI runtime_error\n    : public exception\n{\nprivate:\n    _VSTD::__libcpp_refstring __imp_;\npublic:\n    explicit runtime_error(const string&);\n    explicit runtime_error(const char*);\n\n    runtime_error(const runtime_error&) _NOEXCEPT;\n    runtime_error& operator=(const runtime_error&) _NOEXCEPT;\n\n    virtual ~runtime_error() _NOEXCEPT;\n\n    virtual const char* what() const _NOEXCEPT;\n};\n\nclass _LIBCPP_EXCEPTION_ABI domain_error\n    : public logic_error\n{\npublic:\n    _LIBCPP_INLINE_VISIBILITY explicit domain_error(const string& __s) : logic_error(__s) {}\n    _LIBCPP_INLINE_VISIBILITY explicit domain_error(const char* __s)   : logic_error(__s) {}\n\n    virtual ~domain_error() _NOEXCEPT;\n};\n\nclass _LIBCPP_EXCEPTION_ABI invalid_argument\n    : public logic_error\n{\npublic:\n    _LIBCPP_INLINE_VISIBILITY explicit invalid_argument(const string& __s) : logic_error(__s) {}\n    _LIBCPP_INLINE_VISIBILITY explicit invalid_argument(const char* __s)   : logic_error(__s) {}\n\n    virtual ~invalid_argument() _NOEXCEPT;\n};\n\nclass _LIBCPP_EXCEPTION_ABI length_error\n    : public logic_error\n{\npublic:\n    _LIBCPP_INLINE_VISIBILITY explicit length_error(const string& __s) : logic_error(__s) {}\n    _LIBCPP_INLINE_VISIBILITY explicit length_error(const char* __s)   : logic_error(__s) {}\n\n    virtual ~length_error() _NOEXCEPT;\n};\n\nclass _LIBCPP_EXCEPTION_ABI out_of_range\n    : public logic_error\n{\npublic:\n    _LIBCPP_INLINE_VISIBILITY explicit out_of_range(const string& __s) : logic_error(__s) {}\n    _LIBCPP_INLINE_VISIBILITY explicit out_of_range(const char* __s)   : logic_error(__s) {}\n\n    virtual ~out_of_range() _NOEXCEPT;\n};\n\nclass _LIBCPP_EXCEPTION_ABI range_error\n    : public runtime_error\n{\npublic:\n    _LIBCPP_INLINE_VISIBILITY explicit range_error(const string& __s) : runtime_error(__s) {}\n    _LIBCPP_INLINE_VISIBILITY explicit range_error(const char* __s)   : runtime_error(__s) {}\n\n    virtual ~range_error() _NOEXCEPT;\n};\n\nclass _LIBCPP_EXCEPTION_ABI overflow_error\n    : public runtime_error\n{\npublic:\n    _LIBCPP_INLINE_VISIBILITY explicit overflow_error(const string& __s) : runtime_error(__s) {}\n    _LIBCPP_INLINE_VISIBILITY explicit overflow_error(const char* __s)   : runtime_error(__s) {}\n\n    virtual ~overflow_error() _NOEXCEPT;\n};\n\nclass _LIBCPP_EXCEPTION_ABI underflow_error\n    : public runtime_error\n{\npublic:\n    _LIBCPP_INLINE_VISIBILITY explicit underflow_error(const string& __s) : runtime_error(__s) {}\n    _LIBCPP_INLINE_VISIBILITY explicit underflow_error(const char* __s)   : runtime_error(__s) {}\n\n    virtual ~underflow_error() _NOEXCEPT;\n};\n\n}  // std\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\n// in the dylib\n_LIBCPP_NORETURN _LIBCPP_FUNC_VIS void __throw_runtime_error(const char*);\n\n_LIBCPP_NORETURN inline _LIBCPP_ALWAYS_INLINE\nvoid __throw_logic_error(const char*__msg)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    throw logic_error(__msg);\n#else\n    ((void)__msg);\n\t  _VSTD::abort();\n#endif\n}\n\n_LIBCPP_NORETURN inline _LIBCPP_ALWAYS_INLINE\nvoid __throw_domain_error(const char*__msg)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    throw domain_error(__msg);\n#else\n    ((void)__msg);\n\t  _VSTD::abort();\n#endif\n}\n\n_LIBCPP_NORETURN inline _LIBCPP_ALWAYS_INLINE\nvoid __throw_invalid_argument(const char*__msg)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    throw invalid_argument(__msg);\n#else\n    ((void)__msg);\n\t  _VSTD::abort();\n#endif\n}\n\n_LIBCPP_NORETURN inline _LIBCPP_ALWAYS_INLINE\nvoid __throw_length_error(const char*__msg)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    throw length_error(__msg);\n#else\n    ((void)__msg);\n\t  _VSTD::abort();\n#endif\n}\n\n_LIBCPP_NORETURN inline _LIBCPP_ALWAYS_INLINE\nvoid __throw_out_of_range(const char*__msg)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    throw out_of_range(__msg);\n#else\n    ((void)__msg);\n\t  _VSTD::abort();\n#endif\n}\n\n_LIBCPP_NORETURN inline _LIBCPP_ALWAYS_INLINE\nvoid __throw_range_error(const char*__msg)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    throw range_error(__msg);\n#else\n    ((void)__msg);\n\t  _VSTD::abort();\n#endif\n}\n\n_LIBCPP_NORETURN inline _LIBCPP_ALWAYS_INLINE\nvoid __throw_overflow_error(const char*__msg)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    throw overflow_error(__msg);\n#else\n    ((void)__msg);\n    _VSTD::abort();\n#endif\n}\n\n_LIBCPP_NORETURN inline _LIBCPP_ALWAYS_INLINE\nvoid __throw_underflow_error(const char*__msg)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    throw underflow_error(__msg);\n#else\n    ((void)__msg);\n    _VSTD::abort();\n#endif\n}\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_STDEXCEPT\n","// -*- C++ -*-\n//===------------------------ type_traits ---------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_TYPE_TRAITS\n#define _LIBCPP_TYPE_TRAITS\n\n/*\n    type_traits synopsis\n\nnamespace std\n{\n\n    // helper class:\n    template <class T, T v> struct integral_constant;\n    typedef integral_constant<bool, true>  true_type;   // C++11\n    typedef integral_constant<bool, false> false_type;  // C++11\n    \n    template <bool B>                                   // C++14\n    using bool_constant = integral_constant<bool, B>;   // C++14\n    typedef bool_constant<true> true_type;              // C++14\n    typedef bool_constant<false> false_type;            // C++14\n\n    // helper traits\n    template <bool, class T = void> struct enable_if;\n    template <bool, class T, class F> struct conditional;\n\n    // Primary classification traits:\n    template <class T> struct is_void;\n    template <class T> struct is_null_pointer;  // C++14\n    template <class T> struct is_integral;\n    template <class T> struct is_floating_point;\n    template <class T> struct is_array;\n    template <class T> struct is_pointer;\n    template <class T> struct is_lvalue_reference;\n    template <class T> struct is_rvalue_reference;\n    template <class T> struct is_member_object_pointer;\n    template <class T> struct is_member_function_pointer;\n    template <class T> struct is_enum;\n    template <class T> struct is_union;\n    template <class T> struct is_class;\n    template <class T> struct is_function;\n\n    // Secondary classification traits:\n    template <class T> struct is_reference;\n    template <class T> struct is_arithmetic;\n    template <class T> struct is_fundamental;\n    template <class T> struct is_member_pointer;\n    template <class T> struct is_scalar;\n    template <class T> struct is_object;\n    template <class T> struct is_compound;\n\n    // Const-volatile properties and transformations:\n    template <class T> struct is_const;\n    template <class T> struct is_volatile;\n    template <class T> struct remove_const;\n    template <class T> struct remove_volatile;\n    template <class T> struct remove_cv;\n    template <class T> struct add_const;\n    template <class T> struct add_volatile;\n    template <class T> struct add_cv;\n\n    // Reference transformations:\n    template <class T> struct remove_reference;\n    template <class T> struct add_lvalue_reference;\n    template <class T> struct add_rvalue_reference;\n\n    // Pointer transformations:\n    template <class T> struct remove_pointer;\n    template <class T> struct add_pointer;\n\n    // Integral properties:\n    template <class T> struct is_signed;\n    template <class T> struct is_unsigned;\n    template <class T> struct make_signed;\n    template <class T> struct make_unsigned;\n\n    // Array properties and transformations:\n    template <class T> struct rank;\n    template <class T, unsigned I = 0> struct extent;\n    template <class T> struct remove_extent;\n    template <class T> struct remove_all_extents;\n\n    // Member introspection:\n    template <class T> struct is_pod;\n    template <class T> struct is_trivial;\n    template <class T> struct is_trivially_copyable;\n    template <class T> struct is_standard_layout;\n    template <class T> struct is_literal_type;\n    template <class T> struct is_empty;\n    template <class T> struct is_polymorphic;\n    template <class T> struct is_abstract;\n    template <class T> struct is_final; // C++14\n\n    template <class T, class... Args> struct is_constructible;\n    template <class T>                struct is_default_constructible;\n    template <class T>                struct is_copy_constructible;\n    template <class T>                struct is_move_constructible;\n    template <class T, class U>       struct is_assignable;\n    template <class T>                struct is_copy_assignable;\n    template <class T>                struct is_move_assignable;\n    template <class T, class U>       struct is_swappable_with;       // C++17\n    template <class T>                struct is_swappable;            // C++17\n    template <class T>                struct is_destructible;\n\n    template <class T, class... Args> struct is_trivially_constructible;\n    template <class T>                struct is_trivially_default_constructible;\n    template <class T>                struct is_trivially_copy_constructible;\n    template <class T>                struct is_trivially_move_constructible;\n    template <class T, class U>       struct is_trivially_assignable;\n    template <class T>                struct is_trivially_copy_assignable;\n    template <class T>                struct is_trivially_move_assignable;\n    template <class T>                struct is_trivially_destructible;\n\n    template <class T, class... Args> struct is_nothrow_constructible;\n    template <class T>                struct is_nothrow_default_constructible;\n    template <class T>                struct is_nothrow_copy_constructible;\n    template <class T>                struct is_nothrow_move_constructible;\n    template <class T, class U>       struct is_nothrow_assignable;\n    template <class T>                struct is_nothrow_copy_assignable;\n    template <class T>                struct is_nothrow_move_assignable;\n    template <class T, class U>       struct is_nothrow_swappable_with; // C++17\n    template <class T>                struct is_nothrow_swappable;      // C++17\n    template <class T>                struct is_nothrow_destructible;\n\n    template <class T> struct has_virtual_destructor;\n\n    // Relationships between types:\n    template <class T, class U> struct is_same;\n    template <class Base, class Derived> struct is_base_of;\n    template <class From, class To> struct is_convertible;\n\n    template <class, class R = void> struct is_callable; // not defined\n    template <class Fn, class... ArgTypes, class R>\n      struct is_callable<Fn(ArgTypes...), R>;\n\n    template <class, class R = void> struct is_nothrow_callable; // not defined\n    template <class Fn, class... ArgTypes, class R>\n      struct is_nothrow_callable<Fn(ArgTypes...), R>;\n\n    // Alignment properties and transformations:\n    template <class T> struct alignment_of;\n    template <size_t Len, size_t Align = most_stringent_alignment_requirement>\n        struct aligned_storage;\n    template <size_t Len, class... Types> struct aligned_union;\n\n    template <class T> struct decay;\n    template <class... T> struct common_type;\n    template <class T> struct underlying_type;\n    template <class> class result_of; // undefined\n    template <class Fn, class... ArgTypes> class result_of<Fn(ArgTypes...)>;\n\n    // const-volatile modifications:\n    template <class T>\n      using remove_const_t    = typename remove_const<T>::type;  // C++14\n    template <class T>\n      using remove_volatile_t = typename remove_volatile<T>::type;  // C++14\n    template <class T>\n      using remove_cv_t       = typename remove_cv<T>::type;  // C++14\n    template <class T>\n      using add_const_t       = typename add_const<T>::type;  // C++14\n    template <class T>\n      using add_volatile_t    = typename add_volatile<T>::type;  // C++14\n    template <class T>\n      using add_cv_t          = typename add_cv<T>::type;  // C++14\n  \n    // reference modifications:\n    template <class T>\n      using remove_reference_t     = typename remove_reference<T>::type;  // C++14\n    template <class T>\n      using add_lvalue_reference_t = typename add_lvalue_reference<T>::type;  // C++14\n    template <class T>\n      using add_rvalue_reference_t = typename add_rvalue_reference<T>::type;  // C++14\n  \n    // sign modifications:\n    template <class T>\n      using make_signed_t   = typename make_signed<T>::type;  // C++14\n    template <class T>\n      using make_unsigned_t = typename make_unsigned<T>::type;  // C++14\n  \n    // array modifications:\n    template <class T>\n      using remove_extent_t      = typename remove_extent<T>::type;  // C++14\n    template <class T>\n      using remove_all_extents_t = typename remove_all_extents<T>::type;  // C++14\n\n    // pointer modifications:\n    template <class T>\n      using remove_pointer_t = typename remove_pointer<T>::type;  // C++14\n    template <class T>\n      using add_pointer_t    = typename add_pointer<T>::type;  // C++14\n\n    // other transformations:\n    template <size_t Len, std::size_t Align=default-alignment>\n      using aligned_storage_t = typename aligned_storage<Len,Align>::type;  // C++14\n    template <std::size_t Len, class... Types>\n      using aligned_union_t   = typename aligned_union<Len,Types...>::type;  // C++14\n    template <class T>\n      using decay_t           = typename decay<T>::type;  // C++14\n    template <bool b, class T=void>\n      using enable_if_t       = typename enable_if<b,T>::type;  // C++14\n    template <bool b, class T, class F>\n      using conditional_t     = typename conditional<b,T,F>::type;  // C++14\n    template <class... T>\n      using common_type_t     = typename common_type<T...>::type;  // C++14\n    template <class T>\n      using underlying_type_t = typename underlying_type<T>::type;  // C++14\n    template <class F, class... ArgTypes>\n      using result_of_t       = typename result_of<F(ArgTypes...)>::type;  // C++14\n\n    template <class...>\n      using void_t = void;   // C++17\n      \n      // See C++14 20.10.4.1, primary type categories\n      template <class T> constexpr bool is_void_v\n        = is_void<T>::value;                                             // C++17\n      template <class T> constexpr bool is_null_pointer_v\n        = is_null_pointer<T>::value;                                     // C++17\n      template <class T> constexpr bool is_integral_v\n        = is_integral<T>::value;                                         // C++17\n      template <class T> constexpr bool is_floating_point_v\n        = is_floating_point<T>::value;                                   // C++17\n      template <class T> constexpr bool is_array_v\n        = is_array<T>::value;                                            // C++17\n      template <class T> constexpr bool is_pointer_v\n        = is_pointer<T>::value;                                          // C++17\n      template <class T> constexpr bool is_lvalue_reference_v\n        = is_lvalue_reference<T>::value;                                 // C++17\n      template <class T> constexpr bool is_rvalue_reference_v\n        = is_rvalue_reference<T>::value;                                 // C++17\n      template <class T> constexpr bool is_member_object_pointer_v\n        = is_member_object_pointer<T>::value;                            // C++17\n      template <class T> constexpr bool is_member_function_pointer_v\n        = is_member_function_pointer<T>::value;                          // C++17\n      template <class T> constexpr bool is_enum_v\n        = is_enum<T>::value;                                             // C++17\n      template <class T> constexpr bool is_union_v\n        = is_union<T>::value;                                            // C++17\n      template <class T> constexpr bool is_class_v\n        = is_class<T>::value;                                            // C++17\n      template <class T> constexpr bool is_function_v\n        = is_function<T>::value;                                         // C++17\n\n      // See C++14 20.10.4.2, composite type categories\n      template <class T> constexpr bool is_reference_v\n        = is_reference<T>::value;                                        // C++17\n      template <class T> constexpr bool is_arithmetic_v\n        = is_arithmetic<T>::value;                                       // C++17\n      template <class T> constexpr bool is_fundamental_v\n        = is_fundamental<T>::value;                                      // C++17\n      template <class T> constexpr bool is_object_v\n        = is_object<T>::value;                                           // C++17\n      template <class T> constexpr bool is_scalar_v\n        = is_scalar<T>::value;                                           // C++17\n      template <class T> constexpr bool is_compound_v\n        = is_compound<T>::value;                                         // C++17\n      template <class T> constexpr bool is_member_pointer_v\n        = is_member_pointer<T>::value;                                   // C++17\n\n      // See C++14 20.10.4.3, type properties\n      template <class T> constexpr bool is_const_v\n        = is_const<T>::value;                                            // C++17\n      template <class T> constexpr bool is_volatile_v\n        = is_volatile<T>::value;                                         // C++17\n      template <class T> constexpr bool is_trivial_v\n        = is_trivial<T>::value;                                          // C++17\n      template <class T> constexpr bool is_trivially_copyable_v\n        = is_trivially_copyable<T>::value;                               // C++17\n      template <class T> constexpr bool is_standard_layout_v\n        = is_standard_layout<T>::value;                                  // C++17\n      template <class T> constexpr bool is_pod_v\n        = is_pod<T>::value;                                              // C++17\n      template <class T> constexpr bool is_literal_type_v\n        = is_literal_type<T>::value;                                     // C++17\n      template <class T> constexpr bool is_empty_v\n        = is_empty<T>::value;                                            // C++17\n      template <class T> constexpr bool is_polymorphic_v\n        = is_polymorphic<T>::value;                                      // C++17\n      template <class T> constexpr bool is_abstract_v\n        = is_abstract<T>::value;                                         // C++17\n      template <class T> constexpr bool is_final_v\n        = is_final<T>::value;                                            // C++17\n      template <class T> constexpr bool is_signed_v\n        = is_signed<T>::value;                                           // C++17\n      template <class T> constexpr bool is_unsigned_v\n        = is_unsigned<T>::value;                                         // C++17\n      template <class T, class... Args> constexpr bool is_constructible_v\n        = is_constructible<T, Args...>::value;                           // C++17\n      template <class T> constexpr bool is_default_constructible_v\n        = is_default_constructible<T>::value;                            // C++17\n      template <class T> constexpr bool is_copy_constructible_v\n        = is_copy_constructible<T>::value;                               // C++17\n      template <class T> constexpr bool is_move_constructible_v\n        = is_move_constructible<T>::value;                               // C++17\n      template <class T, class U> constexpr bool is_assignable_v\n        = is_assignable<T, U>::value;                                    // C++17\n      template <class T> constexpr bool is_copy_assignable_v\n        = is_copy_assignable<T>::value;                                  // C++17\n      template <class T> constexpr bool is_move_assignable_v\n        = is_move_assignable<T>::value;                                  // C++17\n      template <class T, class U> constexpr bool is_swappable_with_v\n        = is_swappable_with<T, U>::value;                                // C++17\n      template <class T> constexpr bool is_swappable_v\n        = is_swappable<T>::value;                                        // C++17\n      template <class T> constexpr bool is_destructible_v\n        = is_destructible<T>::value;                                     // C++17\n      template <class T, class... Args> constexpr bool is_trivially_constructible_v\n        = is_trivially_constructible<T, Args...>::value;                 // C++17\n      template <class T> constexpr bool is_trivially_default_constructible_v\n        = is_trivially_default_constructible<T>::value;                  // C++17\n      template <class T> constexpr bool is_trivially_copy_constructible_v\n        = is_trivially_copy_constructible<T>::value;                     // C++17\n      template <class T> constexpr bool is_trivially_move_constructible_v\n        = is_trivially_move_constructible<T>::value;                     // C++17\n      template <class T, class U> constexpr bool is_trivially_assignable_v\n        = is_trivially_assignable<T, U>::value;                          // C++17\n      template <class T> constexpr bool is_trivially_copy_assignable_v\n        = is_trivially_copy_assignable<T>::value;                        // C++17\n      template <class T> constexpr bool is_trivially_move_assignable_v\n        = is_trivially_move_assignable<T>::value;                        // C++17\n      template <class T> constexpr bool is_trivially_destructible_v\n        = is_trivially_destructible<T>::value;                           // C++17\n      template <class T, class... Args> constexpr bool is_nothrow_constructible_v\n        = is_nothrow_constructible<T, Args...>::value;                   // C++17\n      template <class T> constexpr bool is_nothrow_default_constructible_v\n        = is_nothrow_default_constructible<T>::value;                    // C++17\n      template <class T> constexpr bool is_nothrow_copy_constructible_v\n        = is_nothrow_copy_constructible<T>::value;                       // C++17\n      template <class T> constexpr bool is_nothrow_move_constructible_v\n        = is_nothrow_move_constructible<T>::value;                       // C++17\n      template <class T, class U> constexpr bool is_nothrow_assignable_v\n        = is_nothrow_assignable<T, U>::value;                            // C++17\n      template <class T> constexpr bool is_nothrow_copy_assignable_v\n        = is_nothrow_copy_assignable<T>::value;                          // C++17\n      template <class T> constexpr bool is_nothrow_move_assignable_v\n        = is_nothrow_move_assignable<T>::value;                          // C++17\n      template <class T, class U> constexpr bool is_nothrow_swappable_with_v\n        = is_nothrow_swappable_with<T, U>::value;                       // C++17\n      template <class T> constexpr bool is_nothrow_swappable_v\n        = is_nothrow_swappable<T>::value;                               // C++17\n      template <class T> constexpr bool is_nothrow_destructible_v\n        = is_nothrow_destructible<T>::value;                             // C++17\n      template <class T> constexpr bool has_virtual_destructor_v\n        = has_virtual_destructor<T>::value;                              // C++17\n\n      // See C++14 20.10.5, type property queries\n      template <class T> constexpr size_t alignment_of_v\n        = alignment_of<T>::value;                                        // C++17\n      template <class T> constexpr size_t rank_v\n        = rank<T>::value;                                                // C++17\n      template <class T, unsigned I = 0> constexpr size_t extent_v\n        = extent<T, I>::value;                                           // C++17\n\n      // See C++14 20.10.6, type relations\n      template <class T, class U> constexpr bool is_same_v\n        = is_same<T, U>::value;                                          // C++17\n      template <class Base, class Derived> constexpr bool is_base_of_v\n        = is_base_of<Base, Derived>::value;                              // C++17\n      template <class From, class To> constexpr bool is_convertible_v\n        = is_convertible<From, To>::value;                               // C++17\n      template <class T, class R = void> constexpr bool is_callable_v\n        = is_callable<T, R>::value;                                      // C++17\n      template <class T, class R = void> constexpr bool is_nothrow_callable_v\n        = is_nothrow_callable<T, R>::value;                              // C++17\n\n      // [meta.logical], logical operator traits:\n      template<class... B> struct conjunction;                           // C++17\n      template<class... B> \n        constexpr bool conjunction_v = conjunction<B...>::value;         // C++17\n      template<class... B> struct disjunction;                           // C++17\n      template<class... B>\n        constexpr bool disjunction_v = disjunction<B...>::value;         // C++17\n      template<class B> struct negation;                                 // C++17\n      template<class B> \n        constexpr bool negation_v = negation<B>::value;                  // C++17\n\n}\n\n*/\n#include <__config>\n#include <cstddef>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\ntemplate <class _T1, class _T2> struct _LIBCPP_TEMPLATE_VIS pair;\ntemplate <class _Tp> class _LIBCPP_TEMPLATE_VIS reference_wrapper;\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS hash;\n\ntemplate <class>\nstruct __void_t { typedef void type; };\n\ntemplate <class _Tp>\nstruct __identity { typedef _Tp type; };\n\ntemplate <class _Tp, bool>\nstruct _LIBCPP_TEMPLATE_VIS __dependent_type : public _Tp {};\n\ntemplate <bool _Bp, class _If, class _Then>\n    struct _LIBCPP_TEMPLATE_VIS conditional {typedef _If type;};\ntemplate <class _If, class _Then>\n    struct _LIBCPP_TEMPLATE_VIS conditional<false, _If, _Then> {typedef _Then type;};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <bool _Bp, class _If, class _Then> using conditional_t = typename conditional<_Bp, _If, _Then>::type;\n#endif\n\ntemplate <bool, class _Tp> struct _LIBCPP_TEMPLATE_VIS __lazy_enable_if {};\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS __lazy_enable_if<true, _Tp> {typedef typename _Tp::type type;};\n\ntemplate <bool, class _Tp = void> struct _LIBCPP_TEMPLATE_VIS enable_if {};\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS enable_if<true, _Tp> {typedef _Tp type;};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <bool _Bp, class _Tp = void> using enable_if_t = typename enable_if<_Bp, _Tp>::type;\n#endif\n\n// addressof\n#ifndef _LIBCPP_HAS_NO_BUILTIN_ADDRESSOF\n\ntemplate <class _Tp>\ninline _LIBCPP_CONSTEXPR_AFTER_CXX14\n_LIBCPP_NO_CFI _LIBCPP_INLINE_VISIBILITY\n_Tp*\naddressof(_Tp& __x) _NOEXCEPT\n{\n    return __builtin_addressof(__x);\n}\n\n#else\n\ntemplate <class _Tp>\ninline _LIBCPP_NO_CFI _LIBCPP_INLINE_VISIBILITY\n_Tp*\naddressof(_Tp& __x) _NOEXCEPT\n{\n  return reinterpret_cast<_Tp *>(\n      const_cast<char *>(&reinterpret_cast<const volatile char &>(__x)));\n}\n\n#endif // _LIBCPP_HAS_NO_BUILTIN_ADDRESSOF\n\n#if defined(_LIBCPP_HAS_OBJC_ARC) && !defined(_LIBCPP_PREDEFINED_OBJC_ARC_ADDRESSOF)\n// Objective-C++ Automatic Reference Counting uses qualified pointers\n// that require special addressof() signatures. When\n// _LIBCPP_PREDEFINED_OBJC_ARC_ADDRESSOF is defined, the compiler\n// itself is providing these definitions. Otherwise, we provide them.\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n__strong _Tp*\naddressof(__strong _Tp& __x) _NOEXCEPT\n{\n  return &__x;\n}\n\n#ifdef _LIBCPP_HAS_OBJC_ARC_WEAK\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n__weak _Tp*\naddressof(__weak _Tp& __x) _NOEXCEPT\n{\n  return &__x;\n}\n#endif\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n__autoreleasing _Tp*\naddressof(__autoreleasing _Tp& __x) _NOEXCEPT\n{\n  return &__x;\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n__unsafe_unretained _Tp*\naddressof(__unsafe_unretained _Tp& __x) _NOEXCEPT\n{\n  return &__x;\n}\n#endif\n\n#if !defined(_LIBCPP_CXX03_LANG)\ntemplate <class _Tp> _Tp* addressof(const _Tp&&) noexcept = delete;\n#endif\n\nstruct __two {char __lx[2];};\n\n// helper class:\n\ntemplate <class _Tp, _Tp __v>\nstruct _LIBCPP_TEMPLATE_VIS integral_constant\n{\n    static _LIBCPP_CONSTEXPR const _Tp      value = __v;\n    typedef _Tp               value_type;\n    typedef integral_constant type;\n    _LIBCPP_INLINE_VISIBILITY\n        _LIBCPP_CONSTEXPR operator value_type() const _NOEXCEPT {return value;}\n#if _LIBCPP_STD_VER > 11\n    _LIBCPP_INLINE_VISIBILITY\n         constexpr value_type operator ()() const _NOEXCEPT {return value;}\n#endif\n};\n\ntemplate <class _Tp, _Tp __v>\n_LIBCPP_CONSTEXPR const _Tp integral_constant<_Tp, __v>::value;\n\n#if _LIBCPP_STD_VER > 14\ntemplate <bool __b>\nusing bool_constant = integral_constant<bool, __b>;\n#define _LIBCPP_BOOL_CONSTANT(__b) bool_constant<(__b)>\n#else\n#define _LIBCPP_BOOL_CONSTANT(__b) integral_constant<bool,(__b)>\n#endif\n\ntypedef _LIBCPP_BOOL_CONSTANT(true)  true_type;\ntypedef _LIBCPP_BOOL_CONSTANT(false) false_type;\n\n#if !defined(_LIBCPP_CXX03_LANG)\n\n// __lazy_and\n\ntemplate <bool _Last, class ..._Preds>\nstruct __lazy_and_impl;\n\ntemplate <class ..._Preds>\nstruct __lazy_and_impl<false, _Preds...> : false_type {};\n\ntemplate <>\nstruct __lazy_and_impl<true> : true_type {};\n\ntemplate <class _Pred>\nstruct __lazy_and_impl<true, _Pred> : integral_constant<bool, _Pred::type::value> {};\n\ntemplate <class _Hp, class ..._Tp>\nstruct __lazy_and_impl<true, _Hp, _Tp...> : __lazy_and_impl<_Hp::type::value, _Tp...> {};\n\ntemplate <class _P1, class ..._Pr>\nstruct __lazy_and : __lazy_and_impl<_P1::type::value, _Pr...> {};\n\n// __lazy_or\n\ntemplate <bool _List, class ..._Preds>\nstruct __lazy_or_impl;\n\ntemplate <class ..._Preds>\nstruct __lazy_or_impl<true, _Preds...> : true_type {};\n\ntemplate <>\nstruct __lazy_or_impl<false> : false_type {};\n\ntemplate <class _Hp, class ..._Tp>\nstruct __lazy_or_impl<false, _Hp, _Tp...>\n        : __lazy_or_impl<_Hp::type::value, _Tp...> {};\n\ntemplate <class _P1, class ..._Pr>\nstruct __lazy_or : __lazy_or_impl<_P1::type::value, _Pr...> {};\n\n// __lazy_not\n\ntemplate <class _Pred>\nstruct __lazy_not : integral_constant<bool, !_Pred::type::value> {};\n\n// __and_\ntemplate<class...> struct __and_;\ntemplate<> struct __and_<> : true_type {};\n\ntemplate<class _B0> struct __and_<_B0> : _B0 {};\n\ntemplate<class _B0, class _B1>\nstruct __and_<_B0, _B1> : conditional<_B0::value, _B1, _B0>::type {};\n\ntemplate<class _B0, class _B1, class _B2, class... _Bn>\nstruct __and_<_B0, _B1, _B2, _Bn...> \n        : conditional<_B0::value, __and_<_B1, _B2, _Bn...>, _B0>::type {};\n\n// __or_\ntemplate<class...> struct __or_;\ntemplate<> struct __or_<> : false_type {};\n\ntemplate<class _B0> struct __or_<_B0> : _B0 {};\n\ntemplate<class _B0, class _B1>\nstruct __or_<_B0, _B1> : conditional<_B0::value, _B0, _B1>::type {};\n\ntemplate<class _B0, class _B1, class _B2, class... _Bn>\nstruct __or_<_B0, _B1, _B2, _Bn...> \n        : conditional<_B0::value, _B0, __or_<_B1, _B2, _Bn...> >::type {};\n\n// __not_\ntemplate<class _Tp> \nstruct __not_ : conditional<_Tp::value, false_type, true_type>::type {};\n\n#endif // !defined(_LIBCPP_CXX03_LANG)\n\n// is_const\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_const            : public false_type {};\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_const<_Tp const> : public true_type {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_const_v\n    = is_const<_Tp>::value;\n#endif\n\n// is_volatile\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_volatile               : public false_type {};\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_volatile<_Tp volatile> : public true_type {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_volatile_v\n    = is_volatile<_Tp>::value;\n#endif\n\n// remove_const\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_const            {typedef _Tp type;};\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_const<const _Tp> {typedef _Tp type;};\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using remove_const_t = typename remove_const<_Tp>::type;\n#endif\n\n// remove_volatile\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_volatile               {typedef _Tp type;};\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_volatile<volatile _Tp> {typedef _Tp type;};\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using remove_volatile_t = typename remove_volatile<_Tp>::type;\n#endif\n\n// remove_cv\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_cv\n{typedef typename remove_volatile<typename remove_const<_Tp>::type>::type type;};\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using remove_cv_t = typename remove_cv<_Tp>::type;\n#endif\n\n// is_void\n\ntemplate <class _Tp> struct __libcpp_is_void       : public false_type {};\ntemplate <>          struct __libcpp_is_void<void> : public true_type {};\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_void\n    : public __libcpp_is_void<typename remove_cv<_Tp>::type> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_void_v\n    = is_void<_Tp>::value;\n#endif\n\n// __is_nullptr_t\n\ntemplate <class _Tp> struct __is_nullptr_t_impl       : public false_type {};\ntemplate <>          struct __is_nullptr_t_impl<nullptr_t> : public true_type {};\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS __is_nullptr_t\n    : public __is_nullptr_t_impl<typename remove_cv<_Tp>::type> {};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_null_pointer\n    : public __is_nullptr_t_impl<typename remove_cv<_Tp>::type> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_null_pointer_v\n    = is_null_pointer<_Tp>::value;\n#endif\n#endif\n\n// is_integral\n\ntemplate <class _Tp> struct __libcpp_is_integral                     : public false_type {};\ntemplate <>          struct __libcpp_is_integral<bool>               : public true_type {};\ntemplate <>          struct __libcpp_is_integral<char>               : public true_type {};\ntemplate <>          struct __libcpp_is_integral<signed char>        : public true_type {};\ntemplate <>          struct __libcpp_is_integral<unsigned char>      : public true_type {};\ntemplate <>          struct __libcpp_is_integral<wchar_t>            : public true_type {};\n#ifndef _LIBCPP_HAS_NO_UNICODE_CHARS\ntemplate <>          struct __libcpp_is_integral<char16_t>           : public true_type {};\ntemplate <>          struct __libcpp_is_integral<char32_t>           : public true_type {};\n#endif  // _LIBCPP_HAS_NO_UNICODE_CHARS\ntemplate <>          struct __libcpp_is_integral<short>              : public true_type {};\ntemplate <>          struct __libcpp_is_integral<unsigned short>     : public true_type {};\ntemplate <>          struct __libcpp_is_integral<int>                : public true_type {};\ntemplate <>          struct __libcpp_is_integral<unsigned int>       : public true_type {};\ntemplate <>          struct __libcpp_is_integral<long>               : public true_type {};\ntemplate <>          struct __libcpp_is_integral<unsigned long>      : public true_type {};\ntemplate <>          struct __libcpp_is_integral<long long>          : public true_type {};\ntemplate <>          struct __libcpp_is_integral<unsigned long long> : public true_type {};\n#ifndef _LIBCPP_HAS_NO_INT128\ntemplate <>          struct __libcpp_is_integral<__int128_t>         : public true_type {};\ntemplate <>          struct __libcpp_is_integral<__uint128_t>        : public true_type {};\n#endif\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_integral\n    : public __libcpp_is_integral<typename remove_cv<_Tp>::type> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_integral_v\n    = is_integral<_Tp>::value;\n#endif\n\n// is_floating_point\n\ntemplate <class _Tp> struct __libcpp_is_floating_point              : public false_type {};\ntemplate <>          struct __libcpp_is_floating_point<float>       : public true_type {};\ntemplate <>          struct __libcpp_is_floating_point<double>      : public true_type {};\ntemplate <>          struct __libcpp_is_floating_point<long double> : public true_type {};\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_floating_point\n    : public __libcpp_is_floating_point<typename remove_cv<_Tp>::type> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_floating_point_v\n    = is_floating_point<_Tp>::value;\n#endif\n\n// is_array\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_array\n    : public false_type {};\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_array<_Tp[]>\n    : public true_type {};\ntemplate <class _Tp, size_t _Np> struct _LIBCPP_TEMPLATE_VIS is_array<_Tp[_Np]>\n    : public true_type {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_array_v\n    = is_array<_Tp>::value;\n#endif\n\n// is_pointer\n\ntemplate <class _Tp> struct __libcpp_is_pointer       : public false_type {};\ntemplate <class _Tp> struct __libcpp_is_pointer<_Tp*> : public true_type {};\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_pointer\n    : public __libcpp_is_pointer<typename remove_cv<_Tp>::type> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_pointer_v\n    = is_pointer<_Tp>::value;\n#endif\n\n// is_reference\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_lvalue_reference       : public false_type {};\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_lvalue_reference<_Tp&> : public true_type {};\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_rvalue_reference        : public false_type {};\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_rvalue_reference<_Tp&&> : public true_type {};\n#endif\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_reference        : public false_type {};\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_reference<_Tp&>  : public true_type {};\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_reference<_Tp&&> : public true_type {};\n#endif\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_reference_v\n    = is_reference<_Tp>::value;\n\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_lvalue_reference_v\n    = is_lvalue_reference<_Tp>::value;\n\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_rvalue_reference_v\n    = is_rvalue_reference<_Tp>::value;\n#endif\n// is_union\n\n#if __has_feature(is_union) || (_GNUC_VER >= 403)\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_union\n    : public integral_constant<bool, __is_union(_Tp)> {};\n\n#else\n\ntemplate <class _Tp> struct __libcpp_union : public false_type {};\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_union\n    : public __libcpp_union<typename remove_cv<_Tp>::type> {};\n\n#endif\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_union_v\n    = is_union<_Tp>::value;\n#endif\n\n// is_class\n\n#if __has_feature(is_class) || (_GNUC_VER >= 403)\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_class\n    : public integral_constant<bool, __is_class(_Tp)> {};\n\n#else\n\nnamespace __is_class_imp\n{\ntemplate <class _Tp> char  __test(int _Tp::*);\ntemplate <class _Tp> __two __test(...);\n}\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_class\n    : public integral_constant<bool, sizeof(__is_class_imp::__test<_Tp>(0)) == 1 && !is_union<_Tp>::value> {};\n\n#endif\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_class_v\n    = is_class<_Tp>::value;\n#endif\n\n// is_same\n\ntemplate <class _Tp, class _Up> struct _LIBCPP_TEMPLATE_VIS is_same           : public false_type {};\ntemplate <class _Tp>            struct _LIBCPP_TEMPLATE_VIS is_same<_Tp, _Tp> : public true_type {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp, class _Up> _LIBCPP_CONSTEXPR bool is_same_v\n    = is_same<_Tp, _Up>::value;\n#endif\n\n// is_function\n\nnamespace __libcpp_is_function_imp\n{\nstruct __dummy_type {};\ntemplate <class _Tp> char  __test(_Tp*);\ntemplate <class _Tp> char __test(__dummy_type);\ntemplate <class _Tp> __two __test(...);\ntemplate <class _Tp> _Tp&  __source(int);\ntemplate <class _Tp> __dummy_type __source(...);\n}\n\ntemplate <class _Tp, bool = is_class<_Tp>::value ||\n                            is_union<_Tp>::value ||\n                            is_void<_Tp>::value  ||\n                            is_reference<_Tp>::value ||\n                            __is_nullptr_t<_Tp>::value >\nstruct __libcpp_is_function\n    : public integral_constant<bool, sizeof(__libcpp_is_function_imp::__test<_Tp>(__libcpp_is_function_imp::__source<_Tp>(0))) == 1>\n    {};\ntemplate <class _Tp> struct __libcpp_is_function<_Tp, true> : public false_type {};\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_function\n    : public __libcpp_is_function<_Tp> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_function_v\n    = is_function<_Tp>::value;\n#endif\n\n// is_member_function_pointer\n\n// template <class _Tp> struct            __libcpp_is_member_function_pointer             : public false_type {};\n// template <class _Tp, class _Up> struct __libcpp_is_member_function_pointer<_Tp _Up::*> : public is_function<_Tp> {};\n// \n\ntemplate <class _MP, bool _IsMemberFunctionPtr, bool _IsMemberObjectPtr>\nstruct __member_pointer_traits_imp\n{  // forward declaration; specializations later\n};\n\n\ntemplate <class _Tp> struct __libcpp_is_member_function_pointer\n    : public false_type {};\n\ntemplate <class _Ret, class _Class>\nstruct __libcpp_is_member_function_pointer<_Ret _Class::*>\n    : public is_function<_Ret> {};\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_member_function_pointer\n    : public __libcpp_is_member_function_pointer<typename remove_cv<_Tp>::type>::type {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_member_function_pointer_v\n    = is_member_function_pointer<_Tp>::value;\n#endif\n\n// is_member_pointer\n\ntemplate <class _Tp>            struct __libcpp_is_member_pointer             : public false_type {};\ntemplate <class _Tp, class _Up> struct __libcpp_is_member_pointer<_Tp _Up::*> : public true_type {};\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_member_pointer\n    : public __libcpp_is_member_pointer<typename remove_cv<_Tp>::type> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_member_pointer_v\n    = is_member_pointer<_Tp>::value;\n#endif\n\n// is_member_object_pointer\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_member_object_pointer\n    : public integral_constant<bool, is_member_pointer<_Tp>::value &&\n                                    !is_member_function_pointer<_Tp>::value> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_member_object_pointer_v\n    = is_member_object_pointer<_Tp>::value;\n#endif\n\n// is_enum\n\n#if __has_feature(is_enum) || (_GNUC_VER >= 403)\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_enum\n    : public integral_constant<bool, __is_enum(_Tp)> {};\n\n#else\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_enum\n    : public integral_constant<bool, !is_void<_Tp>::value             &&\n                                     !is_integral<_Tp>::value         &&\n                                     !is_floating_point<_Tp>::value   &&\n                                     !is_array<_Tp>::value            &&\n                                     !is_pointer<_Tp>::value          &&\n                                     !is_reference<_Tp>::value        &&\n                                     !is_member_pointer<_Tp>::value   &&\n                                     !is_union<_Tp>::value            &&\n                                     !is_class<_Tp>::value            &&\n                                     !is_function<_Tp>::value         > {};\n\n#endif\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_enum_v\n    = is_enum<_Tp>::value;\n#endif\n\n// is_arithmetic\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_arithmetic\n    : public integral_constant<bool, is_integral<_Tp>::value      ||\n                                     is_floating_point<_Tp>::value> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_arithmetic_v\n    = is_arithmetic<_Tp>::value;\n#endif\n\n// is_fundamental\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_fundamental\n    : public integral_constant<bool, is_void<_Tp>::value        ||\n                                     __is_nullptr_t<_Tp>::value ||\n                                     is_arithmetic<_Tp>::value> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_fundamental_v\n    = is_fundamental<_Tp>::value;\n#endif\n\n// is_scalar\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_scalar\n    : public integral_constant<bool, is_arithmetic<_Tp>::value     ||\n                                     is_member_pointer<_Tp>::value ||\n                                     is_pointer<_Tp>::value        ||\n                                     __is_nullptr_t<_Tp>::value    ||\n                                     is_enum<_Tp>::value           > {};\n\ntemplate <> struct _LIBCPP_TEMPLATE_VIS is_scalar<nullptr_t> : public true_type {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_scalar_v\n    = is_scalar<_Tp>::value;\n#endif\n\n// is_object\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_object\n    : public integral_constant<bool, is_scalar<_Tp>::value ||\n                                     is_array<_Tp>::value  ||\n                                     is_union<_Tp>::value  ||\n                                     is_class<_Tp>::value  > {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_object_v\n    = is_object<_Tp>::value;\n#endif\n\n// is_compound\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_compound\n    : public integral_constant<bool, !is_fundamental<_Tp>::value> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_compound_v\n    = is_compound<_Tp>::value;\n#endif\n\n\n// __is_referenceable  [defns.referenceable]\n\nstruct __is_referenceable_impl {\n    template <class _Tp> static _Tp& __test(int);\n    template <class _Tp> static __two __test(...);\n};\n\ntemplate <class _Tp>\nstruct __is_referenceable : integral_constant<bool,\n    !is_same<decltype(__is_referenceable_impl::__test<_Tp>(0)), __two>::value> {};\n\n\n// add_const\n\ntemplate <class _Tp, bool = is_reference<_Tp>::value ||\n                            is_function<_Tp>::value  ||\n                            is_const<_Tp>::value     >\nstruct __add_const             {typedef _Tp type;};\n\ntemplate <class _Tp>\nstruct __add_const<_Tp, false> {typedef const _Tp type;};\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS add_const\n    {typedef typename __add_const<_Tp>::type type;};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using add_const_t = typename add_const<_Tp>::type;\n#endif\n\n// add_volatile\n\ntemplate <class _Tp, bool = is_reference<_Tp>::value ||\n                            is_function<_Tp>::value  ||\n                            is_volatile<_Tp>::value  >\nstruct __add_volatile             {typedef _Tp type;};\n\ntemplate <class _Tp>\nstruct __add_volatile<_Tp, false> {typedef volatile _Tp type;};\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS add_volatile\n    {typedef typename __add_volatile<_Tp>::type type;};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using add_volatile_t = typename add_volatile<_Tp>::type;\n#endif\n\n// add_cv\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS add_cv\n    {typedef typename add_const<typename add_volatile<_Tp>::type>::type type;};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using add_cv_t = typename add_cv<_Tp>::type;\n#endif\n\n// remove_reference\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_reference        {typedef _Tp type;};\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_reference<_Tp&>  {typedef _Tp type;};\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_reference<_Tp&&> {typedef _Tp type;};\n#endif\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using remove_reference_t = typename remove_reference<_Tp>::type;\n#endif\n\n// add_lvalue_reference\n\ntemplate <class _Tp, bool = __is_referenceable<_Tp>::value> struct __add_lvalue_reference_impl            { typedef _Tp  type; };\ntemplate <class _Tp                                       > struct __add_lvalue_reference_impl<_Tp, true> { typedef _Tp& type; };\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS add_lvalue_reference\n{typedef typename __add_lvalue_reference_impl<_Tp>::type type;};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using add_lvalue_reference_t = typename add_lvalue_reference<_Tp>::type;\n#endif\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, bool = __is_referenceable<_Tp>::value> struct __add_rvalue_reference_impl            { typedef _Tp   type; };\ntemplate <class _Tp                                       > struct __add_rvalue_reference_impl<_Tp, true> { typedef _Tp&& type; };\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS add_rvalue_reference\n{typedef typename __add_rvalue_reference_impl<_Tp>::type type;};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using add_rvalue_reference_t = typename add_rvalue_reference<_Tp>::type;\n#endif\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp> _Tp&& __declval(int);\ntemplate <class _Tp> _Tp   __declval(long);\n\ntemplate <class _Tp>\ndecltype(_VSTD::__declval<_Tp>(0))\ndeclval() _NOEXCEPT;\n\n#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp>\ntypename add_lvalue_reference<_Tp>::type\ndeclval();\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n// __uncvref\n\ntemplate <class _Tp>\nstruct __uncvref  {\n    typedef typename remove_cv<typename remove_reference<_Tp>::type>::type type;\n};\n\ntemplate <class _Tp>\nstruct __unconstref {\n    typedef typename remove_const<typename remove_reference<_Tp>::type>::type type;\n};\n\n#ifndef _LIBCPP_CXX03_LANG\ntemplate <class _Tp>\nusing __uncvref_t = typename __uncvref<_Tp>::type;\n#endif\n\n// __is_same_uncvref\n\ntemplate <class _Tp, class _Up>\nstruct __is_same_uncvref : is_same<typename __uncvref<_Tp>::type,\n                                   typename __uncvref<_Up>::type> {};\n\nstruct __any\n{\n    __any(...);\n};\n\n// remove_pointer\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_pointer                      {typedef _Tp type;};\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_pointer<_Tp*>                {typedef _Tp type;};\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_pointer<_Tp* const>          {typedef _Tp type;};\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_pointer<_Tp* volatile>       {typedef _Tp type;};\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_pointer<_Tp* const volatile> {typedef _Tp type;};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using remove_pointer_t = typename remove_pointer<_Tp>::type;\n#endif\n\n// add_pointer\n\ntemplate <class _Tp, \n        bool = __is_referenceable<_Tp>::value || \n                is_same<typename remove_cv<_Tp>::type, void>::value>\nstruct __add_pointer_impl\n    {typedef typename remove_reference<_Tp>::type* type;};\ntemplate <class _Tp> struct __add_pointer_impl<_Tp, false> \n    {typedef _Tp type;};\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS add_pointer\n    {typedef typename __add_pointer_impl<_Tp>::type type;};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using add_pointer_t = typename add_pointer<_Tp>::type;\n#endif\n\n// is_signed\n\ntemplate <class _Tp, bool = is_integral<_Tp>::value>\nstruct __libcpp_is_signed_impl : public _LIBCPP_BOOL_CONSTANT(_Tp(-1) < _Tp(0)) {};\n\ntemplate <class _Tp>\nstruct __libcpp_is_signed_impl<_Tp, false> : public true_type {};  // floating point\n\ntemplate <class _Tp, bool = is_arithmetic<_Tp>::value>\nstruct __libcpp_is_signed : public __libcpp_is_signed_impl<_Tp> {};\n\ntemplate <class _Tp> struct __libcpp_is_signed<_Tp, false> : public false_type {};\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_signed : public __libcpp_is_signed<_Tp> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_signed_v\n    = is_signed<_Tp>::value;\n#endif\n\n// is_unsigned\n\ntemplate <class _Tp, bool = is_integral<_Tp>::value>\nstruct __libcpp_is_unsigned_impl : public _LIBCPP_BOOL_CONSTANT(_Tp(0) < _Tp(-1)) {};\n\ntemplate <class _Tp>\nstruct __libcpp_is_unsigned_impl<_Tp, false> : public false_type {};  // floating point\n\ntemplate <class _Tp, bool = is_arithmetic<_Tp>::value>\nstruct __libcpp_is_unsigned : public __libcpp_is_unsigned_impl<_Tp> {};\n\ntemplate <class _Tp> struct __libcpp_is_unsigned<_Tp, false> : public false_type {};\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_unsigned : public __libcpp_is_unsigned<_Tp> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_unsigned_v\n    = is_unsigned<_Tp>::value;\n#endif\n\n// rank\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS rank\n    : public integral_constant<size_t, 0> {};\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS rank<_Tp[]>\n    : public integral_constant<size_t, rank<_Tp>::value + 1> {};\ntemplate <class _Tp, size_t _Np> struct _LIBCPP_TEMPLATE_VIS rank<_Tp[_Np]>\n    : public integral_constant<size_t, rank<_Tp>::value + 1> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR size_t rank_v\n    = rank<_Tp>::value;\n#endif\n\n// extent\n\ntemplate <class _Tp, unsigned _Ip = 0> struct _LIBCPP_TEMPLATE_VIS extent\n    : public integral_constant<size_t, 0> {};\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS extent<_Tp[], 0>\n    : public integral_constant<size_t, 0> {};\ntemplate <class _Tp, unsigned _Ip> struct _LIBCPP_TEMPLATE_VIS extent<_Tp[], _Ip>\n    : public integral_constant<size_t, extent<_Tp, _Ip-1>::value> {};\ntemplate <class _Tp, size_t _Np> struct _LIBCPP_TEMPLATE_VIS extent<_Tp[_Np], 0>\n    : public integral_constant<size_t, _Np> {};\ntemplate <class _Tp, size_t _Np, unsigned _Ip> struct _LIBCPP_TEMPLATE_VIS extent<_Tp[_Np], _Ip>\n    : public integral_constant<size_t, extent<_Tp, _Ip-1>::value> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp, unsigned _Ip = 0> _LIBCPP_CONSTEXPR size_t extent_v\n    = extent<_Tp, _Ip>::value;\n#endif\n\n// remove_extent\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_extent\n    {typedef _Tp type;};\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_extent<_Tp[]>\n    {typedef _Tp type;};\ntemplate <class _Tp, size_t _Np> struct _LIBCPP_TEMPLATE_VIS remove_extent<_Tp[_Np]>\n    {typedef _Tp type;};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using remove_extent_t = typename remove_extent<_Tp>::type;\n#endif\n\n// remove_all_extents\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_all_extents\n    {typedef _Tp type;};\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_all_extents<_Tp[]>\n    {typedef typename remove_all_extents<_Tp>::type type;};\ntemplate <class _Tp, size_t _Np> struct _LIBCPP_TEMPLATE_VIS remove_all_extents<_Tp[_Np]>\n    {typedef typename remove_all_extents<_Tp>::type type;};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using remove_all_extents_t = typename remove_all_extents<_Tp>::type;\n#endif\n\n// decay\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS decay\n{\nprivate:\n    typedef typename remove_reference<_Tp>::type _Up;\npublic:\n    typedef typename conditional\n                     <\n                         is_array<_Up>::value,\n                         typename remove_extent<_Up>::type*,\n                         typename conditional\n                         <\n                              is_function<_Up>::value,\n                              typename add_pointer<_Up>::type,\n                              typename remove_cv<_Up>::type\n                         >::type\n                     >::type type;\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using decay_t = typename decay<_Tp>::type;\n#endif\n\n// is_abstract\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_abstract\n    : public integral_constant<bool, __is_abstract(_Tp)> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_abstract_v\n    = is_abstract<_Tp>::value;\n#endif\n\n// is_final\n\n#if defined(_LIBCPP_HAS_IS_FINAL)\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS\n__libcpp_is_final : public integral_constant<bool, __is_final(_Tp)> {};\n#else\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS\n__libcpp_is_final : public false_type {};\n#endif\n\n#if defined(_LIBCPP_HAS_IS_FINAL) && _LIBCPP_STD_VER > 11\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS\nis_final : public integral_constant<bool, __is_final(_Tp)> {};\n#endif\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_final_v\n    = is_final<_Tp>::value;\n#endif\n\n// is_base_of\n\n#ifdef _LIBCPP_HAS_IS_BASE_OF\n\ntemplate <class _Bp, class _Dp>\nstruct _LIBCPP_TEMPLATE_VIS is_base_of\n    : public integral_constant<bool, __is_base_of(_Bp, _Dp)> {};\n\n#else  // _LIBCPP_HAS_IS_BASE_OF\n\nnamespace __is_base_of_imp\n{\ntemplate <class _Tp>\nstruct _Dst\n{\n    _Dst(const volatile _Tp &);\n};\ntemplate <class _Tp>\nstruct _Src\n{\n    operator const volatile _Tp &();\n    template <class _Up> operator const _Dst<_Up> &();\n};\ntemplate <size_t> struct __one { typedef char type; };\ntemplate <class _Bp, class _Dp> typename __one<sizeof(_Dst<_Bp>(declval<_Src<_Dp> >()))>::type __test(int);\ntemplate <class _Bp, class _Dp> __two __test(...);\n}\n\ntemplate <class _Bp, class _Dp>\nstruct _LIBCPP_TEMPLATE_VIS is_base_of\n    : public integral_constant<bool, is_class<_Bp>::value &&\n                                     sizeof(__is_base_of_imp::__test<_Bp, _Dp>(0)) == 2> {};\n\n#endif  // _LIBCPP_HAS_IS_BASE_OF\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Bp, class _Dp> _LIBCPP_CONSTEXPR bool is_base_of_v\n    = is_base_of<_Bp, _Dp>::value;\n#endif\n\n// is_convertible\n\n#if __has_feature(is_convertible_to) && !defined(_LIBCPP_USE_IS_CONVERTIBLE_FALLBACK)\n\ntemplate <class _T1, class _T2> struct _LIBCPP_TEMPLATE_VIS is_convertible\n    : public integral_constant<bool, __is_convertible_to(_T1, _T2) &&\n                                     !is_abstract<_T2>::value> {};\n\n#else  // __has_feature(is_convertible_to)\n\nnamespace __is_convertible_imp\n{\ntemplate <class _Tp> void  __test_convert(_Tp);\n\ntemplate <class _From, class _To, class = void>\nstruct __is_convertible_test : public false_type {};\n\ntemplate <class _From, class _To>\nstruct __is_convertible_test<_From, _To,\n    decltype(_VSTD::__is_convertible_imp::__test_convert<_To>(_VSTD::declval<_From>()))> : public true_type\n{};\n\ntemplate <class _Tp, bool _IsArray =    is_array<_Tp>::value,\n                     bool _IsFunction = is_function<_Tp>::value,\n                     bool _IsVoid =     is_void<_Tp>::value>\n                     struct __is_array_function_or_void                          {enum {value = 0};};\ntemplate <class _Tp> struct __is_array_function_or_void<_Tp, true, false, false> {enum {value = 1};};\ntemplate <class _Tp> struct __is_array_function_or_void<_Tp, false, true, false> {enum {value = 2};};\ntemplate <class _Tp> struct __is_array_function_or_void<_Tp, false, false, true> {enum {value = 3};};\n}\n\ntemplate <class _Tp,\n    unsigned = __is_convertible_imp::__is_array_function_or_void<typename remove_reference<_Tp>::type>::value>\nstruct __is_convertible_check\n{\n    static const size_t __v = 0;\n};\n\ntemplate <class _Tp>\nstruct __is_convertible_check<_Tp, 0>\n{\n    static const size_t __v = sizeof(_Tp);\n};\n\ntemplate <class _T1, class _T2,\n    unsigned _T1_is_array_function_or_void = __is_convertible_imp::__is_array_function_or_void<_T1>::value,\n    unsigned _T2_is_array_function_or_void = __is_convertible_imp::__is_array_function_or_void<_T2>::value>\nstruct __is_convertible\n    : public integral_constant<bool,\n        __is_convertible_imp::__is_convertible_test<_T1, _T2>::value\n#if defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)\n         && !(!is_function<_T1>::value && !is_reference<_T1>::value && is_reference<_T2>::value\n              && (!is_const<typename remove_reference<_T2>::type>::value\n                  || is_volatile<typename remove_reference<_T2>::type>::value)\n                  && (is_same<typename remove_cv<_T1>::type,\n                              typename remove_cv<typename remove_reference<_T2>::type>::type>::value\n                      || is_base_of<typename remove_reference<_T2>::type, _T1>::value))\n#endif\n    >\n{};\n\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 0, 1> : public false_type {};\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 1, 1> : public false_type {};\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 2, 1> : public false_type {};\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 3, 1> : public false_type {};\n\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 0, 2> : public false_type {};\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 1, 2> : public false_type {};\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 2, 2> : public false_type {};\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 3, 2> : public false_type {};\n\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 0, 3> : public false_type {};\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 1, 3> : public false_type {};\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 2, 3> : public false_type {};\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 3, 3> : public true_type {};\n\ntemplate <class _T1, class _T2> struct _LIBCPP_TEMPLATE_VIS is_convertible\n    : public __is_convertible<_T1, _T2>\n{\n    static const size_t __complete_check1 = __is_convertible_check<_T1>::__v;\n    static const size_t __complete_check2 = __is_convertible_check<_T2>::__v;\n};\n\n#endif  // __has_feature(is_convertible_to)\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _From, class _To> _LIBCPP_CONSTEXPR bool is_convertible_v\n    = is_convertible<_From, _To>::value;\n#endif\n\n// is_empty\n\n#if __has_feature(is_empty) || (_GNUC_VER >= 407)\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_empty\n    : public integral_constant<bool, __is_empty(_Tp)> {};\n\n#else  // __has_feature(is_empty)\n\ntemplate <class _Tp>\nstruct __is_empty1\n    : public _Tp\n{\n    double __lx;\n};\n\nstruct __is_empty2\n{\n    double __lx;\n};\n\ntemplate <class _Tp, bool = is_class<_Tp>::value>\nstruct __libcpp_empty : public integral_constant<bool, sizeof(__is_empty1<_Tp>) == sizeof(__is_empty2)> {};\n\ntemplate <class _Tp> struct __libcpp_empty<_Tp, false> : public false_type {};\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_empty : public __libcpp_empty<_Tp> {};\n\n#endif  // __has_feature(is_empty)\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_empty_v\n    = is_empty<_Tp>::value;\n#endif\n\n// is_polymorphic\n\n#if __has_feature(is_polymorphic) || defined(_LIBCPP_COMPILER_MSVC)\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_polymorphic\n    : public integral_constant<bool, __is_polymorphic(_Tp)> {};\n\n#else\n\ntemplate<typename _Tp> char &__is_polymorphic_impl(\n    typename enable_if<sizeof((_Tp*)dynamic_cast<const volatile void*>(declval<_Tp*>())) != 0,\n                       int>::type);\ntemplate<typename _Tp> __two &__is_polymorphic_impl(...);\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_polymorphic\n    : public integral_constant<bool, sizeof(__is_polymorphic_impl<_Tp>(0)) == 1> {};\n\n#endif // __has_feature(is_polymorphic)\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_polymorphic_v\n    = is_polymorphic<_Tp>::value;\n#endif\n\n// has_virtual_destructor\n\n#if __has_feature(has_virtual_destructor) || (_GNUC_VER >= 403)\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS has_virtual_destructor\n    : public integral_constant<bool, __has_virtual_destructor(_Tp)> {};\n\n#else\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS has_virtual_destructor\n    : public false_type {};\n\n#endif\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool has_virtual_destructor_v\n    = has_virtual_destructor<_Tp>::value;\n#endif\n\n// alignment_of\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS alignment_of\n    : public integral_constant<size_t, __alignof__(_Tp)> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR size_t alignment_of_v\n    = alignment_of<_Tp>::value;\n#endif\n\n// aligned_storage\n\ntemplate <class _Hp, class _Tp>\nstruct __type_list\n{\n    typedef _Hp _Head;\n    typedef _Tp _Tail;\n};\n\nstruct __nat\n{\n#ifndef _LIBCPP_CXX03_LANG\n    __nat() = delete;\n    __nat(const __nat&) = delete;\n    __nat& operator=(const __nat&) = delete;\n    ~__nat() = delete;\n#endif\n};\n\ntemplate <class _Tp>\nstruct __align_type\n{\n    static const size_t value = alignment_of<_Tp>::value;\n    typedef _Tp type;\n};\n\nstruct __struct_double {long double __lx;};\nstruct __struct_double4 {double __lx[4];};\n\ntypedef\n    __type_list<__align_type<unsigned char>,\n    __type_list<__align_type<unsigned short>,\n    __type_list<__align_type<unsigned int>,\n    __type_list<__align_type<unsigned long>,\n    __type_list<__align_type<unsigned long long>,\n    __type_list<__align_type<double>,\n    __type_list<__align_type<long double>,\n    __type_list<__align_type<__struct_double>,\n    __type_list<__align_type<__struct_double4>,\n    __type_list<__align_type<int*>,\n    __nat\n    > > > > > > > > > > __all_types;\n\ntemplate <class _TL, size_t _Align> struct __find_pod;\n\ntemplate <class _Hp, size_t _Align>\nstruct __find_pod<__type_list<_Hp, __nat>, _Align>\n{\n    typedef typename conditional<\n                             _Align == _Hp::value,\n                             typename _Hp::type,\n                             void\n                         >::type type;\n};\n\ntemplate <class _Hp, class _Tp, size_t _Align>\nstruct __find_pod<__type_list<_Hp, _Tp>, _Align>\n{\n    typedef typename conditional<\n                             _Align == _Hp::value,\n                             typename _Hp::type,\n                             typename __find_pod<_Tp, _Align>::type\n                         >::type type;\n};\n\ntemplate <class _TL, size_t _Len> struct __find_max_align;\n\ntemplate <class _Hp, size_t _Len>\nstruct __find_max_align<__type_list<_Hp, __nat>, _Len> : public integral_constant<size_t, _Hp::value> {};\n\ntemplate <size_t _Len, size_t _A1, size_t _A2>\nstruct __select_align\n{\nprivate:\n    static const size_t __min = _A2 < _A1 ? _A2 : _A1;\n    static const size_t __max = _A1 < _A2 ? _A2 : _A1;\npublic:\n    static const size_t value = _Len < __max ? __min : __max;\n};\n\ntemplate <class _Hp, class _Tp, size_t _Len>\nstruct __find_max_align<__type_list<_Hp, _Tp>, _Len>\n    : public integral_constant<size_t, __select_align<_Len, _Hp::value, __find_max_align<_Tp, _Len>::value>::value> {};\n\ntemplate <size_t _Len, size_t _Align = __find_max_align<__all_types, _Len>::value>\nstruct _LIBCPP_TEMPLATE_VIS aligned_storage\n{\n    typedef typename __find_pod<__all_types, _Align>::type _Aligner;\n    static_assert(!is_void<_Aligner>::value, \"\");\n    union type\n    {\n        _Aligner __align;\n        unsigned char __data[(_Len + _Align - 1)/_Align * _Align];\n    };\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <size_t _Len, size_t _Align = __find_max_align<__all_types, _Len>::value>\n    using aligned_storage_t = typename aligned_storage<_Len, _Align>::type;\n#endif\n\n#define _CREATE_ALIGNED_STORAGE_SPECIALIZATION(n) \\\ntemplate <size_t _Len>\\\nstruct _LIBCPP_TEMPLATE_VIS aligned_storage<_Len, n>\\\n{\\\n    struct _ALIGNAS(n) type\\\n    {\\\n        unsigned char __lx[(_Len + n - 1)/n * n];\\\n    };\\\n}\n\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x1);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x2);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x4);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x8);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x10);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x20);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x40);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x80);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x100);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x200);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x400);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x800);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x1000);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x2000);\n// PE/COFF does not support alignment beyond 8192 (=0x2000)\n#if !defined(_LIBCPP_OBJECT_FORMAT_COFF)\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x4000);\n#endif // !defined(_LIBCPP_OBJECT_FORMAT_COFF)\n\n#undef _CREATE_ALIGNED_STORAGE_SPECIALIZATION\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n// aligned_union\n\ntemplate <size_t _I0, size_t ..._In>\nstruct __static_max;\n\ntemplate <size_t _I0>\nstruct __static_max<_I0>\n{\n    static const size_t value = _I0;\n};\n\ntemplate <size_t _I0, size_t _I1, size_t ..._In>\nstruct __static_max<_I0, _I1, _In...>\n{\n    static const size_t value = _I0 >= _I1 ? __static_max<_I0, _In...>::value :\n                                             __static_max<_I1, _In...>::value;\n};\n\ntemplate <size_t _Len, class _Type0, class ..._Types>\nstruct aligned_union\n{\n    static const size_t alignment_value = __static_max<__alignof__(_Type0),\n                                                       __alignof__(_Types)...>::value;\n    static const size_t __len = __static_max<_Len, sizeof(_Type0),\n                                             sizeof(_Types)...>::value;\n    typedef typename aligned_storage<__len, alignment_value>::type type;\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <size_t _Len, class ..._Types> using aligned_union_t = typename aligned_union<_Len, _Types...>::type;\n#endif\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Tp>\nstruct __numeric_type\n{\n   static void __test(...);\n   static float __test(float);\n   static double __test(char);\n   static double __test(int);\n   static double __test(unsigned);\n   static double __test(long);\n   static double __test(unsigned long);\n   static double __test(long long);\n   static double __test(unsigned long long);\n   static double __test(double);\n   static long double __test(long double);\n\n   typedef decltype(__test(declval<_Tp>())) type;\n   static const bool value = !is_same<type, void>::value;\n};\n\ntemplate <>\nstruct __numeric_type<void>\n{\n   static const bool value = true;\n};\n\n// __promote\n\ntemplate <class _A1, class _A2 = void, class _A3 = void,\n          bool = __numeric_type<_A1>::value &&\n                 __numeric_type<_A2>::value &&\n                 __numeric_type<_A3>::value>\nclass __promote_imp\n{\npublic:\n    static const bool value = false;\n};\n\ntemplate <class _A1, class _A2, class _A3>\nclass __promote_imp<_A1, _A2, _A3, true>\n{\nprivate:\n    typedef typename __promote_imp<_A1>::type __type1;\n    typedef typename __promote_imp<_A2>::type __type2;\n    typedef typename __promote_imp<_A3>::type __type3;\npublic:\n    typedef decltype(__type1() + __type2() + __type3()) type;\n    static const bool value = true;\n};\n\ntemplate <class _A1, class _A2>\nclass __promote_imp<_A1, _A2, void, true>\n{\nprivate:\n    typedef typename __promote_imp<_A1>::type __type1;\n    typedef typename __promote_imp<_A2>::type __type2;\npublic:\n    typedef decltype(__type1() + __type2()) type;\n    static const bool value = true;\n};\n\ntemplate <class _A1>\nclass __promote_imp<_A1, void, void, true>\n{\npublic:\n    typedef typename __numeric_type<_A1>::type type;\n    static const bool value = true;\n};\n\ntemplate <class _A1, class _A2 = void, class _A3 = void>\nclass __promote : public __promote_imp<_A1, _A2, _A3> {};\n\n// make_signed / make_unsigned\n\ntypedef\n    __type_list<signed char,\n    __type_list<signed short,\n    __type_list<signed int,\n    __type_list<signed long,\n    __type_list<signed long long,\n#ifndef _LIBCPP_HAS_NO_INT128\n    __type_list<__int128_t,\n#endif\n    __nat\n#ifndef _LIBCPP_HAS_NO_INT128\n    >\n#endif\n    > > > > > __signed_types;\n\ntypedef\n    __type_list<unsigned char,\n    __type_list<unsigned short,\n    __type_list<unsigned int,\n    __type_list<unsigned long,\n    __type_list<unsigned long long,\n#ifndef _LIBCPP_HAS_NO_INT128\n    __type_list<__uint128_t,\n#endif\n    __nat\n#ifndef _LIBCPP_HAS_NO_INT128\n    >\n#endif\n    > > > > > __unsigned_types;\n\ntemplate <class _TypeList, size_t _Size, bool = _Size <= sizeof(typename _TypeList::_Head)> struct __find_first;\n\ntemplate <class _Hp, class _Tp, size_t _Size>\nstruct __find_first<__type_list<_Hp, _Tp>, _Size, true>\n{\n    typedef _Hp type;\n};\n\ntemplate <class _Hp, class _Tp, size_t _Size>\nstruct __find_first<__type_list<_Hp, _Tp>, _Size, false>\n{\n    typedef typename __find_first<_Tp, _Size>::type type;\n};\n\ntemplate <class _Tp, class _Up, bool = is_const<typename remove_reference<_Tp>::type>::value,\n                             bool = is_volatile<typename remove_reference<_Tp>::type>::value>\nstruct __apply_cv\n{\n    typedef _Up type;\n};\n\ntemplate <class _Tp, class _Up>\nstruct __apply_cv<_Tp, _Up, true, false>\n{\n    typedef const _Up type;\n};\n\ntemplate <class _Tp, class _Up>\nstruct __apply_cv<_Tp, _Up, false, true>\n{\n    typedef volatile _Up type;\n};\n\ntemplate <class _Tp, class _Up>\nstruct __apply_cv<_Tp, _Up, true, true>\n{\n    typedef const volatile _Up type;\n};\n\ntemplate <class _Tp, class _Up>\nstruct __apply_cv<_Tp&, _Up, false, false>\n{\n    typedef _Up& type;\n};\n\ntemplate <class _Tp, class _Up>\nstruct __apply_cv<_Tp&, _Up, true, false>\n{\n    typedef const _Up& type;\n};\n\ntemplate <class _Tp, class _Up>\nstruct __apply_cv<_Tp&, _Up, false, true>\n{\n    typedef volatile _Up& type;\n};\n\ntemplate <class _Tp, class _Up>\nstruct __apply_cv<_Tp&, _Up, true, true>\n{\n    typedef const volatile _Up& type;\n};\n\ntemplate <class _Tp, bool = is_integral<_Tp>::value || is_enum<_Tp>::value>\nstruct __make_signed {};\n\ntemplate <class _Tp>\nstruct __make_signed<_Tp, true>\n{\n    typedef typename __find_first<__signed_types, sizeof(_Tp)>::type type;\n};\n\ntemplate <> struct __make_signed<bool,               true> {};\ntemplate <> struct __make_signed<  signed short,     true> {typedef short     type;};\ntemplate <> struct __make_signed<unsigned short,     true> {typedef short     type;};\ntemplate <> struct __make_signed<  signed int,       true> {typedef int       type;};\ntemplate <> struct __make_signed<unsigned int,       true> {typedef int       type;};\ntemplate <> struct __make_signed<  signed long,      true> {typedef long      type;};\ntemplate <> struct __make_signed<unsigned long,      true> {typedef long      type;};\ntemplate <> struct __make_signed<  signed long long, true> {typedef long long type;};\ntemplate <> struct __make_signed<unsigned long long, true> {typedef long long type;};\n#ifndef _LIBCPP_HAS_NO_INT128\ntemplate <> struct __make_signed<__int128_t,         true> {typedef __int128_t type;};\ntemplate <> struct __make_signed<__uint128_t,        true> {typedef __int128_t type;};\n#endif\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS make_signed\n{\n    typedef typename __apply_cv<_Tp, typename __make_signed<typename remove_cv<_Tp>::type>::type>::type type;\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using make_signed_t = typename make_signed<_Tp>::type;\n#endif\n\ntemplate <class _Tp, bool = is_integral<_Tp>::value || is_enum<_Tp>::value>\nstruct __make_unsigned {};\n\ntemplate <class _Tp>\nstruct __make_unsigned<_Tp, true>\n{\n    typedef typename __find_first<__unsigned_types, sizeof(_Tp)>::type type;\n};\n\ntemplate <> struct __make_unsigned<bool,               true> {};\ntemplate <> struct __make_unsigned<  signed short,     true> {typedef unsigned short     type;};\ntemplate <> struct __make_unsigned<unsigned short,     true> {typedef unsigned short     type;};\ntemplate <> struct __make_unsigned<  signed int,       true> {typedef unsigned int       type;};\ntemplate <> struct __make_unsigned<unsigned int,       true> {typedef unsigned int       type;};\ntemplate <> struct __make_unsigned<  signed long,      true> {typedef unsigned long      type;};\ntemplate <> struct __make_unsigned<unsigned long,      true> {typedef unsigned long      type;};\ntemplate <> struct __make_unsigned<  signed long long, true> {typedef unsigned long long type;};\ntemplate <> struct __make_unsigned<unsigned long long, true> {typedef unsigned long long type;};\n#ifndef _LIBCPP_HAS_NO_INT128\ntemplate <> struct __make_unsigned<__int128_t,         true> {typedef __uint128_t        type;};\ntemplate <> struct __make_unsigned<__uint128_t,        true> {typedef __uint128_t        type;};\n#endif\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS make_unsigned\n{\n    typedef typename __apply_cv<_Tp, typename __make_unsigned<typename remove_cv<_Tp>::type>::type>::type type;\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using make_unsigned_t = typename make_unsigned<_Tp>::type;\n#endif\n\n#ifdef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Tp, class _Up = void, class _Vp = void>\nstruct _LIBCPP_TEMPLATE_VIS common_type\n{\npublic:\n    typedef typename common_type<typename common_type<_Tp, _Up>::type, _Vp>::type type;\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS common_type<_Tp, void, void>\n{\npublic:\n    typedef typename decay<_Tp>::type type;\n};\n\ntemplate <class _Tp, class _Up>\nstruct _LIBCPP_TEMPLATE_VIS common_type<_Tp, _Up, void>\n{\n    typedef typename decay<decltype(\n        true ? _VSTD::declval<_Tp>() : _VSTD::declval<_Up>()\n      )>::type type;\n};\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\n// bullet 1 - sizeof...(Tp) == 0\n\ntemplate <class ..._Tp>\nstruct _LIBCPP_TEMPLATE_VIS common_type {};\n\n// bullet 2 - sizeof...(Tp) == 1\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS common_type<_Tp>\n{\n    typedef typename decay<_Tp>::type type;\n};\n\n// bullet 3 - sizeof...(Tp) == 2\n\ntemplate <class _Tp, class _Up, class = void>\nstruct __common_type2_imp {};\n\ntemplate <class _Tp, class _Up>\nstruct __common_type2_imp<_Tp, _Up,\n    typename __void_t<decltype(\n        true ? _VSTD::declval<_Tp>() : _VSTD::declval<_Up>()\n    )>::type>\n{\n    typedef typename decay<decltype(\n        true ? _VSTD::declval<_Tp>() : _VSTD::declval<_Up>()\n    )>::type type;\n};\n\ntemplate <class _Tp, class _Up,\n          class _DTp = typename decay<_Tp>::type,\n          class _DUp = typename decay<_Up>::type>\nusing __common_type2 =\n  typename conditional<\n    is_same<_Tp, _DTp>::value && is_same<_Up, _DUp>::value,\n    __common_type2_imp<_Tp, _Up>,\n    common_type<_DTp, _DUp>\n  >::type;\n\ntemplate <class _Tp, class _Up>\nstruct _LIBCPP_TEMPLATE_VIS common_type<_Tp, _Up>\n    : __common_type2<_Tp, _Up> {};\n\n// bullet 4 - sizeof...(Tp) > 2\n\ntemplate <class ...Tp> struct __common_types;\n\ntemplate <class, class = void>\nstruct __common_type_impl {};\n\ntemplate <class _Tp, class _Up>\nstruct __common_type_impl<\n    __common_types<_Tp, _Up>,\n    typename __void_t<typename common_type<_Tp, _Up>::type>::type>\n{\n  typedef typename common_type<_Tp, _Up>::type type;\n};\n\ntemplate <class _Tp, class _Up, class ..._Vp>\nstruct __common_type_impl<__common_types<_Tp, _Up, _Vp...>,\n    typename __void_t<typename common_type<_Tp, _Up>::type>::type>\n  : __common_type_impl<\n      __common_types<typename common_type<_Tp, _Up>::type, _Vp...> >\n{\n\n};\n\ntemplate <class _Tp, class _Up, class ..._Vp>\nstruct _LIBCPP_TEMPLATE_VIS common_type<_Tp, _Up, _Vp...>\n    : __common_type_impl<__common_types<_Tp, _Up, _Vp...> > {};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class ..._Tp> using common_type_t = typename common_type<_Tp...>::type;\n#endif\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n// is_assignable\n\ntemplate<typename, typename _Tp> struct __select_2nd { typedef _Tp type; };\n\ntemplate <class _Tp, class _Arg>\ntypename __select_2nd<decltype((_VSTD::declval<_Tp>() = _VSTD::declval<_Arg>())), true_type>::type\n__is_assignable_test(int);\n\ntemplate <class, class>\nfalse_type __is_assignable_test(...);\n\n\ntemplate <class _Tp, class _Arg, bool = is_void<_Tp>::value || is_void<_Arg>::value>\nstruct __is_assignable_imp\n    : public decltype((_VSTD::__is_assignable_test<_Tp, _Arg>(0))) {};\n\ntemplate <class _Tp, class _Arg>\nstruct __is_assignable_imp<_Tp, _Arg, true>\n    : public false_type\n{\n};\n\ntemplate <class _Tp, class _Arg>\nstruct is_assignable\n    : public __is_assignable_imp<_Tp, _Arg> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp, class _Arg> _LIBCPP_CONSTEXPR bool is_assignable_v\n    = is_assignable<_Tp, _Arg>::value;\n#endif\n\n// is_copy_assignable\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_copy_assignable\n    : public is_assignable<typename add_lvalue_reference<_Tp>::type,\n                  typename add_lvalue_reference<typename add_const<_Tp>::type>::type> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_copy_assignable_v\n    = is_copy_assignable<_Tp>::value;\n#endif\n\n// is_move_assignable\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_move_assignable\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    : public is_assignable<typename add_lvalue_reference<_Tp>::type,\n                           typename add_rvalue_reference<_Tp>::type> {};\n#else\n    : public is_copy_assignable<_Tp> {};\n#endif\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_move_assignable_v\n    = is_move_assignable<_Tp>::value;\n#endif\n\n// is_destructible\n\n//  if it's a reference, return true\n//  if it's a function, return false\n//  if it's   void,     return false\n//  if it's an array of unknown bound, return false\n//  Otherwise, return \"std::declval<_Up&>().~_Up()\" is well-formed\n//    where _Up is remove_all_extents<_Tp>::type\n\ntemplate <class>\nstruct __is_destructible_apply { typedef int type; };\n\ntemplate <typename _Tp>\nstruct __is_destructor_wellformed {\n    template <typename _Tp1>\n    static char  __test (\n        typename __is_destructible_apply<decltype(_VSTD::declval<_Tp1&>().~_Tp1())>::type\n    );\n\n    template <typename _Tp1>\n    static __two __test (...);\n    \n    static const bool value = sizeof(__test<_Tp>(12)) == sizeof(char);\n};\n\ntemplate <class _Tp, bool>\nstruct __destructible_imp;\n\ntemplate <class _Tp>\nstruct __destructible_imp<_Tp, false> \n   : public _VSTD::integral_constant<bool, \n        __is_destructor_wellformed<typename _VSTD::remove_all_extents<_Tp>::type>::value> {};\n\ntemplate <class _Tp>\nstruct __destructible_imp<_Tp, true>\n    : public _VSTD::true_type {};\n\ntemplate <class _Tp, bool>\nstruct __destructible_false;\n\ntemplate <class _Tp>\nstruct __destructible_false<_Tp, false> : public __destructible_imp<_Tp, _VSTD::is_reference<_Tp>::value> {};\n\ntemplate <class _Tp>\nstruct __destructible_false<_Tp, true> : public _VSTD::false_type {};\n\ntemplate <class _Tp>\nstruct is_destructible\n    : public __destructible_false<_Tp, _VSTD::is_function<_Tp>::value> {};\n\ntemplate <class _Tp>\nstruct is_destructible<_Tp[]>\n    : public _VSTD::false_type {};\n\ntemplate <>\nstruct is_destructible<void>\n    : public _VSTD::false_type {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_destructible_v\n    = is_destructible<_Tp>::value;\n#endif\n\n// move\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR\ntypename remove_reference<_Tp>::type&&\nmove(_Tp&& __t) _NOEXCEPT\n{\n    typedef typename remove_reference<_Tp>::type _Up;\n    return static_cast<_Up&&>(__t);\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR\n_Tp&&\nforward(typename remove_reference<_Tp>::type& __t) _NOEXCEPT\n{\n    return static_cast<_Tp&&>(__t);\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR\n_Tp&&\nforward(typename remove_reference<_Tp>::type&& __t) _NOEXCEPT\n{\n    static_assert(!is_lvalue_reference<_Tp>::value,\n                  \"can not forward an rvalue as an lvalue\");\n    return static_cast<_Tp&&>(__t);\n}\n\n#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_Tp&\nmove(_Tp& __t)\n{\n    return __t;\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nconst _Tp&\nmove(const _Tp& __t)\n{\n    return __t;\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_Tp&\nforward(typename remove_reference<_Tp>::type& __t) _NOEXCEPT\n{\n    return __t;\n}\n\n\ntemplate <class _Tp>\nclass __rv\n{\n    typedef typename remove_reference<_Tp>::type _Trr;\n    _Trr& t_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    _Trr* operator->() {return &t_;}\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __rv(_Trr& __t) : t_(__t) {}\n};\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename decay<_Tp>::type\n__decay_copy(_Tp&& __t)\n{\n    return _VSTD::forward<_Tp>(__t);\n}\n\n#else\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename decay<_Tp>::type\n__decay_copy(const _Tp& __t)\n{\n    return _VSTD::forward<_Tp>(__t);\n}\n\n#endif\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...), true, false>\n{\n    typedef _Class _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...), true, false>\n{\n    typedef _Class _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param..., ...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const, true, false>\n{\n    typedef _Class const _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const, true, false>\n{\n    typedef _Class const _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param..., ...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) volatile, true, false>\n{\n    typedef _Class volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) volatile, true, false>\n{\n    typedef _Class volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param..., ...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const volatile, true, false>\n{\n    typedef _Class const volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const volatile, true, false>\n{\n    typedef _Class const volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param..., ...);\n};\n\n#if __has_feature(cxx_reference_qualified_functions) || \\\n    (defined(_GNUC_VER) && _GNUC_VER >= 409)\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) &, true, false>\n{\n    typedef _Class& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) &, true, false>\n{\n    typedef _Class& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param..., ...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const&, true, false>\n{\n    typedef _Class const& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const&, true, false>\n{\n    typedef _Class const& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param..., ...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) volatile&, true, false>\n{\n    typedef _Class volatile& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) volatile&, true, false>\n{\n    typedef _Class volatile& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param..., ...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const volatile&, true, false>\n{\n    typedef _Class const volatile& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const volatile&, true, false>\n{\n    typedef _Class const volatile& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param..., ...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) &&, true, false>\n{\n    typedef _Class&& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) &&, true, false>\n{\n    typedef _Class&& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param..., ...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const&&, true, false>\n{\n    typedef _Class const&& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const&&, true, false>\n{\n    typedef _Class const&& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param..., ...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) volatile&&, true, false>\n{\n    typedef _Class volatile&& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) volatile&&, true, false>\n{\n    typedef _Class volatile&& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param..., ...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const volatile&&, true, false>\n{\n    typedef _Class const volatile&& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const volatile&&, true, false>\n{\n    typedef _Class const volatile&& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param..., ...);\n};\n\n#endif  // __has_feature(cxx_reference_qualified_functions) || _GNUC_VER >= 409\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Rp, class _Class>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(), true, false>\n{\n    typedef _Class _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) ();\n};\n\ntemplate <class _Rp, class _Class>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(...), true, false>\n{\n    typedef _Class _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (...);\n};\n\ntemplate <class _Rp, class _Class, class _P0>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0), true, false>\n{\n    typedef _Class _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0);\n};\n\ntemplate <class _Rp, class _Class, class _P0>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, ...), true, false>\n{\n    typedef _Class _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, ...);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1), true, false>\n{\n    typedef _Class _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, ...), true, false>\n{\n    typedef _Class _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1, ...);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1, class _P2>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, _P2), true, false>\n{\n    typedef _Class _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1, _P2);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1, class _P2>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, _P2, ...), true, false>\n{\n    typedef _Class _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1, _P2, ...);\n};\n\ntemplate <class _Rp, class _Class>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)() const, true, false>\n{\n    typedef _Class const _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) ();\n};\n\ntemplate <class _Rp, class _Class>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(...) const, true, false>\n{\n    typedef _Class const _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (...);\n};\n\ntemplate <class _Rp, class _Class, class _P0>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0) const, true, false>\n{\n    typedef _Class const _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0);\n};\n\ntemplate <class _Rp, class _Class, class _P0>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, ...) const, true, false>\n{\n    typedef _Class const _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, ...);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1) const, true, false>\n{\n    typedef _Class const _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, ...) const, true, false>\n{\n    typedef _Class const _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1, ...);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1, class _P2>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, _P2) const, true, false>\n{\n    typedef _Class const _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1, _P2);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1, class _P2>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, _P2, ...) const, true, false>\n{\n    typedef _Class const _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1, _P2, ...);\n};\n\ntemplate <class _Rp, class _Class>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)() volatile, true, false>\n{\n    typedef _Class volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) ();\n};\n\ntemplate <class _Rp, class _Class>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(...) volatile, true, false>\n{\n    typedef _Class volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (...);\n};\n\ntemplate <class _Rp, class _Class, class _P0>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0) volatile, true, false>\n{\n    typedef _Class volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0);\n};\n\ntemplate <class _Rp, class _Class, class _P0>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, ...) volatile, true, false>\n{\n    typedef _Class volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, ...);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1) volatile, true, false>\n{\n    typedef _Class volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, ...) volatile, true, false>\n{\n    typedef _Class volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1, ...);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1, class _P2>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, _P2) volatile, true, false>\n{\n    typedef _Class volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1, _P2);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1, class _P2>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, _P2, ...) volatile, true, false>\n{\n    typedef _Class volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1, _P2, ...);\n};\n\ntemplate <class _Rp, class _Class>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)() const volatile, true, false>\n{\n    typedef _Class const volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) ();\n};\n\ntemplate <class _Rp, class _Class>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(...) const volatile, true, false>\n{\n    typedef _Class const volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (...);\n};\n\ntemplate <class _Rp, class _Class, class _P0>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0) const volatile, true, false>\n{\n    typedef _Class const volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0);\n};\n\ntemplate <class _Rp, class _Class, class _P0>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, ...) const volatile, true, false>\n{\n    typedef _Class const volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, ...);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1) const volatile, true, false>\n{\n    typedef _Class const volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, ...) const volatile, true, false>\n{\n    typedef _Class const volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1, ...);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1, class _P2>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, _P2) const volatile, true, false>\n{\n    typedef _Class const volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1, _P2);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1, class _P2>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, _P2, ...) const volatile, true, false>\n{\n    typedef _Class const volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1, _P2, ...);\n};\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Rp, class _Class>\nstruct __member_pointer_traits_imp<_Rp _Class::*, false, true>\n{\n    typedef _Class _ClassType;\n    typedef _Rp _ReturnType;\n};\n\ntemplate <class _MP>\nstruct __member_pointer_traits\n    : public __member_pointer_traits_imp<typename remove_cv<_MP>::type,\n                    is_member_function_pointer<_MP>::value,\n                    is_member_object_pointer<_MP>::value>\n{\n//     typedef ... _ClassType;\n//     typedef ... _ReturnType;\n//     typedef ... _FnType;\n};\n\n\ntemplate <class _DecayedFp>\nstruct __member_pointer_class_type {};\n\ntemplate <class _Ret, class _ClassType>\nstruct __member_pointer_class_type<_Ret _ClassType::*> {\n  typedef _ClassType type;\n};\n\n// result_of\n\ntemplate <class _Callable> class result_of;\n\n#ifdef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Fn, bool, bool>\nclass __result_of\n{\n};\n\ntemplate <class _Fn>\nclass __result_of<_Fn(), true, false>\n{\npublic:\n    typedef decltype(declval<_Fn>()()) type;\n};\n\ntemplate <class _Fn, class _A0>\nclass __result_of<_Fn(_A0), true, false>\n{\npublic:\n    typedef decltype(declval<_Fn>()(declval<_A0>())) type;\n};\n\ntemplate <class _Fn, class _A0, class _A1>\nclass __result_of<_Fn(_A0, _A1), true, false>\n{\npublic:\n    typedef decltype(declval<_Fn>()(declval<_A0>(), declval<_A1>())) type;\n};\n\ntemplate <class _Fn, class _A0, class _A1, class _A2>\nclass __result_of<_Fn(_A0, _A1, _A2), true, false>\n{\npublic:\n    typedef decltype(declval<_Fn>()(declval<_A0>(), declval<_A1>(), declval<_A2>())) type;\n};\n\ntemplate <class _MP, class _Tp, bool _IsMemberFunctionPtr>\nstruct __result_of_mp;\n\n// member function pointer\n\ntemplate <class _MP, class _Tp>\nstruct __result_of_mp<_MP, _Tp, true>\n    : public __identity<typename __member_pointer_traits<_MP>::_ReturnType>\n{\n};\n\n// member data pointer\n\ntemplate <class _MP, class _Tp, bool>\nstruct __result_of_mdp;\n\ntemplate <class _Rp, class _Class, class _Tp>\nstruct __result_of_mdp<_Rp _Class::*, _Tp, false>\n{\n    typedef typename __apply_cv<decltype(*_VSTD::declval<_Tp>()), _Rp>::type& type;\n};\n\ntemplate <class _Rp, class _Class, class _Tp>\nstruct __result_of_mdp<_Rp _Class::*, _Tp, true>\n{\n    typedef typename __apply_cv<_Tp, _Rp>::type& type;\n};\n\ntemplate <class _Rp, class _Class, class _Tp>\nstruct __result_of_mp<_Rp _Class::*, _Tp, false>\n    : public __result_of_mdp<_Rp _Class::*, _Tp,\n            is_base_of<_Class, typename remove_reference<_Tp>::type>::value>\n{\n};\n\n\n\ntemplate <class _Fn, class _Tp>\nclass __result_of<_Fn(_Tp), false, true>  // _Fn must be member pointer\n    : public __result_of_mp<typename remove_reference<_Fn>::type,\n                            _Tp,\n                            is_member_function_pointer<typename remove_reference<_Fn>::type>::value>\n{\n};\n\ntemplate <class _Fn, class _Tp, class _A0>\nclass __result_of<_Fn(_Tp, _A0), false, true>  // _Fn must be member pointer\n    : public __result_of_mp<typename remove_reference<_Fn>::type,\n                            _Tp,\n                            is_member_function_pointer<typename remove_reference<_Fn>::type>::value>\n{\n};\n\ntemplate <class _Fn, class _Tp, class _A0, class _A1>\nclass __result_of<_Fn(_Tp, _A0, _A1), false, true>  // _Fn must be member pointer\n    : public __result_of_mp<typename remove_reference<_Fn>::type,\n                            _Tp,\n                            is_member_function_pointer<typename remove_reference<_Fn>::type>::value>\n{\n};\n\ntemplate <class _Fn, class _Tp, class _A0, class _A1, class _A2>\nclass __result_of<_Fn(_Tp, _A0, _A1, _A2), false, true>  // _Fn must be member pointer\n    : public __result_of_mp<typename remove_reference<_Fn>::type,\n                            _Tp,\n                            is_member_function_pointer<typename remove_reference<_Fn>::type>::value>\n{\n};\n\n// result_of\n\ntemplate <class _Fn>\nclass _LIBCPP_TEMPLATE_VIS result_of<_Fn()>\n    : public __result_of<_Fn(),\n                         is_class<typename remove_reference<_Fn>::type>::value ||\n                         is_function<typename remove_pointer<typename remove_reference<_Fn>::type>::type>::value,\n                         is_member_pointer<typename remove_reference<_Fn>::type>::value\n                        >\n{\n};\n\ntemplate <class _Fn, class _A0>\nclass _LIBCPP_TEMPLATE_VIS result_of<_Fn(_A0)>\n    : public __result_of<_Fn(_A0),\n                         is_class<typename remove_reference<_Fn>::type>::value ||\n                         is_function<typename remove_pointer<typename remove_reference<_Fn>::type>::type>::value,\n                         is_member_pointer<typename remove_reference<_Fn>::type>::value\n                        >\n{\n};\n\ntemplate <class _Fn, class _A0, class _A1>\nclass _LIBCPP_TEMPLATE_VIS result_of<_Fn(_A0, _A1)>\n    : public __result_of<_Fn(_A0, _A1),\n                         is_class<typename remove_reference<_Fn>::type>::value ||\n                         is_function<typename remove_pointer<typename remove_reference<_Fn>::type>::type>::value,\n                         is_member_pointer<typename remove_reference<_Fn>::type>::value\n                        >\n{\n};\n\ntemplate <class _Fn, class _A0, class _A1, class _A2>\nclass _LIBCPP_TEMPLATE_VIS result_of<_Fn(_A0, _A1, _A2)>\n    : public __result_of<_Fn(_A0, _A1, _A2),\n                         is_class<typename remove_reference<_Fn>::type>::value ||\n                         is_function<typename remove_pointer<typename remove_reference<_Fn>::type>::type>::value,\n                         is_member_pointer<typename remove_reference<_Fn>::type>::value\n                        >\n{\n};\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n// template <class T, class... Args> struct is_constructible;\n\nnamespace __is_construct\n{\nstruct __nat {};\n}\n\n#if !defined(_LIBCPP_CXX03_LANG) && (!__has_feature(is_constructible) || \\\n    defined(_LIBCPP_TESTING_FALLBACK_IS_CONSTRUCTIBLE))\n\ntemplate <class _Tp, class... _Args>\nstruct __libcpp_is_constructible;\n\ntemplate <class _To, class _From>\nstruct __is_invalid_base_to_derived_cast {\n  static_assert(is_reference<_To>::value, \"Wrong specialization\");\n  using _RawFrom = __uncvref_t<_From>;\n  using _RawTo = __uncvref_t<_To>;\n  static const bool value = __lazy_and<\n        __lazy_not<is_same<_RawFrom, _RawTo>>,\n        is_base_of<_RawFrom, _RawTo>,\n        __lazy_not<__libcpp_is_constructible<_RawTo, _From>>\n  >::value;\n};\n\ntemplate <class _To, class _From>\nstruct __is_invalid_lvalue_to_rvalue_cast : false_type {\n  static_assert(is_reference<_To>::value, \"Wrong specialization\");\n};\n\ntemplate <class _ToRef, class _FromRef>\nstruct __is_invalid_lvalue_to_rvalue_cast<_ToRef&&, _FromRef&> {\n  using _RawFrom = __uncvref_t<_FromRef>;\n  using _RawTo = __uncvref_t<_ToRef>;\n  static const bool value = __lazy_and<\n      __lazy_not<is_function<_RawTo>>,\n      __lazy_or<\n        is_same<_RawFrom, _RawTo>,\n        is_base_of<_RawTo, _RawFrom>>\n    >::value;\n};\n\nstruct __is_constructible_helper\n{\n    template <class _To>\n    static void __eat(_To);\n\n    // This overload is needed to work around a Clang bug that disallows\n    // static_cast<T&&>(e) for non-reference-compatible types.\n    // Example: static_cast<int&&>(declval<double>());\n    // NOTE: The static_cast implementation below is required to support\n    //  classes with explicit conversion operators.\n    template <class _To, class _From,\n              class = decltype(__eat<_To>(_VSTD::declval<_From>()))>\n    static true_type __test_cast(int);\n\n    template <class _To, class _From,\n              class = decltype(static_cast<_To>(_VSTD::declval<_From>()))>\n    static integral_constant<bool,\n        !__is_invalid_base_to_derived_cast<_To, _From>::value &&\n        !__is_invalid_lvalue_to_rvalue_cast<_To, _From>::value\n    > __test_cast(long);\n\n    template <class, class>\n    static false_type __test_cast(...);\n\n    template <class _Tp, class ..._Args,\n        class = decltype(_Tp(_VSTD::declval<_Args>()...))>\n    static true_type __test_nary(int);\n    template <class _Tp, class...>\n    static false_type __test_nary(...);\n\n    template <class _Tp, class _A0, class = decltype(::new _Tp(_VSTD::declval<_A0>()))>\n    static is_destructible<_Tp> __test_unary(int);\n    template <class, class>\n    static false_type __test_unary(...);\n};\n\ntemplate <class _Tp, bool = is_void<_Tp>::value>\nstruct __is_default_constructible\n    : decltype(__is_constructible_helper::__test_nary<_Tp>(0))\n{};\n\ntemplate <class _Tp>\nstruct __is_default_constructible<_Tp, true> : false_type {};\n\ntemplate <class _Tp>\nstruct __is_default_constructible<_Tp[], false> : false_type {};\n\ntemplate <class _Tp, size_t _Nx>\nstruct __is_default_constructible<_Tp[_Nx], false>\n    : __is_default_constructible<typename remove_all_extents<_Tp>::type>  {};\n\ntemplate <class _Tp, class... _Args>\nstruct __libcpp_is_constructible\n{\n  static_assert(sizeof...(_Args) > 1, \"Wrong specialization\");\n  typedef decltype(__is_constructible_helper::__test_nary<_Tp, _Args...>(0))\n      type;\n};\n\ntemplate <class _Tp>\nstruct __libcpp_is_constructible<_Tp> : __is_default_constructible<_Tp> {};\n\ntemplate <class _Tp, class _A0>\nstruct __libcpp_is_constructible<_Tp, _A0>\n    : public decltype(__is_constructible_helper::__test_unary<_Tp, _A0>(0))\n{};\n\ntemplate <class _Tp, class _A0>\nstruct __libcpp_is_constructible<_Tp&, _A0>\n    : public decltype(__is_constructible_helper::\n    __test_cast<_Tp&, _A0>(0))\n{};\n\ntemplate <class _Tp, class _A0>\nstruct __libcpp_is_constructible<_Tp&&, _A0>\n    : public decltype(__is_constructible_helper::\n    __test_cast<_Tp&&, _A0>(0))\n{};\n\n#endif\n\n#if __has_feature(is_constructible)\ntemplate <class _Tp, class ..._Args>\nstruct _LIBCPP_TEMPLATE_VIS is_constructible\n    : public integral_constant<bool, __is_constructible(_Tp, _Args...)>\n    {};\n#elif !defined(_LIBCPP_CXX03_LANG)\ntemplate <class _Tp, class... _Args>\nstruct _LIBCPP_TEMPLATE_VIS is_constructible\n    : public __libcpp_is_constructible<_Tp, _Args...>::type {};\n#else\n// template <class T> struct is_constructible0;\n\n//      main is_constructible0 test\n\ntemplate <class _Tp>\ndecltype((_Tp(), true_type()))\n__is_constructible0_test(_Tp&);\n\nfalse_type\n__is_constructible0_test(__any);\n\ntemplate <class _Tp, class _A0>\ndecltype((_Tp(_VSTD::declval<_A0>()), true_type()))\n__is_constructible1_test(_Tp&, _A0&);\n\ntemplate <class _A0>\nfalse_type\n__is_constructible1_test(__any, _A0&);\n\ntemplate <class _Tp, class _A0, class _A1>\ndecltype((_Tp(_VSTD::declval<_A0>(), _VSTD::declval<_A1>()), true_type()))\n__is_constructible2_test(_Tp&, _A0&, _A1&);\n\ntemplate <class _A0, class _A1>\nfalse_type\n__is_constructible2_test(__any, _A0&, _A1&);\n\ntemplate <bool, class _Tp>\nstruct __is_constructible0_imp // false, _Tp is not a scalar\n    : public common_type\n             <\n                 decltype(__is_constructible0_test(declval<_Tp&>()))\n             >::type\n    {};\n\ntemplate <bool, class _Tp, class _A0>\nstruct __is_constructible1_imp // false, _Tp is not a scalar\n    : public common_type\n             <\n                 decltype(__is_constructible1_test(declval<_Tp&>(), declval<_A0&>()))\n             >::type\n    {};\n\ntemplate <bool, class _Tp, class _A0, class _A1>\nstruct __is_constructible2_imp // false, _Tp is not a scalar\n    : public common_type\n             <\n                 decltype(__is_constructible2_test(declval<_Tp&>(), declval<_A0>(), declval<_A1>()))\n             >::type\n    {};\n\n//      handle scalars and reference types\n\n//      Scalars are default constructible, references are not\n\ntemplate <class _Tp>\nstruct __is_constructible0_imp<true, _Tp>\n    : public is_scalar<_Tp>\n    {};\n\ntemplate <class _Tp, class _A0>\nstruct __is_constructible1_imp<true, _Tp, _A0>\n    : public is_convertible<_A0, _Tp>\n    {};\n\ntemplate <class _Tp, class _A0, class _A1>\nstruct __is_constructible2_imp<true, _Tp, _A0, _A1>\n    : public false_type\n    {};\n\n//      Treat scalars and reference types separately\n\ntemplate <bool, class _Tp>\nstruct __is_constructible0_void_check\n    : public __is_constructible0_imp<is_scalar<_Tp>::value || is_reference<_Tp>::value,\n                                _Tp>\n    {};\n\ntemplate <bool, class _Tp, class _A0>\nstruct __is_constructible1_void_check\n    : public __is_constructible1_imp<is_scalar<_Tp>::value || is_reference<_Tp>::value,\n                                _Tp, _A0>\n    {};\n\ntemplate <bool, class _Tp, class _A0, class _A1>\nstruct __is_constructible2_void_check\n    : public __is_constructible2_imp<is_scalar<_Tp>::value || is_reference<_Tp>::value,\n                                _Tp, _A0, _A1>\n    {};\n\n//      If any of T or Args is void, is_constructible should be false\n\ntemplate <class _Tp>\nstruct __is_constructible0_void_check<true, _Tp>\n    : public false_type\n    {};\n\ntemplate <class _Tp, class _A0>\nstruct __is_constructible1_void_check<true, _Tp, _A0>\n    : public false_type\n    {};\n\ntemplate <class _Tp, class _A0, class _A1>\nstruct __is_constructible2_void_check<true, _Tp, _A0, _A1>\n    : public false_type\n    {};\n\n//      is_constructible entry point\n\ntemplate <class _Tp, class _A0 = __is_construct::__nat,\n                     class _A1 = __is_construct::__nat>\nstruct _LIBCPP_TEMPLATE_VIS is_constructible\n    : public __is_constructible2_void_check<is_void<_Tp>::value\n                                        || is_abstract<_Tp>::value\n                                        || is_function<_Tp>::value\n                                        || is_void<_A0>::value\n                                        || is_void<_A1>::value,\n                                           _Tp, _A0, _A1>\n    {};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_constructible<_Tp, __is_construct::__nat, __is_construct::__nat>\n    : public __is_constructible0_void_check<is_void<_Tp>::value\n                                        || is_abstract<_Tp>::value\n                                        || is_function<_Tp>::value,\n                                           _Tp>\n    {};\n\ntemplate <class _Tp, class _A0>\nstruct _LIBCPP_TEMPLATE_VIS is_constructible<_Tp, _A0, __is_construct::__nat>\n    : public __is_constructible1_void_check<is_void<_Tp>::value\n                                        || is_abstract<_Tp>::value\n                                        || is_function<_Tp>::value\n                                        || is_void<_A0>::value,\n                                           _Tp, _A0>\n    {};\n\n//      Array types are default constructible if their element type\n//      is default constructible\n\ntemplate <class _Ap, size_t _Np>\nstruct __is_constructible0_imp<false, _Ap[_Np]>\n    : public is_constructible<typename remove_all_extents<_Ap>::type>\n    {};\n\ntemplate <class _Ap, size_t _Np, class _A0>\nstruct __is_constructible1_imp<false, _Ap[_Np], _A0>\n    : public false_type\n    {};\n\ntemplate <class _Ap, size_t _Np, class _A0, class _A1>\nstruct __is_constructible2_imp<false, _Ap[_Np], _A0, _A1>\n    : public false_type\n    {};\n\n//      Incomplete array types are not constructible\n\ntemplate <class _Ap>\nstruct __is_constructible0_imp<false, _Ap[]>\n    : public false_type\n    {};\n\ntemplate <class _Ap, class _A0>\nstruct __is_constructible1_imp<false, _Ap[], _A0>\n    : public false_type\n    {};\n\ntemplate <class _Ap, class _A0, class _A1>\nstruct __is_constructible2_imp<false, _Ap[], _A0, _A1>\n    : public false_type\n    {};\n\n#endif // __has_feature(is_constructible)\n\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\ntemplate <class _Tp, class ..._Args> _LIBCPP_CONSTEXPR bool is_constructible_v\n    = is_constructible<_Tp, _Args...>::value;\n#endif\n\n// is_default_constructible\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_default_constructible\n    : public is_constructible<_Tp>\n    {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_default_constructible_v\n    = is_default_constructible<_Tp>::value;\n#endif\n\n// is_copy_constructible\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_copy_constructible\n    : public is_constructible<_Tp, \n                  typename add_lvalue_reference<typename add_const<_Tp>::type>::type> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_copy_constructible_v\n    = is_copy_constructible<_Tp>::value;\n#endif\n\n// is_move_constructible\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_move_constructible\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    : public is_constructible<_Tp, typename add_rvalue_reference<_Tp>::type>\n#else\n    : public is_copy_constructible<_Tp>\n#endif\n    {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_move_constructible_v\n    = is_move_constructible<_Tp>::value;\n#endif\n\n// is_trivially_constructible\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n#if __has_feature(is_trivially_constructible) || _GNUC_VER >= 501\n\ntemplate <class _Tp, class... _Args>\nstruct _LIBCPP_TEMPLATE_VIS is_trivially_constructible\n    : integral_constant<bool, __is_trivially_constructible(_Tp, _Args...)>\n{\n};\n\n#else  // !__has_feature(is_trivially_constructible)\n\ntemplate <class _Tp, class... _Args>\nstruct _LIBCPP_TEMPLATE_VIS is_trivially_constructible\n    : false_type\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_trivially_constructible<_Tp>\n#if __has_feature(has_trivial_constructor) || (_GNUC_VER >= 403)\n    : integral_constant<bool, __has_trivial_constructor(_Tp)>\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value>\n#endif\n{\n};\n\ntemplate <class _Tp>\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\nstruct _LIBCPP_TEMPLATE_VIS is_trivially_constructible<_Tp, _Tp&&>\n#else\nstruct _LIBCPP_TEMPLATE_VIS is_trivially_constructible<_Tp, _Tp>\n#endif\n    : integral_constant<bool, is_scalar<_Tp>::value>\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_trivially_constructible<_Tp, const _Tp&>\n    : integral_constant<bool, is_scalar<_Tp>::value>\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_trivially_constructible<_Tp, _Tp&>\n    : integral_constant<bool, is_scalar<_Tp>::value>\n{\n};\n\n#endif  // !__has_feature(is_trivially_constructible)\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Tp, class _A0 = __is_construct::__nat,\n                     class _A1 = __is_construct::__nat>\nstruct _LIBCPP_TEMPLATE_VIS is_trivially_constructible\n    : false_type\n{\n};\n\n#if __has_feature(is_trivially_constructible) || _GNUC_VER >= 501\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_trivially_constructible<_Tp, __is_construct::__nat,\n                                                       __is_construct::__nat>\n    : integral_constant<bool, __is_trivially_constructible(_Tp)>\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_trivially_constructible<_Tp, _Tp,\n                                                       __is_construct::__nat>\n    : integral_constant<bool, __is_trivially_constructible(_Tp, _Tp)>\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_trivially_constructible<_Tp, const _Tp&,\n                                                       __is_construct::__nat>\n    : integral_constant<bool, __is_trivially_constructible(_Tp, const _Tp&)>\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_trivially_constructible<_Tp, _Tp&,\n                                                       __is_construct::__nat>\n    : integral_constant<bool, __is_trivially_constructible(_Tp, _Tp&)>\n{\n};\n\n#else  // !__has_feature(is_trivially_constructible)\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_trivially_constructible<_Tp, __is_construct::__nat,\n                                                       __is_construct::__nat>\n    : integral_constant<bool, is_scalar<_Tp>::value>\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_trivially_constructible<_Tp, _Tp,\n                                                       __is_construct::__nat>\n    : integral_constant<bool, is_scalar<_Tp>::value>\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_trivially_constructible<_Tp, const _Tp&,\n                                                       __is_construct::__nat>\n    : integral_constant<bool, is_scalar<_Tp>::value>\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_trivially_constructible<_Tp, _Tp&,\n                                                       __is_construct::__nat>\n    : integral_constant<bool, is_scalar<_Tp>::value>\n{\n};\n\n#endif  // !__has_feature(is_trivially_constructible)\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\ntemplate <class _Tp, class... _Args> _LIBCPP_CONSTEXPR bool is_trivially_constructible_v\n    = is_trivially_constructible<_Tp, _Args...>::value;\n#endif\n\n// is_trivially_default_constructible\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_trivially_default_constructible\n    : public is_trivially_constructible<_Tp>\n    {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_trivially_default_constructible_v\n    = is_trivially_default_constructible<_Tp>::value;\n#endif\n\n// is_trivially_copy_constructible\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_trivially_copy_constructible\n    : public is_trivially_constructible<_Tp, typename add_lvalue_reference<const _Tp>::type>\n    {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_trivially_copy_constructible_v\n    = is_trivially_copy_constructible<_Tp>::value;\n#endif\n\n// is_trivially_move_constructible\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_trivially_move_constructible\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    : public is_trivially_constructible<_Tp, typename add_rvalue_reference<_Tp>::type>\n#else\n    : public is_trivially_copy_constructible<_Tp>\n#endif\n    {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_trivially_move_constructible_v\n    = is_trivially_move_constructible<_Tp>::value;\n#endif\n\n// is_trivially_assignable\n\n#if __has_feature(is_trivially_assignable) || _GNUC_VER >= 501\n\ntemplate <class _Tp, class _Arg>\nstruct is_trivially_assignable\n    : integral_constant<bool, __is_trivially_assignable(_Tp, _Arg)>\n{\n};\n\n#else  // !__has_feature(is_trivially_assignable)\n\ntemplate <class _Tp, class _Arg>\nstruct is_trivially_assignable\n    : public false_type {};\n\ntemplate <class _Tp>\nstruct is_trivially_assignable<_Tp&, _Tp>\n    : integral_constant<bool, is_scalar<_Tp>::value> {};\n\ntemplate <class _Tp>\nstruct is_trivially_assignable<_Tp&, _Tp&>\n    : integral_constant<bool, is_scalar<_Tp>::value> {};\n\ntemplate <class _Tp>\nstruct is_trivially_assignable<_Tp&, const _Tp&>\n    : integral_constant<bool, is_scalar<_Tp>::value> {};\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp>\nstruct is_trivially_assignable<_Tp&, _Tp&&>\n    : integral_constant<bool, is_scalar<_Tp>::value> {};\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n#endif  // !__has_feature(is_trivially_assignable)\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp, class _Arg> _LIBCPP_CONSTEXPR bool is_trivially_assignable_v\n    = is_trivially_assignable<_Tp, _Arg>::value;\n#endif\n\n// is_trivially_copy_assignable\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_trivially_copy_assignable\n    : public is_trivially_assignable<typename add_lvalue_reference<_Tp>::type,\n                  typename add_lvalue_reference<typename add_const<_Tp>::type>::type> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_trivially_copy_assignable_v\n    = is_trivially_copy_assignable<_Tp>::value;\n#endif\n\n// is_trivially_move_assignable\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_trivially_move_assignable\n    : public is_trivially_assignable<typename add_lvalue_reference<_Tp>::type,\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n                                     typename add_rvalue_reference<_Tp>::type>\n#else\n                                     typename add_lvalue_reference<_Tp>::type>\n#endif\n    {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_trivially_move_assignable_v\n    = is_trivially_move_assignable<_Tp>::value;\n#endif\n\n// is_trivially_destructible\n\n#if __has_feature(has_trivial_destructor) || (_GNUC_VER >= 403)\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_trivially_destructible\n    : public integral_constant<bool, is_destructible<_Tp>::value && __has_trivial_destructor(_Tp)> {};\n\n#else\n\ntemplate <class _Tp> struct __libcpp_trivial_destructor\n    : public integral_constant<bool, is_scalar<_Tp>::value ||\n                                     is_reference<_Tp>::value> {};\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_trivially_destructible\n    : public __libcpp_trivial_destructor<typename remove_all_extents<_Tp>::type> {};\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_trivially_destructible<_Tp[]>\n    : public false_type {};\n\n#endif\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_trivially_destructible_v\n    = is_trivially_destructible<_Tp>::value;\n#endif\n\n// is_nothrow_constructible\n\n#if 0\ntemplate <class _Tp, class... _Args>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_constructible\n    : public integral_constant<bool, __is_nothrow_constructible(_Tp(_Args...))>\n{\n};\n\n#else\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n#if __has_feature(cxx_noexcept) || (_GNUC_VER >= 407 && __cplusplus >= 201103L)\n\ntemplate <bool, bool, class _Tp, class... _Args> struct __libcpp_is_nothrow_constructible;\n\ntemplate <class _Tp, class... _Args>\nstruct __libcpp_is_nothrow_constructible</*is constructible*/true, /*is reference*/false, _Tp, _Args...>\n    : public integral_constant<bool, noexcept(_Tp(declval<_Args>()...))>\n{\n};\n\ntemplate <class _Tp>\nvoid __implicit_conversion_to(_Tp) noexcept { }\n\ntemplate <class _Tp, class _Arg>\nstruct __libcpp_is_nothrow_constructible</*is constructible*/true, /*is reference*/true, _Tp, _Arg>\n    : public integral_constant<bool, noexcept(__implicit_conversion_to<_Tp>(declval<_Arg>()))>\n{\n};\n\ntemplate <class _Tp, bool _IsReference, class... _Args>\nstruct __libcpp_is_nothrow_constructible</*is constructible*/false, _IsReference, _Tp, _Args...>\n    : public false_type\n{\n};\n\ntemplate <class _Tp, class... _Args>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_constructible\n    : __libcpp_is_nothrow_constructible<is_constructible<_Tp, _Args...>::value, is_reference<_Tp>::value, _Tp, _Args...>\n{\n};\n\ntemplate <class _Tp, size_t _Ns>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_constructible<_Tp[_Ns]>\n    : __libcpp_is_nothrow_constructible<is_constructible<_Tp>::value, is_reference<_Tp>::value, _Tp>\n{\n};\n\n#else  // __has_feature(cxx_noexcept)\n\ntemplate <class _Tp, class... _Args>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_constructible\n    : false_type\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_constructible<_Tp>\n#if __has_feature(has_nothrow_constructor) || (_GNUC_VER >= 403)\n    : integral_constant<bool, __has_nothrow_constructor(_Tp)>\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value>\n#endif\n{\n};\n\ntemplate <class _Tp>\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_constructible<_Tp, _Tp&&>\n#else\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_constructible<_Tp, _Tp>\n#endif\n#if __has_feature(has_nothrow_copy) || (_GNUC_VER >= 403)\n    : integral_constant<bool, __has_nothrow_copy(_Tp)>\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value>\n#endif\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_constructible<_Tp, const _Tp&>\n#if __has_feature(has_nothrow_copy) || (_GNUC_VER >= 403)\n    : integral_constant<bool, __has_nothrow_copy(_Tp)>\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value>\n#endif\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_constructible<_Tp, _Tp&>\n#if __has_feature(has_nothrow_copy) || (_GNUC_VER >= 403)\n    : integral_constant<bool, __has_nothrow_copy(_Tp)>\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value>\n#endif\n{\n};\n\n#endif  // __has_feature(cxx_noexcept)\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Tp, class _A0 = __is_construct::__nat,\n                     class _A1 = __is_construct::__nat>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_constructible\n    : false_type\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_constructible<_Tp, __is_construct::__nat,\n                                                       __is_construct::__nat>\n#if __has_feature(has_nothrow_constructor) || (_GNUC_VER >= 403)\n    : integral_constant<bool, __has_nothrow_constructor(_Tp)>\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value>\n#endif\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_constructible<_Tp, _Tp,\n                                                       __is_construct::__nat>\n#if __has_feature(has_nothrow_copy) || (_GNUC_VER >= 403)\n    : integral_constant<bool, __has_nothrow_copy(_Tp)>\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value>\n#endif\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_constructible<_Tp, const _Tp&,\n                                                       __is_construct::__nat>\n#if __has_feature(has_nothrow_copy) || (_GNUC_VER >= 403)\n    : integral_constant<bool, __has_nothrow_copy(_Tp)>\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value>\n#endif\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_constructible<_Tp, _Tp&,\n                                                       __is_construct::__nat>\n#if __has_feature(has_nothrow_copy) || (_GNUC_VER >= 403)\n    : integral_constant<bool, __has_nothrow_copy(_Tp)>\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value>\n#endif\n{\n};\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n#endif  // __has_feature(is_nothrow_constructible)\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\ntemplate <class _Tp, class ..._Args> _LIBCPP_CONSTEXPR bool is_nothrow_constructible_v\n    = is_nothrow_constructible<_Tp, _Args...>::value;\n#endif\n\n// is_nothrow_default_constructible\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_nothrow_default_constructible\n    : public is_nothrow_constructible<_Tp>\n    {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_nothrow_default_constructible_v\n    = is_nothrow_default_constructible<_Tp>::value;\n#endif\n\n// is_nothrow_copy_constructible\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_nothrow_copy_constructible\n    : public is_nothrow_constructible<_Tp,\n                  typename add_lvalue_reference<typename add_const<_Tp>::type>::type> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_nothrow_copy_constructible_v\n    = is_nothrow_copy_constructible<_Tp>::value;\n#endif\n\n// is_nothrow_move_constructible\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_nothrow_move_constructible\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    : public is_nothrow_constructible<_Tp, typename add_rvalue_reference<_Tp>::type>\n#else\n    : public is_nothrow_copy_constructible<_Tp>\n#endif\n    {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_nothrow_move_constructible_v\n    = is_nothrow_move_constructible<_Tp>::value;\n#endif\n\n// is_nothrow_assignable\n\n#if __has_feature(cxx_noexcept) || (_GNUC_VER >= 407 && __cplusplus >= 201103L)\n\ntemplate <bool, class _Tp, class _Arg> struct __libcpp_is_nothrow_assignable;\n\ntemplate <class _Tp, class _Arg>\nstruct __libcpp_is_nothrow_assignable<false, _Tp, _Arg>\n    : public false_type\n{\n};\n\ntemplate <class _Tp, class _Arg>\nstruct __libcpp_is_nothrow_assignable<true, _Tp, _Arg>\n    : public integral_constant<bool, noexcept(_VSTD::declval<_Tp>() = _VSTD::declval<_Arg>()) >\n{\n};\n\ntemplate <class _Tp, class _Arg>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_assignable\n    : public __libcpp_is_nothrow_assignable<is_assignable<_Tp, _Arg>::value, _Tp, _Arg>\n{\n};\n\n#else  // __has_feature(cxx_noexcept)\n\ntemplate <class _Tp, class _Arg>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_assignable\n    : public false_type {};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_assignable<_Tp&, _Tp>\n#if __has_feature(has_nothrow_assign) || (_GNUC_VER >= 403)\n    : integral_constant<bool, __has_nothrow_assign(_Tp)> {};\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value> {};\n#endif\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_assignable<_Tp&, _Tp&>\n#if __has_feature(has_nothrow_assign) || (_GNUC_VER >= 403)\n    : integral_constant<bool, __has_nothrow_assign(_Tp)> {};\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value> {};\n#endif\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_assignable<_Tp&, const _Tp&>\n#if __has_feature(has_nothrow_assign) || (_GNUC_VER >= 403)\n    : integral_constant<bool, __has_nothrow_assign(_Tp)> {};\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value> {};\n#endif\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp>\nstruct is_nothrow_assignable<_Tp&, _Tp&&>\n#if __has_feature(has_nothrow_assign) || (_GNUC_VER >= 403)\n    : integral_constant<bool, __has_nothrow_assign(_Tp)> {};\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value> {};\n#endif\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n#endif  // __has_feature(cxx_noexcept)\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp, class _Arg> _LIBCPP_CONSTEXPR bool is_nothrow_assignable_v\n    = is_nothrow_assignable<_Tp, _Arg>::value;\n#endif\n\n// is_nothrow_copy_assignable\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_nothrow_copy_assignable\n    : public is_nothrow_assignable<typename add_lvalue_reference<_Tp>::type,\n                  typename add_lvalue_reference<typename add_const<_Tp>::type>::type> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_nothrow_copy_assignable_v\n    = is_nothrow_copy_assignable<_Tp>::value;\n#endif\n\n// is_nothrow_move_assignable\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_nothrow_move_assignable\n    : public is_nothrow_assignable<typename add_lvalue_reference<_Tp>::type,\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n                                     typename add_rvalue_reference<_Tp>::type>\n#else\n                                     typename add_lvalue_reference<_Tp>::type>\n#endif\n    {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_nothrow_move_assignable_v\n    = is_nothrow_move_assignable<_Tp>::value;\n#endif\n\n// is_nothrow_destructible\n\n#if __has_feature(cxx_noexcept) || (_GNUC_VER >= 407 && __cplusplus >= 201103L)\n\ntemplate <bool, class _Tp> struct __libcpp_is_nothrow_destructible;\n\ntemplate <class _Tp>\nstruct __libcpp_is_nothrow_destructible<false, _Tp>\n    : public false_type\n{\n};\n\ntemplate <class _Tp>\nstruct __libcpp_is_nothrow_destructible<true, _Tp>\n    : public integral_constant<bool, noexcept(_VSTD::declval<_Tp>().~_Tp()) >\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_destructible\n    : public __libcpp_is_nothrow_destructible<is_destructible<_Tp>::value, _Tp>\n{\n};\n\ntemplate <class _Tp, size_t _Ns>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_destructible<_Tp[_Ns]>\n    : public is_nothrow_destructible<_Tp>\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_destructible<_Tp&>\n    : public true_type\n{\n};\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_destructible<_Tp&&>\n    : public true_type\n{\n};\n\n#endif\n\n#else\n\ntemplate <class _Tp> struct __libcpp_nothrow_destructor\n    : public integral_constant<bool, is_scalar<_Tp>::value ||\n                                     is_reference<_Tp>::value> {};\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_nothrow_destructible\n    : public __libcpp_nothrow_destructor<typename remove_all_extents<_Tp>::type> {};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_destructible<_Tp[]>\n    : public false_type {};\n\n#endif\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_nothrow_destructible_v\n    = is_nothrow_destructible<_Tp>::value;\n#endif\n\n// is_pod\n\n#if __has_feature(is_pod) || (_GNUC_VER >= 403)\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_pod\n    : public integral_constant<bool, __is_pod(_Tp)> {};\n\n#else\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_pod\n    : public integral_constant<bool, is_trivially_default_constructible<_Tp>::value   &&\n                                     is_trivially_copy_constructible<_Tp>::value      &&\n                                     is_trivially_copy_assignable<_Tp>::value    &&\n                                     is_trivially_destructible<_Tp>::value> {};\n\n#endif\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_pod_v\n    = is_pod<_Tp>::value;\n#endif\n\n// is_literal_type;\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_literal_type\n#ifdef _LIBCPP_IS_LITERAL\n    : public integral_constant<bool, _LIBCPP_IS_LITERAL(_Tp)>\n#else\n    : integral_constant<bool, is_scalar<typename remove_all_extents<_Tp>::type>::value ||\n                              is_reference<typename remove_all_extents<_Tp>::type>::value>\n#endif\n    {};\n    \n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_literal_type_v\n    = is_literal_type<_Tp>::value;\n#endif\n\n// is_standard_layout;\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_standard_layout\n#if __has_feature(is_standard_layout) || (_GNUC_VER >= 407)\n    : public integral_constant<bool, __is_standard_layout(_Tp)>\n#else\n    : integral_constant<bool, is_scalar<typename remove_all_extents<_Tp>::type>::value>\n#endif\n    {};\n    \n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_standard_layout_v\n    = is_standard_layout<_Tp>::value;\n#endif\n\n// is_trivially_copyable;\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_trivially_copyable\n#if __has_feature(is_trivially_copyable)\n    : public integral_constant<bool, __is_trivially_copyable(_Tp)>\n#elif _GNUC_VER >= 501\n    : public integral_constant<bool, !is_volatile<_Tp>::value && __is_trivially_copyable(_Tp)>\n#else\n    : integral_constant<bool, is_scalar<typename remove_all_extents<_Tp>::type>::value>\n#endif\n    {};\n    \n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_trivially_copyable_v\n    = is_trivially_copyable<_Tp>::value;\n#endif\n\n// is_trivial;\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_trivial\n#if __has_feature(is_trivial) || _GNUC_VER >= 407\n    : public integral_constant<bool, __is_trivial(_Tp)>\n#else\n    : integral_constant<bool, is_trivially_copyable<_Tp>::value &&\n                                 is_trivially_default_constructible<_Tp>::value>\n#endif\n    {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_trivial_v\n    = is_trivial<_Tp>::value;\n#endif\n\ntemplate <class _Tp> struct __is_reference_wrapper_impl : public false_type {};\ntemplate <class _Tp> struct __is_reference_wrapper_impl<reference_wrapper<_Tp> > : public true_type {};\ntemplate <class _Tp> struct __is_reference_wrapper\n    : public __is_reference_wrapper_impl<typename remove_cv<_Tp>::type> {};\n\n#ifndef _LIBCPP_CXX03_LANG\n\n// Check for complete types\n\ntemplate <class ..._Tp> struct __check_complete;\n\ntemplate <>\nstruct __check_complete<>\n{\n};\n\ntemplate <class _Hp, class _T0, class ..._Tp>\nstruct __check_complete<_Hp, _T0, _Tp...>\n    : private __check_complete<_Hp>,\n      private __check_complete<_T0, _Tp...>\n{\n};\n\ntemplate <class _Hp>\nstruct __check_complete<_Hp, _Hp>\n    : private __check_complete<_Hp>\n{\n};\n\ntemplate <class _Tp>\nstruct __check_complete<_Tp>\n{\n    static_assert(sizeof(_Tp) > 0, \"Type must be complete.\");\n};\n\ntemplate <class _Tp>\nstruct __check_complete<_Tp&>\n    : private __check_complete<_Tp>\n{\n};\n\ntemplate <class _Tp>\nstruct __check_complete<_Tp&&>\n    : private __check_complete<_Tp>\n{\n};\n\ntemplate <class _Rp, class ..._Param>\nstruct __check_complete<_Rp (*)(_Param...)>\n    : private __check_complete<_Rp>\n{\n};\n\ntemplate <class ..._Param>\nstruct __check_complete<void (*)(_Param...)>\n{\n};\n\ntemplate <class _Rp, class ..._Param>\nstruct __check_complete<_Rp (_Param...)>\n    : private __check_complete<_Rp>\n{\n};\n\ntemplate <class ..._Param>\nstruct __check_complete<void (_Param...)>\n{\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __check_complete<_Rp (_Class::*)(_Param...)>\n    : private __check_complete<_Class>\n{\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __check_complete<_Rp (_Class::*)(_Param...) const>\n    : private __check_complete<_Class>\n{\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __check_complete<_Rp (_Class::*)(_Param...) volatile>\n    : private __check_complete<_Class>\n{\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __check_complete<_Rp (_Class::*)(_Param...) const volatile>\n    : private __check_complete<_Class>\n{\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __check_complete<_Rp (_Class::*)(_Param...) &>\n    : private __check_complete<_Class>\n{\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __check_complete<_Rp (_Class::*)(_Param...) const&>\n    : private __check_complete<_Class>\n{\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __check_complete<_Rp (_Class::*)(_Param...) volatile&>\n    : private __check_complete<_Class>\n{\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __check_complete<_Rp (_Class::*)(_Param...) const volatile&>\n    : private __check_complete<_Class>\n{\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __check_complete<_Rp (_Class::*)(_Param...) &&>\n    : private __check_complete<_Class>\n{\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __check_complete<_Rp (_Class::*)(_Param...) const&&>\n    : private __check_complete<_Class>\n{\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __check_complete<_Rp (_Class::*)(_Param...) volatile&&>\n    : private __check_complete<_Class>\n{\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __check_complete<_Rp (_Class::*)(_Param...) const volatile&&>\n    : private __check_complete<_Class>\n{\n};\n\ntemplate <class _Rp, class _Class>\nstruct __check_complete<_Rp _Class::*>\n    : private __check_complete<_Class>\n{\n};\n\n\ntemplate <class _Fp, class _A0,\n         class _DecayFp = typename decay<_Fp>::type,\n         class _DecayA0 = typename decay<_A0>::type,\n         class _ClassT = typename __member_pointer_class_type<_DecayFp>::type>\nusing __enable_if_bullet1 = typename enable_if\n    <\n        is_member_function_pointer<_DecayFp>::value\n        && is_base_of<_ClassT, _DecayA0>::value\n    >::type;\n\ntemplate <class _Fp, class _A0,\n         class _DecayFp = typename decay<_Fp>::type,\n         class _DecayA0 = typename decay<_A0>::type>\nusing __enable_if_bullet2 = typename enable_if\n    <\n        is_member_function_pointer<_DecayFp>::value\n        && __is_reference_wrapper<_DecayA0>::value\n    >::type;\n\ntemplate <class _Fp, class _A0,\n         class _DecayFp = typename decay<_Fp>::type,\n         class _DecayA0 = typename decay<_A0>::type,\n         class _ClassT = typename __member_pointer_class_type<_DecayFp>::type>\nusing __enable_if_bullet3 = typename enable_if\n    <\n        is_member_function_pointer<_DecayFp>::value\n        && !is_base_of<_ClassT, _DecayA0>::value\n        && !__is_reference_wrapper<_DecayA0>::value\n    >::type;\n\ntemplate <class _Fp, class _A0,\n         class _DecayFp = typename decay<_Fp>::type,\n         class _DecayA0 = typename decay<_A0>::type,\n         class _ClassT = typename __member_pointer_class_type<_DecayFp>::type>\nusing __enable_if_bullet4 = typename enable_if\n    <\n        is_member_object_pointer<_DecayFp>::value\n        && is_base_of<_ClassT, _DecayA0>::value\n    >::type;\n\ntemplate <class _Fp, class _A0,\n         class _DecayFp = typename decay<_Fp>::type,\n         class _DecayA0 = typename decay<_A0>::type>\nusing __enable_if_bullet5 = typename enable_if\n    <\n        is_member_object_pointer<_DecayFp>::value\n        && __is_reference_wrapper<_DecayA0>::value\n    >::type;\n\ntemplate <class _Fp, class _A0,\n         class _DecayFp = typename decay<_Fp>::type,\n         class _DecayA0 = typename decay<_A0>::type,\n         class _ClassT = typename __member_pointer_class_type<_DecayFp>::type>\nusing __enable_if_bullet6 = typename enable_if\n    <\n        is_member_object_pointer<_DecayFp>::value\n        && !is_base_of<_ClassT, _DecayA0>::value\n        && !__is_reference_wrapper<_DecayA0>::value\n    >::type;\n\n// __invoke forward declarations\n\n// fall back - none of the bullets\n\n#define _LIBCPP_INVOKE_RETURN(...) \\\n    noexcept(noexcept(__VA_ARGS__)) -> decltype(__VA_ARGS__) \\\n    { return __VA_ARGS__; }\n\ntemplate <class ..._Args>\nauto __invoke(__any, _Args&& ...__args) -> __nat;\n\ntemplate <class ..._Args>\nauto __invoke_constexpr(__any, _Args&& ...__args) -> __nat;\n\n// bullets 1, 2 and 3\n\ntemplate <class _Fp, class _A0, class ..._Args,\n          class = __enable_if_bullet1<_Fp, _A0>>\ninline _LIBCPP_INLINE_VISIBILITY\nauto\n__invoke(_Fp&& __f, _A0&& __a0, _Args&& ...__args)\n_LIBCPP_INVOKE_RETURN((_VSTD::forward<_A0>(__a0).*__f)(_VSTD::forward<_Args>(__args)...))\n\ntemplate <class _Fp, class _A0, class ..._Args,\n          class = __enable_if_bullet1<_Fp, _A0>>\ninline _LIBCPP_INLINE_VISIBILITY\n_LIBCPP_CONSTEXPR auto\n__invoke_constexpr(_Fp&& __f, _A0&& __a0, _Args&& ...__args)\n_LIBCPP_INVOKE_RETURN((_VSTD::forward<_A0>(__a0).*__f)(_VSTD::forward<_Args>(__args)...))\n\ntemplate <class _Fp, class _A0, class ..._Args,\n          class = __enable_if_bullet2<_Fp, _A0>>\ninline _LIBCPP_INLINE_VISIBILITY\nauto\n__invoke(_Fp&& __f, _A0&& __a0, _Args&& ...__args)\n_LIBCPP_INVOKE_RETURN((__a0.get().*__f)(_VSTD::forward<_Args>(__args)...))\n\ntemplate <class _Fp, class _A0, class ..._Args,\n          class = __enable_if_bullet2<_Fp, _A0>>\ninline _LIBCPP_INLINE_VISIBILITY\n_LIBCPP_CONSTEXPR auto\n__invoke_constexpr(_Fp&& __f, _A0&& __a0, _Args&& ...__args)\n_LIBCPP_INVOKE_RETURN((__a0.get().*__f)(_VSTD::forward<_Args>(__args)...))\n\ntemplate <class _Fp, class _A0, class ..._Args,\n          class = __enable_if_bullet3<_Fp, _A0>>\ninline _LIBCPP_INLINE_VISIBILITY\nauto\n__invoke(_Fp&& __f, _A0&& __a0, _Args&& ...__args)\n_LIBCPP_INVOKE_RETURN(((*_VSTD::forward<_A0>(__a0)).*__f)(_VSTD::forward<_Args>(__args)...))\n\ntemplate <class _Fp, class _A0, class ..._Args,\n          class = __enable_if_bullet3<_Fp, _A0>>\ninline _LIBCPP_INLINE_VISIBILITY\n_LIBCPP_CONSTEXPR auto\n__invoke_constexpr(_Fp&& __f, _A0&& __a0, _Args&& ...__args)\n_LIBCPP_INVOKE_RETURN(((*_VSTD::forward<_A0>(__a0)).*__f)(_VSTD::forward<_Args>(__args)...))\n\n// bullets 4, 5 and 6\n\ntemplate <class _Fp, class _A0,\n          class = __enable_if_bullet4<_Fp, _A0>>\ninline _LIBCPP_INLINE_VISIBILITY\nauto\n__invoke(_Fp&& __f, _A0&& __a0)\n_LIBCPP_INVOKE_RETURN(_VSTD::forward<_A0>(__a0).*__f)\n\ntemplate <class _Fp, class _A0,\n          class = __enable_if_bullet4<_Fp, _A0>>\ninline _LIBCPP_INLINE_VISIBILITY\n_LIBCPP_CONSTEXPR auto\n__invoke_constexpr(_Fp&& __f, _A0&& __a0)\n_LIBCPP_INVOKE_RETURN(_VSTD::forward<_A0>(__a0).*__f)\n\ntemplate <class _Fp, class _A0,\n          class = __enable_if_bullet5<_Fp, _A0>>\ninline _LIBCPP_INLINE_VISIBILITY\nauto\n__invoke(_Fp&& __f, _A0&& __a0)\n_LIBCPP_INVOKE_RETURN(__a0.get().*__f)\n\ntemplate <class _Fp, class _A0,\n          class = __enable_if_bullet5<_Fp, _A0>>\ninline _LIBCPP_INLINE_VISIBILITY\n_LIBCPP_CONSTEXPR auto\n__invoke_constexpr(_Fp&& __f, _A0&& __a0)\n_LIBCPP_INVOKE_RETURN(__a0.get().*__f)\n\ntemplate <class _Fp, class _A0,\n          class = __enable_if_bullet6<_Fp, _A0>>\ninline _LIBCPP_INLINE_VISIBILITY\nauto\n__invoke(_Fp&& __f, _A0&& __a0)\n_LIBCPP_INVOKE_RETURN((*_VSTD::forward<_A0>(__a0)).*__f)\n\ntemplate <class _Fp, class _A0,\n          class = __enable_if_bullet6<_Fp, _A0>>\ninline _LIBCPP_INLINE_VISIBILITY\n_LIBCPP_CONSTEXPR auto\n__invoke_constexpr(_Fp&& __f, _A0&& __a0)\n_LIBCPP_INVOKE_RETURN((*_VSTD::forward<_A0>(__a0)).*__f)\n\n// bullet 7\n\ntemplate <class _Fp, class ..._Args>\ninline _LIBCPP_INLINE_VISIBILITY\nauto\n__invoke(_Fp&& __f, _Args&& ...__args)\n_LIBCPP_INVOKE_RETURN(_VSTD::forward<_Fp>(__f)(_VSTD::forward<_Args>(__args)...))\n\ntemplate <class _Fp, class ..._Args>\ninline _LIBCPP_INLINE_VISIBILITY\n_LIBCPP_CONSTEXPR auto\n__invoke_constexpr(_Fp&& __f, _Args&& ...__args)\n_LIBCPP_INVOKE_RETURN(_VSTD::forward<_Fp>(__f)(_VSTD::forward<_Args>(__args)...))\n\n#undef _LIBCPP_INVOKE_RETURN\n\n// __invokable\n\ntemplate <class _Ret, class _Fp, class ..._Args>\nstruct __invokable_r\n    : private __check_complete<_Fp>\n{\n    using _Result = decltype(\n        _VSTD::__invoke(_VSTD::declval<_Fp>(), _VSTD::declval<_Args>()...));\n\n    static const bool value =\n        conditional<\n            !is_same<_Result, __nat>::value,\n            typename conditional<\n                is_void<_Ret>::value,\n                true_type,\n                is_convertible<_Result, _Ret>\n            >::type,\n            false_type\n        >::type::value;\n};\n\ntemplate <class _Fp, class ..._Args>\nusing __invokable = __invokable_r<void, _Fp, _Args...>;\n\ntemplate <bool _IsInvokable, bool _IsCVVoid, class _Ret, class _Fp, class ..._Args>\nstruct __nothrow_invokable_r_imp {\n  static const bool value = false;\n};\n\ntemplate <class _Ret, class _Fp, class ..._Args>\nstruct __nothrow_invokable_r_imp<true, false, _Ret, _Fp, _Args...>\n{\n    typedef __nothrow_invokable_r_imp _ThisT;\n\n    template <class _Tp>\n    static void __test_noexcept(_Tp) noexcept;\n\n    static const bool value = noexcept(_ThisT::__test_noexcept<_Ret>(\n        _VSTD::__invoke(_VSTD::declval<_Fp>(), _VSTD::declval<_Args>()...)));\n};\n\ntemplate <class _Ret, class _Fp, class ..._Args>\nstruct __nothrow_invokable_r_imp<true, true, _Ret, _Fp, _Args...>\n{\n    static const bool value = noexcept(\n        _VSTD::__invoke(_VSTD::declval<_Fp>(), _VSTD::declval<_Args>()...));\n};\n\ntemplate <class _Ret, class _Fp, class ..._Args>\nusing __nothrow_invokable_r =\n    __nothrow_invokable_r_imp<\n            __invokable_r<_Ret, _Fp, _Args...>::value,\n            is_void<_Ret>::value,\n            _Ret, _Fp, _Args...\n    >;\n\ntemplate <class _Fp, class ..._Args>\nstruct __invoke_of\n    : public enable_if<\n        __invokable<_Fp, _Args...>::value,\n        typename __invokable_r<void, _Fp, _Args...>::_Result>\n{\n};\n\n// result_of\n\ntemplate <class _Fp, class ..._Args>\nclass _LIBCPP_TEMPLATE_VIS result_of<_Fp(_Args...)>\n    : public __invoke_of<_Fp, _Args...>\n{\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using result_of_t = typename result_of<_Tp>::type;\n#endif\n\n#if _LIBCPP_STD_VER > 14\n\n// is_callable\n\ntemplate <class _Fn, class _Ret = void>\nstruct _LIBCPP_TEMPLATE_VIS is_callable;\n\ntemplate <class _Fn, class ..._Args, class _Ret>\nstruct _LIBCPP_TEMPLATE_VIS is_callable<_Fn(_Args...), _Ret>\n    : integral_constant<bool, __invokable_r<_Ret, _Fn, _Args...>::value> {};\n\ntemplate <class _Fn, class _Ret = void>\nconstexpr bool is_callable_v = is_callable<_Fn, _Ret>::value;\n\n// is_nothrow_callable\n\ntemplate <class _Fn, class _Ret = void>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_callable;\n\ntemplate <class _Fn, class ..._Args, class _Ret>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_callable<_Fn(_Args...), _Ret>\n    : integral_constant<bool, __nothrow_invokable_r<_Ret, _Fn, _Args...>::value>\n{};\n\ntemplate <class _Fn, class _Ret = void>\nconstexpr bool is_nothrow_callable_v = is_nothrow_callable<_Fn, _Ret>::value;\n\n#endif // _LIBCPP_STD_VER > 14\n\n#endif  // !defined(_LIBCPP_CXX03_LANG)\n\ntemplate <class _Tp> struct __is_swappable;\ntemplate <class _Tp> struct __is_nothrow_swappable;\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n#ifndef _LIBCPP_CXX03_LANG\ntypename enable_if\n<\n    is_move_constructible<_Tp>::value &&\n    is_move_assignable<_Tp>::value\n>::type\n#else\nvoid\n#endif\nswap(_Tp& __x, _Tp& __y) _NOEXCEPT_(is_nothrow_move_constructible<_Tp>::value &&\n                                    is_nothrow_move_assignable<_Tp>::value)\n{\n    _Tp __t(_VSTD::move(__x));\n    __x = _VSTD::move(__y);\n    __y = _VSTD::move(__t);\n}\n\ntemplate<class _Tp, size_t _Np>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<\n    __is_swappable<_Tp>::value\n>::type\nswap(_Tp (&__a)[_Np], _Tp (&__b)[_Np]) _NOEXCEPT_(__is_nothrow_swappable<_Tp>::value);\n\ntemplate <class _ForwardIterator1, class _ForwardIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\niter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)\n    //                                  _NOEXCEPT_(_NOEXCEPT_(swap(*__a, *__b)))\n               _NOEXCEPT_(_NOEXCEPT_(swap(*_VSTD::declval<_ForwardIterator1>(),\n                                          *_VSTD::declval<_ForwardIterator2>())))\n{\n    swap(*__a, *__b);\n}\n\n// __swappable\n\nnamespace __detail\n{\n// ALL generic swap overloads MUST already have a declaration available at this point.\n\ntemplate <class _Tp, class _Up = _Tp,\n          bool _NotVoid = !is_void<_Tp>::value && !is_void<_Up>::value>\nstruct __swappable_with\n{\n    template <class _LHS, class _RHS>\n    static decltype(swap(_VSTD::declval<_LHS>(), _VSTD::declval<_RHS>()))\n    __test_swap(int);\n    template <class, class>\n    static __nat __test_swap(long);\n\n    // Extra parens are needed for the C++03 definition of decltype.\n    typedef decltype((__test_swap<_Tp, _Up>(0))) __swap1;\n    typedef decltype((__test_swap<_Up, _Tp>(0))) __swap2;\n\n    static const bool value = !is_same<__swap1, __nat>::value\n                           && !is_same<__swap2, __nat>::value;\n};\n\ntemplate <class _Tp, class _Up>\nstruct __swappable_with<_Tp, _Up,  false> : false_type {};\n\ntemplate <class _Tp, class _Up = _Tp, bool _Swappable = __swappable_with<_Tp, _Up>::value>\nstruct __nothrow_swappable_with {\n  static const bool value =\n#ifndef _LIBCPP_HAS_NO_NOEXCEPT\n      noexcept(swap(_VSTD::declval<_Tp>(), _VSTD::declval<_Up>()))\n  &&  noexcept(swap(_VSTD::declval<_Up>(), _VSTD::declval<_Tp>()));\n#else\n      false;\n#endif\n};\n\ntemplate <class _Tp, class _Up>\nstruct __nothrow_swappable_with<_Tp, _Up, false> : false_type {};\n\n}  // __detail\n\ntemplate <class _Tp>\nstruct __is_swappable\n    : public integral_constant<bool, __detail::__swappable_with<_Tp&>::value>\n{\n};\n\ntemplate <class _Tp>\nstruct __is_nothrow_swappable\n    : public integral_constant<bool, __detail::__nothrow_swappable_with<_Tp&>::value>\n{\n};\n\n#if _LIBCPP_STD_VER > 14\n\ntemplate <class _Tp, class _Up>\nstruct _LIBCPP_TEMPLATE_VIS is_swappable_with\n    : public integral_constant<bool, __detail::__swappable_with<_Tp, _Up>::value>\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_swappable\n    : public conditional<\n        __is_referenceable<_Tp>::value,\n        is_swappable_with<\n            typename add_lvalue_reference<_Tp>::type,\n            typename add_lvalue_reference<_Tp>::type>,\n        false_type\n    >::type\n{\n};\n\ntemplate <class _Tp, class _Up>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_swappable_with\n    : public integral_constant<bool, __detail::__nothrow_swappable_with<_Tp, _Up>::value>\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_swappable\n    : public conditional<\n        __is_referenceable<_Tp>::value,\n        is_nothrow_swappable_with<\n            typename add_lvalue_reference<_Tp>::type,\n            typename add_lvalue_reference<_Tp>::type>,\n        false_type\n    >::type\n{\n};\n\ntemplate <class _Tp, class _Up>\nconstexpr bool is_swappable_with_v = is_swappable_with<_Tp, _Up>::value;\n\ntemplate <class _Tp>\nconstexpr bool is_swappable_v = is_swappable<_Tp>::value;\n\ntemplate <class _Tp, class _Up>\nconstexpr bool is_nothrow_swappable_with_v = is_nothrow_swappable_with<_Tp, _Up>::value;\n\ntemplate <class _Tp>\nconstexpr bool is_nothrow_swappable_v = is_nothrow_swappable<_Tp>::value;\n\n#endif // _LIBCPP_STD_VER > 14\n\n#ifdef _LIBCPP_UNDERLYING_TYPE\n\ntemplate <class _Tp>\nstruct underlying_type\n{\n    typedef _LIBCPP_UNDERLYING_TYPE(_Tp) type;\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using underlying_type_t = typename underlying_type<_Tp>::type;\n#endif\n\n#else  // _LIBCPP_UNDERLYING_TYPE\n\ntemplate <class _Tp, bool _Support = false>\nstruct underlying_type\n{\n    static_assert(_Support, \"The underyling_type trait requires compiler \"\n                            \"support. Either no such support exists or \"\n                            \"libc++ does not know how to use it.\");\n};\n\n#endif // _LIBCPP_UNDERLYING_TYPE\n\n\ntemplate <class _Tp, bool = is_enum<_Tp>::value>\nstruct __sfinae_underlying_type\n{\n    typedef typename underlying_type<_Tp>::type type;\n    typedef decltype(((type)1) + 0) __promoted_type;\n};\n\ntemplate <class _Tp>\nstruct __sfinae_underlying_type<_Tp, false> {};\n\ninline _LIBCPP_INLINE_VISIBILITY\nint __convert_to_integral(int __val) { return __val; }\n\ninline _LIBCPP_INLINE_VISIBILITY\nunsigned __convert_to_integral(unsigned __val) { return __val; }\n\ninline _LIBCPP_INLINE_VISIBILITY\nlong __convert_to_integral(long __val) { return __val; }\n\ninline _LIBCPP_INLINE_VISIBILITY\nunsigned long __convert_to_integral(unsigned long __val) { return __val; }\n\ninline _LIBCPP_INLINE_VISIBILITY\nlong long __convert_to_integral(long long __val) { return __val; }\n\ninline _LIBCPP_INLINE_VISIBILITY\nunsigned long long __convert_to_integral(unsigned long long __val) {return __val; }\n\n#ifndef _LIBCPP_HAS_NO_INT128\ninline _LIBCPP_INLINE_VISIBILITY\n__int128_t __convert_to_integral(__int128_t __val) { return __val; }\n\ninline _LIBCPP_INLINE_VISIBILITY\n__uint128_t __convert_to_integral(__uint128_t __val) { return __val; }\n#endif\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename __sfinae_underlying_type<_Tp>::__promoted_type\n__convert_to_integral(_Tp __val) { return __val; }\n\n#ifndef _LIBCPP_CXX03_LANG\n\ntemplate <class _Tp>\nstruct __has_operator_addressof_member_imp\n{\n    template <class _Up>\n        static auto __test(int)\n            -> typename __select_2nd<decltype(_VSTD::declval<_Up>().operator&()), true_type>::type;\n    template <class>\n        static auto __test(long) -> false_type;\n\n    static const bool value = decltype(__test<_Tp>(0))::value;\n};\n\ntemplate <class _Tp>\nstruct __has_operator_addressof_free_imp\n{\n    template <class _Up>\n        static auto __test(int)\n            -> typename __select_2nd<decltype(operator&(_VSTD::declval<_Up>())), true_type>::type;\n    template <class>\n        static auto __test(long) -> false_type;\n\n    static const bool value = decltype(__test<_Tp>(0))::value;\n};\n\ntemplate <class _Tp>\nstruct __has_operator_addressof\n    : public integral_constant<bool, __has_operator_addressof_member_imp<_Tp>::value\n                                  || __has_operator_addressof_free_imp<_Tp>::value>\n{};\n\n#endif  // _LIBCPP_CXX03_LANG\n\n#if _LIBCPP_STD_VER > 14\n\n#define __cpp_lib_void_t 201411\ntemplate <class...> using void_t = void;\n\n# ifndef _LIBCPP_HAS_NO_VARIADICS\ntemplate <class... _Args>\nstruct conjunction : __and_<_Args...> {};\ntemplate<class... _Args> constexpr bool conjunction_v = conjunction<_Args...>::value;\n\ntemplate <class... _Args>\nstruct disjunction : __or_<_Args...> {};\ntemplate<class... _Args> constexpr bool disjunction_v = disjunction<_Args...>::value;\n\ntemplate <class _Tp>\nstruct negation : __not_<_Tp> {};\ntemplate<class _Tp> constexpr bool negation_v = negation<_Tp>::value;\n# endif // _LIBCPP_HAS_NO_VARIADICS\n#endif  // _LIBCPP_STD_VER > 14\n\n// These traits are used in __tree and __hash_table\n#ifndef _LIBCPP_CXX03_LANG\nstruct __extract_key_fail_tag {};\nstruct __extract_key_self_tag {};\nstruct __extract_key_first_tag {};\n\ntemplate <class _ValTy, class _Key,\n          class _RawValTy = typename __unconstref<_ValTy>::type>\nstruct __can_extract_key\n    : conditional<is_same<_RawValTy, _Key>::value, __extract_key_self_tag,\n                  __extract_key_fail_tag>::type {};\n\ntemplate <class _Pair, class _Key, class _First, class _Second>\nstruct __can_extract_key<_Pair, _Key, pair<_First, _Second>>\n    : conditional<is_same<typename remove_const<_First>::type, _Key>::value,\n                  __extract_key_first_tag, __extract_key_fail_tag>::type {};\n\n// __can_extract_map_key uses true_type/false_type instead of the tags.\n// It returns true if _Key != _ContainerValueTy (the container is a map not a set)\n// and _ValTy == _Key.\ntemplate <class _ValTy, class _Key, class _ContainerValueTy,\n          class _RawValTy = typename __unconstref<_ValTy>::type>\nstruct __can_extract_map_key\n    : integral_constant<bool, is_same<_RawValTy, _Key>::value> {};\n\n// This specialization returns __extract_key_fail_tag for non-map containers\n// because _Key == _ContainerValueTy\ntemplate <class _ValTy, class _Key, class _RawValTy>\nstruct __can_extract_map_key<_ValTy, _Key, _Key, _RawValTy>\n    : false_type {};\n\n#endif\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_TYPE_TRAITS\n","// -*- C++ -*-\n//===-------------------------- iterator ----------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_ITERATOR\n#define _LIBCPP_ITERATOR\n\n/*\n    iterator synopsis\n\nnamespace std\n{\n\ntemplate<class Iterator>\nstruct iterator_traits\n{\n    typedef typename Iterator::difference_type difference_type;\n    typedef typename Iterator::value_type value_type;\n    typedef typename Iterator::pointer pointer;\n    typedef typename Iterator::reference reference;\n    typedef typename Iterator::iterator_category iterator_category;\n};\n\ntemplate<class T>\nstruct iterator_traits<T*>\n{\n    typedef ptrdiff_t difference_type;\n    typedef T value_type;\n    typedef T* pointer;\n    typedef T& reference;\n    typedef random_access_iterator_tag iterator_category;\n};\n\ntemplate<class T>\nstruct iterator_traits<const T*>\n{\n    typedef ptrdiff_t difference_type;\n    typedef T value_type;\n    typedef const T* pointer;\n    typedef const T& reference;\n    typedef random_access_iterator_tag iterator_category;\n};\n\ntemplate<class Category, class T, class Distance = ptrdiff_t,\n         class Pointer = T*, class Reference = T&>\nstruct iterator\n{\n    typedef T         value_type;\n    typedef Distance  difference_type;\n    typedef Pointer   pointer;\n    typedef Reference reference;\n    typedef Category  iterator_category;\n};\n\nstruct input_iterator_tag  {};\nstruct output_iterator_tag {};\nstruct forward_iterator_tag       : public input_iterator_tag         {};\nstruct bidirectional_iterator_tag : public forward_iterator_tag       {};\nstruct random_access_iterator_tag : public bidirectional_iterator_tag {};\n\n// extension: second argument not conforming to C++03\ntemplate <class InputIterator>\nvoid advance(InputIterator& i,\n             typename iterator_traits<InputIterator>::difference_type n);\n\ntemplate <class InputIterator>\ntypename iterator_traits<InputIterator>::difference_type\ndistance(InputIterator first, InputIterator last);\n\ntemplate <class Iterator>\nclass reverse_iterator\n    : public iterator<typename iterator_traits<Iterator>::iterator_category,\n                      typename iterator_traits<Iterator>::value_type,\n                      typename iterator_traits<Iterator>::difference_type,\n                      typename iterator_traits<Iterator>::pointer,\n                      typename iterator_traits<Iterator>::reference>\n{\nprotected:\n    Iterator current;\npublic:\n    typedef Iterator                                            iterator_type;\n    typedef typename iterator_traits<Iterator>::difference_type difference_type;\n    typedef typename iterator_traits<Iterator>::reference       reference;\n    typedef typename iterator_traits<Iterator>::pointer         pointer;\n\n    constexpr reverse_iterator();\n    constexpr explicit reverse_iterator(Iterator x);\n    template <class U> constexpr reverse_iterator(const reverse_iterator<U>& u);\n    template <class U> constexpr reverse_iterator& operator=(const reverse_iterator<U>& u);\n    constexpr Iterator base() const;\n    constexpr reference operator*() const;\n    constexpr pointer   operator->() const;\n    constexpr reverse_iterator& operator++();\n    constexpr reverse_iterator  operator++(int);\n    constexpr reverse_iterator& operator--();\n    constexpr reverse_iterator  operator--(int);\n    constexpr reverse_iterator  operator+ (difference_type n) const;\n    constexpr reverse_iterator& operator+=(difference_type n);\n    constexpr reverse_iterator  operator- (difference_type n) const;\n    constexpr reverse_iterator& operator-=(difference_type n);\n    constexpr reference         operator[](difference_type n) const;\n};\n\ntemplate <class Iterator1, class Iterator2>\nconstexpr bool                          // constexpr in C++17\noperator==(const reverse_iterator<Iterator1>& x, const reverse_iterator<Iterator2>& y);\n\ntemplate <class Iterator1, class Iterator2>\nconstexpr bool                          // constexpr in C++17\noperator<(const reverse_iterator<Iterator1>& x, const reverse_iterator<Iterator2>& y);\n\ntemplate <class Iterator1, class Iterator2>\nconstexpr bool                          // constexpr in C++17\noperator!=(const reverse_iterator<Iterator1>& x, const reverse_iterator<Iterator2>& y);\n\ntemplate <class Iterator1, class Iterator2>\nconstexpr bool                          // constexpr in C++17\noperator>(const reverse_iterator<Iterator1>& x, const reverse_iterator<Iterator2>& y);\n\ntemplate <class Iterator1, class Iterator2>\nconstexpr bool                          // constexpr in C++17\noperator>=(const reverse_iterator<Iterator1>& x, const reverse_iterator<Iterator2>& y);\n\ntemplate <class Iterator1, class Iterator2>\nconstexpr bool                          // constexpr in C++17\noperator<=(const reverse_iterator<Iterator1>& x, const reverse_iterator<Iterator2>& y);\n\ntemplate <class Iterator1, class Iterator2>\nconstexpr auto\noperator-(const reverse_iterator<Iterator1>& x, const reverse_iterator<Iterator2>& y)\n-> decltype(__y.base() - __x.base());   // constexpr in C++17\n\ntemplate <class Iterator>\nconstexpr reverse_iterator<Iterator>\noperator+(typename reverse_iterator<Iterator>::difference_type n, \n          const reverse_iterator<Iterator>& x);   // constexpr in C++17\n\ntemplate <class Iterator>\nconstexpr reverse_iterator<Iterator> make_reverse_iterator(Iterator i); // C++14, constexpr in C++17\n\ntemplate <class Container>\nclass back_insert_iterator\n{\nprotected:\n    Container* container;\npublic:\n    typedef Container                   container_type;\n    typedef void                        value_type;\n    typedef void                        difference_type;\n    typedef void                        reference;\n    typedef void                        pointer;\n\n    explicit back_insert_iterator(Container& x);\n    back_insert_iterator& operator=(const typename Container::value_type& value);\n    back_insert_iterator& operator*();\n    back_insert_iterator& operator++();\n    back_insert_iterator  operator++(int);\n};\n\ntemplate <class Container> back_insert_iterator<Container> back_inserter(Container& x);\n\ntemplate <class Container>\nclass front_insert_iterator\n{\nprotected:\n    Container* container;\npublic:\n    typedef Container                    container_type;\n    typedef void                         value_type;\n    typedef void                         difference_type;\n    typedef void                         reference;\n    typedef void                         pointer;\n\n    explicit front_insert_iterator(Container& x);\n    front_insert_iterator& operator=(const typename Container::value_type& value);\n    front_insert_iterator& operator*();\n    front_insert_iterator& operator++();\n    front_insert_iterator  operator++(int);\n};\n\ntemplate <class Container> front_insert_iterator<Container> front_inserter(Container& x);\n\ntemplate <class Container>\nclass insert_iterator\n{\nprotected:\n    Container* container;\n    typename Container::iterator iter;\npublic:\n    typedef Container              container_type;\n    typedef void                   value_type;\n    typedef void                   difference_type;\n    typedef void                   reference;\n    typedef void                   pointer;\n\n    insert_iterator(Container& x, typename Container::iterator i);\n    insert_iterator& operator=(const typename Container::value_type& value);\n    insert_iterator& operator*();\n    insert_iterator& operator++();\n    insert_iterator& operator++(int);\n};\n\ntemplate <class Container, class Iterator>\ninsert_iterator<Container> inserter(Container& x, Iterator i);\n\ntemplate <class Iterator>\nclass move_iterator {\npublic:\n    typedef Iterator                                              iterator_type;\n    typedef typename iterator_traits<Iterator>::difference_type   difference_type;\n    typedef Iterator                                              pointer;\n    typedef typename iterator_traits<Iterator>::value_type        value_type;\n    typedef typename iterator_traits<Iterator>::iterator_category iterator_category;\n    typedef value_type&&                                          reference;\n \n    constexpr move_iterator();  // all the constexprs are in C++17\n    constexpr explicit move_iterator(Iterator i);\n    template <class U>\n      constexpr move_iterator(const move_iterator<U>& u);\n    template <class U>\n      constexpr move_iterator& operator=(const move_iterator<U>& u);\n    constexpr iterator_type base() const;\n    constexpr reference operator*() const;\n    constexpr pointer operator->() const;\n    constexpr move_iterator& operator++();\n    constexpr move_iterator operator++(int);\n    constexpr move_iterator& operator--();\n    constexpr move_iterator operator--(int);\n    constexpr move_iterator operator+(difference_type n) const; \n    constexpr move_iterator& operator+=(difference_type n); \n    constexpr move_iterator operator-(difference_type n) const; \n    constexpr move_iterator& operator-=(difference_type n); \n    constexpr unspecified operator[](difference_type n) const;\nprivate:\n    Iterator current; // exposition only\n};\n\ntemplate <class Iterator1, class Iterator2>\nconstexpr bool   // constexpr in C++17\noperator==(const move_iterator<Iterator1>& x, const move_iterator<Iterator2>& y);\n\ntemplate <class Iterator1, class Iterator2>\nconstexpr bool   // constexpr in C++17\noperator!=(const move_iterator<Iterator1>& x, const move_iterator<Iterator2>& y);\n\ntemplate <class Iterator1, class Iterator2>\nconstexpr bool   // constexpr in C++17\noperator<(const move_iterator<Iterator1>& x, const move_iterator<Iterator2>& y);\n\ntemplate <class Iterator1, class Iterator2>\nconstexpr bool   // constexpr in C++17\noperator<=(const move_iterator<Iterator1>& x, const move_iterator<Iterator2>& y);\n\ntemplate <class Iterator1, class Iterator2>\nconstexpr bool   // constexpr in C++17\noperator>(const move_iterator<Iterator1>& x, const move_iterator<Iterator2>& y);\n\ntemplate <class Iterator1, class Iterator2>\nconstexpr bool   // constexpr in C++17\noperator>=(const move_iterator<Iterator1>& x, const move_iterator<Iterator2>& y);\n\ntemplate <class Iterator1, class Iterator2>\nconstexpr auto   // constexpr in C++17\noperator-(const move_iterator<Iterator1>& x,\n          const move_iterator<Iterator2>& y) -> decltype(x.base() - y.base());\n\ntemplate <class Iterator>\nconstexpr move_iterator<Iterator> operator+(   // constexpr in C++17\n            typename move_iterator<Iterator>::difference_type n, \n            const move_iterator<Iterator>& x);\n\ntemplate <class Iterator>   // constexpr in C++17\nconstexpr  move_iterator<Iterator> make_move_iterator(const Iterator& i);\n\n\ntemplate <class T, class charT = char, class traits = char_traits<charT>, class Distance = ptrdiff_t>\nclass istream_iterator\n    : public iterator<input_iterator_tag, T, Distance, const T*, const T&>\n{\npublic:\n    typedef charT char_type;\n    typedef traits traits_type;\n    typedef basic_istream<charT,traits> istream_type;\n\n    constexpr istream_iterator();\n    istream_iterator(istream_type& s);\n    istream_iterator(const istream_iterator& x);\n    ~istream_iterator();\n\n    const T& operator*() const;\n    const T* operator->() const;\n    istream_iterator& operator++();\n    istream_iterator  operator++(int);\n};\n\ntemplate <class T, class charT, class traits, class Distance>\nbool operator==(const istream_iterator<T,charT,traits,Distance>& x,\n                const istream_iterator<T,charT,traits,Distance>& y);\ntemplate <class T, class charT, class traits, class Distance>\nbool operator!=(const istream_iterator<T,charT,traits,Distance>& x,\n                const istream_iterator<T,charT,traits,Distance>& y);\n\ntemplate <class T, class charT = char, class traits = char_traits<charT> >\nclass ostream_iterator\n    : public iterator<output_iterator_tag, void, void, void ,void>\n{\npublic:\n    typedef charT char_type;\n    typedef traits traits_type;\n    typedef basic_ostream<charT,traits> ostream_type;\n\n    ostream_iterator(ostream_type& s);\n    ostream_iterator(ostream_type& s, const charT* delimiter);\n    ostream_iterator(const ostream_iterator& x);\n    ~ostream_iterator();\n    ostream_iterator& operator=(const T& value);\n\n    ostream_iterator& operator*();\n    ostream_iterator& operator++();\n    ostream_iterator& operator++(int);\n};\n\ntemplate<class charT, class traits = char_traits<charT> >\nclass istreambuf_iterator\n    : public iterator<input_iterator_tag, charT,\n                      typename traits::off_type, unspecified,\n                      charT>\n{\npublic:\n    typedef charT                         char_type;\n    typedef traits                        traits_type;\n    typedef typename traits::int_type     int_type;\n    typedef basic_streambuf<charT,traits> streambuf_type;\n    typedef basic_istream<charT,traits>   istream_type;\n\n    istreambuf_iterator() noexcept;\n    istreambuf_iterator(istream_type& s) noexcept;\n    istreambuf_iterator(streambuf_type* s) noexcept;\n    istreambuf_iterator(a-private-type) noexcept;\n\n    charT                operator*() const;\n    pointer operator->() const;\n    istreambuf_iterator& operator++();\n    a-private-type       operator++(int);\n\n    bool equal(const istreambuf_iterator& b) const;\n};\n\ntemplate <class charT, class traits>\nbool operator==(const istreambuf_iterator<charT,traits>& a,\n                const istreambuf_iterator<charT,traits>& b);\ntemplate <class charT, class traits>\nbool operator!=(const istreambuf_iterator<charT,traits>& a,\n                const istreambuf_iterator<charT,traits>& b);\n\ntemplate <class charT, class traits = char_traits<charT> >\nclass ostreambuf_iterator\n    : public iterator<output_iterator_tag, void, void, void, void>\n{\npublic:\n    typedef charT                         char_type;\n    typedef traits                        traits_type;\n    typedef basic_streambuf<charT,traits> streambuf_type;\n    typedef basic_ostream<charT,traits>   ostream_type;\n\n    ostreambuf_iterator(ostream_type& s) noexcept;\n    ostreambuf_iterator(streambuf_type* s) noexcept;\n    ostreambuf_iterator& operator=(charT c);\n    ostreambuf_iterator& operator*();\n    ostreambuf_iterator& operator++();\n    ostreambuf_iterator& operator++(int);\n    bool failed() const noexcept;\n};\n\ntemplate <class C> constexpr auto begin(C& c) -> decltype(c.begin());\ntemplate <class C> constexpr auto begin(const C& c) -> decltype(c.begin());\ntemplate <class C> constexpr auto end(C& c) -> decltype(c.end());\ntemplate <class C> constexpr auto end(const C& c) -> decltype(c.end());\ntemplate <class T, size_t N> constexpr T* begin(T (&array)[N]);\ntemplate <class T, size_t N> constexpr T* end(T (&array)[N]);\n\ntemplate <class C> auto constexpr cbegin(const C& c) -> decltype(std::begin(c));        // C++14\ntemplate <class C> auto constexpr cend(const C& c) -> decltype(std::end(c));            // C++14\ntemplate <class C> auto constexpr rbegin(C& c) -> decltype(c.rbegin());                 // C++14\ntemplate <class C> auto constexpr rbegin(const C& c) -> decltype(c.rbegin());           // C++14\ntemplate <class C> auto constexpr rend(C& c) -> decltype(c.rend());                     // C++14\ntemplate <class C> constexpr auto rend(const C& c) -> decltype(c.rend());               // C++14\ntemplate <class E> reverse_iterator<const E*> constexpr rbegin(initializer_list<E> il); // C++14\ntemplate <class E> reverse_iterator<const E*> constexpr rend(initializer_list<E> il);   // C++14\ntemplate <class T, size_t N> reverse_iterator<T*> constexpr rbegin(T (&array)[N]);      // C++14\ntemplate <class T, size_t N> reverse_iterator<T*> constexpr rend(T (&array)[N]);        // C++14\ntemplate <class C> constexpr auto crbegin(const C& c) -> decltype(std::rbegin(c));      // C++14\ntemplate <class C> constexpr auto crend(const C& c) -> decltype(std::rend(c));          // C++14\n\n// 24.8, container access:\ntemplate <class C> constexpr auto size(const C& c) -> decltype(c.size());         // C++17\ntemplate <class T, size_t N> constexpr size_t size(const T (&array)[N]) noexcept; // C++17\ntemplate <class C> constexpr auto empty(const C& c) -> decltype(c.empty());       // C++17\ntemplate <class T, size_t N> constexpr bool empty(const T (&array)[N]) noexcept;  // C++17\ntemplate <class E> constexpr bool empty(initializer_list<E> il) noexcept;         // C++17\ntemplate <class C> constexpr auto data(C& c) -> decltype(c.data());               // C++17\ntemplate <class C> constexpr auto data(const C& c) -> decltype(c.data());         // C++17\ntemplate <class T, size_t N> constexpr T* data(T (&array)[N]) noexcept;           // C++17\ntemplate <class E> constexpr const E* data(initializer_list<E> il) noexcept;      // C++17\n\n}  // std\n\n*/\n\n#include <__config>\n#include <iosfwd> // for forward declarations of vector and string.\n#include <__functional_base>\n#include <type_traits>\n#include <cstddef>\n#include <initializer_list>\n#ifdef __APPLE__\n#include <Availability.h>\n#endif\n\n#include <__debug>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\nstruct _LIBCPP_TEMPLATE_VIS input_iterator_tag {};\nstruct _LIBCPP_TEMPLATE_VIS output_iterator_tag {};\nstruct _LIBCPP_TEMPLATE_VIS forward_iterator_tag       : public input_iterator_tag {};\nstruct _LIBCPP_TEMPLATE_VIS bidirectional_iterator_tag : public forward_iterator_tag {};\nstruct _LIBCPP_TEMPLATE_VIS random_access_iterator_tag : public bidirectional_iterator_tag {};\n\ntemplate <class _Tp>\nstruct __has_iterator_category\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::iterator_category* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Iter, bool> struct __iterator_traits_impl {};\n\ntemplate <class _Iter>\nstruct __iterator_traits_impl<_Iter, true>\n{\n    typedef typename _Iter::difference_type   difference_type;\n    typedef typename _Iter::value_type        value_type;\n    typedef typename _Iter::pointer           pointer;\n    typedef typename _Iter::reference         reference;\n    typedef typename _Iter::iterator_category iterator_category;\n};\n\ntemplate <class _Iter, bool> struct __iterator_traits {};\n\ntemplate <class _Iter>\nstruct __iterator_traits<_Iter, true>\n    :  __iterator_traits_impl\n      <\n        _Iter,\n        is_convertible<typename _Iter::iterator_category, input_iterator_tag>::value ||\n        is_convertible<typename _Iter::iterator_category, output_iterator_tag>::value\n      >\n{};\n\n// iterator_traits<Iterator> will only have the nested types if Iterator::iterator_category\n//    exists.  Else iterator_traits<Iterator> will be an empty class.  This is a\n//    conforming extension which allows some programs to compile and behave as\n//    the client expects instead of failing at compile time.\n\ntemplate <class _Iter>\nstruct _LIBCPP_TEMPLATE_VIS iterator_traits\n    : __iterator_traits<_Iter, __has_iterator_category<_Iter>::value> {};\n\ntemplate<class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS iterator_traits<_Tp*>\n{\n    typedef ptrdiff_t difference_type;\n    typedef typename remove_const<_Tp>::type value_type;\n    typedef _Tp* pointer;\n    typedef _Tp& reference;\n    typedef random_access_iterator_tag iterator_category;\n};\n\ntemplate <class _Tp, class _Up, bool = __has_iterator_category<iterator_traits<_Tp> >::value>\nstruct __has_iterator_category_convertible_to\n    : public integral_constant<bool, is_convertible<typename iterator_traits<_Tp>::iterator_category, _Up>::value>\n{};\n\ntemplate <class _Tp, class _Up>\nstruct __has_iterator_category_convertible_to<_Tp, _Up, false> : public false_type {};\n\ntemplate <class _Tp>\nstruct __is_input_iterator : public __has_iterator_category_convertible_to<_Tp, input_iterator_tag> {};\n\ntemplate <class _Tp>\nstruct __is_forward_iterator : public __has_iterator_category_convertible_to<_Tp, forward_iterator_tag> {};\n\ntemplate <class _Tp>\nstruct __is_bidirectional_iterator : public __has_iterator_category_convertible_to<_Tp, bidirectional_iterator_tag> {};\n\ntemplate <class _Tp>\nstruct __is_random_access_iterator : public __has_iterator_category_convertible_to<_Tp, random_access_iterator_tag> {};\n\ntemplate <class _Tp>\nstruct __is_exactly_input_iterator\n    : public integral_constant<bool, \n         __has_iterator_category_convertible_to<_Tp, input_iterator_tag>::value && \n        !__has_iterator_category_convertible_to<_Tp, forward_iterator_tag>::value> {};\n\ntemplate<class _Category, class _Tp, class _Distance = ptrdiff_t,\n         class _Pointer = _Tp*, class _Reference = _Tp&>\nstruct _LIBCPP_TEMPLATE_VIS iterator\n{\n    typedef _Tp        value_type;\n    typedef _Distance  difference_type;\n    typedef _Pointer   pointer;\n    typedef _Reference reference;\n    typedef _Category  iterator_category;\n};\n\ntemplate <class _InputIter>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid __advance(_InputIter& __i,\n             typename iterator_traits<_InputIter>::difference_type __n, input_iterator_tag)\n{\n    for (; __n > 0; --__n)\n        ++__i;\n}\n\ntemplate <class _BiDirIter>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid __advance(_BiDirIter& __i,\n             typename iterator_traits<_BiDirIter>::difference_type __n, bidirectional_iterator_tag)\n{\n    if (__n >= 0)\n        for (; __n > 0; --__n)\n            ++__i;\n    else\n        for (; __n < 0; ++__n)\n            --__i;\n}\n\ntemplate <class _RandIter>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid __advance(_RandIter& __i,\n             typename iterator_traits<_RandIter>::difference_type __n, random_access_iterator_tag)\n{\n   __i += __n;\n}\n\ntemplate <class _InputIter>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid advance(_InputIter& __i,\n             typename iterator_traits<_InputIter>::difference_type __n)\n{\n    __advance(__i, __n, typename iterator_traits<_InputIter>::iterator_category());\n}\n\ntemplate <class _InputIter>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename iterator_traits<_InputIter>::difference_type\n__distance(_InputIter __first, _InputIter __last, input_iterator_tag)\n{\n    typename iterator_traits<_InputIter>::difference_type __r(0);\n    for (; __first != __last; ++__first)\n        ++__r;\n    return __r;\n}\n\ntemplate <class _RandIter>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename iterator_traits<_RandIter>::difference_type\n__distance(_RandIter __first, _RandIter __last, random_access_iterator_tag)\n{\n    return __last - __first;\n}\n\ntemplate <class _InputIter>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename iterator_traits<_InputIter>::difference_type\ndistance(_InputIter __first, _InputIter __last)\n{\n    return __distance(__first, __last, typename iterator_traits<_InputIter>::iterator_category());\n}\n\ntemplate <class _InputIter>\ninline _LIBCPP_INLINE_VISIBILITY\n_InputIter\nnext(_InputIter __x,\n     typename iterator_traits<_InputIter>::difference_type __n = 1,\n     typename enable_if<__is_input_iterator<_InputIter>::value>::type* = 0)\n{\n    _VSTD::advance(__x, __n);\n    return __x;\n}\n\ntemplate <class _BidiretionalIter>\ninline _LIBCPP_INLINE_VISIBILITY\n_BidiretionalIter\nprev(_BidiretionalIter __x,\n     typename iterator_traits<_BidiretionalIter>::difference_type __n = 1,\n     typename enable_if<__is_bidirectional_iterator<_BidiretionalIter>::value>::type* = 0)\n{\n    _VSTD::advance(__x, -__n);\n    return __x;\n}\n\ntemplate <class _Iter>\nclass _LIBCPP_TEMPLATE_VIS reverse_iterator\n    : public iterator<typename iterator_traits<_Iter>::iterator_category,\n                      typename iterator_traits<_Iter>::value_type,\n                      typename iterator_traits<_Iter>::difference_type,\n                      typename iterator_traits<_Iter>::pointer,\n                      typename iterator_traits<_Iter>::reference>\n{\nprivate:\n    /*mutable*/ _Iter __t;  // no longer used as of LWG #2360, not removed due to ABI break\nprotected:\n    _Iter current;\npublic:\n    typedef _Iter                                            iterator_type;\n    typedef typename iterator_traits<_Iter>::difference_type difference_type;\n    typedef typename iterator_traits<_Iter>::reference       reference;\n    typedef typename iterator_traits<_Iter>::pointer         pointer;\n\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\n    reverse_iterator() : __t(), current() {}\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\n    explicit reverse_iterator(_Iter __x) : __t(__x), current(__x) {}\n    template <class _Up>\n        _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\n        reverse_iterator(const reverse_iterator<_Up>& __u) : __t(__u.base()), current(__u.base()) {}\n    template <class _Up>\n        _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\n        reverse_iterator& operator=(const reverse_iterator<_Up>& __u)\n            { __t = current = __u.base(); return *this; }\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\n    _Iter base() const {return current;}\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\n    reference operator*() const {_Iter __tmp = current; return *--__tmp;}\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\n    pointer  operator->() const {return _VSTD::addressof(operator*());}\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\n    reverse_iterator& operator++() {--current; return *this;}\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\n    reverse_iterator  operator++(int) {reverse_iterator __tmp(*this); --current; return __tmp;}\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\n    reverse_iterator& operator--() {++current; return *this;}\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\n    reverse_iterator  operator--(int) {reverse_iterator __tmp(*this); ++current; return __tmp;}\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\n    reverse_iterator  operator+ (difference_type __n) const {return reverse_iterator(current - __n);}\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\n    reverse_iterator& operator+=(difference_type __n) {current -= __n; return *this;}\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\n    reverse_iterator  operator- (difference_type __n) const {return reverse_iterator(current + __n);}\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\n    reverse_iterator& operator-=(difference_type __n) {current += __n; return *this;}\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\n    reference         operator[](difference_type __n) const {return *(*this + __n);}\n};\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\nbool\noperator==(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)\n{\n    return __x.base() == __y.base();\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\nbool\noperator<(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)\n{\n    return __x.base() > __y.base();\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\nbool\noperator!=(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)\n{\n    return __x.base() != __y.base();\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\nbool\noperator>(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)\n{\n    return __x.base() < __y.base();\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\nbool\noperator>=(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)\n{\n    return __x.base() <= __y.base();\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\nbool\noperator<=(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)\n{\n    return __x.base() >= __y.base();\n}\n\n#ifndef _LIBCPP_CXX03_LANG\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\nauto\noperator-(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)\n-> decltype(__y.base() - __x.base())\n{\n    return __y.base() - __x.base();\n}\n#else\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename reverse_iterator<_Iter1>::difference_type\noperator-(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)\n{\n    return __y.base() - __x.base();\n}\n#endif\n\ntemplate <class _Iter>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\nreverse_iterator<_Iter>\noperator+(typename reverse_iterator<_Iter>::difference_type __n, const reverse_iterator<_Iter>& __x)\n{\n    return reverse_iterator<_Iter>(__x.base() - __n);\n}\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Iter>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\nreverse_iterator<_Iter> make_reverse_iterator(_Iter __i)\n{\n    return reverse_iterator<_Iter>(__i);\n}\n#endif\n\ntemplate <class _Container>\nclass _LIBCPP_TEMPLATE_VIS back_insert_iterator\n    : public iterator<output_iterator_tag,\n                      void,\n                      void,\n                      void,\n                      void>\n{\nprotected:\n    _Container* container;\npublic:\n    typedef _Container container_type;\n\n    _LIBCPP_INLINE_VISIBILITY explicit back_insert_iterator(_Container& __x) : container(_VSTD::addressof(__x)) {}\n    _LIBCPP_INLINE_VISIBILITY back_insert_iterator& operator=(const typename _Container::value_type& __value_)\n        {container->push_back(__value_); return *this;}\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY back_insert_iterator& operator=(typename _Container::value_type&& __value_)\n        {container->push_back(_VSTD::move(__value_)); return *this;}\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY back_insert_iterator& operator*()     {return *this;}\n    _LIBCPP_INLINE_VISIBILITY back_insert_iterator& operator++()    {return *this;}\n    _LIBCPP_INLINE_VISIBILITY back_insert_iterator  operator++(int) {return *this;}\n};\n\ntemplate <class _Container>\ninline _LIBCPP_INLINE_VISIBILITY\nback_insert_iterator<_Container>\nback_inserter(_Container& __x)\n{\n    return back_insert_iterator<_Container>(__x);\n}\n\ntemplate <class _Container>\nclass _LIBCPP_TEMPLATE_VIS front_insert_iterator\n    : public iterator<output_iterator_tag,\n                      void,\n                      void,\n                      void,\n                      void>\n{\nprotected:\n    _Container* container;\npublic:\n    typedef _Container container_type;\n\n    _LIBCPP_INLINE_VISIBILITY explicit front_insert_iterator(_Container& __x) : container(_VSTD::addressof(__x)) {}\n    _LIBCPP_INLINE_VISIBILITY front_insert_iterator& operator=(const typename _Container::value_type& __value_)\n        {container->push_front(__value_); return *this;}\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY front_insert_iterator& operator=(typename _Container::value_type&& __value_)\n        {container->push_front(_VSTD::move(__value_)); return *this;}\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY front_insert_iterator& operator*()     {return *this;}\n    _LIBCPP_INLINE_VISIBILITY front_insert_iterator& operator++()    {return *this;}\n    _LIBCPP_INLINE_VISIBILITY front_insert_iterator  operator++(int) {return *this;}\n};\n\ntemplate <class _Container>\ninline _LIBCPP_INLINE_VISIBILITY\nfront_insert_iterator<_Container>\nfront_inserter(_Container& __x)\n{\n    return front_insert_iterator<_Container>(__x);\n}\n\ntemplate <class _Container>\nclass _LIBCPP_TEMPLATE_VIS insert_iterator\n    : public iterator<output_iterator_tag,\n                      void,\n                      void,\n                      void,\n                      void>\n{\nprotected:\n    _Container* container;\n    typename _Container::iterator iter;\npublic:\n    typedef _Container container_type;\n\n    _LIBCPP_INLINE_VISIBILITY insert_iterator(_Container& __x, typename _Container::iterator __i)\n        : container(_VSTD::addressof(__x)), iter(__i) {}\n    _LIBCPP_INLINE_VISIBILITY insert_iterator& operator=(const typename _Container::value_type& __value_)\n        {iter = container->insert(iter, __value_); ++iter; return *this;}\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY insert_iterator& operator=(typename _Container::value_type&& __value_)\n        {iter = container->insert(iter, _VSTD::move(__value_)); ++iter; return *this;}\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY insert_iterator& operator*()        {return *this;}\n    _LIBCPP_INLINE_VISIBILITY insert_iterator& operator++()       {return *this;}\n    _LIBCPP_INLINE_VISIBILITY insert_iterator& operator++(int)    {return *this;}\n};\n\ntemplate <class _Container>\ninline _LIBCPP_INLINE_VISIBILITY\ninsert_iterator<_Container>\ninserter(_Container& __x, typename _Container::iterator __i)\n{\n    return insert_iterator<_Container>(__x, __i);\n}\n\ntemplate <class _Tp, class _CharT = char,\n          class _Traits = char_traits<_CharT>, class _Distance = ptrdiff_t>\nclass _LIBCPP_TEMPLATE_VIS istream_iterator\n    : public iterator<input_iterator_tag, _Tp, _Distance, const _Tp*, const _Tp&>\n{\npublic:\n    typedef _CharT char_type;\n    typedef _Traits traits_type;\n    typedef basic_istream<_CharT,_Traits> istream_type;\nprivate:\n    istream_type* __in_stream_;\n    _Tp __value_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR istream_iterator() : __in_stream_(0), __value_() {}\n    _LIBCPP_INLINE_VISIBILITY istream_iterator(istream_type& __s) : __in_stream_(_VSTD::addressof(__s))\n        {\n            if (!(*__in_stream_ >> __value_))\n                __in_stream_ = 0;\n        }\n\n    _LIBCPP_INLINE_VISIBILITY const _Tp& operator*() const {return __value_;}\n    _LIBCPP_INLINE_VISIBILITY const _Tp* operator->() const {return _VSTD::addressof((operator*()));}\n    _LIBCPP_INLINE_VISIBILITY istream_iterator& operator++()\n        {\n            if (!(*__in_stream_ >> __value_))\n                __in_stream_ = 0;\n            return *this;\n        }\n    _LIBCPP_INLINE_VISIBILITY istream_iterator  operator++(int)\n        {istream_iterator __t(*this); ++(*this); return __t;}\n\n    friend _LIBCPP_INLINE_VISIBILITY\n    bool operator==(const istream_iterator& __x, const istream_iterator& __y)\n        {return __x.__in_stream_ == __y.__in_stream_;}\n\n    friend _LIBCPP_INLINE_VISIBILITY\n    bool operator!=(const istream_iterator& __x, const istream_iterator& __y)\n        {return !(__x == __y);}\n};\n\ntemplate <class _Tp, class _CharT = char, class _Traits = char_traits<_CharT> >\nclass _LIBCPP_TEMPLATE_VIS ostream_iterator\n    : public iterator<output_iterator_tag, void, void, void, void>\n{\npublic:\n    typedef _CharT char_type;\n    typedef _Traits traits_type;\n    typedef basic_ostream<_CharT,_Traits> ostream_type;\nprivate:\n    ostream_type* __out_stream_;\n    const char_type* __delim_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY ostream_iterator(ostream_type& __s) _NOEXCEPT\n        : __out_stream_(_VSTD::addressof(__s)), __delim_(0) {}\n    _LIBCPP_INLINE_VISIBILITY ostream_iterator(ostream_type& __s, const _CharT* __delimiter) _NOEXCEPT\n        : __out_stream_(_VSTD::addressof(__s)), __delim_(__delimiter) {}\n    _LIBCPP_INLINE_VISIBILITY ostream_iterator& operator=(const _Tp& __value_)\n        {\n            *__out_stream_ << __value_;\n            if (__delim_)\n                *__out_stream_ << __delim_;\n            return *this;\n        }\n\n    _LIBCPP_INLINE_VISIBILITY ostream_iterator& operator*()     {return *this;}\n    _LIBCPP_INLINE_VISIBILITY ostream_iterator& operator++()    {return *this;}\n    _LIBCPP_INLINE_VISIBILITY ostream_iterator& operator++(int) {return *this;}\n};\n\ntemplate<class _CharT, class _Traits>\nclass _LIBCPP_TEMPLATE_VIS istreambuf_iterator\n    : public iterator<input_iterator_tag, _CharT,\n                      typename _Traits::off_type, _CharT*,\n                      _CharT>\n{\npublic:\n    typedef _CharT                          char_type;\n    typedef _Traits                         traits_type;\n    typedef typename _Traits::int_type      int_type;\n    typedef basic_streambuf<_CharT,_Traits> streambuf_type;\n    typedef basic_istream<_CharT,_Traits>   istream_type;\nprivate:\n    mutable streambuf_type* __sbuf_;\n\n    class __proxy\n    {\n        char_type __keep_;\n        streambuf_type* __sbuf_;\n        _LIBCPP_INLINE_VISIBILITY __proxy(char_type __c, streambuf_type* __s)\n            : __keep_(__c), __sbuf_(__s) {}\n        friend class istreambuf_iterator;\n    public:\n        _LIBCPP_INLINE_VISIBILITY char_type operator*() const {return __keep_;}\n    };\n\n    _LIBCPP_INLINE_VISIBILITY\n    bool __test_for_eof() const\n    {\n        if (__sbuf_ && traits_type::eq_int_type(__sbuf_->sgetc(), traits_type::eof()))\n            __sbuf_ = 0;\n        return __sbuf_ == 0;\n    }\npublic:\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR istreambuf_iterator() _NOEXCEPT : __sbuf_(0) {}\n    _LIBCPP_INLINE_VISIBILITY istreambuf_iterator(istream_type& __s) _NOEXCEPT\n        : __sbuf_(__s.rdbuf()) {}\n    _LIBCPP_INLINE_VISIBILITY istreambuf_iterator(streambuf_type* __s) _NOEXCEPT\n        : __sbuf_(__s) {}\n    _LIBCPP_INLINE_VISIBILITY istreambuf_iterator(const __proxy& __p) _NOEXCEPT\n        : __sbuf_(__p.__sbuf_) {}\n\n    _LIBCPP_INLINE_VISIBILITY char_type  operator*() const\n        {return static_cast<char_type>(__sbuf_->sgetc());}\n    _LIBCPP_INLINE_VISIBILITY char_type* operator->() const {return nullptr;}\n    _LIBCPP_INLINE_VISIBILITY istreambuf_iterator& operator++()\n        {\n            __sbuf_->sbumpc();\n            return *this;\n        }\n    _LIBCPP_INLINE_VISIBILITY __proxy              operator++(int)\n        {\n            return __proxy(__sbuf_->sbumpc(), __sbuf_);\n        }\n\n    _LIBCPP_INLINE_VISIBILITY bool equal(const istreambuf_iterator& __b) const\n        {return __test_for_eof() == __b.__test_for_eof();}\n};\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbool operator==(const istreambuf_iterator<_CharT,_Traits>& __a,\n                const istreambuf_iterator<_CharT,_Traits>& __b)\n                {return __a.equal(__b);}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbool operator!=(const istreambuf_iterator<_CharT,_Traits>& __a,\n                const istreambuf_iterator<_CharT,_Traits>& __b)\n                {return !__a.equal(__b);}\n\ntemplate <class _CharT, class _Traits>\nclass _LIBCPP_TEMPLATE_VIS ostreambuf_iterator\n    : public iterator<output_iterator_tag, void, void, void, void>\n{\npublic:\n    typedef _CharT                          char_type;\n    typedef _Traits                         traits_type;\n    typedef basic_streambuf<_CharT,_Traits> streambuf_type;\n    typedef basic_ostream<_CharT,_Traits>   ostream_type;\nprivate:\n    streambuf_type* __sbuf_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY ostreambuf_iterator(ostream_type& __s) _NOEXCEPT\n        : __sbuf_(__s.rdbuf()) {}\n    _LIBCPP_INLINE_VISIBILITY ostreambuf_iterator(streambuf_type* __s) _NOEXCEPT\n        : __sbuf_(__s) {}\n    _LIBCPP_INLINE_VISIBILITY ostreambuf_iterator& operator=(_CharT __c)\n        {\n            if (__sbuf_ && traits_type::eq_int_type(__sbuf_->sputc(__c), traits_type::eof()))\n                __sbuf_ = 0;\n            return *this;\n        }\n    _LIBCPP_INLINE_VISIBILITY ostreambuf_iterator& operator*()     {return *this;}\n    _LIBCPP_INLINE_VISIBILITY ostreambuf_iterator& operator++()    {return *this;}\n    _LIBCPP_INLINE_VISIBILITY ostreambuf_iterator& operator++(int) {return *this;}\n    _LIBCPP_INLINE_VISIBILITY bool failed() const _NOEXCEPT {return __sbuf_ == 0;}\n\n#if !defined(__APPLE__) || \\\n    (defined(__MAC_OS_X_VERSION_MIN_REQUIRED) && __MAC_OS_X_VERSION_MIN_REQUIRED > __MAC_10_8) || \\\n    (defined(__IPHONE_OS_VERSION_MIN_REQUIRED) && __IPHONE_OS_VERSION_MIN_REQUIRED > __IPHONE_6_0)\n\n    template <class _Ch, class _Tr>\n    friend\n    _LIBCPP_HIDDEN\n    ostreambuf_iterator<_Ch, _Tr>\n    __pad_and_output(ostreambuf_iterator<_Ch, _Tr> __s,\n                     const _Ch* __ob, const _Ch* __op, const _Ch* __oe,\n                     ios_base& __iob, _Ch __fl);\n#endif\n};\n\ntemplate <class _Iter>\nclass _LIBCPP_TEMPLATE_VIS move_iterator\n{\nprivate:\n    _Iter __i;\npublic:\n    typedef _Iter                                            iterator_type;\n    typedef typename iterator_traits<iterator_type>::iterator_category iterator_category;\n    typedef typename iterator_traits<iterator_type>::value_type value_type;\n    typedef typename iterator_traits<iterator_type>::difference_type difference_type;\n    typedef iterator_type pointer;\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    typedef typename iterator_traits<iterator_type>::reference __reference;\n    typedef typename conditional<\n            is_reference<__reference>::value,\n            typename remove_reference<__reference>::type&&,\n            __reference\n        >::type reference;\n#else\n    typedef typename iterator_traits<iterator_type>::reference reference;\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\n    move_iterator() : __i() {}\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\n    explicit move_iterator(_Iter __x) : __i(__x) {}\n    template <class _Up>\n      _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\n      move_iterator(const move_iterator<_Up>& __u) : __i(__u.base()) {}\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14 _Iter base() const {return __i;}\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14 \n    reference operator*() const { return static_cast<reference>(*__i); }\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\n    pointer  operator->() const { return __i;}\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\n    move_iterator& operator++() {++__i; return *this;}\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\n    move_iterator  operator++(int) {move_iterator __tmp(*this); ++__i; return __tmp;}\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\n    move_iterator& operator--() {--__i; return *this;}\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\n    move_iterator  operator--(int) {move_iterator __tmp(*this); --__i; return __tmp;}\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\n    move_iterator  operator+ (difference_type __n) const {return move_iterator(__i + __n);}\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\n    move_iterator& operator+=(difference_type __n) {__i += __n; return *this;}\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\n    move_iterator  operator- (difference_type __n) const {return move_iterator(__i - __n);}\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\n    move_iterator& operator-=(difference_type __n) {__i -= __n; return *this;}\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\n    reference operator[](difference_type __n) const { return static_cast<reference>(__i[__n]); }\n};\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\nbool\noperator==(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)\n{\n    return __x.base() == __y.base();\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\nbool\noperator<(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)\n{\n    return __x.base() < __y.base();\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\nbool\noperator!=(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)\n{\n    return __x.base() != __y.base();\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\nbool\noperator>(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)\n{\n    return __x.base() > __y.base();\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\nbool\noperator>=(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)\n{\n    return __x.base() >= __y.base();\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\nbool\noperator<=(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)\n{\n    return __x.base() <= __y.base();\n}\n\n#ifndef _LIBCPP_CXX03_LANG\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\nauto\noperator-(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)\n-> decltype(__x.base() - __y.base())\n{\n    return __x.base() - __y.base();\n}\n#else\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename move_iterator<_Iter1>::difference_type\noperator-(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)\n{\n    return __x.base() - __y.base();\n}\n#endif\n\ntemplate <class _Iter>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\nmove_iterator<_Iter>\noperator+(typename move_iterator<_Iter>::difference_type __n, const move_iterator<_Iter>& __x)\n{\n    return move_iterator<_Iter>(__x.base() + __n);\n}\n\ntemplate <class _Iter>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\nmove_iterator<_Iter>\nmake_move_iterator(_Iter __i)\n{\n    return move_iterator<_Iter>(__i);\n}\n\n// __wrap_iter\n\ntemplate <class _Iter> class __wrap_iter;\n\ntemplate <class _Iter1, class _Iter2>\n_LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT_DEBUG;\n\ntemplate <class _Iter1, class _Iter2>\n_LIBCPP_INLINE_VISIBILITY\nbool\noperator<(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT_DEBUG;\n\ntemplate <class _Iter1, class _Iter2>\n_LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT_DEBUG;\n\ntemplate <class _Iter1, class _Iter2>\n_LIBCPP_INLINE_VISIBILITY\nbool\noperator>(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT_DEBUG;\n\ntemplate <class _Iter1, class _Iter2>\n_LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT_DEBUG;\n\ntemplate <class _Iter1, class _Iter2>\n_LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT_DEBUG;\n\n#ifndef _LIBCPP_CXX03_LANG\ntemplate <class _Iter1, class _Iter2>\n_LIBCPP_INLINE_VISIBILITY\nauto\noperator-(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) _NOEXCEPT_DEBUG\n-> decltype(__x.base() - __y.base());\n#else\ntemplate <class _Iter1, class _Iter2>\n_LIBCPP_INLINE_VISIBILITY\ntypename __wrap_iter<_Iter1>::difference_type\noperator-(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT_DEBUG;\n#endif\n\ntemplate <class _Iter>\n_LIBCPP_INLINE_VISIBILITY\n__wrap_iter<_Iter>\noperator+(typename __wrap_iter<_Iter>::difference_type, __wrap_iter<_Iter>) _NOEXCEPT_DEBUG;\n\ntemplate <class _Ip, class _Op> _Op _LIBCPP_INLINE_VISIBILITY copy(_Ip, _Ip, _Op);\ntemplate <class _B1, class _B2> _B2 _LIBCPP_INLINE_VISIBILITY copy_backward(_B1, _B1, _B2);\ntemplate <class _Ip, class _Op> _Op _LIBCPP_INLINE_VISIBILITY move(_Ip, _Ip, _Op);\ntemplate <class _B1, class _B2> _B2 _LIBCPP_INLINE_VISIBILITY move_backward(_B1, _B1, _B2);\n\n#if _LIBCPP_DEBUG_LEVEL < 2\n\ntemplate <class _Tp>\n_LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_trivially_copy_assignable<_Tp>::value,\n    _Tp*\n>::type\n__unwrap_iter(__wrap_iter<_Tp*>);\n\n#else\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_trivially_copy_assignable<_Tp>::value,\n    __wrap_iter<_Tp*>\n>::type\n__unwrap_iter(__wrap_iter<_Tp*> __i);\n\n#endif\n\ntemplate <class _Iter>\nclass __wrap_iter\n{\npublic:\n    typedef _Iter                                                      iterator_type;\n    typedef typename iterator_traits<iterator_type>::iterator_category iterator_category;\n    typedef typename iterator_traits<iterator_type>::value_type        value_type;\n    typedef typename iterator_traits<iterator_type>::difference_type   difference_type;\n    typedef typename iterator_traits<iterator_type>::pointer           pointer;\n    typedef typename iterator_traits<iterator_type>::reference         reference;\nprivate:\n    iterator_type __i;\npublic:\n    _LIBCPP_INLINE_VISIBILITY __wrap_iter() _NOEXCEPT_DEBUG\n#if _LIBCPP_STD_VER > 11\n                : __i{}\n#endif\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        __get_db()->__insert_i(this);\n#endif\n    }\n    template <class _Up> _LIBCPP_INLINE_VISIBILITY __wrap_iter(const __wrap_iter<_Up>& __u,\n        typename enable_if<is_convertible<_Up, iterator_type>::value>::type* = 0) _NOEXCEPT_DEBUG\n        : __i(__u.base())\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        __get_db()->__iterator_copy(this, &__u);\n#endif\n    }\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_INLINE_VISIBILITY\n    __wrap_iter(const __wrap_iter& __x)\n        : __i(__x.base())\n    {\n        __get_db()->__iterator_copy(this, &__x);\n    }\n    _LIBCPP_INLINE_VISIBILITY\n    __wrap_iter& operator=(const __wrap_iter& __x)\n    {\n        if (this != &__x)\n        {\n            __get_db()->__iterator_copy(this, &__x);\n            __i = __x.__i;\n        }\n        return *this;\n    }\n    _LIBCPP_INLINE_VISIBILITY\n    ~__wrap_iter()\n    {\n        __get_db()->__erase_i(this);\n    }\n#endif\n    _LIBCPP_INLINE_VISIBILITY reference operator*() const _NOEXCEPT_DEBUG\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        _LIBCPP_ASSERT(__get_const_db()->__dereferenceable(this),\n                       \"Attempted to dereference a non-dereferenceable iterator\");\n#endif\n        return *__i;\n    }\n    _LIBCPP_INLINE_VISIBILITY pointer  operator->() const _NOEXCEPT_DEBUG\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        _LIBCPP_ASSERT(__get_const_db()->__dereferenceable(this),\n                       \"Attempted to dereference a non-dereferenceable iterator\");\n#endif\n        return (pointer)_VSTD::addressof(*__i);\n    }\n    _LIBCPP_INLINE_VISIBILITY __wrap_iter& operator++() _NOEXCEPT_DEBUG\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        _LIBCPP_ASSERT(__get_const_db()->__dereferenceable(this),\n                       \"Attempted to increment non-incrementable iterator\");\n#endif\n        ++__i;\n        return *this;\n    }\n    _LIBCPP_INLINE_VISIBILITY __wrap_iter  operator++(int) _NOEXCEPT_DEBUG\n        {__wrap_iter __tmp(*this); ++(*this); return __tmp;}\n    _LIBCPP_INLINE_VISIBILITY __wrap_iter& operator--() _NOEXCEPT_DEBUG\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        _LIBCPP_ASSERT(__get_const_db()->__decrementable(this),\n                       \"Attempted to decrement non-decrementable iterator\");\n#endif\n        --__i;\n        return *this;\n    }\n    _LIBCPP_INLINE_VISIBILITY __wrap_iter  operator--(int) _NOEXCEPT_DEBUG\n        {__wrap_iter __tmp(*this); --(*this); return __tmp;}\n    _LIBCPP_INLINE_VISIBILITY __wrap_iter  operator+ (difference_type __n) const _NOEXCEPT_DEBUG\n        {__wrap_iter __w(*this); __w += __n; return __w;}\n    _LIBCPP_INLINE_VISIBILITY __wrap_iter& operator+=(difference_type __n) _NOEXCEPT_DEBUG\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        _LIBCPP_ASSERT(__get_const_db()->__addable(this, __n),\n                   \"Attempted to add/subtract iterator outside of valid range\");\n#endif\n        __i += __n;\n        return *this;\n    }\n    _LIBCPP_INLINE_VISIBILITY __wrap_iter  operator- (difference_type __n) const _NOEXCEPT_DEBUG\n        {return *this + (-__n);}\n    _LIBCPP_INLINE_VISIBILITY __wrap_iter& operator-=(difference_type __n) _NOEXCEPT_DEBUG\n        {*this += -__n; return *this;}\n    _LIBCPP_INLINE_VISIBILITY reference        operator[](difference_type __n) const _NOEXCEPT_DEBUG\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        _LIBCPP_ASSERT(__get_const_db()->__subscriptable(this, __n),\n                   \"Attempted to subscript iterator outside of valid range\");\n#endif\n        return __i[__n];\n    }\n\n    _LIBCPP_INLINE_VISIBILITY iterator_type base() const _NOEXCEPT_DEBUG {return __i;}\n\nprivate:\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_INLINE_VISIBILITY __wrap_iter(const void* __p, iterator_type __x) : __i(__x)\n    {\n        __get_db()->__insert_ic(this, __p);\n    }\n#else\n    _LIBCPP_INLINE_VISIBILITY __wrap_iter(iterator_type __x) _NOEXCEPT_DEBUG : __i(__x) {}\n#endif\n\n    template <class _Up> friend class __wrap_iter;\n    template <class _CharT, class _Traits, class _Alloc> friend class basic_string;\n    template <class _Tp, class _Alloc> friend class _LIBCPP_TEMPLATE_VIS vector;\n\n    template <class _Iter1, class _Iter2>\n    friend\n    bool\n    operator==(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT_DEBUG;\n\n    template <class _Iter1, class _Iter2>\n    friend\n    bool\n    operator<(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT_DEBUG;\n\n    template <class _Iter1, class _Iter2>\n    friend\n    bool\n    operator!=(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT_DEBUG;\n\n    template <class _Iter1, class _Iter2>\n    friend\n    bool\n    operator>(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT_DEBUG;\n\n    template <class _Iter1, class _Iter2>\n    friend\n    bool\n    operator>=(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT_DEBUG;\n\n    template <class _Iter1, class _Iter2>\n    friend\n    bool\n    operator<=(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT_DEBUG;\n\n#ifndef _LIBCPP_CXX03_LANG\n    template <class _Iter1, class _Iter2>\n    friend\n    auto\n    operator-(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) _NOEXCEPT_DEBUG\n    -> decltype(__x.base() - __y.base());\n#else\n    template <class _Iter1, class _Iter2>\n    friend\n    typename __wrap_iter<_Iter1>::difference_type\n    operator-(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT_DEBUG;\n#endif\n\n    template <class _Iter1>\n    friend\n    __wrap_iter<_Iter1>\n    operator+(typename __wrap_iter<_Iter1>::difference_type, __wrap_iter<_Iter1>) _NOEXCEPT_DEBUG;\n\n    template <class _Ip, class _Op> friend _Op copy(_Ip, _Ip, _Op);\n    template <class _B1, class _B2> friend _B2 copy_backward(_B1, _B1, _B2);\n    template <class _Ip, class _Op> friend _Op move(_Ip, _Ip, _Op);\n    template <class _B1, class _B2> friend _B2 move_backward(_B1, _B1, _B2);\n\n#if _LIBCPP_DEBUG_LEVEL < 2\n    template <class _Tp>\n    friend\n    typename enable_if\n    <\n        is_trivially_copy_assignable<_Tp>::value,\n        _Tp*\n    >::type\n    __unwrap_iter(__wrap_iter<_Tp*>);\n#else\n  template <class _Tp>\n  inline _LIBCPP_INLINE_VISIBILITY\n  typename enable_if\n  <\n      is_trivially_copy_assignable<_Tp>::value,\n      __wrap_iter<_Tp*>\n  >::type\n  __unwrap_iter(__wrap_iter<_Tp*> __i);\n#endif\n};\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) _NOEXCEPT_DEBUG\n{\n    return __x.base() == __y.base();\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) _NOEXCEPT_DEBUG\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__less_than_comparable(&__x, &__y),\n                   \"Attempted to compare incomparable iterators\");\n#endif\n    return __x.base() < __y.base();\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) _NOEXCEPT_DEBUG\n{\n    return !(__x == __y);\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) _NOEXCEPT_DEBUG\n{\n    return __y < __x;\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) _NOEXCEPT_DEBUG\n{\n    return !(__x < __y);\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) _NOEXCEPT_DEBUG\n{\n    return !(__y < __x);\n}\n\ntemplate <class _Iter1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter1>& __y) _NOEXCEPT_DEBUG\n{\n    return !(__x == __y);\n}\n\ntemplate <class _Iter1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter1>& __y) _NOEXCEPT_DEBUG\n{\n    return __y < __x;\n}\n\ntemplate <class _Iter1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter1>& __y) _NOEXCEPT_DEBUG\n{\n    return !(__x < __y);\n}\n\ntemplate <class _Iter1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter1>& __y) _NOEXCEPT_DEBUG\n{\n    return !(__y < __x);\n}\n\n#ifndef _LIBCPP_CXX03_LANG\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\nauto\noperator-(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) _NOEXCEPT_DEBUG\n-> decltype(__x.base() - __y.base())\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__less_than_comparable(&__x, &__y),\n                   \"Attempted to subtract incompatible iterators\");\n#endif\n    return __x.base() - __y.base();\n}\n#else\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename __wrap_iter<_Iter1>::difference_type\noperator-(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) _NOEXCEPT_DEBUG\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__less_than_comparable(&__x, &__y),\n                   \"Attempted to subtract incompatible iterators\");\n#endif\n    return __x.base() - __y.base();\n}\n#endif\n\ntemplate <class _Iter>\ninline _LIBCPP_INLINE_VISIBILITY\n__wrap_iter<_Iter>\noperator+(typename __wrap_iter<_Iter>::difference_type __n,\n          __wrap_iter<_Iter> __x) _NOEXCEPT_DEBUG\n{\n    __x += __n;\n    return __x;\n}\n\ntemplate <class _Iter>\nstruct __libcpp_is_trivial_iterator\n    : public _LIBCPP_BOOL_CONSTANT(is_pointer<_Iter>::value) {};\n    \ntemplate <class _Iter>\nstruct __libcpp_is_trivial_iterator<move_iterator<_Iter> >\n    : public _LIBCPP_BOOL_CONSTANT(__libcpp_is_trivial_iterator<_Iter>::value) {};\n\ntemplate <class _Iter>\nstruct __libcpp_is_trivial_iterator<reverse_iterator<_Iter> >\n    : public _LIBCPP_BOOL_CONSTANT(__libcpp_is_trivial_iterator<_Iter>::value) {};\n\ntemplate <class _Iter>\nstruct __libcpp_is_trivial_iterator<__wrap_iter<_Iter> >\n    : public _LIBCPP_BOOL_CONSTANT(__libcpp_is_trivial_iterator<_Iter>::value) {};\n\n\ntemplate <class _Tp, size_t _Np>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n_Tp*\nbegin(_Tp (&__array)[_Np])\n{\n    return __array;\n}\n\ntemplate <class _Tp, size_t _Np>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n_Tp*\nend(_Tp (&__array)[_Np])\n{\n    return __array + _Np;\n}\n\n#if !defined(_LIBCPP_CXX03_LANG)\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\nauto\nbegin(_Cp& __c) -> decltype(__c.begin())\n{\n    return __c.begin();\n}\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\nauto\nbegin(const _Cp& __c) -> decltype(__c.begin())\n{\n    return __c.begin();\n}\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\nauto\nend(_Cp& __c) -> decltype(__c.end())\n{\n    return __c.end();\n}\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\nauto\nend(const _Cp& __c) -> decltype(__c.end())\n{\n    return __c.end();\n}\n\n#if _LIBCPP_STD_VER > 11\n\ntemplate <class _Tp, size_t _Np>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\nreverse_iterator<_Tp*> rbegin(_Tp (&__array)[_Np])\n{\n    return reverse_iterator<_Tp*>(__array + _Np);\n}\n\ntemplate <class _Tp, size_t _Np>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\nreverse_iterator<_Tp*> rend(_Tp (&__array)[_Np])\n{\n    return reverse_iterator<_Tp*>(__array);\n}\n\ntemplate <class _Ep>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\nreverse_iterator<const _Ep*> rbegin(initializer_list<_Ep> __il)\n{\n    return reverse_iterator<const _Ep*>(__il.end());\n}\n\ntemplate <class _Ep>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\nreverse_iterator<const _Ep*> rend(initializer_list<_Ep> __il)\n{\n    return reverse_iterator<const _Ep*>(__il.begin());\n}\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nauto cbegin(const _Cp& __c) -> decltype(_VSTD::begin(__c))\n{\n    return _VSTD::begin(__c);\n}\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nauto cend(const _Cp& __c) -> decltype(_VSTD::end(__c))\n{\n    return _VSTD::end(__c);\n}\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\nauto rbegin(_Cp& __c) -> decltype(__c.rbegin())\n{\n    return __c.rbegin();\n}\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\nauto rbegin(const _Cp& __c) -> decltype(__c.rbegin())\n{\n    return __c.rbegin();\n}\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\nauto rend(_Cp& __c) -> decltype(__c.rend())\n{\n    return __c.rend();\n}\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\nauto rend(const _Cp& __c) -> decltype(__c.rend())\n{\n    return __c.rend();\n}\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\nauto crbegin(const _Cp& __c) -> decltype(_VSTD::rbegin(__c))\n{\n    return _VSTD::rbegin(__c);\n}\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\nauto crend(const _Cp& __c) -> decltype(_VSTD::rend(__c))\n{\n    return _VSTD::rend(__c);\n}\n\n#endif\n\n\n#else  // defined(_LIBCPP_CXX03_LANG)\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename _Cp::iterator\nbegin(_Cp& __c)\n{\n    return __c.begin();\n}\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename _Cp::const_iterator\nbegin(const _Cp& __c)\n{\n    return __c.begin();\n}\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename _Cp::iterator\nend(_Cp& __c)\n{\n    return __c.end();\n}\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename _Cp::const_iterator\nend(const _Cp& __c)\n{\n    return __c.end();\n}\n\n#endif  // !defined(_LIBCPP_CXX03_LANG)\n\n#if _LIBCPP_STD_VER > 14\ntemplate <class _Cont>\nconstexpr auto size(const _Cont& __c) -> decltype(__c.size()) { return __c.size(); }\n\ntemplate <class _Tp, size_t _Sz>\nconstexpr size_t size(const _Tp (&)[_Sz]) noexcept { return _Sz; }\n\ntemplate <class _Cont>\nconstexpr auto empty(const _Cont& __c) -> decltype(__c.empty()) { return __c.empty(); }\n\ntemplate <class _Tp, size_t _Sz>\nconstexpr bool empty(const _Tp (&)[_Sz]) noexcept { return false; }\n\ntemplate <class _Ep>\nconstexpr bool empty(initializer_list<_Ep> __il) noexcept { return __il.size() == 0; }\n\ntemplate <class _Cont> constexpr\nauto data(_Cont& __c) -> decltype(__c.data()) { return __c.data(); }\n\ntemplate <class _Cont> constexpr\nauto data(const _Cont& __c) -> decltype(__c.data()) { return __c.data(); }\n\ntemplate <class _Tp, size_t _Sz>\nconstexpr _Tp* data(_Tp (&__array)[_Sz]) noexcept { return __array; }\n\ntemplate <class _Ep>\nconstexpr const _Ep* data(initializer_list<_Ep> __il) noexcept { return __il.begin(); }\n#endif\n\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_ITERATOR\n","// -*- C++ -*-\n//===-------------------------- utility -----------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_UTILITY\n#define _LIBCPP_UTILITY\n\n/*\n    utility synopsis\n\nnamespace std\n{\n\ntemplate <class T>\n    void\n    swap(T& a, T& b);\n\nnamespace rel_ops\n{\n    template<class T> bool operator!=(const T&, const T&);\n    template<class T> bool operator> (const T&, const T&);\n    template<class T> bool operator<=(const T&, const T&);\n    template<class T> bool operator>=(const T&, const T&);\n}\n\ntemplate<class T>\nvoid\nswap(T& a, T& b) noexcept(is_nothrow_move_constructible<T>::value &&\n                          is_nothrow_move_assignable<T>::value);\n\ntemplate <class T, size_t N>\nvoid\nswap(T (&a)[N], T (&b)[N]) noexcept(noexcept(swap(*a, *b)));\n\ntemplate <class T> T&& forward(typename remove_reference<T>::type& t) noexcept;  // constexpr in C++14\ntemplate <class T> T&& forward(typename remove_reference<T>::type&& t) noexcept; // constexpr in C++14\n\ntemplate <class T> typename remove_reference<T>::type&& move(T&&) noexcept;      // constexpr in C++14\n\ntemplate <class T>\n    typename conditional\n    <\n        !is_nothrow_move_constructible<T>::value && is_copy_constructible<T>::value,\n        const T&,\n        T&&\n    >::type\n    move_if_noexcept(T& x) noexcept; // constexpr in C++14\n\ntemplate <class T> constexpr add_const<T>_t& as_const(T& t) noexcept;      // C++17\ntemplate <class T>                      void as_const(const T&&) = delete; // C++17\n\ntemplate <class T> typename add_rvalue_reference<T>::type declval() noexcept;\n\ntemplate <class T1, class T2>\nstruct pair\n{\n    typedef T1 first_type;\n    typedef T2 second_type;\n\n    T1 first;\n    T2 second;\n\n    pair(const pair&) = default;\n    pair(pair&&) = default;\n    constexpr pair();\n    pair(const T1& x, const T2& y);                          // constexpr in C++14\n    template <class U, class V> pair(U&& x, V&& y);          // constexpr in C++14\n    template <class U, class V> pair(const pair<U, V>& p);   // constexpr in C++14\n    template <class U, class V> pair(pair<U, V>&& p);        // constexpr in C++14\n    template <class... Args1, class... Args2>\n        pair(piecewise_construct_t, tuple<Args1...> first_args,\n             tuple<Args2...> second_args);\n\n    template <class U, class V> pair& operator=(const pair<U, V>& p);\n    pair& operator=(pair&& p) noexcept(is_nothrow_move_assignable<T1>::value &&\n                                       is_nothrow_move_assignable<T2>::value);\n    template <class U, class V> pair& operator=(pair<U, V>&& p);\n\n    void swap(pair& p) noexcept(is_nothrow_swappable_v<T1> &&\n                                is_nothrow_swappable_v<T2>);\n};\n\ntemplate <class T1, class T2> bool operator==(const pair<T1,T2>&, const pair<T1,T2>&); // constexpr in C++14\ntemplate <class T1, class T2> bool operator!=(const pair<T1,T2>&, const pair<T1,T2>&); // constexpr in C++14\ntemplate <class T1, class T2> bool operator< (const pair<T1,T2>&, const pair<T1,T2>&); // constexpr in C++14\ntemplate <class T1, class T2> bool operator> (const pair<T1,T2>&, const pair<T1,T2>&); // constexpr in C++14\ntemplate <class T1, class T2> bool operator>=(const pair<T1,T2>&, const pair<T1,T2>&); // constexpr in C++14\ntemplate <class T1, class T2> bool operator<=(const pair<T1,T2>&, const pair<T1,T2>&); // constexpr in C++14\n\ntemplate <class T1, class T2> pair<V1, V2> make_pair(T1&&, T2&&);   // constexpr in C++14\ntemplate <class T1, class T2>\nvoid\nswap(pair<T1, T2>& x, pair<T1, T2>& y) noexcept(noexcept(x.swap(y)));\n\nstruct piecewise_construct_t { };\nconstexpr piecewise_construct_t piecewise_construct = piecewise_construct_t();\n\ntemplate <class T> class tuple_size;\ntemplate <size_t I, class T> class tuple_element;\n\ntemplate <class T1, class T2> struct tuple_size<pair<T1, T2> >;\ntemplate <class T1, class T2> struct tuple_element<0, pair<T1, T2> >;\ntemplate <class T1, class T2> struct tuple_element<1, pair<T1, T2> >;\n\ntemplate<size_t I, class T1, class T2>\n    typename tuple_element<I, pair<T1, T2> >::type&\n    get(pair<T1, T2>&) noexcept; // constexpr in C++14\n\ntemplate<size_t I, class T1, class T2>\n    const typename tuple_element<I, pair<T1, T2> >::type&\n    get(const pair<T1, T2>&) noexcept; // constexpr in C++14\n\ntemplate<size_t I, class T1, class T2>\n    typename tuple_element<I, pair<T1, T2> >::type&&\n    get(pair<T1, T2>&&) noexcept; // constexpr in C++14\n\ntemplate<size_t I, class T1, class T2>\n    const typename tuple_element<I, pair<T1, T2> >::type&&\n    get(const pair<T1, T2>&&) noexcept; // constexpr in C++14\n\ntemplate<class T1, class T2>\n    constexpr T1& get(pair<T1, T2>&) noexcept; // C++14\n\ntemplate<class T1, class T2>\n    constexpr const T1& get(const pair<T1, T2>&) noexcept; // C++14\n\ntemplate<class T1, class T2>\n    constexpr T1&& get(pair<T1, T2>&&) noexcept; // C++14\n\ntemplate<class T1, class T2>\n    constexpr const T1&& get(const pair<T1, T2>&&) noexcept; // C++14\n\ntemplate<class T1, class T2>\n    constexpr T1& get(pair<T2, T1>&) noexcept; // C++14\n\ntemplate<class T1, class T2>\n    constexpr const T1& get(const pair<T2, T1>&) noexcept; // C++14\n\ntemplate<class T1, class T2>\n    constexpr T1&& get(pair<T2, T1>&&) noexcept; // C++14\n\ntemplate<class T1, class T2>\n    constexpr const T1&& get(const pair<T2, T1>&&) noexcept; // C++14\n\n// C++14\n\ntemplate<class T, T... I>\nstruct integer_sequence\n{\n    typedef T value_type;\n\n    static constexpr size_t size() noexcept;\n};\n\ntemplate<size_t... I>\n  using index_sequence = integer_sequence<size_t, I...>;\n\ntemplate<class T, T N>\n  using make_integer_sequence = integer_sequence<T, 0, 1, ..., N-1>;\ntemplate<size_t N>\n  using make_index_sequence = make_integer_sequence<size_t, N>;\n\ntemplate<class... T>\n  using index_sequence_for = make_index_sequence<sizeof...(T)>;\n\ntemplate<class T, class U=T>\n    T exchange(T& obj, U&& new_value);\n\n// 20.2.7, in-place construction // C++17\nstruct in_place_t {\n  explicit in_place_t() = default;\n};\ninline constexpr in_place_t in_place{};\ntemplate <class T>\n  struct in_place_type_t {\n    explicit in_place_type_t() = default;\n  };\ntemplate <class T>\n  inline constexpr in_place_type_t<T> in_place_type{};\ntemplate <size_t I>\n  struct in_place_index_t {\n    explicit in_place_index_t() = default;\n  };\ntemplate <size_t I>\n  inline constexpr in_place_index_t<I> in_place_index{};\n\n}  // std\n\n*/\n\n#include <__config>\n#include <__tuple>\n#include <type_traits>\n#include <initializer_list>\n#include <__debug>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\nnamespace rel_ops\n{\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const _Tp& __x, const _Tp& __y)\n{\n    return !(__x == __y);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator> (const _Tp& __x, const _Tp& __y)\n{\n    return __y < __x;\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const _Tp& __x, const _Tp& __y)\n{\n    return !(__y < __x);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const _Tp& __x, const _Tp& __y)\n{\n    return !(__x < __y);\n}\n\n}  // rel_ops\n\n// swap_ranges\n\n\ntemplate <class _ForwardIterator1, class _ForwardIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator2\nswap_ranges(_ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2)\n{\n    for(; __first1 != __last1; ++__first1, (void) ++__first2)\n        swap(*__first1, *__first2);\n    return __first2;\n}\n\n// forward declared in <type_traits>\ntemplate<class _Tp, size_t _Np>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<\n    __is_swappable<_Tp>::value\n>::type\nswap(_Tp (&__a)[_Np], _Tp (&__b)[_Np]) _NOEXCEPT_(__is_nothrow_swappable<_Tp>::value)\n{\n    _VSTD::swap_ranges(__a, __a + _Np, __b);\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\ntypename conditional\n<\n    !is_nothrow_move_constructible<_Tp>::value && is_copy_constructible<_Tp>::value,\n    const _Tp&,\n    _Tp&&\n>::type\n#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\nconst _Tp&\n#endif\nmove_if_noexcept(_Tp& __x) _NOEXCEPT\n{\n    return _VSTD::move(__x);\n}\n\n#if _LIBCPP_STD_VER > 14\ntemplate <class _Tp> constexpr add_const_t<_Tp>& as_const(_Tp& __t) noexcept { return __t; }\ntemplate <class _Tp>                        void as_const(const _Tp&&) = delete;\n#endif\n\nstruct _LIBCPP_TEMPLATE_VIS piecewise_construct_t { };\n#if defined(_LIBCPP_HAS_NO_CONSTEXPR) || defined(_LIBCPP_BUILDING_UTILITY)\nextern const piecewise_construct_t piecewise_construct;// = piecewise_construct_t();\n#else\nconstexpr piecewise_construct_t piecewise_construct = piecewise_construct_t();\n#endif\n\n#if defined(_LIBCPP_DEPRECATED_ABI_DISABLE_PAIR_TRIVIAL_COPY_CTOR)\nstruct __non_trivially_copyable_base {\n  _LIBCPP_CONSTEXPR _LIBCPP_INLINE_VISIBILITY\n  __non_trivially_copyable_base() _NOEXCEPT {}\n  _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n  __non_trivially_copyable_base(__non_trivially_copyable_base const&) _NOEXCEPT {}\n};\n#endif\n\ntemplate <class _T1, class _T2>\nstruct _LIBCPP_TEMPLATE_VIS pair\n#if defined(_LIBCPP_DEPRECATED_ABI_DISABLE_PAIR_TRIVIAL_COPY_CTOR)\n: private __non_trivially_copyable_base\n#endif\n{\n    typedef _T1 first_type;\n    typedef _T2 second_type;\n\n    _T1 first;\n    _T2 second;\n\n#if !defined(_LIBCPP_CXX03_LANG)\n    pair(pair const&) = default;\n    pair(pair&&) = default;\n#else\n  // Use the implicitly declared copy constructor in C++03\n#endif\n\n#ifdef _LIBCPP_CXX03_LANG\n    _LIBCPP_INLINE_VISIBILITY\n    pair() : first(), second() {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    pair(_T1 const& __t1, _T2 const& __t2) : first(__t1), second(__t2) {}\n\n    template <class _U1, class _U2>\n    _LIBCPP_INLINE_VISIBILITY\n    pair(const pair<_U1, _U2>& __p) : first(__p.first), second(__p.second) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    pair& operator=(pair const& __p) {\n        first = __p.first;\n        second = __p.second;\n        return *this;\n    }\n#else\n    template <bool _Val>\n    using _EnableB = typename enable_if<_Val, bool>::type;\n\n    struct _CheckArgs {\n      template <class _U1, class _U2>\n      static constexpr bool __enable_default() {\n          return is_default_constructible<_U1>::value\n              && is_default_constructible<_U2>::value;\n      }\n\n      template <class _U1, class _U2>\n      static constexpr bool __enable_explicit() {\n          return is_constructible<first_type, _U1>::value\n              && is_constructible<second_type, _U2>::value\n              && (!is_convertible<_U1, first_type>::value\n                  || !is_convertible<_U2, second_type>::value);\n      }\n\n      template <class _U1, class _U2>\n      static constexpr bool __enable_implicit() {\n          return is_constructible<first_type, _U1>::value\n              && is_constructible<second_type, _U2>::value\n              && is_convertible<_U1, first_type>::value\n              && is_convertible<_U2, second_type>::value;\n      }\n    };\n\n    template <bool _MaybeEnable>\n    using _CheckArgsDep = typename conditional<\n      _MaybeEnable, _CheckArgs, __check_tuple_constructor_fail>::type;\n\n    struct _CheckTupleLikeConstructor {\n        template <class _Tuple>\n        static constexpr bool __enable_implicit() {\n            return __tuple_convertible<_Tuple, pair>::value;\n        }\n\n        template <class _Tuple>\n        static constexpr bool __enable_explicit() {\n            return __tuple_constructible<_Tuple, pair>::value\n               && !__tuple_convertible<_Tuple, pair>::value;\n        }\n\n        template <class _Tuple>\n        static constexpr bool __enable_assign() {\n            return __tuple_assignable<_Tuple, pair>::value;\n        }\n    };\n\n    template <class _Tuple>\n    using _CheckTLC = typename conditional<\n        __tuple_like_with_size<_Tuple, 2>::value\n            && !is_same<typename decay<_Tuple>::type, pair>::value,\n        _CheckTupleLikeConstructor,\n        __check_tuple_constructor_fail\n    >::type;\n\n    template<bool _Dummy = true, _EnableB<\n            _CheckArgsDep<_Dummy>::template __enable_default<_T1, _T2>()\n    > = false>\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR\n    pair() : first(), second() {}\n\n    template <bool _Dummy = true, _EnableB<\n             _CheckArgsDep<_Dummy>::template __enable_explicit<_T1 const&, _T2 const&>()\n    > = false>\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    explicit pair(_T1 const& __t1, _T2 const& __t2)\n        : first(__t1), second(__t2) {}\n\n    template<bool _Dummy = true, _EnableB<\n            _CheckArgsDep<_Dummy>::template __enable_implicit<_T1 const&, _T2 const&>()\n    > = false>\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    pair(_T1 const& __t1, _T2 const& __t2)\n        : first(__t1), second(__t2) {}\n\n    template<class _U1, class _U2, _EnableB<\n             _CheckArgs::template __enable_explicit<_U1, _U2>()\n    > = false>\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    explicit pair(_U1&& __u1, _U2&& __u2)\n        : first(_VSTD::forward<_U1>(__u1)), second(_VSTD::forward<_U2>(__u2)) {}\n\n    template<class _U1, class _U2, _EnableB<\n            _CheckArgs::template __enable_implicit<_U1, _U2>()\n    > = false>\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    pair(_U1&& __u1, _U2&& __u2)\n        : first(_VSTD::forward<_U1>(__u1)), second(_VSTD::forward<_U2>(__u2)) {}\n\n    template<class _U1, class _U2, _EnableB<\n            _CheckArgs::template __enable_explicit<_U1 const&, _U2 const&>()\n    > = false>\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    explicit pair(pair<_U1, _U2> const& __p)\n        : first(__p.first), second(__p.second) {}\n\n    template<class _U1, class _U2, _EnableB<\n            _CheckArgs::template __enable_implicit<_U1 const&, _U2 const&>()\n    > = false>\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    pair(pair<_U1, _U2> const& __p)\n        : first(__p.first), second(__p.second) {}\n\n    template<class _U1, class _U2, _EnableB<\n            _CheckArgs::template __enable_explicit<_U1, _U2>()\n    > = false>\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    explicit pair(pair<_U1, _U2>&&__p)\n        : first(_VSTD::forward<_U1>(__p.first)), second(_VSTD::forward<_U2>(__p.second)) {}\n\n    template<class _U1, class _U2, _EnableB<\n            _CheckArgs::template __enable_implicit<_U1, _U2>()\n    > = false>\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    pair(pair<_U1, _U2>&& __p)\n        : first(_VSTD::forward<_U1>(__p.first)), second(_VSTD::forward<_U2>(__p.second)) {}\n\n    template<class _Tuple, _EnableB<\n            _CheckTLC<_Tuple>::template __enable_explicit<_Tuple>()\n    > = false>\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    explicit pair(_Tuple&& __p)\n        : first(_VSTD::get<0>(_VSTD::forward<_Tuple>(__p))),\n          second(_VSTD::get<1>(_VSTD::forward<_Tuple>(__p))) {}\n\n    template<class _Tuple, _EnableB<\n            _CheckTLC<_Tuple>::template __enable_implicit<_Tuple>()\n    > = false>\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    pair(_Tuple&& __p)\n        : first(_VSTD::get<0>(_VSTD::forward<_Tuple>(__p))),\n          second(_VSTD::get<1>(_VSTD::forward<_Tuple>(__p))) {}\n\n    template <class... _Args1, class... _Args2>\n    _LIBCPP_INLINE_VISIBILITY\n    pair(piecewise_construct_t __pc,\n         tuple<_Args1...> __first_args, tuple<_Args2...> __second_args)\n        : pair(__pc, __first_args, __second_args,\n                typename __make_tuple_indices<sizeof...(_Args1)>::type(),\n                typename __make_tuple_indices<sizeof...(_Args2) >::type()) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    pair& operator=(typename conditional<\n                        is_copy_assignable<first_type>::value &&\n                        is_copy_assignable<second_type>::value,\n                    pair, __nat>::type const& __p)\n        _NOEXCEPT_(is_nothrow_copy_assignable<first_type>::value &&\n                   is_nothrow_copy_assignable<second_type>::value)\n    {\n        first = __p.first;\n        second = __p.second;\n        return *this;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    pair& operator=(typename conditional<\n                        is_move_assignable<first_type>::value &&\n                        is_move_assignable<second_type>::value,\n                    pair, __nat>::type&& __p)\n        _NOEXCEPT_(is_nothrow_move_assignable<first_type>::value &&\n                   is_nothrow_move_assignable<second_type>::value)\n    {\n        first = _VSTD::forward<first_type>(__p.first);\n        second = _VSTD::forward<second_type>(__p.second);\n        return *this;\n    }\n\n    template <class _Tuple, _EnableB<\n            _CheckTLC<_Tuple>::template __enable_assign<_Tuple>()\n     > = false>\n    _LIBCPP_INLINE_VISIBILITY\n    pair& operator=(_Tuple&& __p) {\n        first = _VSTD::get<0>(_VSTD::forward<_Tuple>(__p));\n        second = _VSTD::get<1>(_VSTD::forward<_Tuple>(__p));\n        return *this;\n    }\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    void\n    swap(pair& __p) _NOEXCEPT_(__is_nothrow_swappable<first_type>::value &&\n                               __is_nothrow_swappable<second_type>::value)\n    {\n        using _VSTD::swap;\n        swap(first,  __p.first);\n        swap(second, __p.second);\n    }\nprivate:\n\n#ifndef _LIBCPP_CXX03_LANG\n    template <class... _Args1, class... _Args2, size_t... _I1, size_t... _I2>\n        _LIBCPP_INLINE_VISIBILITY\n        pair(piecewise_construct_t,\n             tuple<_Args1...>& __first_args, tuple<_Args2...>& __second_args,\n             __tuple_indices<_I1...>, __tuple_indices<_I2...>);\n#endif\n};\n\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nbool\noperator==(const pair<_T1,_T2>& __x, const pair<_T1,_T2>& __y)\n{\n    return __x.first == __y.first && __x.second == __y.second;\n}\n\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nbool\noperator!=(const pair<_T1,_T2>& __x, const pair<_T1,_T2>& __y)\n{\n    return !(__x == __y);\n}\n\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nbool\noperator< (const pair<_T1,_T2>& __x, const pair<_T1,_T2>& __y)\n{\n    return __x.first < __y.first || (!(__y.first < __x.first) && __x.second < __y.second);\n}\n\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nbool\noperator> (const pair<_T1,_T2>& __x, const pair<_T1,_T2>& __y)\n{\n    return __y < __x;\n}\n\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nbool\noperator>=(const pair<_T1,_T2>& __x, const pair<_T1,_T2>& __y)\n{\n    return !(__x < __y);\n}\n\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nbool\noperator<=(const pair<_T1,_T2>& __x, const pair<_T1,_T2>& __y)\n{\n    return !(__y < __x);\n}\n\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    __is_swappable<_T1>::value &&\n    __is_swappable<_T2>::value,\n    void\n>::type\nswap(pair<_T1, _T2>& __x, pair<_T1, _T2>& __y)\n                     _NOEXCEPT_((__is_nothrow_swappable<_T1>::value &&\n                                 __is_nothrow_swappable<_T2>::value))\n{\n    __x.swap(__y);\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n\ntemplate <class _Tp>\nstruct __make_pair_return_impl\n{\n    typedef _Tp type;\n};\n\ntemplate <class _Tp>\nstruct __make_pair_return_impl<reference_wrapper<_Tp>>\n{\n    typedef _Tp& type;\n};\n\ntemplate <class _Tp>\nstruct __make_pair_return\n{\n    typedef typename __make_pair_return_impl<typename decay<_Tp>::type>::type type;\n};\n\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\npair<typename __make_pair_return<_T1>::type, typename __make_pair_return<_T2>::type>\nmake_pair(_T1&& __t1, _T2&& __t2)\n{\n    return pair<typename __make_pair_return<_T1>::type, typename __make_pair_return<_T2>::type>\n               (_VSTD::forward<_T1>(__t1), _VSTD::forward<_T2>(__t2));\n}\n\n#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY\npair<_T1,_T2>\nmake_pair(_T1 __x, _T2 __y)\n{\n    return pair<_T1, _T2>(__x, __y);\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _T1, class _T2>\n  class _LIBCPP_TEMPLATE_VIS tuple_size<pair<_T1, _T2> >\n    : public integral_constant<size_t, 2> {};\n\ntemplate <class _T1, class _T2>\nclass _LIBCPP_TEMPLATE_VIS tuple_element<0, pair<_T1, _T2> >\n{\npublic:\n    typedef _T1 type;\n};\n\ntemplate <class _T1, class _T2>\nclass _LIBCPP_TEMPLATE_VIS tuple_element<1, pair<_T1, _T2> >\n{\npublic:\n    typedef _T2 type;\n};\n\ntemplate <size_t _Ip> struct __get_pair;\n\ntemplate <>\nstruct __get_pair<0>\n{\n    template <class _T1, class _T2>\n    static\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    _T1&\n    get(pair<_T1, _T2>& __p) _NOEXCEPT {return __p.first;}\n\n    template <class _T1, class _T2>\n    static\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    const _T1&\n    get(const pair<_T1, _T2>& __p) _NOEXCEPT {return __p.first;}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    template <class _T1, class _T2>\n    static\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    _T1&&\n    get(pair<_T1, _T2>&& __p) _NOEXCEPT {return _VSTD::forward<_T1>(__p.first);}\n\n    template <class _T1, class _T2>\n    static\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    const _T1&&\n    get(const pair<_T1, _T2>&& __p) _NOEXCEPT {return _VSTD::forward<const _T1>(__p.first);}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n};\n\ntemplate <>\nstruct __get_pair<1>\n{\n    template <class _T1, class _T2>\n    static\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    _T2&\n    get(pair<_T1, _T2>& __p) _NOEXCEPT {return __p.second;}\n\n    template <class _T1, class _T2>\n    static\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    const _T2&\n    get(const pair<_T1, _T2>& __p) _NOEXCEPT {return __p.second;}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    template <class _T1, class _T2>\n    static\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    _T2&&\n    get(pair<_T1, _T2>&& __p) _NOEXCEPT {return _VSTD::forward<_T2>(__p.second);}\n\n    template <class _T1, class _T2>\n    static\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    const _T2&&\n    get(const pair<_T1, _T2>&& __p) _NOEXCEPT {return _VSTD::forward<const _T2>(__p.second);}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n};\n\ntemplate <size_t _Ip, class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\ntypename tuple_element<_Ip, pair<_T1, _T2> >::type&\nget(pair<_T1, _T2>& __p) _NOEXCEPT\n{\n    return __get_pair<_Ip>::get(__p);\n}\n\ntemplate <size_t _Ip, class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nconst typename tuple_element<_Ip, pair<_T1, _T2> >::type&\nget(const pair<_T1, _T2>& __p) _NOEXCEPT\n{\n    return __get_pair<_Ip>::get(__p);\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <size_t _Ip, class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\ntypename tuple_element<_Ip, pair<_T1, _T2> >::type&&\nget(pair<_T1, _T2>&& __p) _NOEXCEPT\n{\n    return __get_pair<_Ip>::get(_VSTD::move(__p));\n}\n\ntemplate <size_t _Ip, class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nconst typename tuple_element<_Ip, pair<_T1, _T2> >::type&&\nget(const pair<_T1, _T2>&& __p) _NOEXCEPT\n{\n    return __get_pair<_Ip>::get(_VSTD::move(__p));\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY\nconstexpr _T1 & get(pair<_T1, _T2>& __p) _NOEXCEPT\n{\n    return __get_pair<0>::get(__p);\n}\n\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY\nconstexpr _T1 const & get(pair<_T1, _T2> const& __p) _NOEXCEPT\n{\n    return __get_pair<0>::get(__p);\n}\n\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY\nconstexpr _T1 && get(pair<_T1, _T2>&& __p) _NOEXCEPT\n{\n    return __get_pair<0>::get(_VSTD::move(__p));\n}\n\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY\nconstexpr _T1 const && get(pair<_T1, _T2> const&& __p) _NOEXCEPT\n{\n    return __get_pair<0>::get(_VSTD::move(__p));\n}\n\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY\nconstexpr _T1 & get(pair<_T2, _T1>& __p) _NOEXCEPT\n{\n    return __get_pair<1>::get(__p);\n}\n\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY\nconstexpr _T1 const & get(pair<_T2, _T1> const& __p) _NOEXCEPT\n{\n    return __get_pair<1>::get(__p);\n}\n\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY\nconstexpr _T1 && get(pair<_T2, _T1>&& __p) _NOEXCEPT\n{\n    return __get_pair<1>::get(_VSTD::move(__p));\n}\n\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY\nconstexpr _T1 const && get(pair<_T2, _T1> const&& __p) _NOEXCEPT\n{\n    return __get_pair<1>::get(_VSTD::move(__p));\n}\n\n#endif\n\n#if _LIBCPP_STD_VER > 11\n\ntemplate<class _Tp, _Tp... _Ip>\nstruct _LIBCPP_TEMPLATE_VIS integer_sequence\n{\n    typedef _Tp value_type;\n    static_assert( is_integral<_Tp>::value,\n                  \"std::integer_sequence can only be instantiated with an integral type\" );\n    static\n    _LIBCPP_INLINE_VISIBILITY\n    constexpr\n    size_t\n    size() noexcept { return sizeof...(_Ip); }\n};\n\ntemplate<size_t... _Ip>\n    using index_sequence = integer_sequence<size_t, _Ip...>;\n\n#if __has_builtin(__make_integer_seq) && !defined(_LIBCPP_TESTING_FALLBACK_MAKE_INTEGER_SEQUENCE)\n\ntemplate <class _Tp, _Tp _Ep>\nusing __make_integer_sequence = __make_integer_seq<integer_sequence, _Tp, _Ep>;\n\n#else\n\ntemplate<typename _Tp, _Tp _Np> using __make_integer_sequence_unchecked =\n  typename __detail::__make<_Np>::type::template __convert<integer_sequence, _Tp>;\n\ntemplate <class _Tp, _Tp _Ep>\nstruct __make_integer_sequence_checked\n{\n    static_assert(is_integral<_Tp>::value,\n                  \"std::make_integer_sequence can only be instantiated with an integral type\" );\n    static_assert(0 <= _Ep, \"std::make_integer_sequence must have a non-negative sequence length\");\n    // Workaround GCC bug by preventing bad installations when 0 <= _Ep\n    // https://gcc.gnu.org/bugzilla/show_bug.cgi?id=68929\n    typedef __make_integer_sequence_unchecked<_Tp, 0 <= _Ep ? _Ep : 0> type;\n};\n\ntemplate <class _Tp, _Tp _Ep>\nusing __make_integer_sequence = typename __make_integer_sequence_checked<_Tp, _Ep>::type;\n\n#endif\n\ntemplate<class _Tp, _Tp _Np>\n    using make_integer_sequence = __make_integer_sequence<_Tp, _Np>;\n\ntemplate<size_t _Np>\n    using make_index_sequence = make_integer_sequence<size_t, _Np>;\n\ntemplate<class... _Tp>\n    using index_sequence_for = make_index_sequence<sizeof...(_Tp)>;\n\n#endif  // _LIBCPP_STD_VER > 11\n\n#if _LIBCPP_STD_VER > 11\ntemplate<class _T1, class _T2 = _T1>\ninline _LIBCPP_INLINE_VISIBILITY\n_T1 exchange(_T1& __obj, _T2 && __new_value)\n{\n    _T1 __old_value = _VSTD::move(__obj);\n    __obj = _VSTD::forward<_T2>(__new_value);\n    return __old_value;\n}\n#endif  // _LIBCPP_STD_VER > 11\n\n#if _LIBCPP_STD_VER > 14\n\nstruct _LIBCPP_TYPE_VIS in_place_t {\n    explicit in_place_t() = default;\n};\n#ifndef _LIBCPP_HAS_NO_INLINE_VARIABLES\ninline\n#endif\nconstexpr in_place_t in_place{};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS in_place_type_t {\n    explicit in_place_type_t() = default;\n};\ntemplate <class _Tp>\n#ifndef _LIBCPP_HAS_NO_INLINE_VARIABLES\ninline\n#endif\nconstexpr in_place_type_t<_Tp> in_place_type{};\n\ntemplate <size_t _Idx>\nstruct _LIBCPP_TYPE_VIS in_place_index_t {\n    explicit in_place_index_t() = default;\n};\ntemplate <size_t _Idx>\n#ifndef _LIBCPP_HAS_NO_INLINE_VARIABLES\ninline\n#endif\nconstexpr in_place_index_t<_Idx> in_place_index{};\n\ntemplate <class _Tp> struct __is_inplace_type_imp : false_type {};\ntemplate <class _Tp> struct __is_inplace_type_imp<in_place_type_t<_Tp>> : true_type {};\n\ntemplate <class _Tp>\nusing __is_inplace_type = __is_inplace_type_imp<__uncvref_t<_Tp>>;\n\n#endif // _LIBCPP_STD_VER > 14\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_UTILITY\n","//\n//  linear_algebra.h\n//  ARToolKit5\n//\n//  This file is part of ARToolKit.\n//\n//  ARToolKit is free software: you can redistribute it and/or modify\n//  it under the terms of the GNU Lesser General Public License as published by\n//  the Free Software Foundation, either version 3 of the License, or\n//  (at your option) any later version.\n//\n//  ARToolKit is distributed in the hope that it will be useful,\n//  but WITHOUT ANY WARRANTY; without even the implied warranty of\n//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n//  GNU Lesser General Public License for more details.\n//\n//  You should have received a copy of the GNU Lesser General Public License\n//  along with ARToolKit.  If not, see <http://www.gnu.org/licenses/>.\n//\n//  As a special exception, the copyright holders of this library give you\n//  permission to link this library with independent modules to produce an\n//  executable, regardless of the license terms of these independent modules, and to\n//  copy and distribute the resulting executable under terms of your choice,\n//  provided that you also meet, for each linked independent module, the terms and\n//  conditions of the license of that module. An independent module is a module\n//  which is neither derived from nor based on this library. If you modify this\n//  library, you may extend this exception to your version of the library, but you\n//  are not obligated to do so. If you do not wish to do so, delete this exception\n//  statement from your version.\n//\n//  Copyright 2013-2015 Daqri, LLC.\n//\n//  Author(s): Chris Broaddus\n//\n\n#pragma once\n\n#include \"math_utils.h\"\n#include \"matrix.h\"\n#include <limits>\nnamespace vision {\n    \n    /**\n     * Create a 3x3 identity matrix.\n     */\n    template<typename T>\n\tinline void Identity3x3(T A[9]) {\n\t\tA[0] = 1;\tA[1] = 0;\tA[2] = 0;\n\t\tA[3] = 0;\tA[4] = 1;\tA[5] = 0;\n\t\tA[6] = 0;\tA[7] = 0;\tA[8] = 1;\n\t}\n    \n    /**\n     * Create a 3x4 identity matrix.\n     */\n    template<typename T>\n\tinline void Identity3x4(T A[12]) {\n\t\tA[0] = 1;\tA[1] = 0;\tA[2] = 0;   A[3] = 0;\n\t\tA[4] = 0;\tA[5] = 1;\tA[6] = 0;   A[7] = 0;\n\t\tA[8] = 0;\tA[9] = 0;\tA[10] = 1;  A[11] = 0;\n\t}\n    \n    /**\n\t * Computes the cofactor of a 2x2 matrix.\n\t *\n\t * A = [a\tb;\n\t *\t\tc\td]\n\t *\n\t * |A| = (a * d) - (b * c)\n\t */\n\ttemplate<typename T>\n\tinline T Cofactor2x2(T a, T b, T c, T d) {\n\t\treturn (a * d) - (b * c);\n\t}\n\n    /**\n\t * Computes the cofactor of a 2x2 matrix.\n\t *\n\t * A = [a\tb;\n\t *\t\tc\td]\n\t *\n\t * |A| = (a * d) - (b * c)\n\t */\n    template<typename T>\n\tinline T Cofactor2x2(const T A[4]) {\n\t\treturn Cofactor2x2(A[0], A[1], A[2], A[3]);\n\t}\n    \n    /**\n     * Cofactor of a symmetrix 2x2 matrix.\n     *\n\t * A = [a\tb;\n\t *\t\tb\tc]\n     */\n    template<typename T>\n\tinline T Cofactor2x2(T a, T b, T c) {\n\t\treturn (a * c) - (b * b);\n\t}\n    \n    /**\n\t * Compute the determinant of a 2x2 matrix\n\t */\n\ttemplate<typename T>\n\tinline T Determinant2x2(const T A[4]) {\n\t\treturn Cofactor2x2(A);\n\t}\n    \n    /**\n     * Compute the determinant of a 3x3 matrix.\n     */\n    template<typename T>\n\tinline T Determinant3x3(const T A[9]) {\n        T C1 = Cofactor2x2(A[4], A[5], A[7], A[8]);\n        T C2 = Cofactor2x2(A[3], A[5], A[6], A[8]);\n        T C3 = Cofactor2x2(A[3], A[4], A[6], A[7]);\n\t\treturn (A[0] * C1) - (A[1] * C2) + (A[2] * C3);\n\t}\n    \n    /**\n     * Compute the determinant of a 3x3 symmetric matrix.\n     */\n    template<typename T>\n    inline T DeterminantSymmetric3x3(const T A[9]) {\n        T a = -A[8]*sqr(A[1]);\n        T b = 2*A[1]*A[2]*A[5];\n        T c = A[4]*sqr(A[2]);\n        T d = A[0]*sqr(A[5]);\n        T e = A[0]*A[4]*A[8];\n        return a + b - c - d + e;\n    }\n    \n    /**\n     * Compute the inverse of a 2x2 matrix.\n     */\n    template<typename T>\n\tbool MatrixInverse2x2(T B[4], const T A[4], T threshold) {\n\t\tconst T det = Determinant2x2(A);\n\t\t\n\t\tif(std::abs(det) <= threshold) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tT one_over_det = 1./det;\n\t\t\n\t\tB[0] = A[3] * one_over_det;\n\t\tB[1] = -A[1] * one_over_det;\n\t\tB[2] = -A[2] * one_over_det;\n\t\tB[3] = A[0] * one_over_det;\n\t\t\n\t\treturn true;\n\t}\n    \n    /**\n     * Compute the inverse of a 3x3 matrix.\n     */\n    template<typename T>\n\tbool MatrixInverse3x3(T B[9], const T A[9], T threshold) {\n\t\tconst T det = Determinant3x3(A);\n\t\t\n\t\tif(std::abs(det) <= threshold) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tT one_over_det = 1./det;\n\t\t\n\t\tB[0] = Cofactor2x2(A[4], A[5], A[7], A[8]) * one_over_det;\n\t\tB[1] = Cofactor2x2(A[2], A[1], A[8], A[7]) * one_over_det;\n\t\tB[2] = Cofactor2x2(A[1], A[2], A[4], A[5]) * one_over_det;\n\t\tB[3] = Cofactor2x2(A[5], A[3], A[8], A[6]) * one_over_det;\n\t\tB[4] = Cofactor2x2(A[0], A[2], A[6], A[8]) * one_over_det;\n\t\tB[5] = Cofactor2x2(A[2], A[0], A[5], A[3]) * one_over_det;\n\t\tB[6] = Cofactor2x2(A[3], A[4], A[6], A[7]) * one_over_det;\n\t\tB[7] = Cofactor2x2(A[1], A[0], A[7], A[6]) * one_over_det;\n\t\tB[8] = Cofactor2x2(A[0], A[1], A[3], A[4]) * one_over_det;\n\t\t\n\t\treturn true;\n\t}\n    \n    /**\n     * Compute the inverse of a 3x3 symmetric matrix.\n     */\n    template<typename T>\n\tbool MatrixInverseSymmetric3x3(T B[9], const T A[9], T threshold) {\n        T det = DeterminantSymmetric3x3(A);\n\t\t\n\t\tif(std::abs(det) <= threshold) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tT one_over_det = 1./det;\n\t\t\n\t\tB[0] = Cofactor2x2(A[4], A[5], A[8]) * one_over_det;\n\t\tB[1] = Cofactor2x2(A[2], A[1], A[8], A[7]) * one_over_det;\n\t\tB[2] = Cofactor2x2(A[1], A[2], A[4], A[5]) * one_over_det;\n\t\tB[4] = Cofactor2x2(A[0], A[2], A[8]) * one_over_det;\n\t\tB[5] = Cofactor2x2(A[2], A[0], A[5], A[3]) * one_over_det;\n\t\tB[8] = Cofactor2x2(A[0], A[1], A[4]) * one_over_det;\n\t\t\n        // Symmetric terms\n        B[3] = B[1];\n        B[6] = B[2];\n        B[7] = B[5];\n        \n\t\treturn true;\n\t}\n\n    /**\n     * Solve a 2x2 linear system.\n     */\n    template<typename T>\n    inline bool SolveLinearSystem2x2(T x[2], const T A[4], const T b[2]) {\n        T Ainv[4];\n        \n        // Inverse of A\n        if(!MatrixInverse2x2(Ainv, A, std::numeric_limits<T>::epsilon())) {\n            return false;\n        }\n        \n        // x = inv(A)*b\n        Multiply_2x2_2x1(x, Ainv, b);\n        \n        return true;\n    }\n    \n    /**\n     * Solve a 3x3 symmetric linear system.\n     */\n    template<typename T>\n    inline bool SolveSymmetricLinearSystem3x3(T x[3], const T A[9], const T b[3]) {\n        T Ainv[9];\n        \n        // Inverse of A\n        if(!MatrixInverseSymmetric3x3(Ainv, A, std::numeric_limits<T>::epsilon())) {\n            return false;\n        }\n        \n        // x = inv(A)*b\n        Multiply_3x3_3x1(x, Ainv, b);\n        \n        return true;\n    }\n    \n    /**\n     * Compute the dot product.\n     */\n    template<typename T>\n    inline T DotProduct4(const T a[4], const T b[4]) {\n        return a[0]*b[0] + a[1]*b[1] + a[2]*b[2] + a[3]*b[3];\n    }\n    template<typename T>\n    inline T DotProduct9(const T a[9], const T b[9]) {\n        return a[0]*b[0] + a[1]*b[1] + a[2]*b[2] + a[3]*b[3] + a[4]*b[4] + a[5]*b[5] + a[6]*b[6] + a[7]*b[7] + a[8]*b[8];\n    }\n\n    /**\n     * Compute the dot product.\n     */\n    template<typename T>\n\tinline T DotProduct(const T* a, const T* b, int n) {\n\t\tT x = 0;\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tx += (a[i]*b[i]);\n\t\t}\n\t\treturn x;\n\t}\n    \n    /**\n     * Sum sqaured.\n     */\n    template<typename T>\n    inline T SumSquares9(const T x[9]) {\n        return DotProduct9(x, x);\n    }\n    \n    /**\n     * Scale a vector.\n     */\n    template<typename T>\n    inline void ScaleVector4(T dst[4], const T src[4], T s) {\n        dst[0] = src[0]*s;\n        dst[1] = src[1]*s;\n        dst[2] = src[2]*s;\n        dst[3] = src[3]*s;\n    }\n    template<typename T>\n    inline void ScaleVector8(T dst[8], const T src[8], T s) {\n        dst[0] = src[0]*s;\n        dst[1] = src[1]*s;\n        dst[2] = src[2]*s;\n        dst[3] = src[3]*s;\n        dst[4] = src[4]*s;\n        dst[5] = src[5]*s;\n        dst[6] = src[6]*s;\n        dst[7] = src[7]*s;\n    }\n    template<typename T>\n    inline void ScaleVector9(T dst[9], const T src[9], T s) {\n        dst[0] = src[0]*s;\n        dst[1] = src[1]*s;\n        dst[2] = src[2]*s;\n        dst[3] = src[3]*s;\n        dst[4] = src[4]*s;\n        dst[5] = src[5]*s;\n        dst[6] = src[6]*s;\n        dst[7] = src[7]*s;\n        dst[8] = src[8]*s;\n    }\n    \n    /**\n     * Accumulate a scaled vector.\n     *\n     * dst += src*s\n     */\n    template<typename T>\n    inline void AccumulateScaledVector9(T dst[9], const T src[9], T s) {\n        dst[0] += src[0]*s;\n        dst[1] += src[1]*s;\n        dst[2] += src[2]*s;\n        dst[3] += src[3]*s;\n        dst[4] += src[4]*s;\n        dst[5] += src[5]*s;\n        dst[6] += src[6]*s;\n        dst[7] += src[7]*s;\n        dst[8] += src[8]*s;\n    }\n    \n    /**\n     * w = a*u + b*v\n     */\n    template<typename T>\n    inline void AddScaledVectors4(T w[4], const T u[4], const T v[4], T a, T b) {\n        w[0] = a*u[0] + b*v[0];\n        w[1] = a*u[1] + b*v[1];\n        w[2] = a*u[2] + b*v[2];\n        w[3] = a*u[3] + b*v[3];\n    }\n    \n    /**\n     * Subtract two vectors.\n     */\n    template<typename T>\n\tinline void SubVector2(T c[2], const T a[2], const T b[2]) {\n\t\tc[0] = a[0] - b[0];\n\t\tc[1] = a[1] - b[1];\n\t}\n    \n    /**\n     * Update the outer product such that A += x*x'.\n     */\n    template<typename T>\n    inline void UpdateOuterProduct2x2(T A[4], const T x[2]) {\n        A[0] += x[0]*x[0];\n        A[1] += x[0]*x[1];\n        A[3] += x[1]*x[1];\n    }\n    \n    /**\n     * Compute b += -J'r\n     */\n    template<typename T>\n    inline void UpdateGaussNewtonOperations2x2(T b[2], const T J[2], T residual) {\n        b[0] -= J[0]*residual;\n        b[1] -= J[1]*residual;\n    }\n    \n    /**\n\t * Extend the lower left triangular matrix to the upper right\n\t *\n\t * @param[in,out] A n x n square matrix\n\t * @param[in] n size of matrix\n\t */\n\ttemplate<typename T>\n\tinline void SymmetricExtendLowerToUpper(T* A, int n) {\n\t\tint i, j;\n\t\tfor(i = 1; i < n; i++) {\n\t\t\tT* Ai = &A[i*n];\n\t\t\tfor(j = 0; j < i; j++) {\n\t\t\t\tA[j*n+i] = Ai[j];\n\t\t\t}\n\t\t}\n\t}\n    \n    /**\n\t * Extend the upper right triangular matrix to the lower left\n\t *\n\t * @param[in,out] A n x n square matrix\n\t * @param[in] n size of matrix\n\t */\n\ttemplate<typename T>\n\tinline void SymmetricExtendUpperToLower(T* A, int n) {\n\t\tint i, j;\n\t\tfor(i = 1; i < n; i++) {\n\t\t\tT* Ai = &A[i*n];\n\t\t\tfor(j = 0; j < i; j++) {\n\t\t\t\tAi[j] = A[j*n+i];\n\t\t\t}\n\t\t}\n\t}\n    \n} // vision\n","//\n//  matrix.h\n//  ARToolKit5\n//\n//  This file is part of ARToolKit.\n//\n//  ARToolKit is free software: you can redistribute it and/or modify\n//  it under the terms of the GNU Lesser General Public License as published by\n//  the Free Software Foundation, either version 3 of the License, or\n//  (at your option) any later version.\n//\n//  ARToolKit is distributed in the hope that it will be useful,\n//  but WITHOUT ANY WARRANTY; without even the implied warranty of\n//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n//  GNU Lesser General Public License for more details.\n//\n//  You should have received a copy of the GNU Lesser General Public License\n//  along with ARToolKit.  If not, see <http://www.gnu.org/licenses/>.\n//\n//  As a special exception, the copyright holders of this library give you\n//  permission to link this library with independent modules to produce an\n//  executable, regardless of the license terms of these independent modules, and to\n//  copy and distribute the resulting executable under terms of your choice,\n//  provided that you also meet, for each linked independent module, the terms and\n//  conditions of the license of that module. An independent module is a module\n//  which is neither derived from nor based on this library. If you modify this\n//  library, you may extend this exception to your version of the library, but you\n//  are not obligated to do so. If you do not wish to do so, delete this exception\n//  statement from your version.\n//\n//  Copyright 2013-2015 Daqri, LLC.\n//\n//  Author(s): Chris Broaddus\n//\n\n#pragma once\n\n#include \"framework/error.h\"\n\nnamespace vision {\n    \n    /**\n     * C = A*B where A,B and C are 2x2 matrices.\n     */\n    template<typename T>\n    inline void Multiply2x2_2x2(T C[4], const T A[4], const T B[4]) {\n        C[0] = A[0]*B[0] + A[1]*B[2];\n        C[1] = A[0]*B[1] + A[1]*B[3];\n        C[2] = A[2]*B[0] + A[3]*B[2];\n        C[3] = A[2]*B[1] + A[3]*B[3];\n    }\n    \n    /**\n     * C = A*B where A,B and C are 3x3 matrices.\n     */\n    template<typename T>\n\tinline void Multiply3x3_3x3(T C[9], const T A[9], const T B[9]) {\n\t\tC[0] = A[0]*B[0] + A[1]*B[3] + A[2]*B[6];\n\t\tC[1] = A[0]*B[1] + A[1]*B[4] + A[2]*B[7];\n\t\tC[2] = A[0]*B[2] + A[1]*B[5] + A[2]*B[8];\n\t\tC[3] = A[3]*B[0] + A[4]*B[3] + A[5]*B[6];\n\t\tC[4] = A[3]*B[1] + A[4]*B[4] + A[5]*B[7];\n\t\tC[5] = A[3]*B[2] + A[4]*B[5] + A[5]*B[8];\n\t\tC[6] = A[6]*B[0] + A[7]*B[3] + A[8]*B[6];\n\t\tC[7] = A[6]*B[1] + A[7]*B[4] + A[8]*B[7];\n\t\tC[8] = A[6]*B[2] + A[7]*B[5] + A[8]*B[8];\n\t}\n    \n    /**\n     * y = A*x where A is a 2x2 and x is a 2x1.\n     */\n    template<typename T>\n\tinline void Multiply_2x2_2x1(T y[2], const T A[4], const T x[2]) {\n\t\ty[0] = A[0]*x[0] + A[1]*x[1];\n\t\ty[1] = A[2]*x[0] + A[3]*x[1];\n\t}\n    \n    /**\n     * y = A*x where A is a 3x3 and x is a 3x1.\n     */\n    template<typename T>\n\tinline void Multiply_3x3_3x1(T y[3], const T A[9], const T x[3]) {\n\t\ty[0] = A[0]*x[0] + A[1]*x[1] + A[2]*x[2];\n\t\ty[1] = A[3]*x[0] + A[4]*x[1] + A[5]*x[2];\n\t\ty[2] = A[6]*x[0] + A[7]*x[1] + A[8]*x[2];\n\t}\n    \n    /**\n     * General matrix multiplication.\n     *\n     * C = A*B\n     */\n    template<typename T>\n    inline void Multiply(T* C,\n                         const T* A,\n                         int Arows,\n                         int Acols,\n                         const T* B,\n                         int Brows,\n                         int Bcols) {\n        ASSERT(Acols == Brows, \"Number of columns of A must be the same as the number of rows of B\");\n\t\tT sum;\n\t\tfor(int i = 0; i < Arows; ++i) {\n\t\t\tconst int A_offset = i*Acols;\n\t\t\tconst int B_offset = i*Bcols;\n\t\t\tconst T* Aptr = &A[A_offset];\n\t\t\tfor(int j = 0; j < Bcols; ++j) {\n\t\t\t\tsum = *Aptr * B[j];\n\t\t\t\tfor(int k = 1; k < Acols; ++k) {\n\t\t\t\t\tsum += Aptr[k] * B[k*Bcols+j];\n\t\t\t\t}\n\t\t\t\tC[B_offset+j] = sum;\n\t\t\t}\n\t\t}\n\t}\n    \n    /**\n     * C += A'*A\n     */\n    template<typename T>\n    inline void MultiplyAndAccumulateAtA(T* C, const T* A, int Arows, int Acols) {\n        int Brows = Acols;\n\t\tfor(int i = 0; i < Brows; ++i) {\n            const int shift = i*Acols;\n\t\t\tfor(int j = i; j < Acols; ++j) {\n\t\t\t\tT sum = A[i] * A[j];\n\t\t\t\tfor(int k = 1; k < Arows; ++k) {\n                    sum += A[k*Acols+i] * A[k*Acols+j];\n\t\t\t\t}\n\t\t\t\tC[shift+j] += sum;\n\t\t\t}\n\t\t}\n    }\n    \n    /**\n     *  y += A'*x\n     */\n    template<class T>\n    inline void MultiplyAndAccumulateAtx(T* y, const T* A, int rows, int cols, const T* x) {\n\t\tT sum;\n\t\tfor(int i = 0; i < cols; i++) {\n\t\t\tsum = A[i]*x[0];\n\t\t\tfor(int j = 1; j < rows; j++) {\n\t\t\t\tsum += A[j*cols+i] * x[j];\n\t\t\t}\n\t\t\ty[i] += sum;\n\t\t}\n\t}\n    \n} // vision","/*\n *  arPattGetID.c\n *  ARToolKit5\n *\n *  This file is part of ARToolKit.\n *\n *  ARToolKit is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation, either version 3 of the License, or\n *  (at your option) any later version.\n *\n *  ARToolKit is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public License\n *  along with ARToolKit.  If not, see <http://www.gnu.org/licenses/>.\n *\n *  As a special exception, the copyright holders of this library give you\n *  permission to link this library with independent modules to produce an\n *  executable, regardless of the license terms of these independent modules, and to\n *  copy and distribute the resulting executable under terms of your choice,\n *  provided that you also meet, for each linked independent module, the terms and\n *  conditions of the license of that module. An independent module is a module\n *  which is neither derived from nor based on this library. If you modify this\n *  library, you may extend this exception to your version of the library, but you\n *  are not obligated to do so. If you do not wish to do so, delete this exception\n *  statement from your version.\n *\n *  Copyright 2015 Daqri, LLC.\n *  Copyright 2003-2015 ARToolworks, Inc.\n *\n *  Author(s): Hirokazu Kato, Philip Lamb\n *\n */\n/*******************************************************\n *\n * Author: Hirokazu Kato\n *\n *         kato@sys.im.hiroshima-cu.ac.jp\n *\n * Revision: 3.0\n * Date: 03/08/13\n *\n *******************************************************/\n\n#include <AR/ar.h>\n#include <stdio.h>\n#include <math.h>\n#include <stdint.h>\n#ifndef _MSC_VER\n#  include <stdbool.h>\n#else\ntypedef unsigned char bool;\n#endif\n#if DEBUG_PATT_GETID\n#  ifndef __APPLE__\n#    include <GL/gl.h>\n#  else\n#    include <OpenGL/gl.h>\n#  endif\nint  cnt = 1;\n#endif\n\n#ifndef MAX\n#  define MAX(x,y) (x > y ? x : y)\n#endif\n#ifndef MIN\n#  define MIN(x,y) (x < y ? x : y)\n#endif\n#ifndef CLAMP\n#  define CLAMP(x,r1,r2) (MIN(MAX(x,r1),r2))\n#endif\n\n#ifdef ARDOUBLE_IS_FLOAT\n#  define SQRT sqrtf\n#  define _100_0 100.0f\n#  define _30_0 30.f\n#  define _10_0 10.0f\n#  define _2_0 2.0f\n#  define SQRT_3_0 1.7320508f\n#  define _1_0 1.0f\n#  define _0_5 0.5f\n#  define _0_0 0.0f\n#else\n#  define SQRT sqrt\n#  define _100_0 100.0\n#  define _30_0 30.0\n#  define _10_0 10.0\n#  define _2_0 2.0\n#  define SQRT_3_0 1.7320508\n#  define _1_0 1.0\n#  define _0_5 0.5\n#  define _0_0 0.0\n#endif\n\n#define AR_GLOBAL_ID_OUTER_SIZE 14\n#define AR_GLOBAL_ID_INNER_SIZE 3\n\n//#define DEBUG_BCH\n\nstatic void   get_cpara( ARdouble world[4][2], ARdouble vertex[4][2],\n                         ARdouble para[3][3] );\nstatic int    pattern_match( ARPattHandle *pattHandle, int mode, ARUint8 *data, int size,\n                             int *code, int *dir, ARdouble *cf );\nstatic int    decode_bch(const AR_MATRIX_CODE_TYPE matrixCodeType, const uint64_t in, uint8_t recd127[127], uint64_t *out_p);\nstatic int    get_matrix_code( ARUint8 *data, int size, int *code_out_p, int *dir, ARdouble *cf, const AR_MATRIX_CODE_TYPE matrixCodeType, int *errorCorrected );\nstatic int    get_global_id_code( ARUint8 *data, uint64_t *code_out_p, int *dir, ARdouble *cf, int *errorCorrected );\n\n#if !AR_DISABLE_NON_CORE_FNS\nint arPattGetID( ARPattHandle *pattHandle, int imageProcMode, int pattDetectMode,\n                 ARUint8 *image, int xsize, int ysize, AR_PIXEL_FORMAT pixelFormat,\n                 int *x_coord, int *y_coord, int *vertex, ARdouble pattRatio,\n                 int *code, int *dir, ARdouble *cf, const AR_MATRIX_CODE_TYPE matrixCodeType )\n{\n    ARUint8 ext_patt1[AR_PATT_SIZE1_MAX*AR_PATT_SIZE1_MAX*3]; // Holds unwarped pattern extracted from image for template matching.\n    ARUint8 ext_patt2[AR_PATT_SIZE2_MAX*AR_PATT_SIZE2_MAX]; // Holds unwarped pattern extracted from image for matrix-code matching.\n    int errorCodeMtx, errorCodePatt;\n\n    // Matrix code detection pass.\n    if( pattDetectMode == AR_MATRIX_CODE_DETECTION\n     || pattDetectMode == AR_TEMPLATE_MATCHING_COLOR_AND_MATRIX\n     || pattDetectMode == AR_TEMPLATE_MATCHING_MONO_AND_MATRIX ) {\n        arPattGetImage(imageProcMode, AR_MATRIX_CODE_DETECTION, matrixCodeType & AR_MATRIX_CODE_TYPE_SIZE_MASK, (matrixCodeType & AR_MATRIX_CODE_TYPE_SIZE_MASK)*AR_PATT_SAMPLE_FACTOR2,\n                       image, xsize, ysize, pixelFormat, x_coord, y_coord, vertex, pattRatio, ext_patt2);\n#if DEBUG_PATT_GETID\n        glPixelZoom( 4.0f, -4.0f);\n        glRasterPos3f( 0.0f, (matrixCodeType & AR_MATRIX_CODE_TYPE_SIZE_MASK)*4.0f*cnt, 1.0f );\n        glDrawPixels( matrixCodeType & AR_MATRIX_CODE_TYPE_SIZE_MASK, matrixCodeType & AR_MATRIX_CODE_TYPE_SIZE_MASK, GL_LUMINANCE, GL_UNSIGNED_BYTE, ext_patt2 );\n        glPixelZoom( 1.0f, 1.0f);\n        cnt++;\n#endif\n        errorCodeMtx = get_matrix_code(ext_patt2, matrixCodeType & AR_MATRIX_CODE_TYPE_SIZE_MASK, code, dir, cf, matrixCodeType, NULL);\n    } else errorCodeMtx = 1;\n\n    // Template matching pass.\n    if( pattDetectMode == AR_TEMPLATE_MATCHING_COLOR\n     || pattDetectMode == AR_TEMPLATE_MATCHING_MONO\n     || pattDetectMode == AR_TEMPLATE_MATCHING_COLOR_AND_MATRIX\n     || pattDetectMode == AR_TEMPLATE_MATCHING_MONO_AND_MATRIX ) {\n        if (!pattHandle) {\n            *code = 0;\n            *dir  = 0;\n            *cf   = -_1_0;\n            errorCodePatt = -1;\n        } else {\n            if (pattDetectMode == AR_TEMPLATE_MATCHING_COLOR || pattDetectMode == AR_TEMPLATE_MATCHING_COLOR_AND_MATRIX) {\n                arPattGetImage(imageProcMode, AR_TEMPLATE_MATCHING_COLOR, pattHandle->pattSize, pattHandle->pattSize*AR_PATT_SAMPLE_FACTOR1,\n                               image, xsize, ysize, pixelFormat, x_coord, y_coord, vertex, pattRatio, ext_patt1);\n                errorCodePatt = pattern_match(pattHandle, AR_TEMPLATE_MATCHING_COLOR, ext_patt1, pattHandle->pattSize, code, dir, cf);\n            } else {\n                arPattGetImage(imageProcMode, AR_TEMPLATE_MATCHING_MONO, pattHandle->pattSize, pattHandle->pattSize*AR_PATT_SAMPLE_FACTOR1,\n                               image, xsize, ysize, pixelFormat, x_coord, y_coord, vertex, pattRatio, ext_patt1);\n                errorCodePatt = pattern_match(pattHandle, AR_TEMPLATE_MATCHING_MONO, ext_patt1, pattHandle->pattSize, code, dir, cf);\n            }\n#if DEBUG_PATT_GETID\n            glPixelZoom( 4.0f, -4.0f);\n            glRasterPos3f( 0.0f, pattHandle->pattSize*4.0f*cnt, 1.0f );\n            if( pattDetectMode == AR_TEMPLATE_MATCHING_COLOR || pattDetectMode == AR_TEMPLATE_MATCHING_COLOR_AND_MATRIX)\n                glDrawPixels( pattHandle->pattSize, pattHandle->pattSize, GL_BGR, GL_UNSIGNED_BYTE, ext_patt1 );\n            else\n                glDrawPixels( pattHandle->pattSize, pattHandle->pattSize, GL_LUMINANCE, GL_UNSIGNED_BYTE, ext_patt1 );\n            glPixelZoom( 1.0f, 1.0f);\n            cnt++;\n#endif\n        }\n    } else errorCodePatt = 1;\n\n    if (errorCodeMtx == 1) return (errorCodePatt);\n    else if (errorCodePatt == 1) return (errorCodeMtx);\n    else if (errorCodeMtx < 0 && errorCodePatt < 0) return (errorCodePatt);\n    else return (0);\n}\n\nint arPattGetID2( ARPattHandle *pattHandle, int imageProcMode, int pattDetectMode,\n                 ARUint8 *image, int xsize, int ysize, AR_PIXEL_FORMAT pixelFormat, ARParamLTf *paramLTf, ARdouble vertex[4][2], ARdouble pattRatio,\n                 int *codePatt, int *dirPatt, ARdouble *cfPatt, int *codeMatrix, int *dirMatrix, ARdouble *cfMatrix,\n                 const AR_MATRIX_CODE_TYPE matrixCodeType )\n{\n    return (arPattGetIDGlobal(pattHandle, imageProcMode, pattDetectMode, image, xsize, ysize, pixelFormat, paramLTf, vertex, pattRatio,\n                              codePatt, dirPatt, cfPatt, codeMatrix, dirMatrix, cfMatrix,\n                              matrixCodeType, NULL, NULL));\n}\n#endif // !AR_DISABLE_NON_CORE_FNS\n\nint arPattGetIDGlobal( ARPattHandle *pattHandle, int imageProcMode, int pattDetectMode,\n                      ARUint8 *image, int xsize, int ysize, AR_PIXEL_FORMAT pixelFormat, ARParamLTf *paramLTf, ARdouble vertex[4][2], ARdouble pattRatio,\n                      int *codePatt, int *dirPatt, ARdouble *cfPatt, int *codeMatrix, int *dirMatrix, ARdouble *cfMatrix,\n                      const AR_MATRIX_CODE_TYPE matrixCodeType, int *errorCorrected, uint64_t *codeGlobalID_p )\n{\n    ARUint8 ext_patt[MAX(AR_PATT_SIZE1_MAX,AR_PATT_SIZE2_MAX)*MAX(AR_PATT_SIZE1_MAX,AR_PATT_SIZE2_MAX)*3]; // Holds unwarped pattern extracted from image.\n    int errorCodeMtx, errorCodePatt;\n    uint64_t codeGlobalID;\n\n    // Matrix code detection pass.\n    if( pattDetectMode == AR_MATRIX_CODE_DETECTION\n       || pattDetectMode == AR_TEMPLATE_MATCHING_COLOR_AND_MATRIX\n       || pattDetectMode == AR_TEMPLATE_MATCHING_MONO_AND_MATRIX ) {\n        if (matrixCodeType == AR_MATRIX_CODE_GLOBAL_ID) {\n            if (arPattGetImage2(imageProcMode, AR_MATRIX_CODE_DETECTION, AR_GLOBAL_ID_OUTER_SIZE, AR_GLOBAL_ID_OUTER_SIZE * AR_PATT_SAMPLE_FACTOR2,\n                                image, xsize, ysize, pixelFormat, paramLTf, vertex, (((ARdouble)AR_GLOBAL_ID_OUTER_SIZE)/((ARdouble)(AR_GLOBAL_ID_OUTER_SIZE + 2))), ext_patt) < 0) {\n                errorCodeMtx = -6;\n                *codeMatrix = -1;\n            } else {\n                errorCodeMtx = get_global_id_code(ext_patt, &codeGlobalID, dirMatrix, cfMatrix, errorCorrected);\n                \n                if (errorCodeMtx < 0) {\n                    *codeMatrix = -1;\n                } else if (codeGlobalID == UINT64_MAX) { // Heuristic-based elimination of frequently misrecognised codes.\n                    errorCodeMtx = -5;\n                    *codeMatrix = -1;\n                } else {\n                    if ((codeGlobalID & 0xffff8000ULL) == 0ULL) *codeMatrix = (int)(codeGlobalID & 0x00007fffULL); // If upper 33 bits are zero, return lower 31 bits as regular matrix code as well.\n                    else *codeMatrix = 0; // otherwise, regular matrix code = 0;\n                    if (codeGlobalID_p) *codeGlobalID_p = codeGlobalID;\n                }\n            }\n        } else {\n            if (arPattGetImage2(imageProcMode, AR_MATRIX_CODE_DETECTION, matrixCodeType & AR_MATRIX_CODE_TYPE_SIZE_MASK, (matrixCodeType & AR_MATRIX_CODE_TYPE_SIZE_MASK) * AR_PATT_SAMPLE_FACTOR2,\n                                image, xsize, ysize, pixelFormat, paramLTf, vertex, pattRatio, ext_patt) < 0) {\n                errorCodeMtx = -6;\n                *codeMatrix = -1;\n            } else {\n#if DEBUG_PATT_GETID\n                glPixelZoom( 4.0f, -4.0f);\n                glRasterPos3f( 0.0f, (matrixCodeType & AR_MATRIX_CODE_TYPE_SIZE_MASK)*4.0f*cnt, 1.0f );\n                glDrawPixels( matrixCodeType & AR_MATRIX_CODE_TYPE_SIZE_MASK, matrixCodeType & AR_MATRIX_CODE_TYPE_SIZE_MASK, GL_LUMINANCE, GL_UNSIGNED_BYTE, ext_patt );\n                glPixelZoom( 1.0f, 1.0f);\n                cnt++;\n#endif\n                errorCodeMtx = get_matrix_code(ext_patt, matrixCodeType & AR_MATRIX_CODE_TYPE_SIZE_MASK, codeMatrix, dirMatrix, cfMatrix, matrixCodeType, errorCorrected);\n                if (codeGlobalID_p) *codeGlobalID_p = 0ULL;\n            }\n        }\n    } else errorCodeMtx = 1;\n    \n    // Template matching pass.\n    if( pattDetectMode == AR_TEMPLATE_MATCHING_COLOR\n       || pattDetectMode == AR_TEMPLATE_MATCHING_MONO\n       || pattDetectMode == AR_TEMPLATE_MATCHING_COLOR_AND_MATRIX\n       || pattDetectMode == AR_TEMPLATE_MATCHING_MONO_AND_MATRIX ) {\n        if (!pattHandle) {\n            errorCodePatt = -1;\n            *codePatt = -1;\n        } else {\n            if (pattDetectMode == AR_TEMPLATE_MATCHING_COLOR || pattDetectMode == AR_TEMPLATE_MATCHING_COLOR_AND_MATRIX) {\n                if (arPattGetImage2(imageProcMode, AR_TEMPLATE_MATCHING_COLOR, pattHandle->pattSize, pattHandle->pattSize*AR_PATT_SAMPLE_FACTOR1,\n                                    image, xsize, ysize, pixelFormat, paramLTf, vertex, pattRatio, ext_patt) < 0) {\n                    errorCodePatt = -6;\n                    *codePatt = -1;\n                } else {\n                    errorCodePatt = pattern_match(pattHandle, AR_TEMPLATE_MATCHING_COLOR, ext_patt, pattHandle->pattSize, codePatt, dirPatt, cfPatt);\n#if DEBUG_PATT_GETID\n                    glPixelZoom( 4.0f, -4.0f);\n                    glRasterPos3f( 0.0f, pattHandle->pattSize*4.0f*cnt, 1.0f );\n                    glDrawPixels( pattHandle->pattSize, pattHandle->pattSize, GL_BGR, GL_UNSIGNED_BYTE, ext_patt );\n                    glPixelZoom( 1.0f, 1.0f);\n                    cnt++;\n#endif\n                }\n            } else {\n                if (arPattGetImage2(imageProcMode, AR_TEMPLATE_MATCHING_MONO, pattHandle->pattSize, pattHandle->pattSize*AR_PATT_SAMPLE_FACTOR1,\n                                    image, xsize, ysize, pixelFormat, paramLTf, vertex, pattRatio, ext_patt) < 0) {\n                    errorCodePatt = -6;\n                    *codePatt = -1;\n                } else {\n                    errorCodePatt = pattern_match(pattHandle, AR_TEMPLATE_MATCHING_MONO, ext_patt, pattHandle->pattSize, codePatt, dirPatt, cfPatt);\n#if DEBUG_PATT_GETID\n                    glPixelZoom( 4.0f, -4.0f);\n                    glRasterPos3f( 0.0f, pattHandle->pattSize*4.0f*cnt, 1.0f );\n                    glDrawPixels( pattHandle->pattSize, pattHandle->pattSize, GL_LUMINANCE, GL_UNSIGNED_BYTE, ext_patt );\n                    glPixelZoom( 1.0f, 1.0f);\n                    cnt++;\n#endif\n                }\n            }\n        }\n    } else errorCodePatt = 1;\n    \n    if (errorCodeMtx == 1) return (errorCodePatt);                           // pattern-mode only.\n    else if (errorCodePatt == 1) return (errorCodeMtx);                      // matrix-mode only.\n    else if (errorCodeMtx < 0 && errorCodePatt < 0) return (errorCodePatt);  // if mixed mode and errors in both modes, return error from pattern mode.\n    else return (0);\n    \n}\n\n#if !AR_DISABLE_NON_CORE_FNS\nint arPattGetImage( int imageProcMode, int pattDetectMode, int patt_size, int sample_size,\n                    ARUint8 *image, int xsize, int ysize, AR_PIXEL_FORMAT pixelFormat, int *x_coord, int *y_coord, int *vertex,\n                    ARdouble pattRatio, ARUint8 *ext_patt )\n{\n    ARUint32 *ext_patt2;\n    ARdouble    world[4][2];\n    ARdouble    local[4][2];\n    ARdouble    para[3][3];\n    ARdouble    d, xw, yw;\n    ARdouble    pattRatio1, pattRatio2;\n    int       xc, yc;\n    int       xdiv, ydiv;\n    int       xdiv2, ydiv2;\n    int       lx1, lx2, ly1, ly2, lxPatt, lyPatt;\n    int       i, j;\n\n    world[0][0] = _100_0;\n    world[0][1] = _100_0;\n    world[1][0] = _100_0 + _10_0;\n    world[1][1] = _100_0;\n    world[2][0] = _100_0 + _10_0;\n    world[2][1] = _100_0 + _10_0;\n    world[3][0] = _100_0;\n    world[3][1] = _100_0 + _10_0;\n    for( i = 0; i < 4; i++ ) {\n        local[i][0] = x_coord[vertex[i]];\n        local[i][1] = y_coord[vertex[i]];\n    }\n    get_cpara( world, local, para );\n\n\t// The square roots of lx1, lx2, ly1, and ly2 are the lengths of the sides of the polygon.\n    lx1 = (int)((local[0][0] - local[1][0])*(local[0][0] - local[1][0])\n        + (local[0][1] - local[1][1])*(local[0][1] - local[1][1]));\n    lx2 = (int)((local[2][0] - local[3][0])*(local[2][0] - local[3][0])\n        + (local[2][1] - local[3][1])*(local[2][1] - local[3][1]));\n    ly1 = (int)((local[1][0] - local[2][0])*(local[1][0] - local[2][0])\n        + (local[1][1] - local[2][1])*(local[1][1] - local[2][1]));\n    ly2 = (int)((local[3][0] - local[0][0])*(local[3][0] - local[0][0])\n        + (local[3][1] - local[0][1])*(local[3][1] - local[0][1]));\n    if( lx2 > lx1 ) lx1 = lx2;\n    if( ly2 > ly1 ) ly1 = ly2;\n    lxPatt = (int)(lx1*pattRatio*pattRatio);\n    lyPatt = (int)(ly1*pattRatio*pattRatio);\n    xdiv2 = patt_size;\n    ydiv2 = patt_size;\n    if( imageProcMode == AR_IMAGE_PROC_FRAME_IMAGE ) {\n        while( xdiv2*xdiv2 < lxPatt && xdiv2 < sample_size ) xdiv2*=2; // while (xdiv2 < ((sqrt(lx1) * pattRatio)) xdiv2*=2;\n        while( ydiv2*ydiv2 < lyPatt && ydiv2 < sample_size ) ydiv2*=2; // while (ydiv2 < ((sqrt(ly1) * pattRatio)) ydiv2*=2;\n    }\n    else {\n        while( xdiv2*xdiv2*4 < lxPatt && xdiv2 < sample_size ) xdiv2*=2;\n        while( ydiv2*ydiv2*4 < lyPatt && ydiv2 < sample_size ) ydiv2*=2;\n    }\n    if( xdiv2 > sample_size ) xdiv2 = sample_size;\n    if( ydiv2 > sample_size ) ydiv2 = sample_size;\n\n    xdiv = xdiv2/patt_size;\n    ydiv = ydiv2/patt_size;\n    pattRatio1 = (_1_0 - pattRatio)/_2_0 * _10_0; // borderSize * 10.0\n    pattRatio2 = pattRatio * _10_0;\n\n    if( pattDetectMode == AR_TEMPLATE_MATCHING_COLOR ) {\n        arMallocClear( ext_patt2, ARUint32, patt_size*patt_size*3 );\n\n        if( pixelFormat == AR_PIXEL_FORMAT_RGB ) {\n            for( j = 0; j < ydiv2; j++ ) {\n                yw = (_100_0+pattRatio1) + pattRatio2 * (j+_0_5) / (ARdouble)ydiv2;\n                for( i = 0; i < xdiv2; i++ ) {\n                    xw = (_100_0+pattRatio1) + pattRatio2 * (i+_0_5) / (ARdouble)xdiv2;\n                    d = para[2][0]*xw + para[2][1]*yw + para[2][2];\n                    if( d == 0 ) goto bail;\n                    xc = (int)((para[0][0]*xw + para[0][1]*yw + para[0][2])/d);\n                    yc = (int)((para[1][0]*xw + para[1][1]*yw + para[1][2])/d);\n                    if( imageProcMode == AR_IMAGE_PROC_FIELD_IMAGE ) {\n                        xc = ((xc+1)/2)*2;\n                        yc = ((yc+1)/2)*2;\n                    }\n                    if( xc >= 0 && xc < xsize && yc >= 0 && yc < ysize ) {\n                        ext_patt2[((j/ydiv)*patt_size+(i/xdiv))*3+0] += image[(yc*xsize+xc)*3+2];\n                        ext_patt2[((j/ydiv)*patt_size+(i/xdiv))*3+1] += image[(yc*xsize+xc)*3+1];\n                        ext_patt2[((j/ydiv)*patt_size+(i/xdiv))*3+2] += image[(yc*xsize+xc)*3+0];\n                    }\n                }\n            }\n        }\n        else if( pixelFormat == AR_PIXEL_FORMAT_BGR ) {\n            for( j = 0; j < ydiv2; j++ ) {\n                yw = (_100_0+pattRatio1) + pattRatio2 * (j+_0_5) / (ARdouble)ydiv2;\n                for( i = 0; i < xdiv2; i++ ) {\n                    xw = (_100_0+pattRatio1) + pattRatio2 * (i+_0_5) / (ARdouble)xdiv2;\n                    d = para[2][0]*xw + para[2][1]*yw + para[2][2];\n                    if( d == 0 ) goto bail;\n                    xc = (int)((para[0][0]*xw + para[0][1]*yw + para[0][2])/d);\n                    yc = (int)((para[1][0]*xw + para[1][1]*yw + para[1][2])/d);\n                    if( imageProcMode == AR_IMAGE_PROC_FIELD_IMAGE ) {\n                        xc = ((xc+1)/2)*2;\n                        yc = ((yc+1)/2)*2;\n                    }\n                    if( xc >= 0 && xc < xsize && yc >= 0 && yc < ysize ) {\n                        ext_patt2[((j/ydiv)*patt_size+(i/xdiv))*3+0] += image[(yc*xsize+xc)*3+0];\n                        ext_patt2[((j/ydiv)*patt_size+(i/xdiv))*3+1] += image[(yc*xsize+xc)*3+1];\n                        ext_patt2[((j/ydiv)*patt_size+(i/xdiv))*3+2] += image[(yc*xsize+xc)*3+2];\n                    }\n                }\n            }\n        }\n        else if( pixelFormat == AR_PIXEL_FORMAT_RGBA ) {\n            for( j = 0; j < ydiv2; j++ ) {\n                yw = (_100_0+pattRatio1) + pattRatio2 * (j+_0_5) / (ARdouble)ydiv2;\n                for( i = 0; i < xdiv2; i++ ) {\n                    xw = (_100_0+pattRatio1) + pattRatio2 * (i+_0_5) / (ARdouble)xdiv2;\n                    d = para[2][0]*xw + para[2][1]*yw + para[2][2];\n                    if( d == 0 ) goto bail;\n                    xc = (int)((para[0][0]*xw + para[0][1]*yw + para[0][2])/d);\n                    yc = (int)((para[1][0]*xw + para[1][1]*yw + para[1][2])/d);\n                    if( imageProcMode == AR_IMAGE_PROC_FIELD_IMAGE ) {\n                        xc = ((xc+1)/2)*2;\n                        yc = ((yc+1)/2)*2;\n                    }\n                    if( xc >= 0 && xc < xsize && yc >= 0 && yc < ysize ) {\n                        ext_patt2[((j/ydiv)*patt_size+(i/xdiv))*3+0] += image[(yc*xsize+xc)*4+2];\n                        ext_patt2[((j/ydiv)*patt_size+(i/xdiv))*3+1] += image[(yc*xsize+xc)*4+1];\n                        ext_patt2[((j/ydiv)*patt_size+(i/xdiv))*3+2] += image[(yc*xsize+xc)*4+0];\n                    }\n                }\n            }\n        }\n        else if( pixelFormat == AR_PIXEL_FORMAT_BGRA ) {\n            for( j = 0; j < ydiv2; j++ ) {\n                yw = (_100_0+pattRatio1) + pattRatio2 * (j+_0_5) / (ARdouble)ydiv2;\n                for( i = 0; i < xdiv2; i++ ) {\n                    xw = (_100_0+pattRatio1) + pattRatio2 * (i+_0_5) / (ARdouble)xdiv2;\n                    d = para[2][0]*xw + para[2][1]*yw + para[2][2];\n                    if( d == 0 ) goto bail;\n                    xc = (int)((para[0][0]*xw + para[0][1]*yw + para[0][2])/d);\n                    yc = (int)((para[1][0]*xw + para[1][1]*yw + para[1][2])/d);\n                    if( imageProcMode == AR_IMAGE_PROC_FIELD_IMAGE ) {\n                        xc = ((xc+1)/2)*2;\n                        yc = ((yc+1)/2)*2;\n                    }\n                    if( xc >= 0 && xc < xsize && yc >= 0 && yc < ysize ) {\n                        ext_patt2[((j/ydiv)*patt_size+(i/xdiv))*3+0] += image[(yc*xsize+xc)*4+0];\n                        ext_patt2[((j/ydiv)*patt_size+(i/xdiv))*3+1] += image[(yc*xsize+xc)*4+1];\n                        ext_patt2[((j/ydiv)*patt_size+(i/xdiv))*3+2] += image[(yc*xsize+xc)*4+2];\n                    }\n                }\n            }\n        }\n        else if( pixelFormat == AR_PIXEL_FORMAT_ABGR ) {\n            for( j = 0; j < ydiv2; j++ ) {\n                yw = (_100_0+pattRatio1) + pattRatio2 * (j+_0_5) / (ARdouble)ydiv2;\n                for( i = 0; i < xdiv2; i++ ) {\n                    xw = (_100_0+pattRatio1) + pattRatio2 * (i+_0_5) / (ARdouble)xdiv2;\n                    d = para[2][0]*xw + para[2][1]*yw + para[2][2];\n                    if( d == 0 ) goto bail;\n                    xc = (int)((para[0][0]*xw + para[0][1]*yw + para[0][2])/d);\n                    yc = (int)((para[1][0]*xw + para[1][1]*yw + para[1][2])/d);\n                    if( imageProcMode == AR_IMAGE_PROC_FIELD_IMAGE ) {\n                        xc = ((xc+1)/2)*2;\n                        yc = ((yc+1)/2)*2;\n                    }\n                    if( xc >= 0 && xc < xsize && yc >= 0 && yc < ysize ) {\n                        ext_patt2[((j/ydiv)*patt_size+(i/xdiv))*3+0] += image[(yc*xsize+xc)*4+1];\n                        ext_patt2[((j/ydiv)*patt_size+(i/xdiv))*3+1] += image[(yc*xsize+xc)*4+2];\n                        ext_patt2[((j/ydiv)*patt_size+(i/xdiv))*3+2] += image[(yc*xsize+xc)*4+3];\n                    }\n                }\n            }\n        }\n        else if( pixelFormat == AR_PIXEL_FORMAT_MONO || pixelFormat == AR_PIXEL_FORMAT_420v || pixelFormat == AR_PIXEL_FORMAT_420f || pixelFormat == AR_PIXEL_FORMAT_NV21 ) {\n            // N.B.: caller asked for colour matching, but we can/will only supply mono.\n            for( j = 0; j < ydiv2; j++ ) {\n                yw = (_100_0+pattRatio1) + pattRatio2 * (j+_0_5) / (ARdouble)ydiv2;\n                for( i = 0; i < xdiv2; i++ ) {\n                    xw = (_100_0+pattRatio1) + pattRatio2 * (i+_0_5) / (ARdouble)xdiv2;\n                    d = para[2][0]*xw + para[2][1]*yw + para[2][2];\n                    if( d == 0 ) goto bail;\n                    xc = (int)((para[0][0]*xw + para[0][1]*yw + para[0][2])/d);\n                    yc = (int)((para[1][0]*xw + para[1][1]*yw + para[1][2])/d);\n                    if( imageProcMode == AR_IMAGE_PROC_FIELD_IMAGE ) {\n                        xc = ((xc+1)/2)*2;\n                        yc = ((yc+1)/2)*2;\n                    }\n                    if( xc >= 0 && xc < xsize && yc >= 0 && yc < ysize ) {\n                        ext_patt2[((j/ydiv)*patt_size+(i/xdiv))*3+0] += image[yc*xsize+xc];\n                        ext_patt2[((j/ydiv)*patt_size+(i/xdiv))*3+1] += image[yc*xsize+xc];\n                        ext_patt2[((j/ydiv)*patt_size+(i/xdiv))*3+2] += image[yc*xsize+xc];\n                    }\n                }\n            }\n        }\n        else if( pixelFormat == AR_PIXEL_FORMAT_ARGB ) {\n            for( j = 0; j < ydiv2; j++ ) {\n                yw = (_100_0+pattRatio1) + pattRatio2 * (j+_0_5) / (ARdouble)ydiv2;\n                for( i = 0; i < xdiv2; i++ ) {\n                    xw = (_100_0+pattRatio1) + pattRatio2 * (i+_0_5) / (ARdouble)xdiv2;\n                    d = para[2][0]*xw + para[2][1]*yw + para[2][2];\n                    if( d == 0 ) goto bail;\n                    xc = (int)((para[0][0]*xw + para[0][1]*yw + para[0][2])/d);\n                    yc = (int)((para[1][0]*xw + para[1][1]*yw + para[1][2])/d);\n                    if( imageProcMode == AR_IMAGE_PROC_FIELD_IMAGE ) {\n                        xc = ((xc+1)/2)*2;\n                        yc = ((yc+1)/2)*2;\n                    }\n                    if( xc >= 0 && xc < xsize && yc >= 0 && yc < ysize ) {\n                        ext_patt2[((j/ydiv)*patt_size+(i/xdiv))*3+0] += image[(yc*xsize+xc)*4+3];\n                        ext_patt2[((j/ydiv)*patt_size+(i/xdiv))*3+1] += image[(yc*xsize+xc)*4+2];\n                        ext_patt2[((j/ydiv)*patt_size+(i/xdiv))*3+2] += image[(yc*xsize+xc)*4+1];\n                    }\n                }\n            }\n        }\n        else if( pixelFormat == AR_PIXEL_FORMAT_2vuy ) {\n            for( j = 0; j < ydiv2; j++ ) {\n                yw = (_100_0+pattRatio1) + pattRatio2 * (j+_0_5) / (ARdouble)ydiv2;\n                for( i = 0; i < xdiv2; i++ ) {\n                    xw = (_100_0+pattRatio1) + pattRatio2 * (i+_0_5) / (ARdouble)xdiv2;\n                    d = para[2][0]*xw + para[2][1]*yw + para[2][2];\n                    if( d == 0 ) goto bail;\n                    xc = (int)((para[0][0]*xw + para[0][1]*yw + para[0][2])/d);\n                    yc = (int)((para[1][0]*xw + para[1][1]*yw + para[1][2])/d);\n                    if( imageProcMode == AR_IMAGE_PROC_FIELD_IMAGE ) {\n                        xc = ((xc+1)/2)*2;\n                        yc = ((yc+1)/2)*2;\n                    }\n                    if( xc >= 0 && xc < xsize && yc >= 0 && yc < ysize ) {\n                        float Cb =     (float)(image[(yc*xsize + (xc & 0xFFFE))*2 + 0] - 128); // Byte 0 of each 4-byte block for both even- and odd-numbered columns.\n                        float Yprime = (float)(image[(yc*xsize +            xc)*2 + 1] - 16);  // Byte 1 of each 4-byte block for even-numbered columns, byte 3 for odd-numbered columns.\n                        float Cr =     (float)(image[(yc*xsize + (xc & 0xFFFE))*2 + 2] - 128); // Byte 2 of each 4-byte block for both even- and odd-numbered columns.\n\t\t\t\t\t\t// Conversion from Poynton's color FAQ http://www.poynton.com.\n                        int B0 = (int)(298.082f*Yprime + 516.411f*Cb              ) >> 8;\n                        int G0 = (int)(298.082f*Yprime - 100.291f*Cb - 208.120f*Cr) >> 8;\n                        int R0 = (int)(298.082f*Yprime               + 408.583f*Cr) >> 8;\n                        ext_patt2[((j/ydiv)*patt_size+(i/xdiv))*3+0] += CLAMP(B0, 0, 255);\n                        ext_patt2[((j/ydiv)*patt_size+(i/xdiv))*3+1] += CLAMP(G0, 0, 255);\n                        ext_patt2[((j/ydiv)*patt_size+(i/xdiv))*3+2] += CLAMP(R0, 0, 255);\n                    }\n                }\n            }\n        }\n        else if( pixelFormat == AR_PIXEL_FORMAT_yuvs ) {\n            for( j = 0; j < ydiv2; j++ ) {\n                yw = (_100_0+pattRatio1) + pattRatio2 * (j+_0_5) / (ARdouble)ydiv2;\n                for( i = 0; i < xdiv2; i++ ) {\n                    xw = (_100_0+pattRatio1) + pattRatio2 * (i+_0_5) / (ARdouble)xdiv2;\n                    d = para[2][0]*xw + para[2][1]*yw + para[2][2];\n                    if( d == 0 ) goto bail;\n                    xc = (int)((para[0][0]*xw + para[0][1]*yw + para[0][2])/d);\n                    yc = (int)((para[1][0]*xw + para[1][1]*yw + para[1][2])/d);\n                    if( imageProcMode == AR_IMAGE_PROC_FIELD_IMAGE ) {\n                        xc = ((xc+1)/2)*2;\n                        yc = ((yc+1)/2)*2;\n                    }\n                    if( xc >= 0 && xc < xsize && yc >= 0 && yc < ysize ) {\n                        float Yprime = (float)(image[(yc*xsize +            xc)*2 + 0] - 16);  // Byte 0 of each 4-byte block for even-numbered columns, byte 2 for odd-numbered columns.\n                        float Cb =     (float)(image[(yc*xsize + (xc & 0xFFFE))*2 + 1] - 128); // Byte 1 of each 4-byte block for both even- and odd-numbered columns.\n                        float Cr =     (float)(image[(yc*xsize + (xc & 0xFFFE))*2 + 3] - 128); // Byte 3 of each 4-byte block for both even- and odd-numbered columns.\n\t\t\t\t\t\t// Conversion from Poynton's color FAQ http://www.poynton.com.\n                        int B0 = (int)(298.082f*Yprime + 516.411f*Cb              ) >> 8;\n                        int G0 = (int)(298.082f*Yprime - 100.291f*Cb - 208.120f*Cr) >> 8;\n                        int R0 = (int)(298.082f*Yprime               + 408.583f*Cr) >> 8;\n                        ext_patt2[((j/ydiv)*patt_size+(i/xdiv))*3+0] += CLAMP(B0, 0, 255);\n                        ext_patt2[((j/ydiv)*patt_size+(i/xdiv))*3+1] += CLAMP(G0, 0, 255);\n                        ext_patt2[((j/ydiv)*patt_size+(i/xdiv))*3+2] += CLAMP(R0, 0, 255);\n                    }\n                }\n            }\n        }\n        else if( pixelFormat == AR_PIXEL_FORMAT_RGB_565 ) {\n            for( j = 0; j < ydiv2; j++ ) {\n                yw = (_100_0+pattRatio1) + pattRatio2 * (j+_0_5) / (ARdouble)ydiv2;\n                for( i = 0; i < xdiv2; i++ ) {\n                    xw = (_100_0+pattRatio1) + pattRatio2 * (i+_0_5) / (ARdouble)xdiv2;\n                    d = para[2][0]*xw + para[2][1]*yw + para[2][2];\n                    if( d == 0 ) goto bail;\n                    xc = (int)((para[0][0]*xw + para[0][1]*yw + para[0][2])/d);\n                    yc = (int)((para[1][0]*xw + para[1][1]*yw + para[1][2])/d);\n                    if( imageProcMode == AR_IMAGE_PROC_FIELD_IMAGE ) {\n                        xc = ((xc+1)/2)*2;\n                        yc = ((yc+1)/2)*2;\n                    }\n                    if( xc >= 0 && xc < xsize && yc >= 0 && yc < ysize ) {\n                        ext_patt2[((j/ydiv)*patt_size+(i/xdiv))*3+0] +=                                            (((image[(yc*xsize+xc)*2+1] & 0x1f) << 3) + 0x04);\n                        ext_patt2[((j/ydiv)*patt_size+(i/xdiv))*3+1] += (((image[(yc*xsize+xc)*2+0] & 0x07) << 5) + ((image[(yc*xsize+xc)*2+1] & 0xe0) >> 3) + 0x02);\n                        ext_patt2[((j/ydiv)*patt_size+(i/xdiv))*3+2] +=  ((image[(yc*xsize+xc)*2+0] & 0xf8) + 0x04);\n                    }\n                }\n            }\n        }\n        else if( pixelFormat == AR_PIXEL_FORMAT_RGBA_5551 ) {\n            for( j = 0; j < ydiv2; j++ ) {\n                yw = (_100_0+pattRatio1) + pattRatio2 * (j+_0_5) / (ARdouble)ydiv2;\n                for( i = 0; i < xdiv2; i++ ) {\n                    xw = (_100_0+pattRatio1) + pattRatio2 * (i+_0_5) / (ARdouble)xdiv2;\n                    d = para[2][0]*xw + para[2][1]*yw + para[2][2];\n                    if( d == 0 ) goto bail;\n                    xc = (int)((para[0][0]*xw + para[0][1]*yw + para[0][2])/d);\n                    yc = (int)((para[1][0]*xw + para[1][1]*yw + para[1][2])/d);\n                    if( imageProcMode == AR_IMAGE_PROC_FIELD_IMAGE ) {\n                        xc = ((xc+1)/2)*2;\n                        yc = ((yc+1)/2)*2;\n                    }\n                    if( xc >= 0 && xc < xsize && yc >= 0 && yc < ysize ) {\n                        ext_patt2[((j/ydiv)*patt_size+(i/xdiv))*3+0] +=                                            (((image[(yc*xsize+xc)*2+1] & 0x3e) << 2) + 0x04);\n                        ext_patt2[((j/ydiv)*patt_size+(i/xdiv))*3+1] += (((image[(yc*xsize+xc)*2+0] & 0x07) << 5) + ((image[(yc*xsize+xc)*2+1] & 0xc0) >> 3) + 0x04);\n                        ext_patt2[((j/ydiv)*patt_size+(i/xdiv))*3+2] +=  ((image[(yc*xsize+xc)*2+0] & 0xf8) + 0x04);\n                    }\n                }\n            }\n        }\n        else if( pixelFormat == AR_PIXEL_FORMAT_RGBA_4444 ) {\n            for( j = 0; j < ydiv2; j++ ) {\n                yw = (_100_0+pattRatio1) + pattRatio2 * (j+_0_5) / (ARdouble)ydiv2;\n                for( i = 0; i < xdiv2; i++ ) {\n                    xw = (_100_0+pattRatio1) + pattRatio2 * (i+_0_5) / (ARdouble)xdiv2;\n                    d = para[2][0]*xw + para[2][1]*yw + para[2][2];\n                    if( d == 0 ) goto bail;\n                    xc = (int)((para[0][0]*xw + para[0][1]*yw + para[0][2])/d);\n                    yc = (int)((para[1][0]*xw + para[1][1]*yw + para[1][2])/d);\n                    if( imageProcMode == AR_IMAGE_PROC_FIELD_IMAGE ) {\n                        xc = ((xc+1)/2)*2;\n                        yc = ((yc+1)/2)*2;\n                    }\n                    if( xc >= 0 && xc < xsize && yc >= 0 && yc < ysize ) {\n                        ext_patt2[((j/ydiv)*patt_size+(i/xdiv))*3+0] +=  ((image[(yc*xsize+xc)*2+1] & 0xf0) + 0x08);\n                        ext_patt2[((j/ydiv)*patt_size+(i/xdiv))*3+1] += (((image[(yc*xsize+xc)*2+0] & 0x0f) << 4) + 0x08);\n                        ext_patt2[((j/ydiv)*patt_size+(i/xdiv))*3+2] +=  ((image[(yc*xsize+xc)*2+0] & 0xf0) + 0x08);\n                    }\n                }\n            }\n        }\n        else {\n            ARLOGe(\"Error: unsupported pixel format.\\n\");\n            goto bail;\n        }\n\n        for( i = 0; i < patt_size*patt_size*3; i++ ) {\n            ext_patt[i] = ext_patt2[i] / (xdiv*ydiv);\n        }\n\n        free( ext_patt2 );\n    }\n    else { // pattDetectMode != AR_TEMPLATE_MATCHING_COLOR\n        arMallocClear( ext_patt2, ARUint32, patt_size*patt_size );\n\n        if( pixelFormat == AR_PIXEL_FORMAT_RGB || pixelFormat == AR_PIXEL_FORMAT_BGR ) {\n            for( j = 0; j < ydiv2; j++ ) {\n                yw = (_100_0+pattRatio1) + pattRatio2 * (j+_0_5) / (ARdouble)ydiv2;\n                for( i = 0; i < xdiv2; i++ ) {\n                    xw = (_100_0+pattRatio1) + pattRatio2 * (i+_0_5) / (ARdouble)xdiv2;\n                    d = para[2][0]*xw + para[2][1]*yw + para[2][2];\n                    if( d == 0 ) goto bail;\n                    xc = (int)((para[0][0]*xw + para[0][1]*yw + para[0][2])/d);\n                    yc = (int)((para[1][0]*xw + para[1][1]*yw + para[1][2])/d);\n                    if( imageProcMode == AR_IMAGE_PROC_FIELD_IMAGE ) {\n                        xc = ((xc+1)/2)*2;\n                        yc = ((yc+1)/2)*2;\n                    }\n                    if( xc >= 0 && xc < xsize && yc >= 0 && yc < ysize ) {\n                        ext_patt2[(j/ydiv)*patt_size+(i/xdiv)]\n                             += (   image[(yc*xsize+xc)*3+0]\n                                  + image[(yc*xsize+xc)*3+1]\n                                  + image[(yc*xsize+xc)*3+2] )/3;\n                    }\n                }\n            }\n        }\n        else if( pixelFormat == AR_PIXEL_FORMAT_RGBA || pixelFormat == AR_PIXEL_FORMAT_BGRA ) {\n            for( j = 0; j < ydiv2; j++ ) {\n                yw = (_100_0+pattRatio1) + pattRatio2 * (j+_0_5) / (ARdouble)ydiv2;\n                for( i = 0; i < xdiv2; i++ ) {\n                    xw = (_100_0+pattRatio1) + pattRatio2 * (i+_0_5) / (ARdouble)xdiv2;\n                    d = para[2][0]*xw + para[2][1]*yw + para[2][2];\n                    if( d == 0 ) goto bail;\n                    xc = (int)((para[0][0]*xw + para[0][1]*yw + para[0][2])/d);\n                    yc = (int)((para[1][0]*xw + para[1][1]*yw + para[1][2])/d);\n                    if( imageProcMode == AR_IMAGE_PROC_FIELD_IMAGE ) {\n                        xc = ((xc+1)/2)*2;\n                        yc = ((yc+1)/2)*2;\n                    }\n                    if( xc >= 0 && xc < xsize && yc >= 0 && yc < ysize ) {\n                        ext_patt2[(j/ydiv)*patt_size+(i/xdiv)]\n                             += (   image[(yc*xsize+xc)*4+0]\n                                  + image[(yc*xsize+xc)*4+1]\n                                  + image[(yc*xsize+xc)*4+2] )/3;\n                    }\n                }\n            }\n        }\n        else if( pixelFormat == AR_PIXEL_FORMAT_ABGR || pixelFormat == AR_PIXEL_FORMAT_ARGB ) {\n            for( j = 0; j < ydiv2; j++ ) {\n                yw = (_100_0+pattRatio1) + pattRatio2 * (j+_0_5) / (ARdouble)ydiv2;\n                for( i = 0; i < xdiv2; i++ ) {\n                    xw = (_100_0+pattRatio1) + pattRatio2 * (i+_0_5) / (ARdouble)xdiv2;\n                    d = para[2][0]*xw + para[2][1]*yw + para[2][2];\n                    if( d == 0 ) goto bail;\n                    xc = (int)((para[0][0]*xw + para[0][1]*yw + para[0][2])/d);\n                    yc = (int)((para[1][0]*xw + para[1][1]*yw + para[1][2])/d);\n                    if( imageProcMode == AR_IMAGE_PROC_FIELD_IMAGE ) {\n                        xc = ((xc+1)/2)*2;\n                        yc = ((yc+1)/2)*2;\n                    }\n                    if( xc >= 0 && xc < xsize && yc >= 0 && yc < ysize ) {\n                        ext_patt2[(j/ydiv)*patt_size+(i/xdiv)]\n                             += (   image[(yc*xsize+xc)*4+1]\n                                  + image[(yc*xsize+xc)*4+2]\n                                  + image[(yc*xsize+xc)*4+3] )/3;\n                    }\n                }\n            }\n        }\n        else if( pixelFormat == AR_PIXEL_FORMAT_MONO || pixelFormat == AR_PIXEL_FORMAT_420v || pixelFormat == AR_PIXEL_FORMAT_420f || pixelFormat == AR_PIXEL_FORMAT_NV21 ) {\n            for( j = 0; j < ydiv2; j++ ) {\n                yw = (_100_0+pattRatio1) + pattRatio2 * (j+_0_5) / (ARdouble)ydiv2;\n                for( i = 0; i < xdiv2; i++ ) {\n                    xw = (_100_0+pattRatio1) + pattRatio2 * (i+_0_5) / (ARdouble)xdiv2;\n                    d = para[2][0]*xw + para[2][1]*yw + para[2][2];\n                    if( d == 0 ) goto bail;\n                    xc = (int)((para[0][0]*xw + para[0][1]*yw + para[0][2])/d);\n                    yc = (int)((para[1][0]*xw + para[1][1]*yw + para[1][2])/d);\n                    if( imageProcMode == AR_IMAGE_PROC_FIELD_IMAGE ) {\n                        xc = ((xc+1)/2)*2;\n                        yc = ((yc+1)/2)*2;\n                    }\n                    if( xc >= 0 && xc < xsize && yc >= 0 && yc < ysize ) {\n                        ext_patt2[(j/ydiv)*patt_size+(i/xdiv)] += image[yc*xsize+xc];\n                    }\n                }\n            }\n        }\n        else if( pixelFormat == AR_PIXEL_FORMAT_2vuy ) {\n            for( j = 0; j < ydiv2; j++ ) {\n                yw = (_100_0+pattRatio1) + pattRatio2 * (j+_0_5) / (ARdouble)ydiv2;\n                for( i = 0; i < xdiv2; i++ ) {\n                    xw = (_100_0+pattRatio1) + pattRatio2 * (i+_0_5) / (ARdouble)xdiv2;\n                    d = para[2][0]*xw + para[2][1]*yw + para[2][2];\n                    if( d == 0 ) goto bail;\n                    xc = (int)((para[0][0]*xw + para[0][1]*yw + para[0][2])/d);\n                    yc = (int)((para[1][0]*xw + para[1][1]*yw + para[1][2])/d);\n                    if( imageProcMode == AR_IMAGE_PROC_FIELD_IMAGE ) {\n                        xc = ((xc+1)/2)*2;\n                        yc = ((yc+1)/2)*2;\n                    }\n                    if( xc >= 0 && xc < xsize && yc >= 0 && yc < ysize ) {\n                        ext_patt2[(j/ydiv)*patt_size+(i/xdiv)] += image[(yc*xsize+xc)*2+1];\n                    }\n                }\n            }\n        }\n        else if( pixelFormat == AR_PIXEL_FORMAT_yuvs ) {\n            for( j = 0; j < ydiv2; j++ ) {\n                yw = (_100_0+pattRatio1) + pattRatio2 * (j+_0_5) / (ARdouble)ydiv2;\n                for( i = 0; i < xdiv2; i++ ) {\n                    xw = (_100_0+pattRatio1) + pattRatio2 * (i+_0_5) / (ARdouble)xdiv2;\n                    d = para[2][0]*xw + para[2][1]*yw + para[2][2];\n                    if( d == 0 ) goto bail;\n                    xc = (int)((para[0][0]*xw + para[0][1]*yw + para[0][2])/d);\n                    yc = (int)((para[1][0]*xw + para[1][1]*yw + para[1][2])/d);\n                    if( imageProcMode == AR_IMAGE_PROC_FIELD_IMAGE ) {\n                        xc = ((xc+1)/2)*2;\n                        yc = ((yc+1)/2)*2;\n                    }\n                    if( xc >= 0 && xc < xsize && yc >= 0 && yc < ysize ) {\n                        ext_patt2[(j/ydiv)*patt_size+(i/xdiv)] += image[(yc*xsize+xc)*2];\n                    }\n                }\n            }\n        }\n        else if( pixelFormat == AR_PIXEL_FORMAT_RGB_565 ) {\n            for( j = 0; j < ydiv2; j++ ) {\n                yw = (_100_0+pattRatio1) + pattRatio2 * (j+_0_5) / (ARdouble)ydiv2;\n                for( i = 0; i < xdiv2; i++ ) {\n                    xw = (_100_0+pattRatio1) + pattRatio2 * (i+_0_5) / (ARdouble)xdiv2;\n                    d = para[2][0]*xw + para[2][1]*yw + para[2][2];\n                    if( d == 0 ) goto bail;\n                    xc = (int)((para[0][0]*xw + para[0][1]*yw + para[0][2])/d);\n                    yc = (int)((para[1][0]*xw + para[1][1]*yw + para[1][2])/d);\n                    if( imageProcMode == AR_IMAGE_PROC_FIELD_IMAGE ) {\n                        xc = ((xc+1)/2)*2;\n                        yc = ((yc+1)/2)*2;\n                    }\n                    if( xc >= 0 && xc < xsize && yc >= 0 && yc < ysize ) {\n                        ext_patt2[(j/ydiv)*patt_size+(i/xdiv)]\n                        += (   ((image[(yc*xsize+xc)*2+0] & 0xf8) + 0x04)\n                            + (((image[(yc*xsize+xc)*2+0] & 0x07) << 5) + ((image[(yc*xsize+xc)*2+1] & 0xe0) >> 3) + 0x02)\n                            + (((image[(yc*xsize+xc)*2+1] & 0x1f) << 3) + 0x04) )/3;\n                    }\n                }\n            }\n        }\n        else if( pixelFormat == AR_PIXEL_FORMAT_RGBA_5551 ) {\n            for( j = 0; j < ydiv2; j++ ) {\n                yw = (_100_0+pattRatio1) + pattRatio2 * (j+_0_5) / (ARdouble)ydiv2;\n                for( i = 0; i < xdiv2; i++ ) {\n                    xw = (_100_0+pattRatio1) + pattRatio2 * (i+_0_5) / (ARdouble)xdiv2;\n                    d = para[2][0]*xw + para[2][1]*yw + para[2][2];\n                    if( d == 0 ) goto bail;\n                    xc = (int)((para[0][0]*xw + para[0][1]*yw + para[0][2])/d);\n                    yc = (int)((para[1][0]*xw + para[1][1]*yw + para[1][2])/d);\n                    if( imageProcMode == AR_IMAGE_PROC_FIELD_IMAGE ) {\n                        xc = ((xc+1)/2)*2;\n                        yc = ((yc+1)/2)*2;\n                    }\n                    if( xc >= 0 && xc < xsize && yc >= 0 && yc < ysize ) {\n                        ext_patt2[(j/ydiv)*patt_size+(i/xdiv)]\n                        += (    ((image[(yc*xsize+xc)*2+0] & 0xf8) + 0x04)\n                             + (((image[(yc*xsize+xc)*2+0] & 0x07) << 5) + ((image[(yc*xsize+xc)*2+1] & 0xc0) >> 3) + 0x04)\n                             + (((image[(yc*xsize+xc)*2+1] & 0x3e) << 2) + 0x04) )/3;\n                    }\n                }\n            }\n        }\n        else if( pixelFormat == AR_PIXEL_FORMAT_RGBA_4444 ) {\n            for( j = 0; j < ydiv2; j++ ) {\n                yw = (_100_0+pattRatio1) + pattRatio2 * (j+_0_5) / (ARdouble)ydiv2;\n                for( i = 0; i < xdiv2; i++ ) {\n                    xw = (_100_0+pattRatio1) + pattRatio2 * (i+_0_5) / (ARdouble)xdiv2;\n                    d = para[2][0]*xw + para[2][1]*yw + para[2][2];\n                    if( d == 0 ) goto bail;\n                    xc = (int)((para[0][0]*xw + para[0][1]*yw + para[0][2])/d);\n                    yc = (int)((para[1][0]*xw + para[1][1]*yw + para[1][2])/d);\n                    if( imageProcMode == AR_IMAGE_PROC_FIELD_IMAGE ) {\n                        xc = ((xc+1)/2)*2;\n                        yc = ((yc+1)/2)*2;\n                    }\n                    if( xc >= 0 && xc < xsize && yc >= 0 && yc < ysize ) {\n                        ext_patt2[(j/ydiv)*patt_size+(i/xdiv)]\n                        += (    ((image[(yc*xsize+xc)*2+0] & 0xf0) + 0x08)\n                             + (((image[(yc*xsize+xc)*2+0] & 0x0f) << 4) + 0x08)\n                             +  ((image[(yc*xsize+xc)*2+1] & 0xf0) + 0x08) )/3;\n                    }\n                }\n            }\n        }\n        else {\n            ARLOGe(\"Error: unsupported pixel format.\\n\");\n            goto bail;\n        }\n        \n        for( i = 0; i < patt_size*patt_size; i++ ) {\n            ext_patt[i] = ext_patt2[i] / (xdiv*ydiv);\n        }\n\n        free( ext_patt2 );\n    }\n\n    return 0;\n    \nbail:\n    free(ext_patt2);\n    return -1;\n}\n\n#endif // !AR_DISABLE_NON_CORE_FNS\n\nint arPattGetImage2( int imageProcMode, int pattDetectMode, int patt_size, int sample_size,\n                     ARUint8 *image, int xsize, int ysize, AR_PIXEL_FORMAT pixelFormat, ARParamLTf *paramLTf,\n                     ARdouble vertex[4][2], ARdouble pattRatio, ARUint8 *ext_patt)\n{\n    ARUint32 *ext_patt2;\n    ARdouble  world[4][2];\n    ARdouble  local[4][2];\n    ARdouble  para[3][3];\n    ARdouble  d, xw, yw;\n    float     xc2, yc2;\n    ARdouble  pattRatio1, pattRatio2;\n    int       xc, yc;\n    int       xdiv, ydiv;\n    int       xdiv2, ydiv2;\n    int       lx1, lx2, ly1, ly2, lxPatt, lyPatt;\n    int       i, j;\n\n    world[0][0] = _100_0;\n    world[0][1] = _100_0;\n    world[1][0] = _100_0 + _10_0;\n    world[1][1] = _100_0;\n    world[2][0] = _100_0 + _10_0;\n    world[2][1] = _100_0 + _10_0;\n    world[3][0] = _100_0;\n    world[3][1] = _100_0 + _10_0;\n    for( i = 0; i < 4; i++ ) {\n        local[i][0] = vertex[i][0];\n        local[i][1] = vertex[i][1];\n    }\n    get_cpara( world, local, para );\n\n\t// The square roots of lx1, lx2, ly1, and ly2 are the lengths of the sides of the polygon.\n    lx1 = (int)((local[0][0] - local[1][0])*(local[0][0] - local[1][0])\n              + (local[0][1] - local[1][1])*(local[0][1] - local[1][1]));\n    lx2 = (int)((local[2][0] - local[3][0])*(local[2][0] - local[3][0])\n              + (local[2][1] - local[3][1])*(local[2][1] - local[3][1]));\n    ly1 = (int)((local[1][0] - local[2][0])*(local[1][0] - local[2][0])\n              + (local[1][1] - local[2][1])*(local[1][1] - local[2][1]));\n    ly2 = (int)((local[3][0] - local[0][0])*(local[3][0] - local[0][0])\n              + (local[3][1] - local[0][1])*(local[3][1] - local[0][1]));\n    \n    // Take the longest two adjacent sides, and calculate the length of those sides which is pattern space (actually the square of the length).\n    if( lx2 > lx1 ) lx1 = lx2;\n    if( ly2 > ly1 ) ly1 = ly2;\n    lxPatt = (int)(lx1*pattRatio*pattRatio);\n    lyPatt = (int)(ly1*pattRatio*pattRatio);\n    \n    // Work out how many samples (\"divisions\") to take of the pattern space. Start with the pattern size itself,\n    // but scale up by factors of two, until the number of divisions exceeds the number of pixels in the pattern space\n    // on that side, or we reach the maximum sample size.\n    xdiv2 = patt_size;\n    ydiv2 = patt_size;\n    if( imageProcMode == AR_IMAGE_PROC_FRAME_IMAGE ) {\n        while( xdiv2*xdiv2 < lxPatt && xdiv2 < sample_size ) xdiv2*=2; // i.e. while (xdiv2 < ((sqrt(lx1) * pattRatio)) xdiv2*=2;\n        while( ydiv2*ydiv2 < lyPatt && ydiv2 < sample_size ) ydiv2*=2; // i.e. while (ydiv2 < ((sqrt(ly1) * pattRatio)) ydiv2*=2;\n    }\n    else {\n        while( xdiv2*xdiv2*4 < lxPatt && xdiv2 < sample_size ) xdiv2*=2;\n        while( ydiv2*ydiv2*4 < lyPatt && ydiv2 < sample_size ) ydiv2*=2;\n    }\n    if( xdiv2 > sample_size ) xdiv2 = sample_size;\n    if( ydiv2 > sample_size ) ydiv2 = sample_size;\n\n    xdiv = xdiv2/patt_size;\n    ydiv = ydiv2/patt_size;\n    pattRatio1 = (_1_0 - pattRatio)/_2_0 * _10_0; // borderSize * 10.0\n    pattRatio2 = pattRatio * _10_0;\n\n    if( pattDetectMode == AR_TEMPLATE_MATCHING_COLOR ) {\n        arMallocClear( ext_patt2, ARUint32, patt_size*patt_size*3 );\n\n        if( pixelFormat == AR_PIXEL_FORMAT_RGB ) {\n            for( j = 0; j < ydiv2; j++ ) {\n                yw = (_100_0+pattRatio1) + pattRatio2 * (j+_0_5) / (ARdouble)ydiv2;\n                for( i = 0; i < xdiv2; i++ ) {\n                    xw = (_100_0+pattRatio1) + pattRatio2 * (i+_0_5) / (ARdouble)xdiv2;\n                    d = para[2][0]*xw + para[2][1]*yw + para[2][2];\n                    if( d == 0 ) goto bail;\n                    xc2 = (float)((para[0][0]*xw + para[0][1]*yw + para[0][2])/d);\n                    yc2 = (float)((para[1][0]*xw + para[1][1]*yw + para[1][2])/d);\n                    arParamIdeal2ObservLTf( paramLTf, xc2, yc2, &xc2, &yc2 );\n                    //arParamIdeal2Observ( dist_factor, xc2, yc2, &xc2, &yc2, dist_function_version );\n                    if( imageProcMode == AR_IMAGE_PROC_FIELD_IMAGE ) {\n                        xc = ((int)(xc2+1.0f)/2)*2;\n                        yc = ((int)(yc2+1.0f)/2)*2;\n                    }\n                    else {\n                        xc = (int)(xc2+0.5f);\n                        yc = (int)(yc2+0.5f);\n                    }\n                    if( xc >= 0 && xc < xsize && yc >= 0 && yc < ysize ) {\n                        ext_patt2[((j/ydiv)*patt_size+(i/xdiv))*3+0] += image[(yc*xsize+xc)*3+2];\n                        ext_patt2[((j/ydiv)*patt_size+(i/xdiv))*3+1] += image[(yc*xsize+xc)*3+1];\n                        ext_patt2[((j/ydiv)*patt_size+(i/xdiv))*3+2] += image[(yc*xsize+xc)*3+0];\n                    }\n                }\n            }\n        }\n        else if( pixelFormat == AR_PIXEL_FORMAT_BGR ) {\n            for( j = 0; j < ydiv2; j++ ) {\n                yw = (_100_0+pattRatio1) + pattRatio2 * (j+_0_5) / (ARdouble)ydiv2;\n                for( i = 0; i < xdiv2; i++ ) {\n                    xw = (_100_0+pattRatio1) + pattRatio2 * (i+_0_5) / (ARdouble)xdiv2;\n                    d = para[2][0]*xw + para[2][1]*yw + para[2][2];\n                    if( d == 0 ) goto bail;\n                    xc2 = (float)((para[0][0]*xw + para[0][1]*yw + para[0][2])/d);\n                    yc2 = (float)((para[1][0]*xw + para[1][1]*yw + para[1][2])/d);\n                    arParamIdeal2ObservLTf( paramLTf, xc2, yc2, &xc2, &yc2 );\n                    //arParamIdeal2Observ( dist_factor, xc2, yc2, &xc2, &yc2, dist_function_version );\n                    if( imageProcMode == AR_IMAGE_PROC_FIELD_IMAGE ) {\n                        xc = ((int)(xc2+1.0f)/2)*2;\n                        yc = ((int)(yc2+1.0f)/2)*2;\n                    }\n                    else {\n                        xc = (int)(xc2+0.5f);\n                        yc = (int)(yc2+0.5f);\n                    }\n                    if( xc >= 0 && xc < xsize && yc >= 0 && yc < ysize ) {\n                        ext_patt2[((j/ydiv)*patt_size+(i/xdiv))*3+0] += image[(yc*xsize+xc)*3+0];\n                        ext_patt2[((j/ydiv)*patt_size+(i/xdiv))*3+1] += image[(yc*xsize+xc)*3+1];\n                        ext_patt2[((j/ydiv)*patt_size+(i/xdiv))*3+2] += image[(yc*xsize+xc)*3+2];\n                    }\n                }\n            }\n        }\n        else if( pixelFormat == AR_PIXEL_FORMAT_RGBA ) {\n            for( j = 0; j < ydiv2; j++ ) {\n                yw = (_100_0+pattRatio1) + pattRatio2 * (j+_0_5) / (ARdouble)ydiv2;\n                for( i = 0; i < xdiv2; i++ ) {\n                    xw = (_100_0+pattRatio1) + pattRatio2 * (i+_0_5) / (ARdouble)xdiv2;\n                    d = para[2][0]*xw + para[2][1]*yw + para[2][2];\n                    if( d == 0 ) goto bail;\n                    xc2 = (float)((para[0][0]*xw + para[0][1]*yw + para[0][2])/d);\n                    yc2 = (float)((para[1][0]*xw + para[1][1]*yw + para[1][2])/d);\n                    arParamIdeal2ObservLTf( paramLTf, xc2, yc2, &xc2, &yc2 );\n                    //arParamIdeal2Observ( dist_factor, xc2, yc2, &xc2, &yc2, dist_function_version );\n                    if( imageProcMode == AR_IMAGE_PROC_FIELD_IMAGE ) {\n                        xc = ((int)(xc2+1.0f)/2)*2;\n                        yc = ((int)(yc2+1.0f)/2)*2;\n                    }\n                    else {\n                        xc = (int)(xc2+0.5f);\n                        yc = (int)(yc2+0.5f);\n                    }\n                    if( xc >= 0 && xc < xsize && yc >= 0 && yc < ysize ) {\n                        ext_patt2[((j/ydiv)*patt_size+(i/xdiv))*3+0] += image[(yc*xsize+xc)*4+2];\n                        ext_patt2[((j/ydiv)*patt_size+(i/xdiv))*3+1] += image[(yc*xsize+xc)*4+1];\n                        ext_patt2[((j/ydiv)*patt_size+(i/xdiv))*3+2] += image[(yc*xsize+xc)*4+0];\n                    }\n                }\n            }\n        }\n        else if( pixelFormat == AR_PIXEL_FORMAT_BGRA ) {\n            for( j = 0; j < ydiv2; j++ ) {\n                yw = (_100_0+pattRatio1) + pattRatio2 * (j+_0_5) / (ARdouble)ydiv2;\n                for( i = 0; i < xdiv2; i++ ) {\n                    xw = (_100_0+pattRatio1) + pattRatio2 * (i+_0_5) / (ARdouble)xdiv2;\n                    d = para[2][0]*xw + para[2][1]*yw + para[2][2];\n                    if( d == 0 ) goto bail;\n                    xc2 = (float)((para[0][0]*xw + para[0][1]*yw + para[0][2])/d);\n                    yc2 = (float)((para[1][0]*xw + para[1][1]*yw + para[1][2])/d);\n                    arParamIdeal2ObservLTf( paramLTf, xc2, yc2, &xc2, &yc2 );\n                    //arParamIdeal2Observ( dist_factor, xc2, yc2, &xc2, &yc2, dist_function_version );\n                    if( imageProcMode == AR_IMAGE_PROC_FIELD_IMAGE ) {\n                        xc = ((int)(xc2+1.0f)/2)*2;\n                        yc = ((int)(yc2+1.0f)/2)*2;\n                    }\n                    else {\n                        xc = (int)(xc2+0.5f);\n                        yc = (int)(yc2+0.5f);\n                    }\n                    if( xc >= 0 && xc < xsize && yc >= 0 && yc < ysize ) {\n                        ext_patt2[((j/ydiv)*patt_size+(i/xdiv))*3+0] += image[(yc*xsize+xc)*4+0];\n                        ext_patt2[((j/ydiv)*patt_size+(i/xdiv))*3+1] += image[(yc*xsize+xc)*4+1];\n                        ext_patt2[((j/ydiv)*patt_size+(i/xdiv))*3+2] += image[(yc*xsize+xc)*4+2];\n                    }\n                }\n            }\n        }\n        else if( pixelFormat == AR_PIXEL_FORMAT_ABGR ) {\n            for( j = 0; j < ydiv2; j++ ) {\n                yw = (_100_0+pattRatio1) + pattRatio2 * (j+_0_5) / (ARdouble)ydiv2;\n                for( i = 0; i < xdiv2; i++ ) {\n                    xw = (_100_0+pattRatio1) + pattRatio2 * (i+_0_5) / (ARdouble)xdiv2;\n                    d = para[2][0]*xw + para[2][1]*yw + para[2][2];\n                    if( d == 0 ) goto bail;\n                    xc2 = (float)((para[0][0]*xw + para[0][1]*yw + para[0][2])/d);\n                    yc2 = (float)((para[1][0]*xw + para[1][1]*yw + para[1][2])/d);\n                    arParamIdeal2ObservLTf( paramLTf, xc2, yc2, &xc2, &yc2 );\n                    //arParamIdeal2Observ( dist_factor, xc2, yc2, &xc2, &yc2, dist_function_version );\n                    if( imageProcMode == AR_IMAGE_PROC_FIELD_IMAGE ) {\n                        xc = ((int)(xc2+1.0f)/2)*2;\n                        yc = ((int)(yc2+1.0f)/2)*2;\n                    }\n                    else {\n                        xc = (int)(xc2+0.5f);\n                        yc = (int)(yc2+0.5f);\n                    }\n                    if( xc >= 0 && xc < xsize && yc >= 0 && yc < ysize ) {\n                        ext_patt2[((j/ydiv)*patt_size+(i/xdiv))*3+0] += image[(yc*xsize+xc)*4+1];\n                        ext_patt2[((j/ydiv)*patt_size+(i/xdiv))*3+1] += image[(yc*xsize+xc)*4+2];\n                        ext_patt2[((j/ydiv)*patt_size+(i/xdiv))*3+2] += image[(yc*xsize+xc)*4+3];\n                    }\n                }\n            }\n        }\n        else if( pixelFormat == AR_PIXEL_FORMAT_MONO || pixelFormat == AR_PIXEL_FORMAT_420v || pixelFormat == AR_PIXEL_FORMAT_420f || pixelFormat == AR_PIXEL_FORMAT_NV21 ) {\n            // N.B.: caller asked for colour matching, but we can/will only supply mono.\n            for( j = 0; j < ydiv2; j++ ) {\n                yw = (_100_0+pattRatio1) + pattRatio2 * (j+_0_5) / (ARdouble)ydiv2;\n                for( i = 0; i < xdiv2; i++ ) {\n                    xw = (_100_0+pattRatio1) + pattRatio2 * (i+_0_5) / (ARdouble)xdiv2;\n                    d = para[2][0]*xw + para[2][1]*yw + para[2][2];\n                    if( d == 0 ) goto bail;\n                    xc2 = (float)((para[0][0]*xw + para[0][1]*yw + para[0][2])/d);\n                    yc2 = (float)((para[1][0]*xw + para[1][1]*yw + para[1][2])/d);\n                    arParamIdeal2ObservLTf( paramLTf, xc2, yc2, &xc2, &yc2 );\n                    //arParamIdeal2Observ( dist_factor, xc2, yc2, &xc2, &yc2, dist_function_version );\n                    if( imageProcMode == AR_IMAGE_PROC_FIELD_IMAGE ) {\n                        xc = ((int)(xc2+1.0f)/2)*2;\n                        yc = ((int)(yc2+1.0f)/2)*2;\n                    }\n                    else {\n                        xc = (int)(xc2+0.5f);\n                        yc = (int)(yc2+0.5f);\n                    }\n                    if( xc >= 0 && xc < xsize && yc >= 0 && yc < ysize ) {\n                        ext_patt2[((j/ydiv)*patt_size+(i/xdiv))*3+0] += image[yc*xsize+xc];\n                        ext_patt2[((j/ydiv)*patt_size+(i/xdiv))*3+1] += image[yc*xsize+xc];\n                        ext_patt2[((j/ydiv)*patt_size+(i/xdiv))*3+2] += image[yc*xsize+xc];\n                    }\n                }\n            }\n        }\n        else if( pixelFormat == AR_PIXEL_FORMAT_ARGB ) {\n            for( j = 0; j < ydiv2; j++ ) {\n                yw = (_100_0+pattRatio1) + pattRatio2 * (j+_0_5) / (ARdouble)ydiv2;\n                for( i = 0; i < xdiv2; i++ ) {\n                    xw = (_100_0+pattRatio1) + pattRatio2 * (i+_0_5) / (ARdouble)xdiv2;\n                    d = para[2][0]*xw + para[2][1]*yw + para[2][2];\n                    if( d == 0 ) goto bail;\n                    xc2 = (float)((para[0][0]*xw + para[0][1]*yw + para[0][2])/d);\n                    yc2 = (float)((para[1][0]*xw + para[1][1]*yw + para[1][2])/d);\n                    arParamIdeal2ObservLTf( paramLTf, xc2, yc2, &xc2, &yc2 );\n                    //arParamIdeal2Observ( dist_factor, xc2, yc2, &xc2, &yc2, dist_function_version );\n                    if( imageProcMode == AR_IMAGE_PROC_FIELD_IMAGE ) {\n                        xc = ((int)(xc2+1.0f)/2)*2;\n                        yc = ((int)(yc2+1.0f)/2)*2;\n                    }\n                    else {\n                        xc = (int)(xc2+0.5f);\n                        yc = (int)(yc2+0.5f);\n                    }\n                    if( xc >= 0 && xc < xsize && yc >= 0 && yc < ysize ) {\n                        ext_patt2[((j/ydiv)*patt_size+(i/xdiv))*3+0] += image[(yc*xsize+xc)*4+3];\n                        ext_patt2[((j/ydiv)*patt_size+(i/xdiv))*3+1] += image[(yc*xsize+xc)*4+2];\n                        ext_patt2[((j/ydiv)*patt_size+(i/xdiv))*3+2] += image[(yc*xsize+xc)*4+1];\n                    }\n                }\n            }\n        }\n        else if( pixelFormat == AR_PIXEL_FORMAT_2vuy ) {\n            for( j = 0; j < ydiv2; j++ ) {\n                yw = (_100_0+pattRatio1) + pattRatio2 * (j+_0_5) / (ARdouble)ydiv2;\n                for( i = 0; i < xdiv2; i++ ) {\n                    xw = (_100_0+pattRatio1) + pattRatio2 * (i+_0_5) / (ARdouble)xdiv2;\n                    d = para[2][0]*xw + para[2][1]*yw + para[2][2];\n                    if( d == 0 ) goto bail;\n                    xc2 = (float)((para[0][0]*xw + para[0][1]*yw + para[0][2])/d);\n                    yc2 = (float)((para[1][0]*xw + para[1][1]*yw + para[1][2])/d);\n                    arParamIdeal2ObservLTf( paramLTf, xc2, yc2, &xc2, &yc2 );\n                    //arParamIdeal2Observ( dist_factor, xc2, yc2, &xc2, &yc2, dist_function_version );\n                    if( imageProcMode == AR_IMAGE_PROC_FIELD_IMAGE ) {\n                        xc = ((int)(xc2+1.0f)/2)*2;\n                        yc = ((int)(yc2+1.0f)/2)*2;\n                    }\n                    else {\n                        xc = (int)(xc2+0.5f);\n                        yc = (int)(yc2+0.5f);\n                    }\n                    if( xc >= 0 && xc < xsize && yc >= 0 && yc < ysize ) {\n                        float Cb =     (float)(image[(yc*xsize + (xc & 0xFFFE))*2 + 0] - 128); // Byte 0 of each 4-byte block for both even- and odd-numbered columns.\n                        float Yprime = (float)(image[(yc*xsize +            xc)*2 + 1] - 16);  // Byte 1 of each 4-byte block for even-numbered columns, byte 3 for odd-numbered columns.\n                        float Cr =     (float)(image[(yc*xsize + (xc & 0xFFFE))*2 + 2] - 128); // Byte 2 of each 4-byte block for both even- and odd-numbered columns.\n\t\t\t\t\t\t// Conversion from Poynton's color FAQ http://www.poynton.com.\n                        int B0 = (int)(298.082f*Yprime + 516.411f*Cb              ) >> 8;\n                        int G0 = (int)(298.082f*Yprime - 100.291f*Cb - 208.120f*Cr) >> 8;\n                        int R0 = (int)(298.082f*Yprime               + 408.583f*Cr) >> 8;\n                        ext_patt2[((j/ydiv)*patt_size+(i/xdiv))*3+0] += CLAMP(B0, 0, 255);\n                        ext_patt2[((j/ydiv)*patt_size+(i/xdiv))*3+1] += CLAMP(G0, 0, 255);\n                        ext_patt2[((j/ydiv)*patt_size+(i/xdiv))*3+2] += CLAMP(R0, 0, 255);\n                    }\n                }\n            }\n        }\n        else if( pixelFormat == AR_PIXEL_FORMAT_yuvs ) {\n            for( j = 0; j < ydiv2; j++ ) {\n                yw = (_100_0+pattRatio1) + pattRatio2 * (j+_0_5) / (ARdouble)ydiv2;\n                for( i = 0; i < xdiv2; i++ ) {\n                    xw = (_100_0+pattRatio1) + pattRatio2 * (i+_0_5) / (ARdouble)xdiv2;\n                    d = para[2][0]*xw + para[2][1]*yw + para[2][2];\n                    if( d == 0 ) goto bail;\n                    xc2 = (float)((para[0][0]*xw + para[0][1]*yw + para[0][2])/d);\n                    yc2 = (float)((para[1][0]*xw + para[1][1]*yw + para[1][2])/d);\n                    arParamIdeal2ObservLTf( paramLTf, xc2, yc2, &xc2, &yc2 );\n                    //arParamIdeal2Observ( dist_factor, xc2, yc2, &xc2, &yc2, dist_function_version );\n                    if( imageProcMode == AR_IMAGE_PROC_FIELD_IMAGE ) {\n                        xc = ((int)(xc2+1.0f)/2)*2;\n                        yc = ((int)(yc2+1.0f)/2)*2;\n                    }\n                    else {\n                        xc = (int)(xc2+0.5f);\n                        yc = (int)(yc2+0.5f);\n                    }\n                    if( xc >= 0 && xc < xsize && yc >= 0 && yc < ysize ) {\n                        float Yprime = (float)(image[(yc*xsize +            xc)*2 + 0] - 16);  // Byte 0 of each 4-byte block for even-numbered columns, byte 2 for odd-numbered columns.\n                        float Cb =     (float)(image[(yc*xsize + (xc & 0xFFFE))*2 + 1] - 128); // Byte 1 of each 4-byte block for both even- and odd-numbered columns.\n                        float Cr =     (float)(image[(yc*xsize + (xc & 0xFFFE))*2 + 3] - 128); // Byte 3 of each 4-byte block for both even- and odd-numbered columns.\n\t\t\t\t\t\t// Conversion from Poynton's color FAQ http://www.poynton.com.\n                        int B0 = (int)(298.082f*Yprime + 516.411f*Cb              ) >> 8;\n                        int G0 = (int)(298.082f*Yprime - 100.291f*Cb - 208.120f*Cr) >> 8;\n                        int R0 = (int)(298.082f*Yprime               + 408.583f*Cr) >> 8;\n                        ext_patt2[((j/ydiv)*patt_size+(i/xdiv))*3+0] += CLAMP(B0, 0, 255);\n                        ext_patt2[((j/ydiv)*patt_size+(i/xdiv))*3+1] += CLAMP(G0, 0, 255);\n                        ext_patt2[((j/ydiv)*patt_size+(i/xdiv))*3+2] += CLAMP(R0, 0, 255);\n                    }\n                }\n            }\n        }\n        else if( pixelFormat == AR_PIXEL_FORMAT_RGB_565 ) {\n            for( j = 0; j < ydiv2; j++ ) {\n                yw = (_100_0+pattRatio1) + pattRatio2 * (j+_0_5) / (ARdouble)ydiv2;\n                for( i = 0; i < xdiv2; i++ ) {\n                    xw = (_100_0+pattRatio1) + pattRatio2 * (i+_0_5) / (ARdouble)xdiv2;\n                    d = para[2][0]*xw + para[2][1]*yw + para[2][2];\n                    if( d == 0 ) goto bail;\n                    xc2 = (float)((para[0][0]*xw + para[0][1]*yw + para[0][2])/d);\n                    yc2 = (float)((para[1][0]*xw + para[1][1]*yw + para[1][2])/d);\n                    arParamIdeal2ObservLTf( paramLTf, xc2, yc2, &xc2, &yc2 );\n                    //arParamIdeal2Observ( dist_factor, xc2, yc2, &xc2, &yc2, dist_function_version );\n                    if( imageProcMode == AR_IMAGE_PROC_FIELD_IMAGE ) {\n                        xc = ((int)(xc2+1.0f)/2)*2;\n                        yc = ((int)(yc2+1.0f)/2)*2;\n                    }\n                    else {\n                        xc = (int)(xc2+0.5f);\n                        yc = (int)(yc2+0.5f);\n                    }\n                    if( xc >= 0 && xc < xsize && yc >= 0 && yc < ysize ) {\n                        ext_patt2[((j/ydiv)*patt_size+(i/xdiv))*3+0] +=                                            (((image[(yc*xsize+xc)*2+1] & 0x1f) << 3) + 0x04);\n                        ext_patt2[((j/ydiv)*patt_size+(i/xdiv))*3+1] += (((image[(yc*xsize+xc)*2+0] & 0x07) << 5) + ((image[(yc*xsize+xc)*2+1] & 0xe0) >> 3) + 0x02);\n                        ext_patt2[((j/ydiv)*patt_size+(i/xdiv))*3+2] +=  ((image[(yc*xsize+xc)*2+0] & 0xf8) + 0x04);\n                    }\n                }\n            }\n        }\n        else if( pixelFormat == AR_PIXEL_FORMAT_RGBA_5551 ) {\n            for( j = 0; j < ydiv2; j++ ) {\n                yw = (_100_0+pattRatio1) + pattRatio2 * (j+_0_5) / (ARdouble)ydiv2;\n                for( i = 0; i < xdiv2; i++ ) {\n                    xw = (_100_0+pattRatio1) + pattRatio2 * (i+_0_5) / (ARdouble)xdiv2;\n                    d = para[2][0]*xw + para[2][1]*yw + para[2][2];\n                    if( d == 0 ) goto bail;\n                    xc2 = (float)((para[0][0]*xw + para[0][1]*yw + para[0][2])/d);\n                    yc2 = (float)((para[1][0]*xw + para[1][1]*yw + para[1][2])/d);\n                    arParamIdeal2ObservLTf( paramLTf, xc2, yc2, &xc2, &yc2 );\n                    //arParamIdeal2Observ( dist_factor, xc2, yc2, &xc2, &yc2, dist_function_version );\n                    if( imageProcMode == AR_IMAGE_PROC_FIELD_IMAGE ) {\n                        xc = ((int)(xc2+1.0f)/2)*2;\n                        yc = ((int)(yc2+1.0f)/2)*2;\n                    }\n                    else {\n                        xc = (int)(xc2+0.5f);\n                        yc = (int)(yc2+0.5f);\n                    }\n                    if( xc >= 0 && xc < xsize && yc >= 0 && yc < ysize ) {\n                        ext_patt2[((j/ydiv)*patt_size+(i/xdiv))*3+0] +=                                            (((image[(yc*xsize+xc)*2+1] & 0x3e) << 2) + 0x04);\n                        ext_patt2[((j/ydiv)*patt_size+(i/xdiv))*3+1] += (((image[(yc*xsize+xc)*2+0] & 0x07) << 5) + ((image[(yc*xsize+xc)*2+1] & 0xc0) >> 3) + 0x04);\n                        ext_patt2[((j/ydiv)*patt_size+(i/xdiv))*3+2] +=  ((image[(yc*xsize+xc)*2+0] & 0xf8) + 0x04);\n                    }\n                }\n            }\n        }\n        else if( pixelFormat == AR_PIXEL_FORMAT_RGBA_4444 ) {\n            for( j = 0; j < ydiv2; j++ ) {\n                yw = (_100_0+pattRatio1) + pattRatio2 * (j+_0_5) / (ARdouble)ydiv2;\n                for( i = 0; i < xdiv2; i++ ) {\n                    xw = (_100_0+pattRatio1) + pattRatio2 * (i+_0_5) / (ARdouble)xdiv2;\n                    d = para[2][0]*xw + para[2][1]*yw + para[2][2];\n                    if( d == 0 ) goto bail;\n                    xc2 = (float)((para[0][0]*xw + para[0][1]*yw + para[0][2])/d);\n                    yc2 = (float)((para[1][0]*xw + para[1][1]*yw + para[1][2])/d);\n                    arParamIdeal2ObservLTf( paramLTf, xc2, yc2, &xc2, &yc2 );\n                    //arParamIdeal2Observ( dist_factor, xc2, yc2, &xc2, &yc2, dist_function_version );\n                    if( imageProcMode == AR_IMAGE_PROC_FIELD_IMAGE ) {\n                        xc = ((int)(xc2+1.0f)/2)*2;\n                        yc = ((int)(yc2+1.0f)/2)*2;\n                    }\n                    else {\n                        xc = (int)(xc2+0.5f);\n                        yc = (int)(yc2+0.5f);\n                    }\n                    if( xc >= 0 && xc < xsize && yc >= 0 && yc < ysize ) {\n                        ext_patt2[((j/ydiv)*patt_size+(i/xdiv))*3+0] +=  ((image[(yc*xsize+xc)*2+1] & 0xf0) + 0x08);\n                        ext_patt2[((j/ydiv)*patt_size+(i/xdiv))*3+1] += (((image[(yc*xsize+xc)*2+0] & 0x0f) << 4) + 0x08);\n                        ext_patt2[((j/ydiv)*patt_size+(i/xdiv))*3+2] +=  ((image[(yc*xsize+xc)*2+0] & 0xf0) + 0x08);\n                    }\n                }\n            }\n        }\n        else {\n            ARLOGe(\"Error: unsupported pixel format.\\n\");\n            goto bail;\n        }\n\n        for( i = 0; i < patt_size*patt_size*3; i++ ) {\n            ext_patt[i] = ext_patt2[i] / (xdiv*ydiv);\n        }\n\n        free( ext_patt2 );\n    }\n    else { // !AR_TEMPLATE_MATCHING_COLOR\n        arMallocClear( ext_patt2, ARUint32, patt_size*patt_size );\n\n        if( pixelFormat == AR_PIXEL_FORMAT_RGB || pixelFormat == AR_PIXEL_FORMAT_BGR ) {\n            for( j = 0; j < ydiv2; j++ ) {\n                yw = (_100_0+pattRatio1) + pattRatio2 * (j+_0_5) / (ARdouble)ydiv2;\n                for( i = 0; i < xdiv2; i++ ) {\n                    xw = (_100_0+pattRatio1) + pattRatio2 * (i+_0_5) / (ARdouble)xdiv2;\n                    d = para[2][0]*xw + para[2][1]*yw + para[2][2];\n                    if( d == 0 ) goto bail;\n                    xc2 = (float)((para[0][0]*xw + para[0][1]*yw + para[0][2])/d);\n                    yc2 = (float)((para[1][0]*xw + para[1][1]*yw + para[1][2])/d);\n                    arParamIdeal2ObservLTf( paramLTf, xc2, yc2, &xc2, &yc2 );\n                    //arParamIdeal2Observ( dist_factor, xc2, yc2, &xc2, &yc2, dist_function_version );\n                    if( imageProcMode == AR_IMAGE_PROC_FIELD_IMAGE ) {\n                        xc = ((int)(xc2+1.0f)/2)*2;\n                        yc = ((int)(yc2+1.0f)/2)*2;\n                    }\n                    else {\n                        xc = (int)(xc2+0.5f);\n                        yc = (int)(yc2+0.5f);\n                    }\n                    if( xc >= 0 && xc < xsize && yc >= 0 && yc < ysize ) {\n                        ext_patt2[(j/ydiv)*patt_size+(i/xdiv)]\n                             += (   image[(yc*xsize+xc)*3+0]\n                                  + image[(yc*xsize+xc)*3+1]\n                                  + image[(yc*xsize+xc)*3+2] )/3;\n                    }\n                }\n            }\n        }\n        else if( pixelFormat == AR_PIXEL_FORMAT_RGBA || pixelFormat == AR_PIXEL_FORMAT_BGRA ) {\n            for( j = 0; j < ydiv2; j++ ) {\n                yw = (_100_0+pattRatio1) + pattRatio2 * (j+_0_5) / (ARdouble)ydiv2;\n                for( i = 0; i < xdiv2; i++ ) {\n                    xw = (_100_0+pattRatio1) + pattRatio2 * (i+_0_5) / (ARdouble)xdiv2;\n                    d = para[2][0]*xw + para[2][1]*yw + para[2][2];\n                    if( d == 0 ) goto bail;\n                    xc2 = (float)((para[0][0]*xw + para[0][1]*yw + para[0][2])/d);\n                    yc2 = (float)((para[1][0]*xw + para[1][1]*yw + para[1][2])/d);\n                    arParamIdeal2ObservLTf( paramLTf, xc2, yc2, &xc2, &yc2 );\n                    //arParamIdeal2Observ( dist_factor, xc2, yc2, &xc2, &yc2, dist_function_version );\n                    if( imageProcMode == AR_IMAGE_PROC_FIELD_IMAGE ) {\n                        xc = ((int)(xc2+1.0f)/2)*2;\n                        yc = ((int)(yc2+1.0f)/2)*2;\n                    }\n                    else {\n                        xc = (int)(xc2+0.5f);\n                        yc = (int)(yc2+0.5f);\n                    }\n                    if( xc >= 0 && xc < xsize && yc >= 0 && yc < ysize ) {\n                        ext_patt2[(j/ydiv)*patt_size+(i/xdiv)]\n                             += (   image[(yc*xsize+xc)*4+0]\n                                  + image[(yc*xsize+xc)*4+1]\n                                  + image[(yc*xsize+xc)*4+2] )/3;\n                    }\n                }\n            }\n        }\n        else if( pixelFormat == AR_PIXEL_FORMAT_ABGR || pixelFormat == AR_PIXEL_FORMAT_ARGB ) {\n            for( j = 0; j < ydiv2; j++ ) {\n                yw = (_100_0+pattRatio1) + pattRatio2 * (j+_0_5) / (ARdouble)ydiv2;\n                for( i = 0; i < xdiv2; i++ ) {\n                    xw = (_100_0+pattRatio1) + pattRatio2 * (i+_0_5) / (ARdouble)xdiv2;\n                    d = para[2][0]*xw + para[2][1]*yw + para[2][2];\n                    if( d == 0 ) goto bail;\n                    xc2 = (float)((para[0][0]*xw + para[0][1]*yw + para[0][2])/d);\n                    yc2 = (float)((para[1][0]*xw + para[1][1]*yw + para[1][2])/d);\n                    arParamIdeal2ObservLTf( paramLTf, xc2, yc2, &xc2, &yc2 );\n                    //arParamIdeal2Observ( dist_factor, xc2, yc2, &xc2, &yc2, dist_function_version );\n                    if( imageProcMode == AR_IMAGE_PROC_FIELD_IMAGE ) {\n                        xc = ((int)(xc2+1.0f)/2)*2;\n                        yc = ((int)(yc2+1.0f)/2)*2;\n                    }\n                    else {\n                        xc = (int)(xc2+0.5f);\n                        yc = (int)(yc2+0.5f);\n                    }\n                    if( xc >= 0 && xc < xsize && yc >= 0 && yc < ysize ) {\n                        ext_patt2[(j/ydiv)*patt_size+(i/xdiv)]\n                             += (   image[(yc*xsize+xc)*4+1]\n                                  + image[(yc*xsize+xc)*4+2]\n                                  + image[(yc*xsize+xc)*4+3] )/3;\n                    }\n                }\n            }\n        }\n        else if( pixelFormat == AR_PIXEL_FORMAT_MONO || pixelFormat == AR_PIXEL_FORMAT_420v || pixelFormat == AR_PIXEL_FORMAT_420f || pixelFormat == AR_PIXEL_FORMAT_NV21 ) {\n            for( j = 0; j < ydiv2; j++ ) {\n                yw = (_100_0+pattRatio1) + pattRatio2 * (j+_0_5) / (ARdouble)ydiv2;\n                for( i = 0; i < xdiv2; i++ ) {\n                    xw = (_100_0+pattRatio1) + pattRatio2 * (i+_0_5) / (ARdouble)xdiv2;\n                    d = para[2][0]*xw + para[2][1]*yw + para[2][2];\n                    if( d == 0 ) goto bail;\n                    xc2 = (float)((para[0][0]*xw + para[0][1]*yw + para[0][2])/d);\n                    yc2 = (float)((para[1][0]*xw + para[1][1]*yw + para[1][2])/d);\n                    arParamIdeal2ObservLTf( paramLTf, xc2, yc2, &xc2, &yc2 );\n                    //arParamIdeal2Observ( dist_factor, xc2, yc2, &xc2, &yc2, dist_function_version );\n                    if( imageProcMode == AR_IMAGE_PROC_FIELD_IMAGE ) {\n                        xc = ((int)(xc2+1.0f)/2)*2;\n                        yc = ((int)(yc2+1.0f)/2)*2;\n                    }\n                    else {\n                        xc = (int)(xc2+0.5f);\n                        yc = (int)(yc2+0.5f);\n                    }\n                    if( xc >= 0 && xc < xsize && yc >= 0 && yc < ysize ) {\n                        ext_patt2[(j/ydiv)*patt_size+(i/xdiv)] += image[yc*xsize+xc];\n                    }\n                }\n            }\n        }\n        else if( pixelFormat == AR_PIXEL_FORMAT_2vuy ) {\n            for( j = 0; j < ydiv2; j++ ) {\n                yw = (_100_0+pattRatio1) + pattRatio2 * (j+_0_5) / (ARdouble)ydiv2;\n                for( i = 0; i < xdiv2; i++ ) {\n                    xw = (_100_0+pattRatio1) + pattRatio2 * (i+_0_5) / (ARdouble)xdiv2;\n                    d = para[2][0]*xw + para[2][1]*yw + para[2][2];\n                    if( d == 0 ) goto bail;\n                    xc2 = (float)((para[0][0]*xw + para[0][1]*yw + para[0][2])/d);\n                    yc2 = (float)((para[1][0]*xw + para[1][1]*yw + para[1][2])/d);\n                    arParamIdeal2ObservLTf( paramLTf, xc2, yc2, &xc2, &yc2 );\n                    //arParamIdeal2Observ( dist_factor, xc2, yc2, &xc2, &yc2, dist_function_version );\n                    if( imageProcMode == AR_IMAGE_PROC_FIELD_IMAGE ) {\n                        xc = ((int)(xc2+1.0f)/2)*2;\n                        yc = ((int)(yc2+1.0f)/2)*2;\n                    }\n                    else {\n                        xc = (int)(xc2+0.5f);\n                        yc = (int)(yc2+0.5f);\n                    }\n                    if( xc >= 0 && xc < xsize && yc >= 0 && yc < ysize ) {\n                        ext_patt2[(j/ydiv)*patt_size+(i/xdiv)] += image[(yc*xsize+xc)*2+1];\n                    }\n                }\n            }\n        }\n        else if( pixelFormat == AR_PIXEL_FORMAT_yuvs ) {\n            for( j = 0; j < ydiv2; j++ ) {\n                yw = (_100_0+pattRatio1) + pattRatio2 * (j+_0_5) / (ARdouble)ydiv2;\n                for( i = 0; i < xdiv2; i++ ) {\n                    xw = (_100_0+pattRatio1) + pattRatio2 * (i+_0_5) / (ARdouble)xdiv2;\n                    d = para[2][0]*xw + para[2][1]*yw + para[2][2];\n                    if( d == 0 ) goto bail;\n                    xc2 = (float)((para[0][0]*xw + para[0][1]*yw + para[0][2])/d);\n                    yc2 = (float)((para[1][0]*xw + para[1][1]*yw + para[1][2])/d);\n                    arParamIdeal2ObservLTf( paramLTf, xc2, yc2, &xc2, &yc2 );\n                    //arParamIdeal2Observ( dist_factor, xc2, yc2, &xc2, &yc2, dist_function_version );\n                    if( imageProcMode == AR_IMAGE_PROC_FIELD_IMAGE ) {\n                        xc = ((int)(xc2+1.0f)/2)*2;\n                        yc = ((int)(yc2+1.0f)/2)*2;\n                    }\n                    else {\n                        xc = (int)(xc2+0.5f);\n                        yc = (int)(yc2+0.5f);\n                    }\n                    if( xc >= 0 && xc < xsize && yc >= 0 && yc < ysize ) {\n                        ext_patt2[(j/ydiv)*patt_size+(i/xdiv)] += image[(yc*xsize+xc)*2];\n                    }\n                }\n            }\n        }\n        else if( pixelFormat == AR_PIXEL_FORMAT_RGB_565 ) {\n            for( j = 0; j < ydiv2; j++ ) {\n                yw = (_100_0+pattRatio1) + pattRatio2 * (j+_0_5) / (ARdouble)ydiv2;\n                for( i = 0; i < xdiv2; i++ ) {\n                    xw = (_100_0+pattRatio1) + pattRatio2 * (i+_0_5) / (ARdouble)xdiv2;\n                    d = para[2][0]*xw + para[2][1]*yw + para[2][2];\n                    if( d == 0 ) goto bail;\n                    xc2 = (float)((para[0][0]*xw + para[0][1]*yw + para[0][2])/d);\n                    yc2 = (float)((para[1][0]*xw + para[1][1]*yw + para[1][2])/d);\n                    arParamIdeal2ObservLTf( paramLTf, xc2, yc2, &xc2, &yc2 );\n                    //arParamIdeal2Observ( dist_factor, xc2, yc2, &xc2, &yc2, dist_function_version );\n                    if( imageProcMode == AR_IMAGE_PROC_FIELD_IMAGE ) {\n                        xc = ((int)(xc2+1.0f)/2)*2;\n                        yc = ((int)(yc2+1.0f)/2)*2;\n                    }\n                    else {\n                        xc = (int)(xc2+0.5f);\n                        yc = (int)(yc2+0.5f);\n                    }\n                    if( xc >= 0 && xc < xsize && yc >= 0 && yc < ysize ) {\n                        ext_patt2[(j/ydiv)*patt_size+(i/xdiv)]\n                        += (   ((image[(yc*xsize+xc)*2+0] & 0xf8) + 0x04)\n                            + (((image[(yc*xsize+xc)*2+0] & 0x07) << 5) + ((image[(yc*xsize+xc)*2+1] & 0xe0) >> 3) + 0x02)\n                            + (((image[(yc*xsize+xc)*2+1] & 0x1f) << 3) + 0x04) )/3;\n                    }\n                }\n            }\n        }\n        else if( pixelFormat == AR_PIXEL_FORMAT_RGBA_5551 ) {\n            for( j = 0; j < ydiv2; j++ ) {\n                yw = (_100_0+pattRatio1) + pattRatio2 * (j+_0_5) / (ARdouble)ydiv2;\n                for( i = 0; i < xdiv2; i++ ) {\n                    xw = (_100_0+pattRatio1) + pattRatio2 * (i+_0_5) / (ARdouble)xdiv2;\n                    d = para[2][0]*xw + para[2][1]*yw + para[2][2];\n                    if( d == 0 ) goto bail;\n                    xc2 = (float)((para[0][0]*xw + para[0][1]*yw + para[0][2])/d);\n                    yc2 = (float)((para[1][0]*xw + para[1][1]*yw + para[1][2])/d);\n                    arParamIdeal2ObservLTf( paramLTf, xc2, yc2, &xc2, &yc2 );\n                    //arParamIdeal2Observ( dist_factor, xc2, yc2, &xc2, &yc2, dist_function_version );\n                    if( imageProcMode == AR_IMAGE_PROC_FIELD_IMAGE ) {\n                        xc = ((int)(xc2+1.0f)/2)*2;\n                        yc = ((int)(yc2+1.0f)/2)*2;\n                    }\n                    else {\n                        xc = (int)(xc2+0.5f);\n                        yc = (int)(yc2+0.5f);\n                    }\n                    if( xc >= 0 && xc < xsize && yc >= 0 && yc < ysize ) {\n                        ext_patt2[(j/ydiv)*patt_size+(i/xdiv)]\n                        += (    ((image[(yc*xsize+xc)*2+0] & 0xf8) + 0x04)\n                            + (((image[(yc*xsize+xc)*2+0] & 0x07) << 5) + ((image[(yc*xsize+xc)*2+1] & 0xc0) >> 3) + 0x04)\n                            + (((image[(yc*xsize+xc)*2+1] & 0x3e) << 2) + 0x04) )/3;\n                    }\n                }\n            }\n        }\n        else if( pixelFormat == AR_PIXEL_FORMAT_RGBA_4444 ) {\n            for( j = 0; j < ydiv2; j++ ) {\n                yw = (_100_0+pattRatio1) + pattRatio2 * (j+_0_5) / (ARdouble)ydiv2;\n                for( i = 0; i < xdiv2; i++ ) {\n                    xw = (_100_0+pattRatio1) + pattRatio2 * (i+_0_5) / (ARdouble)xdiv2;\n                    d = para[2][0]*xw + para[2][1]*yw + para[2][2];\n                    if( d == 0 ) goto bail;\n                    xc2 = (float)((para[0][0]*xw + para[0][1]*yw + para[0][2])/d);\n                    yc2 = (float)((para[1][0]*xw + para[1][1]*yw + para[1][2])/d);\n                    arParamIdeal2ObservLTf( paramLTf, xc2, yc2, &xc2, &yc2 );\n                    //arParamIdeal2Observ( dist_factor, xc2, yc2, &xc2, &yc2, dist_function_version );\n                    if( imageProcMode == AR_IMAGE_PROC_FIELD_IMAGE ) {\n                        xc = ((int)(xc2+1.0f)/2)*2;\n                        yc = ((int)(yc2+1.0f)/2)*2;\n                    }\n                    else {\n                        xc = (int)(xc2+0.5f);\n                        yc = (int)(yc2+0.5f);\n                    }\n                    if( xc >= 0 && xc < xsize && yc >= 0 && yc < ysize ) {\n                        ext_patt2[(j/ydiv)*patt_size+(i/xdiv)]\n                        += (    ((image[(yc*xsize+xc)*2+0] & 0xf0) + 0x08)\n                            + (((image[(yc*xsize+xc)*2+0] & 0x0f) << 4) + 0x08)\n                            +  ((image[(yc*xsize+xc)*2+1] & 0xf0) + 0x08) )/3;\n                    }\n                }\n            }\n        }\n        else {\n            ARLOGe(\"Error: unsupported pixel format.\\n\");\n            goto bail;\n        }\n\n        for( i = 0; i < patt_size*patt_size; i++ ) {\n            ext_patt[i] = ext_patt2[i] / (xdiv*ydiv);\n        }\n\n        free( ext_patt2 );\n    }\n\n    return 0;\n    \nbail:\n    free(ext_patt2);\n    return -1;\n}\n\nint arPattGetImage3( ARHandle *arHandle, int markerNo, ARUint8 *image, ARPattRectInfo *rect, int xsize, int ysize,\n                     int overSampleScale, ARUint8 *outImage )\n{\n    ARUint32 *tempImage;\n    ARdouble  world[4][2];\n    ARdouble  local[4][2];\n    ARdouble  para[3][3];\n    int       xdiv, ydiv;\n    int       xdiv2, ydiv2;\n    ARdouble  d, xw, yw;\n    float     xc2, yc2;\n    int       xc, yc;\n    int       xsize2, ysize2;\n    int       i, j;\n\n    xsize2 = arHandle->xsize;\n    ysize2 = arHandle->ysize;\n    world[0][0] = _100_0;\n    world[0][1] = _100_0;\n    world[1][0] = _100_0 + _10_0;\n    world[1][1] = _100_0;\n    world[2][0] = _100_0 + _10_0;\n    world[2][1] = _100_0 + _10_0;\n    world[3][0] = _100_0;\n    world[3][1] = _100_0 + _10_0;\n    for( i = 0; i < 4; i++ ) {\n        local[i][0] = arHandle->markerInfo[markerNo].vertex[i][0];\n        local[i][1] = arHandle->markerInfo[markerNo].vertex[i][1];\n    }\n    get_cpara( world, local, para );\n\n    xdiv = overSampleScale;\n    ydiv = overSampleScale;\n    xdiv2 = xsize*xdiv;\n    ydiv2 = ysize*xdiv;\n\n    if( arHandle->arPixelFormat == AR_PIXEL_FORMAT_RGB\n     || arHandle->arPixelFormat == AR_PIXEL_FORMAT_BGR ) {\n        arMallocClear(tempImage, ARUint32, xsize*ysize*3);\n        for( j = 0; j < ydiv2; j++ ) {\n            yw = _100_0 + _10_0 * (rect->topLeftY + (rect->bottomRightY - rect->topLeftY) * (j+_0_5) / (float)ydiv2);\n            for( i = 0; i < xdiv2; i++ ) {\n                xw = _100_0 + _10_0 * (rect->topLeftX + (rect->bottomRightX - rect->topLeftX) * (i+_0_5) / (float)xdiv2);\n                d = para[2][0]*xw + para[2][1]*yw + para[2][2];\n                if( d == 0 ) { free(tempImage); return -1; }\n                xc2 = (float)((para[0][0]*xw + para[0][1]*yw + para[0][2])/d);\n                yc2 = (float)((para[1][0]*xw + para[1][1]*yw + para[1][2])/d);\n                arParamIdeal2ObservLTf( &(arHandle->arParamLT->paramLTf), xc2, yc2, &xc2, &yc2 );\n                //arParamIdeal2Observ( arHandle->arParam.dist_factor, xc2, yc2, &xc2, &yc2, arHandle->arParam.dist_function_version );\n                xc = (int)(xc2+0.5f);\n                yc = (int)(yc2+0.5f);\n                if( xc < 0 || xc >= xsize2 || yc < 0 || yc >= ysize2 ) { free(tempImage); return -1; }\n                tempImage[((j/ydiv)*xsize+(i/xdiv))*3+0] += image[(yc*xsize2+xc)*3+0];\n                tempImage[((j/ydiv)*xsize+(i/xdiv))*3+1] += image[(yc*xsize2+xc)*3+1];\n                tempImage[((j/ydiv)*xsize+(i/xdiv))*3+2] += image[(yc*xsize2+xc)*3+2];\n            }\n        }\n        for( i = 0; i < xsize*ysize*3; i++ ) {\n            outImage[i] = tempImage[i] / (xdiv*ydiv);\n        }\n    }\n    else if( arHandle->arPixelFormat == AR_PIXEL_FORMAT_RGBA // Assume alpha is 255.\n          || arHandle->arPixelFormat == AR_PIXEL_FORMAT_BGRA\n          || arHandle->arPixelFormat == AR_PIXEL_FORMAT_ARGB\n          || arHandle->arPixelFormat == AR_PIXEL_FORMAT_ABGR ) {\n        arMallocClear(tempImage, ARUint32, xsize*ysize*4);\n        for( j = 0; j < ydiv2; j++ ) {\n            yw = _100_0 + _10_0 * (rect->topLeftY + (rect->bottomRightY - rect->topLeftY) * (j+_0_5) / (float)ydiv2);\n            for( i = 0; i < xdiv2; i++ ) {\n                xw = _100_0 + _10_0 * (rect->topLeftX + (rect->bottomRightX - rect->topLeftX) * (i+_0_5) / (float)xdiv2);\n                d = para[2][0]*xw + para[2][1]*yw + para[2][2];\n                if( d == 0 ) { free(tempImage); return -1; }\n                xc2 = (float)((para[0][0]*xw + para[0][1]*yw + para[0][2])/d);\n                yc2 = (float)((para[1][0]*xw + para[1][1]*yw + para[1][2])/d);\n                arParamIdeal2ObservLTf( &(arHandle->arParamLT->paramLTf), xc2, yc2, &xc2, &yc2 );\n                //arParamIdeal2Observ( arHandle->arParam.dist_factor, xc2, yc2, &xc2, &yc2, arHandle->arParam.dist_function_version );\n                xc = (int)(xc2+0.5f);\n                yc = (int)(yc2+0.5f);\n                if( xc < 0 || xc >= xsize2 || yc < 0 || yc >= ysize2 ) { free(tempImage); return -1; }\n                tempImage[((j/ydiv)*xsize+(i/xdiv))*4+0] += image[(yc*xsize2+xc)*4+0];\n                tempImage[((j/ydiv)*xsize+(i/xdiv))*4+1] += image[(yc*xsize2+xc)*4+1];\n                tempImage[((j/ydiv)*xsize+(i/xdiv))*4+2] += image[(yc*xsize2+xc)*4+2];\n                tempImage[((j/ydiv)*xsize+(i/xdiv))*4+3] += image[(yc*xsize2+xc)*4+3];\n            }\n        }\n        for( i = 0; i < xsize*ysize*4; i++ ) {\n            outImage[i] = tempImage[i] / (xdiv*ydiv);\n        }\n    }\n    else if( arHandle->arPixelFormat == AR_PIXEL_FORMAT_MONO\n          || arHandle->arPixelFormat == AR_PIXEL_FORMAT_420v\n          || arHandle->arPixelFormat == AR_PIXEL_FORMAT_420f\n          || arHandle->arPixelFormat == AR_PIXEL_FORMAT_NV21 ) {\n        arMallocClear(tempImage, ARUint32, xsize*ysize);\n        for( j = 0; j < ydiv2; j++ ) {\n            yw = _100_0 + _10_0 * (rect->topLeftY + (rect->bottomRightY - rect->topLeftY) * (j+_0_5) / (float)ydiv2);\n            for( i = 0; i < xdiv2; i++ ) {\n                xw = _100_0 + _10_0 * (rect->topLeftX + (rect->bottomRightX - rect->topLeftX) * (i+_0_5) / (float)xdiv2);\n                d = para[2][0]*xw + para[2][1]*yw + para[2][2];\n                if( d == 0 ) { free(tempImage); return -1; }\n                xc2 = (float)((para[0][0]*xw + para[0][1]*yw + para[0][2])/d);\n                yc2 = (float)((para[1][0]*xw + para[1][1]*yw + para[1][2])/d);\n                arParamIdeal2ObservLTf( &(arHandle->arParamLT->paramLTf), xc2, yc2, &xc2, &yc2 );\n                //arParamIdeal2Observ( arHandle->arParam.dist_factor, xc2, yc2, &xc2, &yc2, arHandle->arParam.dist_function_version );\n                xc = (int)(xc2+0.5f);\n                yc = (int)(yc2+0.5f);\n                if( xc < 0 || xc >= xsize2 || yc < 0 || yc >= ysize2 ) { free(tempImage); return -1; }\n                tempImage[(j/ydiv)*xsize+(i/xdiv)] += image[yc*xsize2+xc];\n            }\n        }\n        for( i = 0; i < xsize*ysize; i++ ) {\n            outImage[i] = tempImage[i] / (xdiv*ydiv);\n        }\n    }\n    else exit(0);\n\n    free( tempImage );\n\n    return 0;\n}\n\nstatic void get_cpara( ARdouble world[4][2], ARdouble vertex[4][2],\n                       ARdouble para[3][3] )\n{\n    ARMat   *a, *b, *c;\n    int     i;\n\n    a = arMatrixAlloc( 8, 8 );\n    b = arMatrixAlloc( 8, 1 );\n    c = arMatrixAlloc( 8, 1 );\n    for( i = 0; i < 4; i++ ) {\n        a->m[i*16+0]  = world[i][0];\n        a->m[i*16+1]  = world[i][1];\n        a->m[i*16+2]  = _1_0;\n        a->m[i*16+3]  = _0_0;\n        a->m[i*16+4]  = _0_0;\n        a->m[i*16+5]  = _0_0;\n        a->m[i*16+6]  = -world[i][0] * vertex[i][0];\n        a->m[i*16+7]  = -world[i][1] * vertex[i][0];\n        a->m[i*16+8]  = _0_0;\n        a->m[i*16+9]  = _0_0;\n        a->m[i*16+10] = _0_0;\n        a->m[i*16+11] = world[i][0];\n        a->m[i*16+12] = world[i][1];\n        a->m[i*16+13] = _1_0;\n        a->m[i*16+14] = -world[i][0] * vertex[i][1];\n        a->m[i*16+15] = -world[i][1] * vertex[i][1];\n        b->m[i*2+0] = vertex[i][0];\n        b->m[i*2+1] = vertex[i][1];\n    }\n    arMatrixSelfInv( a );\n    arMatrixMul( c, a, b );\n    for( i = 0; i < 2; i++ ) {\n        para[i][0] = c->m[i*3+0];\n        para[i][1] = c->m[i*3+1];\n        para[i][2] = c->m[i*3+2];\n    }\n    para[2][0] = c->m[2*3+0];\n    para[2][1] = c->m[2*3+1];\n    para[2][2] = _1_0;\n    arMatrixFree( a );\n    arMatrixFree( b );\n    arMatrixFree( c );\n}\n\nstatic int pattern_match( ARPattHandle *pattHandle, int mode, ARUint8 *data, int size, int *code, int *dir, ARdouble *cf )\n{\n    int   *input;\n    int    sum, ave;\n    int    res1, res2;\n    int    i, j, k, l;\n    ARdouble datapow;\n    ARdouble sum2, max;\n\n    if( pattHandle == NULL ) {\n        *code = 0;\n        *dir  = 0;\n        *cf   = -_1_0;\n        return -1;\n    }\n\n    if( mode == AR_TEMPLATE_MATCHING_COLOR ) {\n\n        arMalloc( input, int, size*size*3 );\n        sum = ave = 0;\n        for(i=0;i<size*size*3;i++) {\n            ave += (255-data[i]);\n        }\n        ave /= (size*size*3);\n\n        for(i=0;i<size*size*3;i++) {\n            input[i] = (255-data[i]) - ave;\n            sum += input[i]*input[i];\n        }\n\n        datapow = SQRT( (ARdouble)sum );\n        //if( datapow == 0.0 ) {\n        if( datapow/(size*SQRT_3_0) < AR_PATT_CONTRAST_THRESH1 ) {\n            *code = 0;\n            *dir  = 0;\n            *cf   = -_1_0;\n            free( input );\n            return -2; // Insufficient contrast.\n        }\n\n        res1 = res2 = -1;\n        k = -1; // Best match in search space.\n        max = _0_0;\n        for( l = 0; l < pattHandle->patt_num; l++ ) { // Consider the whole search space.\n            k++;\n            while( pattHandle->pattf[k] == 0 ) k++; // No pattern at this slot.\n            if( pattHandle->pattf[k] == 2 ) continue; // Pattern at this slot is deactivated.\n            for( j = 0; j < 4; j++ ) { // The 4 rotated variants of the pattern.\n                sum = 0;\n                for(i=0;i<size*size*3;i++) sum += input[i]*pattHandle->patt[k*4 + j][i]; // Correlation operation.\n                sum2 = sum / pattHandle->pattpow[k*4 + j] / datapow;\n                if( sum2 > max ) { max = sum2; res1 = j; res2 = k; }\n            }\n        }\n        *dir  = res1;\n        *code = res2;\n        *cf   = max;\n\n        free( input );\n        return 0;\n    }\n    else if( mode == AR_TEMPLATE_MATCHING_MONO ) {\n\n        arMalloc( input, int, size*size );\n        sum = ave = 0;\n        for(i=0;i<size*size;i++) {\n            ave += (255-data[i]);\n        }\n        ave /= (size*size);\n\n        for(i=0;i<size*size;i++) {\n            input[i] = (255-data[i]) - ave;\n            sum += input[i]*input[i];\n        }\n\n        datapow = SQRT( (ARdouble)sum );\n        //if( datapow == 0.0 ) {\n        if( datapow/size < AR_PATT_CONTRAST_THRESH1 ) {\n            *code = 0;\n            *dir  = 0;\n            *cf   = -_1_0;\n            free( input );\n            return -2; // Insufficient contrast.\n        }\n\n        res1 = res2 = -1;\n        k = -1;\n        max = _0_0;\n        for( l = 0; l < pattHandle->patt_num; l++ ) {\n            k++;\n            while( pattHandle->pattf[k] == 0 ) k++;\n            if( pattHandle->pattf[k] == 2 ) continue;\n            for( j = 0; j < 4; j++ ) {\n                sum = 0;\n                for(i=0;i<size*size;i++) sum += input[i]*pattHandle->pattBW[k*4 + j][i];\n                sum2 = sum / pattHandle->pattpowBW[k*4 + j] / datapow;\n                if( sum2 > max ) { max = sum2; res1 = j; res2 = k; }\n            }\n        }\n        *dir  = res1;\n        *code = res2;\n        *cf   = max;\n\n        free( input );\n        return 0;\n    }\n    else {\n        return -1;\n    }\n}\n\nstatic int decode_bch(const AR_MATRIX_CODE_TYPE matrixCodeType, const uint64_t in, uint8_t recd127[127], uint64_t *out_p)\n{\n    uint64_t in_bitwise;\n    uint8_t *recd;\n    uint64_t out_bit;\n    int t, n, length, k;\n    uint8_t recd15[15];\n    const int *alpha_to, *index_of;\n    const int bch_15_alpha_to[15] = {1, 2, 4, 8, 3, 6, 12, 11, 5, 10, 7, 14, 15, 13, 9};\n    const int bch_15_index_of[16] = {-1, 0, 1, 4, 2, 8, 5, 10, 3, 14, 9, 7, 6, 13, 11, 12};\n    const int bch_127_alpha_to[127] = {1, 2, 4, 8, 16, 32, 64, 3, 6, 12, 24, 48, 96, 67, 5, 10, 20, 40, 80, 35, 70, 15, 30, 60, 120, 115, 101, 73, 17, 34, 68, 11, 22, 44, 88, 51, 102, 79, 29, 58, 116, 107, 85, 41, 82, 39, 78, 31, 62, 124, 123, 117, 105, 81, 33, 66, 7, 14, 28, 56, 112, 99, 69, 9, 18, 36, 72, 19, 38, 76, 27, 54, 108, 91, 53, 106, 87, 45, 90, 55, 110, 95, 61, 122, 119, 109, 89, 49, 98, 71, 13, 26, 52, 104, 83, 37, 74, 23, 46, 92, 59, 118, 111, 93, 57, 114, 103, 77, 25, 50, 100, 75, 21, 42, 84, 43, 86, 47, 94, 63, 126, 127, 125, 121, 113, 97, 65};\n    const int bch_127_index_of[128] = {-1, 0, 1, 7, 2, 14, 8, 56, 3, 63, 15, 31, 9, 90, 57, 21, 4, 28, 64, 67, 16, 112, 32, 97, 10, 108, 91, 70, 58, 38, 22, 47, 5, 54, 29, 19, 65, 95, 68, 45, 17, 43, 113, 115, 33, 77, 98, 117, 11, 87, 109, 35, 92, 74, 71, 79, 59, 104, 39, 100, 23, 82, 48, 119, 6, 126, 55, 13, 30, 62, 20, 89, 66, 27, 96, 111, 69, 107, 46, 37, 18, 53, 44, 94, 114, 42, 116, 76, 34, 86, 78, 73, 99, 103, 118, 81, 12, 125, 88, 61, 110, 26, 36, 106, 93, 52, 75, 41, 72, 85, 80, 102, 60, 124, 105, 25, 40, 51, 101, 84, 24, 123, 83, 50, 49, 122, 120, 121};\n    int i, j, u, q, t2, count = 0, syn_error = 0;\n\tint elp[20][18], d[20], l[20], u_lu[20], s[19], loc[127], reg[10]; // int elp[t2 + 2, t2], d[t2 + 2], l[t2 + 2], u_lu[t2 + 2], s[t2 + 1], loc[n], reg[t + 1].\n    \n    if (matrixCodeType == AR_MATRIX_CODE_4x4_BCH_13_9_3 || matrixCodeType == AR_MATRIX_CODE_4x4_BCH_13_5_5) {\n        if (matrixCodeType == AR_MATRIX_CODE_4x4_BCH_13_9_3) {\n            t = 1; k = 9;\n        } else {\n            t = 2; k = 5;\n        }\n        n = 15;\n        length = 13;\n        alpha_to = bch_15_alpha_to;\n        index_of = bch_15_index_of;\n        // Unpack input into recd15[]. recd15[0] is least significant bit.\n        in_bitwise = in;\n        for (i = 0; i < length; i++) {\n            recd15[i] = (uint8_t)(in_bitwise & 1);\n            in_bitwise = in_bitwise >> 1;\n        }\n        recd = recd15;\n    } else if (matrixCodeType == AR_MATRIX_CODE_GLOBAL_ID) {\n        t = 9; k = 64;\n        n = 127;\n        length = 120;\n        alpha_to = bch_127_alpha_to;\n        index_of = bch_127_index_of;\n        recd = recd127;\n    } else {\n#ifdef DEBUG_BCH\n        ARLOGe(\"Error: unsupported BCH code.\\n\");\n#endif\n        return (-1); // Unsupported code.\n    }\n    \n    \n    /*\n     * Simon Rockliff's implementation of Berlekamp's algorithm.\n     * Copyright (c) 1994-7,  Robert Morelos-Zaragoza. All rights reserved.\n     *\n     * Assume we have received bits in recd[i], i=0..(n-1).\n     *\n     * Compute the 2*t syndromes by substituting alpha^i into rec(X) and\n     * evaluating, storing the syndromes in s[i], i=1..2t (leave s[0] zero) .\n     * Then we use the Berlekamp algorithm to find the error location polynomial\n     * elp[i].\n     *\n     * If the degree of the elp is >t, then we cannot correct all the errors, and\n     * we have detected an uncorrectable error pattern. We output the information\n     * bits uncorrected.\n     *\n     * If the degree of elp is <=t, we substitute alpha^i , i=1..n into the elp\n     * to get the roots, hence the inverse roots, the error location numbers.\n     * This step is usually called \"Chien's search\".\n     *\n     * If the number of errors located is not equal the degree of the elp, then\n     * the decoder assumes that there are more than t errors and cannot correct\n     * them, only detect them. We output the information bits uncorrected.\n     *\n     * t = error correcting capability (max. no. of errors the code corrects)\n     * length = length of the BCH code\n     * n = 2**m - 1 = size of the multiplicative group of GF(2**m)\n     * alpha_to [] = log table of GF(2**m) \n     * index_of[] = antilog table of GF(2**m)\n     * recd[] = coefficients of the received polynomial \n     */\n\tt2 = 2 * t;\n    \n\t/* first form the syndromes */\n\tfor (i = 1; i <= t2; i++) {\n\t\ts[i] = 0;\n\t\tfor (j = 0; j < length; j++) {\n\t\t\tif (recd[j] != 0) s[i] ^= alpha_to[(i * j) % n];\n        }\n\t\tif (s[i] != 0) syn_error = 1; /* set error flag if non-zero syndrome */\n\t\ts[i] = index_of[s[i]]; /* convert syndrome from polynomial form to index form  */\n\t}\n    \n\tif (syn_error) {\t/* if there are errors, try to correct them */\n\t\t/*\n\t\t * Compute the error location polynomial via the Berlekamp\n\t\t * iterative algorithm. Following the terminology of Lin and\n\t\t * Costello's book :   d[u] is the 'mu'th discrepancy, where\n\t\t * u='mu'+1 and 'mu' (the Greek letter!) is the step number\n\t\t * ranging from -1 to 2*t (see L&C),  l[u] is the degree of\n\t\t * the elp at that step, and u_l[u] is the difference between\n\t\t * the step number and the degree of the elp. \n\t\t */\n\t\t/* initialise table entries */\n\t\td[0] = 0;\t\t\t/* index form */\n\t\td[1] = s[1];\t\t/* index form */\n\t\telp[0][0] = 0;\t\t/* index form */\n\t\telp[1][0] = 1;\t\t/* polynomial form */\n\t\tfor (i = 1; i < t2; i++) {\n\t\t\telp[0][i] = -1;\t/* index form */\n\t\t\telp[1][i] = 0;\t/* polynomial form */\n\t\t}\n\t\tl[0] = 0;\n\t\tl[1] = 0;\n\t\tu_lu[0] = -1;\n\t\tu_lu[1] = 0;\n\t\tu = 0;\n        \n\t\tdo {\n\t\t\tu++;\n\t\t\tif (d[u] == -1) {\n\t\t\t\tl[u + 1] = l[u];\n\t\t\t\tfor (i = 0; i <= l[u]; i++) {\n\t\t\t\t\telp[u + 1][i] = elp[u][i];\n\t\t\t\t\telp[u][i] = index_of[elp[u][i]]; /* put elp into index form  */\n\t\t\t\t}\n\t\t\t} else {\n                /*\n                 * search for words with greatest u_lu[q] for\n                 * which d[q]!=0 \n                 */\n\t\t\t\tq = u - 1;\n\t\t\t\twhile ((d[q] == -1) && (q > 0)) q--;\n\t\t\t\t/* have found first non-zero d[q]  */\n\t\t\t\tif (q > 0) {\n                    j = q;\n                    do {\n                        j--;\n                        if ((d[j] != -1) && (u_lu[q] < u_lu[j]))\n                            q = j;\n                    } while (j > 0);\n\t\t\t\t}\n                \n\t\t\t\t/*\n\t\t\t\t * have now found q such that d[u]!=0 and\n\t\t\t\t * u_lu[q] is maximum \n\t\t\t\t */\n\t\t\t\t/* store degree of new elp polynomial */\n\t\t\t\tif (l[u] > l[q] + u - q) l[u + 1] = l[u];\n\t\t\t\telse l[u + 1] = l[q] + u - q;\n                \n\t\t\t\t/* form new elp(x) */\n\t\t\t\tfor (i = 0; i < t2; i++) elp[u + 1][i] = 0;\n\t\t\t\tfor (i = 0; i <= l[q]; i++) {\n\t\t\t\t\tif (elp[q][i] != -1) elp[u + 1][i + u - q] = alpha_to[(d[u] + n - d[q] + elp[q][i]) % n];\n                }\n\t\t\t\tfor (i = 0; i <= l[u]; i++) {\n\t\t\t\t\telp[u + 1][i] ^= elp[u][i];\n\t\t\t\t\telp[u][i] = index_of[elp[u][i]]; /* put elp into index form  */\n\t\t\t\t}\n\t\t\t}\n\t\t\tu_lu[u + 1] = u - l[u + 1];\n            \n\t\t\t/* form (u+1)th discrepancy */\n\t\t\tif (u < t2) {\t\n                /* no discrepancy computed on last iteration */\n                if (s[u + 1] != -1) d[u + 1] = alpha_to[s[u + 1]];\n                else d[u + 1] = 0;\n\t\t\t    for (i = 1; i <= l[u + 1]; i++) {\n                    if ((s[u + 1 - i] != -1) && (elp[u + 1][i] != 0)) d[u + 1] ^= alpha_to[(s[u + 1 - i] + index_of[elp[u + 1][i]]) % n];\n                }\n                d[u + 1] = index_of[d[u + 1]]; /* put d[u+1] into index form */\n\t\t\t}\n\t\t} while ((u < t2) && (l[u + 1] <= t));\n        \n\t\tu++;\n\t\tif (l[u] <= t) { /* Can correct errors */\n\t\t\tfor (i = 0; i <= l[u]; i++) elp[u][i] = index_of[elp[u][i]]; /* put elp into index form */\n            \n\t\t\t/* Chien search: find roots of the error location polynomial */\n\t\t\tfor (i = 1; i <= l[u]; i++) reg[i] = elp[u][i];\n\t\t\tcount = 0;\n\t\t\tfor (i = 1; i <= n; i++) {\n\t\t\t\tq = 1;\n\t\t\t\tfor (j = 1; j <= l[u]; j++) {\n \t\t\t\t\tif (reg[j] != -1) {\n\t\t\t\t\t\treg[j] = (reg[j] + j) % n;\n\t\t\t\t\t\tq ^= alpha_to[reg[j]];\n\t\t\t\t\t}\n                }\n\t\t\t\tif (!q) {\t/* store root and error\n                             * location number indices */\n\t\t\t\t\tloc[count] = n - i; /* root[count] = i; */\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (count == l[u]){\n                /* no. roots = degree of elp hence <= t errors */\n\t\t\t\tfor (i = 0; i < l[u]; i++) recd[loc[i]] ^= 1;\n            } else\t{\n                /* elp has degree >t hence cannot solve */\n#ifdef DEBUG_BCH\n                ARLOGe(\"count != l[u].\\n\");\n#endif\n                return (-1);\n            }\n\t\t} else {\n#ifdef DEBUG_BCH\n            ARLOGe(\"l[u] > t.\\n\");\n#endif\n            return (-1);\n        }\n\t} // End syn_error.\n    \n    // Pack the result into *out_p. Data bits begin with LSB at recd[length - k] through to MSB at recd[length - 1];\n    *out_p = 0LL;\n    out_bit = 1LL;\n    for (i = length - k; i < length; i++) {\n        *out_p += (uint64_t)recd[i] * out_bit;\n        out_bit <<= 1;\n    }\n    \n    if (syn_error) return (l[u]);\n    else return (0);\n}\n\n//const signed char hamming63EncoderTable[8] = {0, 7, 25, 30, 42, 45, 51, 52};\nconst signed char hamming63DecoderTable[64] = {\n    0, 0, 0, 1, 0, 1, 1, 1, 0, 2, 4, -1, -1, 5, 3, 1,\n    0, 2, -1, 6, 7, -1, 3, 1, 2, 2, 3, 2, 3, 2, 3, 3,\n    0, -1, 4, 6, 7, 5, -1, 1, 4, 5, 4, 4, 5, 5, 4, 5,\n    7, 6, 6, 6, 7, 7, 7, 6, -1, 2, 4, 6, 7, 5, 3, -1};\nconst bool hamming63DecoderTableErrorCorrected[64] = {\n    0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1,\n    1, 1, 0, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 0, 1,\n    1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 0, 1, 1,\n    1, 1, 1, 0, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0};\n//const signed char parity65EncoderTable[32] = {0, 33, 34, 3, 36, 5, 6, 39, 40, 9, 10, 43, 12, 45, 46, 15, 48, 17, 18, 51, 20, 53, 54, 23, 24, 57, 58, 27, 60, 29, 30, 63};\nconst signed char parity65DecoderTable[64] = {\n    0, -1, -1, 3, -1, 5, 6, -1, -1, 9, 10, -1, 12, -1, -1, 15,\n    -1, 17, 18, -1, 20, -1, -1, 23, 24, -1, -1, 27, -1, 29, 30, -1,\n    -1, 1, 2, -1, 4, -1, -1, 7, 8, -1, -1, 11, -1, 13, 14, -1,\n    16, -1, -1, 19, -1, 21, 22, -1, -1, 25, 26, -1, 28, -1, -1, 31};\n\n/*-------------------------\n   dir=0   1--\n           ---\n           1-0\n\n   dir=1   --0\n           ---\n           1-1\n\n   dir=2   0-1\n           ---\n           --1\n\n   dir=3   1-1\n           ---\n           0--\n---------------------------*/\nstatic int get_matrix_code( ARUint8 *data, int size, int *code_out_p, int *dir, ARdouble *cf, const AR_MATRIX_CODE_TYPE matrixCodeType, int *errorCorrected )\n{\n    ARUint8  max, min, thresh;\n    ARUint8  dirCode[4];\n    int      corner[4];\n    int      contrast, contrastMin;\n    int      i, j, ret;\n    uint64_t code, codeRaw;\n\n    if( size < 3 || size > 8 ) {\n        *code_out_p = -1;\n        *dir  = 0;\n        *cf   = -_1_0;\n        return -1;\n    }\n\n\t// Look at corners of unwarped marker pattern space to work out threshhold.\n    corner[0] = 0;\n    corner[1] = (size - 1)*size;\n    corner[2] = size*size - 1;\n    corner[3] = size - 1;\n    max = 0;\n    min = 255;\n    for( i = 0; i < 4; i++ ) {\n        if( data[corner[i]] > max ) max = data[corner[i]];\n        if( data[corner[i]] < min ) min = data[corner[i]];\n    }\n    if( max - min < AR_PATT_CONTRAST_THRESH2 ) {\n        *code_out_p = -1;\n        *dir  = 0;\n        *cf   = -_1_0;\n        return -2; // Insufficient contrast.\n    }\n    thresh = (max + min)/2;\n#if DEBUG_PATT_GETID\n    ARLOG(\"max=%d, min=%d, thresh=%d  \",max, min, thresh);\n#endif\n\n\t// Look at corners to work out which direction pattern is facing.\n\t// An unrotated pattern has 1 in top-left corner, 1 in bottom-left corner,\n\t// and 0 in bottom-right corner, where 1 is a pixel less than the threshhold\n\t// (i.e. black).\n    for( i = 0; i < 4; i++ ) dirCode[i] = (data[corner[i]] < thresh) ? 1 : 0;\n    for( i = 0; i < 4; i++ ) {\n        if( dirCode[i] == 1 && dirCode[(i+1)%4] == 1 && dirCode[(i+2)%4] == 0 ) {\n            *dir = i;\n            break;\n        }\n    }\n    if( i == 4 ) { // Barcode locator pattern not found.\n        *code_out_p = -1;\n        *dir  = 0;\n        *cf   = -_1_0;\n        return -3; // Bad barcode.\n    }\n\n\t// Binarize the unwarped marker pattern space.\n\t// Record the minimum observed contrast for use as a confidence measure.\n    contrastMin = 255;\n    for( i = 0; i < size*size; i++ ) {\n#if DEBUG_PATT_GETID\n    ARLOG(\"%3d \", data[i]);\n#endif\n        contrast = data[i] - thresh;\n        if( contrast < 0 ) contrast = -contrast;\n        if( contrast < contrastMin ) contrastMin = contrast;\n        data[i] = (data[i] < thresh)? 1: 0;\n    }\n#if DEBUG_PATT_GETID\n    ARLOG(\"\\n\");\n#endif\n\n\t// Calculate the matrix code.\n\t// The three pixels forming the corners (used to determine which direction\n    // the marker is facing) are ignored.\n    codeRaw = 0LL;\n    if( *dir == 0 ) {\n#if DEBUG_PATT_GETID\n        ARLOG(\"DIR:%d  \", *dir);\n#endif\n        for( j = 0; j < size; j++ ) {\n            for( i = 0; i < size; i++ ) {\n                if( i == 0      && j == 0      ) continue;\n                if( i == 0      && j == size-1 ) continue;\n                if( i == size-1 && j == size-1 ) continue;\n                codeRaw <<= 1;\n                if( data[j*size + i] ) codeRaw++;\n#if DEBUG_PATT_GETID\n                ARLOG(\"%2d \", data[j*size+i]);\n#endif\n            }\n        }\n#if DEBUG_PATT_GETID\n        ARLOG(\"\\n\");\n#endif\n    } else if( *dir == 1 ) {\n#if DEBUG_PATT_GETID\n        ARLOG(\"DIR:%d  \", *dir);\n#endif\n        for( i = 0; i < size; i++ ) {\n            for( j = size-1; j >= 0; j-- ) {\n                if( i == 0      && j == size-1 ) continue;\n                if( i == size-1 && j == size-1 ) continue;\n                if( i == size-1 && j == 0      ) continue;\n                codeRaw <<= 1;\n                if( data[j*size+i] ) codeRaw++;\n#if DEBUG_PATT_GETID\n                ARLOG(\"%2d \", data[j*size+i]);\n#endif\n            }\n        }\n#if DEBUG_PATT_GETID\n        ARLOG(\"\\n\");\n#endif\n    } else if( *dir == 2 ) {\n#if DEBUG_PATT_GETID\n        ARLOG(\"DIR:%d  \", *dir);\n#endif\n        for( j = size-1; j >= 0; j-- ) {\n            for( i = size-1; i >= 0; i-- ) {\n                if( i == size-1 && j == size-1 ) continue;\n                if( i == size-1 && j == 0      ) continue;\n                if( i == 0      && j == 0      ) continue;\n                codeRaw <<= 1;\n                if( data[j*size+i] ) codeRaw++;\n#if DEBUG_PATT_GETID\n                ARLOG(\"%2d \", data[j*size+i]);\n#endif\n            }\n        }\n#if DEBUG_PATT_GETID\n        ARLOG(\"\\n\");\n#endif\n    } else if( *dir == 3 ) {\n#if DEBUG_PATT_GETID\n        ARLOG(\"DIR:%d  \", *dir);\n#endif\n        for( i = size-1; i >= 0; i-- ) {\n            for( j = 0; j < size; j++ ) {\n                if( i == size-1 && j == 0      ) continue;\n                if( i == 0      && j == 0      ) continue;\n                if( i == 0      && j == size-1 ) continue;\n                codeRaw <<= 1;\n                if( data[j*size+i] ) codeRaw++;\n#if DEBUG_PATT_GETID\n                ARLOG(\"%2d \", data[j*size+i]);\n#endif\n            }\n        }\n#if DEBUG_PATT_GETID\n        ARLOG(\"\\n\");\n#endif\n    }\n    \n#if DEBUG_PATT_GETID\n    ARLOG(\"Contrast = %d\\n\", contrastMin);\n#endif\n    *cf = (contrastMin > 30)? _1_0: (ARdouble)contrastMin/_30_0;\n\n    if (matrixCodeType == AR_MATRIX_CODE_3x3_PARITY65) {\n        code = parity65DecoderTable[codeRaw];\n        if (parity65DecoderTable[codeRaw] < 0) {\n            *code_out_p = -1;\n            *cf = -_1_0;\n            return (-4); // EDC fail.\n        } \n    } else if (matrixCodeType == AR_MATRIX_CODE_3x3_HAMMING63) {\n        code = hamming63DecoderTable[codeRaw];\n        if (errorCorrected) *errorCorrected = hamming63DecoderTableErrorCorrected[codeRaw];\n        if (hamming63DecoderTable[codeRaw] < 0) {\n            *code_out_p = -1;\n            *cf = -_1_0;\n            return (-4); // EDC fail.\n        }\n    } else if (matrixCodeType == AR_MATRIX_CODE_4x4_BCH_13_9_3 || matrixCodeType == AR_MATRIX_CODE_4x4_BCH_13_5_5) {\n        ret = decode_bch(matrixCodeType, codeRaw, NULL, &code);\n        if (ret < 0) {\n            *code_out_p = -1;\n            *cf = -_1_0;\n            return (-4); // EDC fail.\n        } else if (ret > 0) {\n            if (errorCorrected) *errorCorrected = ret;\n        }\n    } else {\n        code = codeRaw;\n    }\n    \n    *code_out_p = (int)code;\n    return 0;\n}\n\nstatic int get_global_id_code( ARUint8 *data, uint64_t *code_out_p, int *dir_p, ARdouble *cf, int *errorCorrected )\n{\n    ARUint8  max, min, thresh;\n    ARUint8  dirCode[4];\n    int      dir;\n    int      corner[4];\n    int      contrast, contrastMin;\n    int      i, j, ret, bit;\n    uint64_t code;\n    uint8_t  recd127[127];\n    \n\t// Look at corners of unwarped marker pattern space to work out threshhold.\n    corner[0] = 0;\n    corner[1] = (AR_GLOBAL_ID_OUTER_SIZE - 1)*AR_GLOBAL_ID_OUTER_SIZE;\n    corner[2] = AR_GLOBAL_ID_OUTER_SIZE*AR_GLOBAL_ID_OUTER_SIZE - 1;\n    corner[3] = AR_GLOBAL_ID_OUTER_SIZE - 1;\n    max = 0;\n    min = 255;\n    for( i = 0; i < 4; i++ ) {\n        if( data[corner[i]] > max ) max = data[corner[i]];\n        if( data[corner[i]] < min ) min = data[corner[i]];\n    }\n    if( max - min < AR_PATT_CONTRAST_THRESH2 ) {\n        *dir_p  = 0;\n        *cf   = -_1_0;\n        return -2; // Insufficient contrast.\n    }\n    thresh = (max + min)/2;\n#if DEBUG_PATT_GETID\n    ARLOG(\"max=%d, min=%d, thresh=%d  \", max, min, thresh);\n#endif\n    \n\t// Look at corners to work out which direction pattern is facing.\n\t// An unrotated pattern has 1 in top-left corner, 1 in bottom-left corner,\n\t// and 0 in bottom-right corner, where 1 is a pixel less than the threshhold\n\t// (i.e. black).\n    for( i = 0; i < 4; i++ ) dirCode[i] = (data[corner[i]] < thresh) ? 1 : 0;\n    for( i = 0; i < 4; i++ ) {\n        if( dirCode[i] == 1 && dirCode[(i+1)%4] == 1 && dirCode[(i+2)%4] == 0 ) {\n            dir = i;\n            break;\n        }\n    }\n    if( i == 4 ) { // Barcode locator pattern not found.\n        *dir_p  = 0;\n        *cf   = -_1_0;\n        return -3; // Bad barcode.\n    }\n    \n\t// Calculate the matrix code.\n\t// The 12 pixels forming the corners (used to determine which direction\n    // the marker is facing) are ignored.\n\t// Binarize the unwarped marker pattern space.\n\t// Record the minimum observed contrast for use as a confidence measure.\n    contrastMin = 255;\n    bit = 119; // Bits are read MSB to LSB. In our case, bit 119 is MSB, bit 0 is LSB.\n    if( dir == 0 ) {\n        for( j = 0; j < AR_GLOBAL_ID_OUTER_SIZE; j++ ) {\n            for( i = 0; i < AR_GLOBAL_ID_OUTER_SIZE; i++ ) {\n                if (i > (AR_GLOBAL_ID_INNER_SIZE - 1) && i < (AR_GLOBAL_ID_OUTER_SIZE - AR_GLOBAL_ID_INNER_SIZE) && j > (AR_GLOBAL_ID_INNER_SIZE - 1) && j < (AR_GLOBAL_ID_OUTER_SIZE - AR_GLOBAL_ID_INNER_SIZE)) continue; // Skip interior.\n                if ((i&~1) == 0      && (j&~1) == 0     ) continue;\n                if ((i&~1) == 0      && (j&~1) == AR_GLOBAL_ID_OUTER_SIZE-2) continue;\n                if ((i&~1) == AR_GLOBAL_ID_OUTER_SIZE-2 && (j&~1) == AR_GLOBAL_ID_OUTER_SIZE-2) continue;\n                contrast = data[j*AR_GLOBAL_ID_OUTER_SIZE + i] - thresh;\n                recd127[bit--] = (contrast < 0 ? 1 : 0);\n                contrast = abs(contrast);\n                if (contrast < contrastMin) contrastMin = contrast;\n            }\n        }\n    } else if( dir == 1 ) {\n        for( i = 0; i < AR_GLOBAL_ID_OUTER_SIZE; i++ ) {\n            for( j = AR_GLOBAL_ID_OUTER_SIZE-1; j >= 0; j-- ) {\n                if (i > (AR_GLOBAL_ID_INNER_SIZE - 1) && i < (AR_GLOBAL_ID_OUTER_SIZE - AR_GLOBAL_ID_INNER_SIZE) && j > (AR_GLOBAL_ID_INNER_SIZE - 1) && j < (AR_GLOBAL_ID_OUTER_SIZE - AR_GLOBAL_ID_INNER_SIZE)) continue; // Skip interior.\n                if ((i&~1) == 0      && (j&~1) == AR_GLOBAL_ID_OUTER_SIZE-2) continue;\n                if ((i&~1) == AR_GLOBAL_ID_OUTER_SIZE-2 && (j&~1) == AR_GLOBAL_ID_OUTER_SIZE-2) continue;\n                if ((i&~1) == AR_GLOBAL_ID_OUTER_SIZE-2 && (j&~1) == 0     ) continue;\n                contrast = data[j*AR_GLOBAL_ID_OUTER_SIZE + i] - thresh;\n                recd127[bit--] = (contrast < 0 ? 1 : 0);\n                contrast = abs(contrast);\n                if (contrast < contrastMin) contrastMin = contrast;\n            }\n        }\n    } else if( dir == 2 ) {\n        for( j = AR_GLOBAL_ID_OUTER_SIZE-1; j >= 0; j-- ) {\n            for( i = AR_GLOBAL_ID_OUTER_SIZE-1; i >= 0; i-- ) {\n                if (i > (AR_GLOBAL_ID_INNER_SIZE - 1) && i < (AR_GLOBAL_ID_OUTER_SIZE - AR_GLOBAL_ID_INNER_SIZE) && j > (AR_GLOBAL_ID_INNER_SIZE - 1) && j < (AR_GLOBAL_ID_OUTER_SIZE - AR_GLOBAL_ID_INNER_SIZE)) continue; // Skip interior.\n                if ((i&~1) == AR_GLOBAL_ID_OUTER_SIZE-2 && (j&~1) == AR_GLOBAL_ID_OUTER_SIZE-2) continue;\n                if ((i&~1) == AR_GLOBAL_ID_OUTER_SIZE-2 && (j&~1) == 0     ) continue;\n                if ((i&~1) == 0      && (j&~1) == 0     ) continue;\n                contrast = data[j*AR_GLOBAL_ID_OUTER_SIZE + i] - thresh;\n                recd127[bit--] = (contrast < 0 ? 1 : 0);\n                contrast = abs(contrast);\n                if (contrast < contrastMin) contrastMin = contrast;\n            }\n        }\n    } else if( dir == 3 ) {\n        for( i = AR_GLOBAL_ID_OUTER_SIZE-1; i >= 0; i-- ) {\n            for( j = 0; j < AR_GLOBAL_ID_OUTER_SIZE; j++ ) {\n                if (i > (AR_GLOBAL_ID_INNER_SIZE - 1) && i < (AR_GLOBAL_ID_OUTER_SIZE - AR_GLOBAL_ID_INNER_SIZE) && j > (AR_GLOBAL_ID_INNER_SIZE - 1) && j < (AR_GLOBAL_ID_OUTER_SIZE - AR_GLOBAL_ID_INNER_SIZE)) continue; // Skip interior.\n                if ((i&~1) == AR_GLOBAL_ID_OUTER_SIZE-2 && (j&~1) == 0     ) continue;\n                if ((i&~1) == 0      && (j&~1) == 0     ) continue;\n                if ((i&~1) == 0      && (j&~1) == AR_GLOBAL_ID_OUTER_SIZE-2) continue;\n                contrast = data[j*AR_GLOBAL_ID_OUTER_SIZE + i] - thresh;\n                recd127[bit--] = (contrast < 0 ? 1 : 0);\n                contrast = abs(contrast);\n                if (contrast < contrastMin) contrastMin = contrast;\n            }\n        }\n    }\n    \n#if DEBUG_PATT_GETID\n    ARLOG(\"Contrast = %d\\n\", contrastMin);\n#endif\n    *dir_p = dir;\n    *cf = (contrastMin > 30)? _1_0: (ARdouble)contrastMin/_30_0;\n    ret = decode_bch(AR_MATRIX_CODE_GLOBAL_ID, 0, recd127, &code);\n    if (ret < 0) {\n        return (-4); // EDC fail.\n    }\n    if (errorCorrected) *errorCorrected = ret;\n    *code_out_p = code;\n    return 0;\n}\n\n","/*\n *  ar3DCreateHandle.c\n *  ARToolKit5\n *\n *  This file is part of ARToolKit.\n *\n *  ARToolKit is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation, either version 3 of the License, or\n *  (at your option) any later version.\n *\n *  ARToolKit is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public License\n *  along with ARToolKit.  If not, see <http://www.gnu.org/licenses/>.\n *\n *  As a special exception, the copyright holders of this library give you\n *  permission to link this library with independent modules to produce an\n *  executable, regardless of the license terms of these independent modules, and to\n *  copy and distribute the resulting executable under terms of your choice,\n *  provided that you also meet, for each linked independent module, the terms and\n *  conditions of the license of that module. An independent module is a module\n *  which is neither derived from nor based on this library. If you modify this\n *  library, you may extend this exception to your version of the library, but you\n *  are not obligated to do so. If you do not wish to do so, delete this exception\n *  statement from your version.\n *\n *  Copyright 2015 Daqri, LLC.\n *  Copyright 2003-2015 ARToolworks, Inc.\n *\n *  Author(s): Hirokazu Kato, Philip Lamb\n *\n */\n/*******************************************************\n *\n * Author: Hirokazu Kato\n *\n *         kato@sys.im.hiroshima-cu.ac.jp\n *\n * Revision: 1.1\n * Date: 03/08/14\n *\n *******************************************************/\n\n#include <AR/ar.h>\n#include <AR/icp.h>\n\nAR3DHandle *ar3DCreateHandle(ARParam *arParam)\n{\n    return ar3DCreateHandle2( arParam->mat );\n}\n\nAR3DHandle *ar3DCreateHandle2(ARdouble cpara[3][4])\n{\n    AR3DHandle   *handle;\n\n    arMalloc( handle, AR3DHandle, 1 );\n\n    handle->icpHandle = icpCreateHandle( cpara );\n    if( handle->icpHandle == NULL ) {\n        free( handle );\n        return NULL;\n    }\n\n    return handle;\n}\n\nint ar3DDeleteHandle( AR3DHandle **handle )\n{\n    if( *handle == NULL ) return -1;\n\n    icpDeleteHandle( &((*handle)->icpHandle) );\n    free( *handle );\n    *handle = NULL;\n\n    return 0;\n}\n\nint ar3DChangeCpara( AR3DHandle *handle, ARdouble cpara[3][4] )\n{\n    return icpSetMatXc2U( handle->icpHandle, cpara );\n}\n\n\nint ar3DChangeMaxLoopCount( AR3DHandle *handle, int maxLoopCount )\n{\n    return icpSetMaxLoop( handle->icpHandle, maxLoopCount );\n}\n\nint ar3DChangeLoopBreakThresh( AR3DHandle *handle, ARdouble loopBreakThresh )\n{\n    return icpSetBreakLoopErrorThresh( handle->icpHandle, loopBreakThresh );\n}\n\nint ar3DChangeLoopBreakThreshRatio( AR3DHandle *handle, ARdouble loopBreakThreshRatio )\n{\n    return icpSetBreakLoopErrorRatioThresh( handle->icpHandle, loopBreakThreshRatio );\n}\n\n\n\n\nAR3DStereoHandle *ar3DStereoCreateHandle(ARParam *arParamL, ARParam *arParamR,\n                                         ARdouble transL[3][4], ARdouble transR[3][4])\n{\n    return ar3DStereoCreateHandle2( arParamL->mat, arParamR->mat, transL, transR );\n}\n\nAR3DStereoHandle *ar3DStereoCreateHandle2(ARdouble cparaL[3][4], ARdouble cparaR[3][4],\n                                          ARdouble transL[3][4], ARdouble transR[3][4])\n{\n    AR3DStereoHandle   *handle;\n\n    arMalloc( handle, AR3DStereoHandle, 1 );\n\n    handle->icpStereoHandle = icpStereoCreateHandle(cparaL, cparaR, transL, transR);\n    if( handle->icpStereoHandle == NULL ) {\n        free( handle );\n        return NULL;\n    }\n\n    return handle;\n}\n\nint ar3DStereoDeleteHandle( AR3DStereoHandle **handle )\n{\n    if( *handle == NULL ) return -1;\n\n    icpStereoDeleteHandle( &((*handle)->icpStereoHandle) );\n    free( *handle );\n    *handle = NULL;\n\n    return 0;\n}\n\nint ar3DStereoChangeMaxLoopCount( AR3DStereoHandle *handle, int maxLoopCount )\n{\n    return icpStereoSetMaxLoop( handle->icpStereoHandle, maxLoopCount );\n}\n\nint ar3DStereoChangeLoopBreakThresh( AR3DStereoHandle *handle, ARdouble loopBreakThresh )\n{\n    return icpStereoSetBreakLoopErrorThresh( handle->icpStereoHandle, loopBreakThresh );\n}\n\nint ar3DStereoChangeLoopBreakThreshRatio( AR3DStereoHandle *handle, ARdouble loopBreakThreshRatio )\n{\n    return icpStereoSetBreakLoopErrorRatioThresh( handle->icpStereoHandle, loopBreakThreshRatio );\n}\n\nint ar3DStereoChangeCpara( AR3DStereoHandle *handle, ARdouble cparaL[3][4], ARdouble cparaR[3][4] )\n{\n    if( icpStereoSetMatXcl2Ul(handle->icpStereoHandle, cparaL) < 0 ) return -1;\n    if( icpStereoSetMatXcr2Ur(handle->icpStereoHandle, cparaR) < 0 ) return -1;\n    return 0;\n}\n\nint ar3DStereoChangeTransMat( AR3DStereoHandle *handle, ARdouble transL[3][4], ARdouble transR[3][4] )\n{\n    if( icpStereoSetMatC2L(handle->icpStereoHandle, transL) < 0 ) return -1;\n    if( icpStereoSetMatC2R(handle->icpStereoHandle, transR) < 0 ) return -1;\n    return 0;\n}\n","/*\n *  arCreateHandle.c\n *  ARToolKit5\n *\n *  This file is part of ARToolKit.\n *\n *  ARToolKit is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation, either version 3 of the License, or\n *  (at your option) any later version.\n *\n *  ARToolKit is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public License\n *  along with ARToolKit.  If not, see <http://www.gnu.org/licenses/>.\n *\n *  As a special exception, the copyright holders of this library give you\n *  permission to link this library with independent modules to produce an\n *  executable, regardless of the license terms of these independent modules, and to\n *  copy and distribute the resulting executable under terms of your choice,\n *  provided that you also meet, for each linked independent module, the terms and\n *  conditions of the license of that module. An independent module is a module\n *  which is neither derived from nor based on this library. If you modify this\n *  library, you may extend this exception to your version of the library, but you\n *  are not obligated to do so. If you do not wish to do so, delete this exception\n *  statement from your version.\n *\n *  Copyright 2015 Daqri, LLC.\n *  Copyright 2003-2015 ARToolworks, Inc.\n *\n *  Author(s): Hirokazu Kato, Philip Lamb\n *\n */\n/*******************************************************\n *\n * Author: Hirokazu Kato\n *\n *         kato@sys.im.hiroshima-cu.ac.jp\n *\n * Revision: 5.1\n * Date: 03/08/13\n *\n *******************************************************/\n\n#include <AR/ar.h>\n#include <stdio.h>\n#include <math.h>\n\nARHandle *arCreateHandle( ARParamLT *paramLT )\n{\n    ARHandle   *handle;\n\n    arMalloc( handle, ARHandle, 1 );\n\n    handle->arDebug                 = AR_DEBUG_DISABLE;\n#if !AR_DISABLE_LABELING_DEBUG_MODE\n    handle->labelInfo.bwImage       = NULL;\n#endif\n    handle->arImageProcInfo         = NULL;\n    handle->arPixelFormat           = AR_PIXEL_FORMAT_INVALID;\n    handle->arPixelSize             = 0;\n    handle->arLabelingMode          = AR_DEFAULT_LABELING_MODE;\n    handle->arLabelingThresh        = AR_DEFAULT_LABELING_THRESH;\n    handle->arImageProcMode         = AR_DEFAULT_IMAGE_PROC_MODE;\n    handle->arPatternDetectionMode  = AR_DEFAULT_PATTERN_DETECTION_MODE;\n    handle->arMarkerExtractionMode  = AR_DEFAULT_MARKER_EXTRACTION_MODE;\n    handle->pattRatio               = AR_PATT_RATIO;\n    handle->matrixCodeType          = AR_MATRIX_CODE_TYPE_DEFAULT;\n\n    handle->arParamLT           = paramLT;\n    handle->xsize               = paramLT->param.xsize;\n    handle->ysize               = paramLT->param.ysize;\n\n    handle->marker_num          = 0;\n    handle->marker2_num         = 0;\n    handle->labelInfo.label_num = 0;\n    handle->history_num         = 0;\n\n    arMalloc( handle->labelInfo.labelImage, AR_LABELING_LABEL_TYPE, handle->xsize*handle->ysize );\n    \n    handle->pattHandle = NULL;\n    \n    arSetPixelFormat(handle, AR_DEFAULT_PIXEL_FORMAT);\n\n    arSetDebugMode(handle, AR_DEFAULT_DEBUG_MODE);\n    \n    handle->arLabelingThreshMode = -1;\n    arSetLabelingThreshMode(handle, AR_LABELING_THRESH_MODE_DEFAULT);\n    arSetLabelingThreshModeAutoInterval(handle, AR_LABELING_THRESH_AUTO_INTERVAL_DEFAULT);\n    \n    return handle;\n}\n\nint arDeleteHandle( ARHandle *handle )\n{\n    if( handle == NULL ) return -1;\n\n    if (handle->arImageProcInfo) {\n        arImageProcFinal(handle->arImageProcInfo);\n        handle->arImageProcInfo = NULL;\n    }\n    \n    //if( handle->arParamLT != NULL ) arParamLTFree( &handle->arParamLT );\n    free( handle->labelInfo.labelImage );\n#if !AR_DISABLE_LABELING_DEBUG_MODE\n    if (handle->labelInfo.bwImage) free( handle->labelInfo.bwImage );\n#endif\n    free( handle );\n\n    return 0;\n}\n\nint arSetDebugMode( ARHandle *handle, int mode )\n{\n    if( handle == NULL ) return -1;\n\n    if (handle->arDebug != mode) {\n        handle->arDebug = mode;\n#if !AR_DISABLE_LABELING_DEBUG_MODE\n        if (mode == AR_DEBUG_DISABLE) {\n            free(handle->labelInfo.bwImage);\n            handle->labelInfo.bwImage = NULL;\n        } else {\n            arMalloc(handle->labelInfo.bwImage, ARUint8, handle->xsize * handle->ysize);\n        }\n#endif\n    }\n    return 0;\n}\n\nint arGetDebugMode( ARHandle *handle, int *mode )\n{\n    if (!handle || !mode) return -1;\n    *mode = handle->arDebug;\n\n    return 0;\n}\n\nint arSetLabelingMode( ARHandle *handle, int mode )\n{\n    if( handle == NULL ) return -1;\n\n    switch( mode ) {\n        case AR_LABELING_WHITE_REGION:\n        case AR_LABELING_BLACK_REGION:\n            break;\n        default:\n            return -1;\n    }\n\n    handle->arLabelingMode = mode;\n\n    return 0;\n}\n\nint arGetLabelingMode( ARHandle *handle, int *mode )\n{\n    if (!handle || !mode) return -1;\n    *mode = handle->arLabelingMode;\n\n    return 0;\n}\n\nint arSetLabelingThresh( ARHandle *handle, int thresh )\n{\n    if( handle == NULL ) return -1;\n\n    if( thresh < 0 || thresh > 255 ) return -1;\n\n    handle->arLabelingThresh = thresh;\n    \n    return 0;\n}\n\nint arGetLabelingThresh( ARHandle *handle, int *thresh )\n{\n    if (!handle || !thresh) return -1;\n    *thresh = handle->arLabelingThresh;\n\n    return 0;\n}\n\nint arSetLabelingThreshMode(ARHandle *handle, const AR_LABELING_THRESH_MODE mode)\n{\n    AR_LABELING_THRESH_MODE mode1;\n\n\tif (!handle) return (-1);\n    if (handle->arLabelingThreshMode != mode) {\n        if (handle->arImageProcInfo) {\n            arImageProcFinal(handle->arImageProcInfo);\n            handle->arImageProcInfo = NULL;\n        }\n\n        mode1 = mode;\n        switch (mode) {\n            case AR_LABELING_THRESH_MODE_AUTO_MEDIAN:\n            case AR_LABELING_THRESH_MODE_AUTO_OTSU:\n#if !AR_DISABLE_THRESH_MODE_AUTO_ADAPTIVE\n            case AR_LABELING_THRESH_MODE_AUTO_ADAPTIVE:\n#endif\n                handle->arImageProcInfo = arImageProcInit(handle->xsize, handle->ysize, handle->arPixelFormat, 0);\n                break;\n            case AR_LABELING_THRESH_MODE_AUTO_BRACKETING:\n                handle->arLabelingThreshAutoBracketOver = handle->arLabelingThreshAutoBracketUnder = 1;\n                break;\n            case AR_LABELING_THRESH_MODE_MANUAL:\n                break; // Do nothing.\n            default:\n                ARLOGe(\"Unknown or unsupported labeling threshold mode requested. Set to manual.\\n\");\n                mode1 = AR_LABELING_THRESH_MODE_MANUAL;\n        }\n        handle->arLabelingThreshMode = mode1;\n        if (handle->arDebug == AR_DEBUG_ENABLE) {\n            const char *modeDescs[] = {\n                \"MANUAL\",\n                \"AUTO_MEDIAN\",\n                \"AUTO_OTSU\",\n                \"AUTO_ADAPTIVE\"\n                \"AUTO_BRACKETING\"\n            };\n            ARLOGe(\"Labeling threshold mode set to %s.\\n\", modeDescs[mode1]);\n        }\n    }\n    return (0);\n}\n\nint arGetLabelingThreshMode(const ARHandle *handle, AR_LABELING_THRESH_MODE *mode_p)\n{\n    if (!handle || !mode_p) return (-1);\n    *mode_p = handle->arLabelingThreshMode;\n    return (0);\n}\n\nint arSetLabelingThreshModeAutoInterval(ARHandle *handle, const int interval)\n{\n    if (!handle) return (-1);\n    handle->arLabelingThreshAutoInterval = interval;\n    handle->arLabelingThreshAutoIntervalTTL = 0;\n    return (0);\n}\n\nint arGetLabelingThreshModeAutoInterval(const ARHandle *handle, int *interval_p)\n{\n    if (!handle || !interval_p) return (-1);\n    *interval_p = handle->arLabelingThreshAutoInterval;\n    return (0);\n}\n\nint arSetImageProcMode( ARHandle *handle, int mode )\n{\n    if( handle == NULL ) return -1;\n\n    switch( mode ) {\n        case AR_IMAGE_PROC_FRAME_IMAGE:\n        case AR_IMAGE_PROC_FIELD_IMAGE:\n            break;\n        default:\n            return -1;\n    }\n\n    handle->arImageProcMode = mode;\n\n    return 0;\n}\n\nint arGetImageProcMode( ARHandle *handle, int *mode )\n{\n    if( handle == NULL ) return -1;\n    *mode = handle->arImageProcMode;\n\n    return 0;\n}\n\nint arSetPatternDetectionMode( ARHandle *handle, int mode )\n{\n    if( handle == NULL ) return -1;\n\n    switch( mode ) {\n        case AR_TEMPLATE_MATCHING_COLOR:\n        case AR_TEMPLATE_MATCHING_MONO:\n        case AR_MATRIX_CODE_DETECTION:\n        case AR_TEMPLATE_MATCHING_COLOR_AND_MATRIX:\n        case AR_TEMPLATE_MATCHING_MONO_AND_MATRIX:\n            break;\n        default:\n            return -1;\n    }\n\n    handle->arPatternDetectionMode = mode;\n\n    return 0;\n}\n \nint  arSetMatrixCodeType(ARHandle *handle, const AR_MATRIX_CODE_TYPE type)\n{\n    if (!handle) return (-1);\n    handle->matrixCodeType = type;\n    return (0);\n}\n\nint  arGetMatrixCodeType(ARHandle *handle, AR_MATRIX_CODE_TYPE *type_p)\n{\n    if (!handle || !type_p) return (-1);\n    *type_p = handle->matrixCodeType;\n    return (0);\n}\n\nint arGetPatternDetectionMode( ARHandle *handle, int *mode )\n{\n    if( handle == NULL ) return -1;\n    *mode = handle->arPatternDetectionMode;\n\n    return 0;\n}\n\nint arSetMarkerExtractionMode( ARHandle *handle, int mode )\n{\n    if( handle == NULL ) return -1;\n\n    switch( mode ) {\n        case AR_USE_TRACKING_HISTORY:\n        case AR_NOUSE_TRACKING_HISTORY:\n        case AR_USE_TRACKING_HISTORY_V2:\n            break;\n        default:\n            return -1;\n    }\n\n    handle->arMarkerExtractionMode = mode;\n\n    return 0;\n}\n\nint arGetMarkerExtractionMode( ARHandle *handle, int *mode )\n{\n    if( handle == NULL ) return -1;\n    *mode = handle->arMarkerExtractionMode;\n\n    return 0;\n}\n\nint arSetBorderSize( ARHandle *handle, const ARdouble borderSize )\n{\n    if( handle == NULL ) return -1;\n    if (borderSize <= 0.0 || borderSize >= 0.5) return (-1);\n    \n    handle->pattRatio = 1.0 - 2.0*borderSize;\n    return 0;    \n}\n\nint arGetBorderSize( ARHandle *handle, ARdouble *borderSize )\n{\n    if( handle == NULL ) return -1;\n    *borderSize = (1.0 - handle->pattRatio)*0.5;\n    \n    return 0;\n}\n\nint arSetPattRatio( ARHandle *handle, const ARdouble pattRatio )\n{\n    if( handle == NULL ) return -1;\n    if (pattRatio <= 0.0 || pattRatio >= 1.0) return (-1);\n    \n    handle->pattRatio = pattRatio;\n    return 0;\n}\n\nint arGetPattRatio( ARHandle *handle, ARdouble *pattRatio )\n{\n    if( handle == NULL ) return -1;\n    *pattRatio = handle->pattRatio;\n    \n    return 0;\n}\n\nint arSetPixelFormat( ARHandle *handle, AR_PIXEL_FORMAT pixFormat )\n{\n    int monoFormat;\n    \n    if (handle == NULL) return (-1);\n    if (pixFormat == handle->arPixelFormat) return (0);\n\n    switch( pixFormat ) {\n        case AR_PIXEL_FORMAT_RGB:\n        case AR_PIXEL_FORMAT_BGR:\n        case AR_PIXEL_FORMAT_RGBA:\n        case AR_PIXEL_FORMAT_BGRA:\n        case AR_PIXEL_FORMAT_ABGR:\n        case AR_PIXEL_FORMAT_ARGB:\n        case AR_PIXEL_FORMAT_2vuy:\n        case AR_PIXEL_FORMAT_yuvs:\n        case AR_PIXEL_FORMAT_RGB_565:\n        case AR_PIXEL_FORMAT_RGBA_5551:\n        case AR_PIXEL_FORMAT_RGBA_4444:\n            monoFormat = FALSE;\n            break;\n        case AR_PIXEL_FORMAT_MONO:\n        case AR_PIXEL_FORMAT_420v:\n        case AR_PIXEL_FORMAT_420f:\n        case AR_PIXEL_FORMAT_NV21:\n            monoFormat = TRUE;\n            break;\n        default:\n            ARLOGe(\"Error: Unsupported pixel format (%d) requested.\\n\", pixFormat);\n            return -1;\n    }\n\n    handle->arPixelFormat = pixFormat;\n    handle->arPixelSize   = arUtilGetPixelSize(handle->arPixelFormat);\n    \n    // Update handle settings that depend on pixel format.\n    if (handle->arImageProcInfo) {\n        arImageProcFinal(handle->arImageProcInfo);\n        handle->arImageProcInfo = arImageProcInit(handle->xsize, handle->ysize, handle->arPixelFormat, 0);\n    }\n    \n    // If template matching, automatically switch to these most suitable colour template matching mode.\n    if (monoFormat) {\n        if (handle->arPatternDetectionMode == AR_TEMPLATE_MATCHING_COLOR) handle->arPatternDetectionMode = AR_TEMPLATE_MATCHING_MONO;\n        else if (handle->arPatternDetectionMode == AR_TEMPLATE_MATCHING_COLOR_AND_MATRIX) handle->arPatternDetectionMode = AR_TEMPLATE_MATCHING_MONO_AND_MATRIX;\n    } else {\n        if (handle->arPatternDetectionMode == AR_TEMPLATE_MATCHING_MONO) handle->arPatternDetectionMode = AR_TEMPLATE_MATCHING_MONO_AND_MATRIX;\n        else if (handle->arPatternDetectionMode == AR_TEMPLATE_MATCHING_MONO_AND_MATRIX) handle->arPatternDetectionMode = AR_TEMPLATE_MATCHING_COLOR_AND_MATRIX;\n    }\n    \n    return 0;\n}\n\nint arGetPixelFormat( ARHandle *handle, AR_PIXEL_FORMAT *pixFormat )\n{\n    if( handle == NULL ) return -1;\n    *pixFormat = handle->arPixelFormat;\n\n    return 0;\n}\n\n\nint arGetMarkerNum( ARHandle *handle )\n{\n    if( handle == NULL ) return -1;\n\n    return handle->marker_num;\n}\n\nARMarkerInfo *arGetMarker( ARHandle *handle )\n{\n    if( handle == NULL ) return NULL;\n\n    if( handle->marker_num <= 0 ) return NULL;\n\n    return &(handle->markerInfo[0]);\n}\n","/*\n *  arDetectMarker2.c\n *  ARToolKit5\n *\n *  This file is part of ARToolKit.\n *\n *  ARToolKit is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation, either version 3 of the License, or\n *  (at your option) any later version.\n *\n *  ARToolKit is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public License\n *  along with ARToolKit.  If not, see <http://www.gnu.org/licenses/>.\n *\n *  As a special exception, the copyright holders of this library give you\n *  permission to link this library with independent modules to produce an\n *  executable, regardless of the license terms of these independent modules, and to\n *  copy and distribute the resulting executable under terms of your choice,\n *  provided that you also meet, for each linked independent module, the terms and\n *  conditions of the license of that module. An independent module is a module\n *  which is neither derived from nor based on this library. If you modify this\n *  library, you may extend this exception to your version of the library, but you\n *  are not obligated to do so. If you do not wish to do so, delete this exception\n *  statement from your version.\n *\n *  Copyright 2015 Daqri, LLC.\n *  Copyright 2002-2015 ARToolworks, Inc.\n *\n *  Author(s): Hirokazu Kato, Philip Lamb\n *\n */\n/*******************************************************\n *\n * Author: Hirokazu Kato\n *\n *         kato@sys.im.hiroshima-cu.ac.jp\n *\n * Revision: 2.11\n * Date: 00/05/06\n *\n ******************************************************/\n\n#include <AR/ar.h>\n\nstatic int check_square( int area, ARMarkerInfo2 *marker_info2, ARdouble factor );\n\nstatic int get_vertex( int x_coord[], int y_coord[], int st, int ed,\n                       ARdouble thresh, int vertex[], int *vnum );\n\nint arDetectMarker2( int xsize, int ysize, ARLabelInfo *labelInfo, int imageProcMode,\n                     int areaMax, int areaMin, ARdouble squareFitThresh,\n                     ARMarkerInfo2 *markerInfo2, int *marker2_num )\n{\n    ARMarkerInfo2     *pm;\n    int               i, j, ret;\n    ARdouble            d;\n\n    if( imageProcMode == AR_IMAGE_PROC_FIELD_IMAGE ) {\n        areaMin /= 4;\n        areaMax /= 4;\n        xsize /=  2;\n        ysize /=  2;\n    }\n\n    *marker2_num = 0;\n    for( i = 0; i < labelInfo->label_num; i++ ) {\n        if( labelInfo->area[i] < areaMin || labelInfo->area[i] > areaMax ) continue;\n        if( labelInfo->clip[i][0] == 1 || labelInfo->clip[i][1] == xsize-2 ) continue;\n        if( labelInfo->clip[i][2] == 1 || labelInfo->clip[i][3] == ysize-2 ) continue;\n\n        ret = arGetContour( labelInfo->labelImage, xsize, ysize, labelInfo->work, i+1,\n                            labelInfo->clip[i], &(markerInfo2[*marker2_num]));\n        if( ret < 0 ) continue;\n\n        ret = check_square( labelInfo->area[i], &(markerInfo2[*marker2_num]), squareFitThresh );\n        if( ret < 0 ) continue;\n\n        markerInfo2[*marker2_num].area   = labelInfo->area[i];\n        markerInfo2[*marker2_num].pos[0] = labelInfo->pos[i][0];\n        markerInfo2[*marker2_num].pos[1] = labelInfo->pos[i][1];\n        (*marker2_num)++;\n        if( *marker2_num == AR_SQUARE_MAX ) break;\n    }\n\n    for( i = 0; i < *marker2_num; i++ ) {\n        for( j = i+1; j < *marker2_num; j++ ) {\n            d = (markerInfo2[i].pos[0] - markerInfo2[j].pos[0])\n              * (markerInfo2[i].pos[0] - markerInfo2[j].pos[0])\n              + (markerInfo2[i].pos[1] - markerInfo2[j].pos[1])\n              * (markerInfo2[i].pos[1] - markerInfo2[j].pos[1]);\n            if( markerInfo2[i].area > markerInfo2[j].area ) {\n                if( d < markerInfo2[i].area / 4 ) {\n                    markerInfo2[j].area = 0;\n                }\n            }\n            else {\n                if( d < markerInfo2[j].area / 4 ) {\n                    markerInfo2[i].area = 0;\n                }\n            }\n        }\n    }\n    for( i = 0; i < *marker2_num; i++ ) {\n        if( markerInfo2[i].area == 0.0 ) {\n            for( j=i+1; j < *marker2_num; j++ ) {\n                markerInfo2[j-1] = markerInfo2[j];\n            }\n            (*marker2_num)--;\n        }\n    }\n\n    if( imageProcMode == AR_IMAGE_PROC_FIELD_IMAGE ) {\n        pm = &(markerInfo2[0]);\n        for( i = 0; i < *marker2_num; i++ ) {\n            pm->area *= 4;\n            pm->pos[0] *= 2.0;\n            pm->pos[1] *= 2.0;\n            for( j = 0; j< pm->coord_num; j++ ) {\n                pm->x_coord[j] *= 2;\n                pm->y_coord[j] *= 2;\n            }\n            pm++;\n        }\n    }\n\n    return 0;\n}\n\nint arGetContour( AR_LABELING_LABEL_TYPE *limage, int xsize, int ysize, int *label_ref, int label,\n                  int clip[4], ARMarkerInfo2 *marker_info2)\n{\n    int        xdir[8] = { 0, 1, 1, 1, 0,-1,-1,-1};\n    int        ydir[8] = {-1,-1, 0, 1, 1, 1, 0,-1};\n    int        wx[AR_CHAIN_MAX];\n    int        wy[AR_CHAIN_MAX];\n    AR_LABELING_LABEL_TYPE   *p1;\n    int        sx, sy, dir;\n    int        dmax, d, v1 = 0 /*COVHI10455*/;\n    int        i, j;\n\n    j = clip[2];\n    p1 = &(limage[j*xsize + clip[0]]);\n    for( i = clip[0]; i <= clip[1]; i++, p1++ ) {\n        if( *p1 > 0 && label_ref[(*p1)-1] == label ) {\n            sx = i; sy = j; break;\n        }\n    }\n    if( i > clip[1] ) {\n        ARLOGe(\"??? 1\\n\"); return -1;\n    }\n\n    marker_info2->coord_num = 1;\n    marker_info2->x_coord[0] = sx;\n    marker_info2->y_coord[0] = sy;\n    dir = 5;\n    for(;;) {\n        p1 = &(limage[marker_info2->y_coord[marker_info2->coord_num-1] * xsize\n                    + marker_info2->x_coord[marker_info2->coord_num-1]]);\n        dir = (dir+5)%8;\n        for(i=0;i<8;i++) {\n            if( p1[ydir[dir]*xsize+xdir[dir]] > 0 ) break;\n            dir = (dir+1)%8;\n        }\n        if( i == 8 ) {\n            ARLOGe(\"??? 2\\n\"); return -1;\n        }\n        marker_info2->x_coord[marker_info2->coord_num]\n            = marker_info2->x_coord[marker_info2->coord_num-1] + xdir[dir];\n        marker_info2->y_coord[marker_info2->coord_num]\n            = marker_info2->y_coord[marker_info2->coord_num-1] + ydir[dir];\n        if( marker_info2->x_coord[marker_info2->coord_num] == sx\n         && marker_info2->y_coord[marker_info2->coord_num] == sy ) break;\n        marker_info2->coord_num++;\n        if( marker_info2->coord_num == AR_CHAIN_MAX-1 ) {\n            ARLOGe(\"??? 3\\n\"); return -1;\n        }\n    }\n\n    dmax = 0;\n    for(i=1;i<marker_info2->coord_num;i++) {\n        d = (marker_info2->x_coord[i]-sx)*(marker_info2->x_coord[i]-sx)\n          + (marker_info2->y_coord[i]-sy)*(marker_info2->y_coord[i]-sy);\n        if( d > dmax ) {\n            dmax = d;\n            v1 = i;\n        }\n    }\n\n    for(i=0;i<v1;i++) {\n        wx[i] = marker_info2->x_coord[i];\n        wy[i] = marker_info2->y_coord[i];\n    }\n    for(i=v1;i<marker_info2->coord_num;i++) {\n        marker_info2->x_coord[i-v1] = marker_info2->x_coord[i];\n        marker_info2->y_coord[i-v1] = marker_info2->y_coord[i];\n    }\n    for(i=0;i<v1;i++) {\n        marker_info2->x_coord[i-v1+marker_info2->coord_num] = wx[i];\n        marker_info2->y_coord[i-v1+marker_info2->coord_num] = wy[i];\n    }\n    marker_info2->x_coord[marker_info2->coord_num] = marker_info2->x_coord[0];\n    marker_info2->y_coord[marker_info2->coord_num] = marker_info2->y_coord[0];\n    marker_info2->coord_num++;\n\n    return 0;\n}\n\nstatic int check_square( int area, ARMarkerInfo2 *marker_info2, ARdouble factor )\n{\n    int             sx, sy;\n    int             dmax, d, v1;\n    int             vertex[10], vnum;\n    int             wv1[10], wvnum1, wv2[10], wvnum2, v2;\n    ARdouble          thresh;\n    int             i;\n\n    dmax = 0;\n    v1 = 0;\n    sx = marker_info2->x_coord[0];\n    sy = marker_info2->y_coord[0];\n    for(i=1;i<marker_info2->coord_num-1;i++) {\n        d = (marker_info2->x_coord[i]-sx)*(marker_info2->x_coord[i]-sx)\n          + (marker_info2->y_coord[i]-sy)*(marker_info2->y_coord[i]-sy);\n        if( d > dmax ) {\n            dmax = d;\n            v1 = i;\n        }\n    }\n\n    thresh = (area/0.75) * 0.01 * factor;\n    vnum = 1;\n    vertex[0] = 0;\n    wvnum1 = 0;\n    wvnum2 = 0;\n    if( get_vertex(marker_info2->x_coord, marker_info2->y_coord, 0,  v1,\n                   thresh, wv1, &wvnum1) < 0 ) {\n        return -1;\n    }\n    if( get_vertex(marker_info2->x_coord, marker_info2->y_coord,\n                   v1,  marker_info2->coord_num-1, thresh, wv2, &wvnum2) < 0 ) {\n        return -1;\n    }\n\n    if( wvnum1 == 1 && wvnum2 == 1 ) {\n        vertex[1] = wv1[0];\n        vertex[2] = v1;\n        vertex[3] = wv2[0];\n    }\n    else if( wvnum1 > 1 && wvnum2 == 0 ) {\n        v2 = v1 / 2;\n        wvnum1 = wvnum2 = 0;\n        if( get_vertex(marker_info2->x_coord, marker_info2->y_coord,\n                       0,  v2, thresh, wv1, &wvnum1) < 0 ) {\n            return -1;\n        }\n        if( get_vertex(marker_info2->x_coord, marker_info2->y_coord,\n                       v2,  v1, thresh, wv2, &wvnum2) < 0 ) {\n            return -1;\n        }\n        if( wvnum1 == 1 && wvnum2 == 1 ) {\n            vertex[1] = wv1[0];\n            vertex[2] = wv2[0];\n            vertex[3] = v1;\n        }\n        else {\n            return -1;\n        }\n    }\n    else if( wvnum1 == 0 && wvnum2 > 1 ) {\n        v2 = (v1 + marker_info2->coord_num-1) / 2;\n        wvnum1 = wvnum2 = 0;\n        if( get_vertex(marker_info2->x_coord, marker_info2->y_coord,\n                   v1, v2, thresh, wv1, &wvnum1) < 0 ) {\n            return -1;\n        }\n        if( get_vertex(marker_info2->x_coord, marker_info2->y_coord,\n                   v2, marker_info2->coord_num-1, thresh, wv2, &wvnum2) < 0 ) {\n            return -1;\n        }\n        if( wvnum1 == 1 && wvnum2 == 1 ) {\n            vertex[1] = v1;\n            vertex[2] = wv1[0];\n            vertex[3] = wv2[0];\n        }\n        else {\n            return -1;\n        }\n    }\n    else {\n        return -1;\n    }\n\n    marker_info2->vertex[0] = vertex[0];\n    marker_info2->vertex[1] = vertex[1];\n    marker_info2->vertex[2] = vertex[2];\n    marker_info2->vertex[3] = vertex[3];\n    marker_info2->vertex[4] = marker_info2->coord_num-1;\n\n    return 0;\n}\n\nstatic int get_vertex( int x_coord[], int y_coord[], int st,  int ed,\n                       ARdouble thresh, int vertex[], int *vnum)\n{\n    ARdouble d, dmax;\n    ARdouble a, b, c;\n    int      i, v1;\n\n    a = y_coord[ed] - y_coord[st];\n    b = x_coord[st] - x_coord[ed];\n    c = x_coord[ed] * y_coord[st] - y_coord[ed] * x_coord[st];\n    dmax = 0;\n    for (i = v1 = (st + 1) /*COVHI10453*/; i < ed; i++) {\n        d = a*x_coord[i] + b*y_coord[i] + c;\n        if( d*d > dmax ) {\n            dmax = d*d;\n            v1 = i;\n        }\n    }\n    if( dmax/(a*a+b*b) > thresh ) {\n        if( get_vertex(x_coord, y_coord, st,  v1, thresh, vertex, vnum) < 0 )\n            return -1;\n\n        if( (*vnum) > 5 ) return(-1);\n        vertex[(*vnum)] = v1;\n        (*vnum)++;\n\n        if( get_vertex(x_coord, y_coord, v1,  ed, thresh, vertex, vnum) < 0 )\n            return -1;\n    }\n\n    return 0;\n}\n","/*\n *  arGetLine.c\n *  ARToolKit5\n *\n *  This file is part of ARToolKit.\n *\n *  ARToolKit is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation, either version 3 of the License, or\n *  (at your option) any later version.\n *\n *  ARToolKit is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public License\n *  along with ARToolKit.  If not, see <http://www.gnu.org/licenses/>.\n *\n *  As a special exception, the copyright holders of this library give you\n *  permission to link this library with independent modules to produce an\n *  executable, regardless of the license terms of these independent modules, and to\n *  copy and distribute the resulting executable under terms of your choice,\n *  provided that you also meet, for each linked independent module, the terms and\n *  conditions of the license of that module. An independent module is a module\n *  which is neither derived from nor based on this library. If you modify this\n *  library, you may extend this exception to your version of the library, but you\n *  are not obligated to do so. If you do not wish to do so, delete this exception\n *  statement from your version.\n *\n *  Copyright 2015 Daqri, LLC.\n *  Copyright 2003-2015 ARToolworks, Inc.\n *\n *  Author(s): Hirokazu Kato\n *\n */\n/*******************************************************\n *\n * Author: Hirokazu Kato\n *\n *         kato@sys.im.hiroshima-cu.ac.jp\n *\n * Revision: 4.0\n * Date: 03/08/13\n *\n *******************************************************/\n\n#include <stdio.h>\n#include <AR/ar.h>\n\n#ifdef ARDOUBLE_IS_FLOAT\n#  define _0_5 0.5f\n#  define _0_05 0.05f\n#  define _0_0 0.0f\n#  define EPSILON 0.0001f\n#  define FABS(x) fabsf(x)\n#else\n#  define _0_5 0.5\n#  define _0_05 0.05\n#  define _0_0 0.0\n#  define EPSILON 0.0001\n#  define FABS(x) fabs(x)\n#endif\n\nint arGetLine(int x_coord[], int y_coord[], int coord_num, int vertex[], ARParamLTf *paramLTf,\n              ARdouble line[4][3], ARdouble v[4][2])\n{\n    ARMat    *input, *evec;\n    ARVec    *ev, *mean;\n    ARdouble   w1;\n    int      st, ed, n;\n    int      i, j;\n\n    ev     = arVecAlloc( 2 );\n    mean   = arVecAlloc( 2 );\n    evec   = arMatrixAlloc( 2, 2 );\n    for( i = 0; i < 4; i++ ) {\n        w1 = (ARdouble)(vertex[i+1]-vertex[i]+1) * _0_05 + _0_5;\n        st = (int)(vertex[i]   + w1);\n        ed = (int)(vertex[i+1] - w1);\n        n = ed - st + 1;\n        input  = arMatrixAlloc( n, 2 );\n        for( j = 0; j < n; j++ ) {\n#ifdef ARDOUBLE_IS_FLOAT\n            if (arParamObserv2IdealLTf( paramLTf, (float)x_coord[st+j], (float)y_coord[st+j],\n                                       &(input->m[j*2+0]), &(input->m[j*2+1]) ) < 0) goto bail;\n#else\n            float m0, m1;\n            if (arParamObserv2IdealLTf( paramLTf, (float)x_coord[st+j], (float)y_coord[st+j], &m0, &m1 ) < 0) goto bail;\n            input->m[j*2+0] = (ARdouble)m0;\n            input->m[j*2+1] = (ARdouble)m1;\n#endif\n            //arParamObserv2Ideal( dist_factor, (ARdouble)x_coord[st+j], (ARdouble)y_coord[st+j],\n            //                     &(input->m[j*2+0]), &(input->m[j*2+1]), dist_function_version );\n        }\n        if( arMatrixPCA(input, evec, ev, mean) < 0 ) goto bail;\n        line[i][0] =  evec->m[1];\n        line[i][1] = -evec->m[0];\n        line[i][2] = -(line[i][0]*mean->v[0] + line[i][1]*mean->v[1]);\n        arMatrixFree( input );\n    }\n    arMatrixFree( evec );\n    arVecFree( mean );\n    arVecFree( ev );\n\n    for( i = 0; i < 4; i++ ) {\n        w1 = line[(i+3)%4][0] * line[i][1] - line[i][0] * line[(i+3)%4][1];\n        //if( w1 == _0_0 ) return(-1); // lines are parallel.\n        if( FABS(w1) < EPSILON ) return(-1); // lines are close to parallel.\n        v[i][0] = (  line[(i+3)%4][1] * line[i][2]\n                   - line[i][1] * line[(i+3)%4][2] ) / w1;\n        v[i][1] = (  line[i][0] * line[(i+3)%4][2]\n                   - line[(i+3)%4][0] * line[i][2] ) / w1;\n    }\n\n    return 0;\n    \nbail:\n    arMatrixFree( input );\n    arMatrixFree( evec );\n    arVecFree( mean );\n    arVecFree( ev );\n    return -1;\n}\n","/*\n *  arGetMarkerInfo.c\n *  ARToolKit5\n *\n *  This file is part of ARToolKit.\n *\n *  ARToolKit is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation, either version 3 of the License, or\n *  (at your option) any later version.\n *\n *  ARToolKit is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public License\n *  along with ARToolKit.  If not, see <http://www.gnu.org/licenses/>.\n *\n *  As a special exception, the copyright holders of this library give you\n *  permission to link this library with independent modules to produce an\n *  executable, regardless of the license terms of these independent modules, and to\n *  copy and distribute the resulting executable under terms of your choice,\n *  provided that you also meet, for each linked independent module, the terms and\n *  conditions of the license of that module. An independent module is a module\n *  which is neither derived from nor based on this library. If you modify this\n *  library, you may extend this exception to your version of the library, but you\n *  are not obligated to do so. If you do not wish to do so, delete this exception\n *  statement from your version.\n *\n *  Copyright 2015 Daqri, LLC.\n *  Copyright 2003-2015 ARToolworks, Inc.\n *\n *  Author(s): Philip Lamb\n *\n */\n/*******************************************************\n *\n * Author: Hirokazu Kato\n *\n *         kato@sys.im.hiroshima-cu.ac.jp\n *\n * Revision: 4.0\n * Date: 03/08/13\n *\n *******************************************************/\n\n#include <AR/ar.h>\n\nint arGetMarkerInfo( ARUint8 *image, int xsize, int ysize, int pixelFormat, ARMarkerInfo2 *markerInfo2, int marker2_num,\n                     ARPattHandle *pattHandle, int imageProcMode, int pattDetectMode, ARParamLTf *arParamLTf, ARdouble pattRatio,\n                     ARMarkerInfo *markerInfo, int *marker_num,\n                     const AR_MATRIX_CODE_TYPE matrixCodeType )\n{\n    int            i, j, result;\n#ifndef ARDOUBLE_IS_FLOAT\n    float pos0, pos1;\n#endif\n\n    for( i = j = 0; i < marker2_num; i++ ) {\n        markerInfo[j].area   = markerInfo2[i].area;\n#ifdef ARDOUBLE_IS_FLOAT\n        if (arParamObserv2IdealLTf(arParamLTf, markerInfo2[i].pos[0], markerInfo2[i].pos[1],\n                                   &(markerInfo[j].pos[0]), &(markerInfo[j].pos[1]) ) < 0) continue;\n#else\n        if (arParamObserv2IdealLTf(arParamLTf, (float)markerInfo2[i].pos[0], (float)markerInfo2[i].pos[1], &pos0, &pos1) < 0) continue;\n        markerInfo[j].pos[0] = (ARdouble)pos0;\n        markerInfo[j].pos[1] = (ARdouble)pos1;\n#endif\n        //arParamObserv2Ideal( dist_factor, markerInfo2[i].pos[0], markerInfo2[i].pos[1],\n        //                     &(markerInfo[j].pos[0]), &(markerInfo[j].pos[1]), dist_function_version );\n\n        if( arGetLine(markerInfo2[i].x_coord, markerInfo2[i].y_coord, markerInfo2[i].coord_num,\n                      markerInfo2[i].vertex, arParamLTf,\n                      markerInfo[j].line, markerInfo[j].vertex) < 0 ) continue;\n\n        result = arPattGetIDGlobal( pattHandle, imageProcMode, pattDetectMode, image, xsize, ysize, pixelFormat, arParamLTf, markerInfo[j].vertex, pattRatio, \n                     &markerInfo[j].idPatt, &markerInfo[j].dirPatt, &markerInfo[j].cfPatt,\n                     &markerInfo[j].idMatrix, &markerInfo[j].dirMatrix, &markerInfo[j].cfMatrix,\n                      matrixCodeType, &markerInfo[j].errorCorrected, &markerInfo[j].globalID );\n\n        if      (result == 0)  markerInfo[j].cutoffPhase = AR_MARKER_INFO_CUTOFF_PHASE_NONE;\n        else if (result == -1) markerInfo[j].cutoffPhase = AR_MARKER_INFO_CUTOFF_PHASE_MATCH_GENERIC;\n        else if (result == -2) markerInfo[j].cutoffPhase = AR_MARKER_INFO_CUTOFF_PHASE_MATCH_CONTRAST;\n        else if (result == -3) markerInfo[j].cutoffPhase = AR_MARKER_INFO_CUTOFF_PHASE_MATCH_BARCODE_NOT_FOUND;\n        else if (result == -4) markerInfo[j].cutoffPhase = AR_MARKER_INFO_CUTOFF_PHASE_MATCH_BARCODE_EDC_FAIL;\n        else if (result == -5) markerInfo[j].cutoffPhase = AR_MARKER_INFO_CUTOFF_PHASE_HEURISTIC_TROUBLESOME_MATRIX_CODES;\n        else if (result == -6) markerInfo[j].cutoffPhase = AR_MARKER_INFO_CUTOFF_PHASE_PATTERN_EXTRACTION;\n  \n        // If not mixing template matching and matrix code detection, then copy id, dir and cf\n        // from values in appropriate type.\n        if (pattDetectMode == AR_TEMPLATE_MATCHING_COLOR || pattDetectMode == AR_TEMPLATE_MATCHING_MONO) {\n            markerInfo[j].id  = markerInfo[j].idPatt;\n            markerInfo[j].dir = markerInfo[j].dirPatt;\n            markerInfo[j].cf  = markerInfo[j].cfPatt;\n        } else if( pattDetectMode == AR_MATRIX_CODE_DETECTION ) {\n            markerInfo[j].id  = markerInfo[j].idMatrix;\n            markerInfo[j].dir = markerInfo[j].dirMatrix;\n            markerInfo[j].cf  = markerInfo[j].cfMatrix;\n        }\n\n        j++;\n    }\n    *marker_num = j;\n\n    return 0;\n}\n","/*\n *  arGetTransMat.c\n *  ARToolKit5\n *\n *  This file is part of ARToolKit.\n *\n *  ARToolKit is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation, either version 3 of the License, or\n *  (at your option) any later version.\n *\n *  ARToolKit is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public License\n *  along with ARToolKit.  If not, see <http://www.gnu.org/licenses/>.\n *\n *  As a special exception, the copyright holders of this library give you\n *  permission to link this library with independent modules to produce an\n *  executable, regardless of the license terms of these independent modules, and to\n *  copy and distribute the resulting executable under terms of your choice,\n *  provided that you also meet, for each linked independent module, the terms and\n *  conditions of the license of that module. An independent module is a module\n *  which is neither derived from nor based on this library. If you modify this\n *  library, you may extend this exception to your version of the library, but you\n *  are not obligated to do so. If you do not wish to do so, delete this exception\n *  statement from your version.\n *\n *  Copyright 2015 Daqri, LLC.\n *  Copyright 2002-2015 ARToolworks, Inc.\n *\n *  Author(s): Hirokazu Kato\n *\n */\n/*******************************************************\n *\n * Author: Hirokazu Kato\n *\n *         kato@sys.im.hiroshima-cu.ac.jp\n *\n * Revision: 3.1\n * Date: 01/12/07\n *\n *******************************************************/\n\n#include <AR/ar.h>\n#include <AR/icp.h>\n\n\nARdouble arGetTransMatSquare( AR3DHandle *handle, ARMarkerInfo *marker_info, ARdouble width, ARdouble conv[3][4] )\n{\n    ICP2DCoordT    screenCoord[4];\n    ICP3DCoordT    worldCoord[4];\n    ICPDataT       data;\n    ARdouble         initMatXw2Xc[3][4];\n    ARdouble         err;\n    int            dir;\n\n    dir = marker_info->dir;\n    screenCoord[0].x = marker_info->vertex[(4-dir)%4][0];\n    screenCoord[0].y = marker_info->vertex[(4-dir)%4][1];\n    screenCoord[1].x = marker_info->vertex[(5-dir)%4][0];\n    screenCoord[1].y = marker_info->vertex[(5-dir)%4][1];\n    screenCoord[2].x = marker_info->vertex[(6-dir)%4][0];\n    screenCoord[2].y = marker_info->vertex[(6-dir)%4][1];\n    screenCoord[3].x = marker_info->vertex[(7-dir)%4][0];\n    screenCoord[3].y = marker_info->vertex[(7-dir)%4][1];\n    worldCoord[0].x = -width/2.0;\n    worldCoord[0].y =  width/2.0;\n    worldCoord[0].z =  0.0;\n    worldCoord[1].x =  width/2.0;\n    worldCoord[1].y =  width/2.0;\n    worldCoord[1].z =  0.0;\n    worldCoord[2].x =  width/2.0;\n    worldCoord[2].y = -width/2.0;\n    worldCoord[2].z =  0.0;\n    worldCoord[3].x = -width/2.0;\n    worldCoord[3].y = -width/2.0;\n    worldCoord[3].z =  0.0;\n    data.screenCoord = screenCoord;\n    data.worldCoord  = worldCoord;\n    data.num         = 4;\n\n    if( icpGetInitXw2Xc_from_PlanarData( handle->icpHandle->matXc2U, data.screenCoord, data.worldCoord, data.num, initMatXw2Xc ) < 0 ) return 100000000.0;\n\n\n    if( icpPoint( handle->icpHandle, &data, initMatXw2Xc, conv, &err ) < 0 ) return 100000000.0;\n\n    return err;\n}\n\nARdouble arGetTransMatSquareCont( AR3DHandle *handle, ARMarkerInfo *marker_info, ARdouble initConv[3][4],\n                                ARdouble width, ARdouble conv[3][4] )\n{\n    ICP2DCoordT    screenCoord[4];\n    ICP3DCoordT    worldCoord[4];\n    ICPDataT       data;\n    ARdouble         err;\n    int            dir;\n\n    dir = marker_info->dir;\n    screenCoord[0].x = marker_info->vertex[(4-dir)%4][0];\n    screenCoord[0].y = marker_info->vertex[(4-dir)%4][1];\n    screenCoord[1].x = marker_info->vertex[(5-dir)%4][0];\n    screenCoord[1].y = marker_info->vertex[(5-dir)%4][1];\n    screenCoord[2].x = marker_info->vertex[(6-dir)%4][0];\n    screenCoord[2].y = marker_info->vertex[(6-dir)%4][1];\n    screenCoord[3].x = marker_info->vertex[(7-dir)%4][0];\n    screenCoord[3].y = marker_info->vertex[(7-dir)%4][1];\n    worldCoord[0].x = -width/2.0;\n    worldCoord[0].y =  width/2.0;\n    worldCoord[0].z =  0.0;\n    worldCoord[1].x =  width/2.0;\n    worldCoord[1].y =  width/2.0;\n    worldCoord[1].z =  0.0;\n    worldCoord[2].x =  width/2.0;\n    worldCoord[2].y = -width/2.0;\n    worldCoord[2].z =  0.0;\n    worldCoord[3].x = -width/2.0;\n    worldCoord[3].y = -width/2.0;\n    worldCoord[3].z =  0.0;\n    data.screenCoord = screenCoord;\n    data.worldCoord  = worldCoord;\n    data.num         = 4;\n\n    if( icpPoint( handle->icpHandle, &data, initConv, conv, &err ) < 0 ) return 100000000.0;\n\n    return err;\n}\n\nARdouble arGetTransMat( AR3DHandle *handle, ARdouble initConv[3][4], ARdouble pos2d[][2], ARdouble pos3d[][3], int num,\n                      ARdouble conv[3][4] )\n{\n    ICPDataT       data;\n    ARdouble         err;\n    int            i;\n\n    arMalloc( data.screenCoord, ICP2DCoordT, num );\n    arMalloc( data.worldCoord,  ICP3DCoordT, num );\n\n    for( i = 0; i < num; i++ ) {\n        data.screenCoord[i].x = pos2d[i][0];\n        data.screenCoord[i].y = pos2d[i][1];\n        data.worldCoord[i].x  = pos3d[i][0];\n        data.worldCoord[i].y  = pos3d[i][1];\n        data.worldCoord[i].z  = pos3d[i][2];\n    }\n    data.num = num;\n\n    if( icpPoint( handle->icpHandle, &data, initConv, conv, &err ) < 0 ) {\n        err = 100000000.0;\n    }\n\n    free( data.screenCoord );\n    free( data.worldCoord );\n\n    return err;\n}\n\nARdouble arGetTransMatRobust( AR3DHandle *handle, ARdouble initConv[3][4], ARdouble pos2d[][2], ARdouble pos3d[][3], int num,\n                            ARdouble conv[3][4] )\n{\n    ICPDataT       data;\n    ARdouble         err;\n    int            i;\n\n    arMalloc( data.screenCoord, ICP2DCoordT, num );\n    arMalloc( data.worldCoord,  ICP3DCoordT, num );\n\n    for( i = 0; i < num; i++ ) {\n        data.screenCoord[i].x = pos2d[i][0];\n        data.screenCoord[i].y = pos2d[i][1];\n        data.worldCoord[i].x  = pos3d[i][0];\n        data.worldCoord[i].y  = pos3d[i][1];\n        data.worldCoord[i].z  = pos3d[i][2];\n    }\n    data.num = num;\n\n    if( icpPointRobust( handle->icpHandle, &data, initConv, conv, &err ) < 0 ) {\n        err = 100000000.0;\n    }\n\n    free( data.screenCoord );\n    free( data.worldCoord );\n\n    return err;\n}\n","// -*- C++ -*-\n//===----------------------------- new ------------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_NEW\n#define _LIBCPP_NEW\n\n/*\n    new synopsis\n\nnamespace std\n{\n\nclass bad_alloc\n    : public exception\n{\npublic:\n    bad_alloc() noexcept;\n    bad_alloc(const bad_alloc&) noexcept;\n    bad_alloc& operator=(const bad_alloc&) noexcept;\n    virtual const char* what() const noexcept;\n};\n\nclass bad_array_length : public bad_alloc // FIXME: Not part of C++\n{\npublic:\n    bad_array_length() noexcept;\n};\n\nclass bad_array_new_length : public bad_alloc // C++14\n{\npublic:\n    bad_array_new_length() noexcept;\n};\n\nenum class align_val_t : size_t {}; // C++17\nstruct nothrow_t {};\nextern const nothrow_t nothrow;\ntypedef void (*new_handler)();\nnew_handler set_new_handler(new_handler new_p) noexcept;\nnew_handler get_new_handler() noexcept;\n\n}  // std\n\nvoid* operator new(std::size_t size);                                   // replaceable\nvoid* operator new(std::size_t size, std::align_val_t alignment);       // replaceable, C++17\nvoid* operator new(std::size_t size, const std::nothrow_t&) noexcept;   // replaceable\nvoid* operator new(std::size_t size, std::align_val_t alignment,\n                   const std::nothrow_t&) noexcept;                     // replaceable, C++17\nvoid  operator delete(void* ptr) noexcept;                              // replaceable\nvoid  operator delete(void* ptr, std::size_t size) noexcept;            // replaceable, C++14\nvoid  operator delete(void* ptr, std::align_val_t alignment) noexcept;  // replaceable, C++17\nvoid  operator delete(void* ptr, std::size_t size,\n                      std::align_val_t alignment) noexcept;             // replaceable, C++17\nvoid  operator delete(void* ptr, const std::nothrow_t&) noexcept;       // replaceable\nvoid  operator delete(void* ptr, std:align_val_t alignment,\n                      const std::nothrow_t&) noexcept;                  // replaceable, C++17\n\nvoid* operator new[](std::size_t size);                                 // replaceable\nvoid* operator new[](std::size_t size,\n                     std::align_val_t alignment) noexcept;              // replaceable, C++17\nvoid* operator new[](std::size_t size, const std::nothrow_t&) noexcept; // replaceable\nvoid* operator new[](std::size_t size, std::align_val_t alignment,\n                     const std::nothrow_t&) noexcept;                   // replaceable, C++17\nvoid  operator delete[](void* ptr) noexcept;                            // replaceable\nvoid  operator delete[](void* ptr, std::size_t size) noexcept;          // replaceable, C++14\nvoid  operator delete[](void* ptr,\n                        std::align_val_t alignment) noexcept;           // replaceable, C++17\nvoid  operator delete[](void* ptr, std::size_t size,\n                        std::align_val_t alignment) noexcept;           // replaceable, C++17\nvoid  operator delete[](void* ptr, const std::nothrow_t&) noexcept;     // replaceable\nvoid  operator delete[](void* ptr, std::align_val_t alignment,\n                        const std::nothrow_t&) noexcept;                // replaceable, C++17\n\nvoid* operator new  (std::size_t size, void* ptr) noexcept;\nvoid* operator new[](std::size_t size, void* ptr) noexcept;\nvoid  operator delete  (void* ptr, void*) noexcept;\nvoid  operator delete[](void* ptr, void*) noexcept;\n\n*/\n\n#include <__config>\n#include <exception>\n#include <cstddef>\n#ifdef _LIBCPP_NO_EXCEPTIONS\n#include <cstdlib>\n#endif\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n#if !(defined(_LIBCPP_BUILDING_NEW) || _LIBCPP_STD_VER >= 14 || \\\n    (defined(__cpp_sized_deallocation) && __cpp_sized_deallocation >= 201309))\n# define _LIBCPP_HAS_NO_SIZED_DEALLOCATION\n#endif\n\n#if !defined(_LIBCPP_HAS_NO_ALIGNED_ALLOCATION) && \\\n    (!(defined(_LIBCPP_BUILDING_NEW) || _LIBCPP_STD_VER > 14 || \\\n    (defined(__cpp_aligned_new) && __cpp_aligned_new >= 201606)))\n# define _LIBCPP_HAS_NO_ALIGNED_ALLOCATION\n#endif\n\nnamespace std  // purposefully not using versioning namespace\n{\n\nclass _LIBCPP_EXCEPTION_ABI bad_alloc\n    : public exception\n{\npublic:\n    bad_alloc() _NOEXCEPT;\n    virtual ~bad_alloc() _NOEXCEPT;\n    virtual const char* what() const _NOEXCEPT;\n};\n\nclass _LIBCPP_EXCEPTION_ABI bad_array_new_length\n    : public bad_alloc\n{\npublic:\n    bad_array_new_length() _NOEXCEPT;\n    virtual ~bad_array_new_length() _NOEXCEPT;\n    virtual const char* what() const _NOEXCEPT;\n};\n\n_LIBCPP_NORETURN _LIBCPP_FUNC_VIS void __throw_bad_alloc();  // not in C++ spec\n\n#if defined(_LIBCPP_BUILDING_NEW) || (_LIBCPP_STD_VER > 11)\n\nclass _LIBCPP_EXCEPTION_ABI bad_array_length\n    : public bad_alloc\n{\npublic:\n    bad_array_length() _NOEXCEPT;\n    virtual ~bad_array_length() _NOEXCEPT;\n    virtual const char* what() const _NOEXCEPT;\n};\n\n#define _LIBCPP_BAD_ARRAY_LENGTH_DEFINED\n\n#endif  // defined(_LIBCPP_BUILDING_NEW) || (_LIBCPP_STD_VER > 11)\n\n#if !defined(_LIBCPP_HAS_NO_ALIGNED_ALLOCATION) || _LIBCPP_STD_VER > 14\n#ifndef _LIBCPP_CXX03_LANG\nenum class _LIBCPP_ENUM_VIS align_val_t : size_t { };\n#else\nenum align_val_t { __zero = 0, __max = (size_t)-1 };\n#endif\n#endif\n\nstruct _LIBCPP_TYPE_VIS nothrow_t {};\nextern _LIBCPP_FUNC_VIS const nothrow_t nothrow;\ntypedef void (*new_handler)();\n_LIBCPP_FUNC_VIS new_handler set_new_handler(new_handler) _NOEXCEPT;\n_LIBCPP_FUNC_VIS new_handler get_new_handler() _NOEXCEPT;\n\n}  // std\n\n#if defined(_LIBCPP_CXX03_LANG)\n#define _THROW_BAD_ALLOC throw(std::bad_alloc)\n#else\n#define _THROW_BAD_ALLOC\n#endif\n\n_LIBCPP_OVERRIDABLE_FUNC_VIS void* operator new(std::size_t __sz) _THROW_BAD_ALLOC;\n_LIBCPP_OVERRIDABLE_FUNC_VIS void* operator new(std::size_t __sz, const std::nothrow_t&) _NOEXCEPT _NOALIAS;\n_LIBCPP_OVERRIDABLE_FUNC_VIS void  operator delete(void* __p) _NOEXCEPT;\n_LIBCPP_OVERRIDABLE_FUNC_VIS void  operator delete(void* __p, const std::nothrow_t&) _NOEXCEPT;\n#ifndef _LIBCPP_HAS_NO_SIZED_DEALLOCATION\n_LIBCPP_OVERRIDABLE_FUNC_VIS void  operator delete(void* __p, std::size_t __sz) _NOEXCEPT;\n#endif\n\n_LIBCPP_OVERRIDABLE_FUNC_VIS void* operator new[](std::size_t __sz) _THROW_BAD_ALLOC;\n_LIBCPP_OVERRIDABLE_FUNC_VIS void* operator new[](std::size_t __sz, const std::nothrow_t&) _NOEXCEPT _NOALIAS;\n_LIBCPP_OVERRIDABLE_FUNC_VIS void  operator delete[](void* __p) _NOEXCEPT;\n_LIBCPP_OVERRIDABLE_FUNC_VIS void  operator delete[](void* __p, const std::nothrow_t&) _NOEXCEPT;\n#ifndef _LIBCPP_HAS_NO_SIZED_DEALLOCATION\n_LIBCPP_OVERRIDABLE_FUNC_VIS void  operator delete[](void* __p, std::size_t __sz) _NOEXCEPT;\n#endif\n\n#ifndef _LIBCPP_HAS_NO_ALIGNED_ALLOCATION\n_LIBCPP_OVERRIDABLE_FUNC_VIS void* operator new(std::size_t __sz, std::align_val_t) _THROW_BAD_ALLOC;\n_LIBCPP_OVERRIDABLE_FUNC_VIS void* operator new(std::size_t __sz, std::align_val_t, const std::nothrow_t&) _NOEXCEPT _NOALIAS;\n_LIBCPP_OVERRIDABLE_FUNC_VIS void  operator delete(void* __p, std::align_val_t) _NOEXCEPT;\n_LIBCPP_OVERRIDABLE_FUNC_VIS void  operator delete(void* __p, std::align_val_t, const std::nothrow_t&) _NOEXCEPT;\n#ifndef _LIBCPP_HAS_NO_SIZED_DEALLOCATION\n_LIBCPP_OVERRIDABLE_FUNC_VIS void  operator delete(void* __p, std::size_t __sz, std::align_val_t) _NOEXCEPT;\n#endif\n\n_LIBCPP_OVERRIDABLE_FUNC_VIS void* operator new[](std::size_t __sz, std::align_val_t) _THROW_BAD_ALLOC;\n_LIBCPP_OVERRIDABLE_FUNC_VIS void* operator new[](std::size_t __sz, std::align_val_t, const std::nothrow_t&) _NOEXCEPT _NOALIAS;\n_LIBCPP_OVERRIDABLE_FUNC_VIS void  operator delete[](void* __p, std::align_val_t) _NOEXCEPT;\n_LIBCPP_OVERRIDABLE_FUNC_VIS void  operator delete[](void* __p, std::align_val_t, const std::nothrow_t&) _NOEXCEPT;\n#ifndef _LIBCPP_HAS_NO_SIZED_DEALLOCATION\n_LIBCPP_OVERRIDABLE_FUNC_VIS void  operator delete[](void* __p, std::size_t __sz, std::align_val_t) _NOEXCEPT;\n#endif\n#endif\n\ninline _LIBCPP_INLINE_VISIBILITY void* operator new  (std::size_t, void* __p) _NOEXCEPT {return __p;}\ninline _LIBCPP_INLINE_VISIBILITY void* operator new[](std::size_t, void* __p) _NOEXCEPT {return __p;}\ninline _LIBCPP_INLINE_VISIBILITY void  operator delete  (void*, void*) _NOEXCEPT {}\ninline _LIBCPP_INLINE_VISIBILITY void  operator delete[](void*, void*) _NOEXCEPT {}\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\ninline _LIBCPP_INLINE_VISIBILITY void *__allocate(size_t __size) {\n#ifdef _LIBCPP_HAS_NO_BUILTIN_OPERATOR_NEW_DELETE\n  return ::operator new(__size);\n#else\n  return __builtin_operator_new(__size);\n#endif\n}\n\ninline _LIBCPP_INLINE_VISIBILITY void __libcpp_deallocate(void *__ptr) {\n#ifdef _LIBCPP_HAS_NO_BUILTIN_OPERATOR_NEW_DELETE\n  ::operator delete(__ptr);\n#else\n  __builtin_operator_delete(__ptr);\n#endif\n}\n\n#ifdef _LIBCPP_BAD_ARRAY_LENGTH_DEFINED\n_LIBCPP_NORETURN inline _LIBCPP_ALWAYS_INLINE\nvoid __throw_bad_array_length()\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    throw bad_array_length();\n#else\n\t_VSTD::abort();\n#endif\n}\n#endif\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_NEW\n","//\n//  kmedoids.h\n//  ARToolKit5\n//\n//  This file is part of ARToolKit.\n//\n//  ARToolKit is free software: you can redistribute it and/or modify\n//  it under the terms of the GNU Lesser General Public License as published by\n//  the Free Software Foundation, either version 3 of the License, or\n//  (at your option) any later version.\n//\n//  ARToolKit is distributed in the hope that it will be useful,\n//  but WITHOUT ANY WARRANTY; without even the implied warranty of\n//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n//  GNU Lesser General Public License for more details.\n//\n//  You should have received a copy of the GNU Lesser General Public License\n//  along with ARToolKit.  If not, see <http://www.gnu.org/licenses/>.\n//\n//  As a special exception, the copyright holders of this library give you\n//  permission to link this library with independent modules to produce an\n//  executable, regardless of the license terms of these independent modules, and to\n//  copy and distribute the resulting executable under terms of your choice,\n//  provided that you also meet, for each linked independent module, the terms and\n//  conditions of the license of that module. An independent module is a module\n//  which is neither derived from nor based on this library. If you modify this\n//  library, you may extend this exception to your version of the library, but you\n//  are not obligated to do so. If you do not wish to do so, delete this exception\n//  statement from your version.\n//\n//  Copyright 2013-2015 Daqri, LLC.\n//\n//  Author(s): Chris Broaddus\n//\n\n#pragma once\n\n#include <vector>\n#include <math/rand.h>\n#include <math/indexing.h>\n#include <math/hamming.h>\n#include <framework/error.h>\n\nnamespace vision {\n\n    /**\n     * Implements k-medoids for binary features.\n     */\n    template<int NUM_BYTES_PER_FEATURE>\n    class BinarykMedoids {\n    public:\n        \n        BinarykMedoids(int& rand_seed);\n        BinarykMedoids(int& rand_seed, int k, int num_hypotheses);\n        ~BinarykMedoids() {}\n        \n        /**\n         * Set/Get number of clusters\n         */\n        inline void setk(int k) {\n            mK = k;\n            mCenters.resize(k);\n        }\n        inline int k() const { return mK; }\n        \n        /**\n         * Set/Get number of hypotheses\n         */\n        inline void setNumHypotheses(int n) { mNumHypotheses = n; }\n        inline int numHypotheses() const { return mNumHypotheses; }\n        \n        /**\n         * Assign featurs to a cluster center\n         */\n        void assign(const unsigned char* features,\n                    int num_features);\n        void assign(const unsigned char* features,\n                    int num_features,\n                    const int* indices,\n                    int num_indices);\n        \n        /**\n         * @return Assignment vector\n         */\n        inline const std::vector<int>& assignment() const { return mAssignment; }\n\n        /**\n         * @return Centers\n         */\n        inline const std::vector<int>& centers() const { return mCenters; }\n        \n    private:\n        \n        // Seed for random numbers\n        int& mRandSeed;\n        \n        // Number of cluster centers\n        int mK;\n        \n        // Number of hypotheses to evaulate\n        int mNumHypotheses;\n        \n        // Index of each cluster center\n        std::vector<int> mCenters;\n        \n        // Assignment of each feature to a cluster center\n        std::vector<int> mAssignment;\n        std::vector<int> mHypAssignment;\n        \n        // Vector to store random indices\n        std::vector<int> mRandIndices;\n\n        /**\n         * Assign features to the centers.\n         */\n        unsigned int assign(std::vector<int>& assignment,\n                            const unsigned char* features,\n                            int num_features,\n                            const int* indices,\n                            int num_indices,\n                            const int* centers,\n                            int num_centers);\n\n    }; // BinarykMedoids\n\n    template<int NUM_BYTES_PER_FEATURE>\n    BinarykMedoids<NUM_BYTES_PER_FEATURE>::BinarykMedoids(int& rand_seed)\n    : mRandSeed(rand_seed)\n    , mK(0)\n    , mNumHypotheses(0) { }\n    \n    template<int NUM_BYTES_PER_FEATURE>\n    BinarykMedoids<NUM_BYTES_PER_FEATURE>::BinarykMedoids(int& rand_seed, int k, int num_hypotheses)\n    : mRandSeed(rand_seed)\n    , mNumHypotheses(num_hypotheses) {\n        setk(k);\n    }\n\n    template<int NUM_BYTES_PER_FEATURE>\n    void BinarykMedoids<NUM_BYTES_PER_FEATURE>::assign(const unsigned char* features,\n                                                       int num_features) {\n        std::vector<int> indices(num_features);\n        for(size_t i = 0; i < indices.size(); i++) {\n            indices[i] = (int)i;\n        }\n        assign(features, num_features, &indices[0], (int)indices.size());\n    }\n    \n    template<int NUM_BYTES_PER_FEATURE>\n    void BinarykMedoids<NUM_BYTES_PER_FEATURE>::assign(const unsigned char* features,\n                                                       int num_features,\n                                                       const int* indices,\n                                                       int num_indices) {\n        ASSERT(mK == mCenters.size(), \"k should match the number of cluster centers\");\n        ASSERT(num_features > 0, \"Number of features must be positive\");\n        ASSERT(num_indices <= num_features, \"More indices than features\");\n        ASSERT(num_indices >= mK, \"Not enough features\");\n        \n        mAssignment.resize(num_indices, -1);\n        mHypAssignment.resize(num_indices, -1);\n        mRandIndices.resize(num_indices);\n        \n        SequentialVector(&mRandIndices[0], (int)mRandIndices.size(), 0);\n        \n        unsigned int best_dist = std::numeric_limits<unsigned int>::max();\n        \n        for(int i = 0; i < mNumHypotheses; i++) {\n            // Shuffle the first \"k\" indices\n            ArrayShuffle(&mRandIndices[0], (int)mRandIndices.size(), mK, mRandSeed);\n            \n            // Assign features to the centers\n            unsigned int dist = assign(mHypAssignment,\n                                       features,\n                                       num_features,\n                                       indices,\n                                       num_indices,\n                                       &mRandIndices[0],\n                                       mK);\n            \n            if(dist < best_dist) {\n                // Move the best assignment\n                mAssignment.swap(mHypAssignment);\n                CopyVector(&mCenters[0], &mRandIndices[0], mK);\n                best_dist = dist;\n            }\n        }\n        ASSERT(mK == mCenters.size(), \"k should match the number of cluster centers\");\n    }\n\n    template<int NUM_BYTES_PER_FEATURE>\n    unsigned int BinarykMedoids<NUM_BYTES_PER_FEATURE>::assign(std::vector<int>& assignment,\n                                                               const unsigned char* features,\n                                                               int num_features,\n                                                               const int* indices,\n                                                               int num_indices,\n                                                               const int* centers,\n                                                               int num_centers) {\n        ASSERT(assignment.size() == num_indices, \"Assignment size is incorrect\");\n        ASSERT(num_features > 0, \"Number of features must be positive\");\n        ASSERT(num_indices <= num_features, \"More indices than features\");\n        ASSERT(num_centers > 0, \"There must be at least 1 center\");\n        \n        unsigned int sum_dist = 0;\n        \n        for(int i = 0; i < num_indices; i++) {\n            unsigned int best_dist = std::numeric_limits<unsigned int>::max();\n            // Find the closest center\n            for(int j = 0; j < num_centers; j++) {\n                // Compute the distance from the center\n                unsigned int dist = HammingDistance<NUM_BYTES_PER_FEATURE>(&features[NUM_BYTES_PER_FEATURE*indices[i]],\n                                                                           &features[NUM_BYTES_PER_FEATURE*indices[centers[j]]]);\n                if(dist < best_dist) {\n                    assignment[i] = centers[j];\n                    best_dist = dist;\n                }\n            }\n            // Sum the BEST_DIST measures\n            sum_dist += best_dist;\n        }\n        \n        return sum_dist;\n    }\n\n} // vision","//\n//  feature_point.h\n//  ARToolKit5\n//\n//  This file is part of ARToolKit.\n//\n//  ARToolKit is free software: you can redistribute it and/or modify\n//  it under the terms of the GNU Lesser General Public License as published by\n//  the Free Software Foundation, either version 3 of the License, or\n//  (at your option) any later version.\n//\n//  ARToolKit is distributed in the hope that it will be useful,\n//  but WITHOUT ANY WARRANTY; without even the implied warranty of\n//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n//  GNU Lesser General Public License for more details.\n//\n//  You should have received a copy of the GNU Lesser General Public License\n//  along with ARToolKit.  If not, see <http://www.gnu.org/licenses/>.\n//\n//  As a special exception, the copyright holders of this library give you\n//  permission to link this library with independent modules to produce an\n//  executable, regardless of the license terms of these independent modules, and to\n//  copy and distribute the resulting executable under terms of your choice,\n//  provided that you also meet, for each linked independent module, the terms and\n//  conditions of the license of that module. An independent module is a module\n//  which is neither derived from nor based on this library. If you modify this\n//  library, you may extend this exception to your version of the library, but you\n//  are not obligated to do so. If you do not wish to do so, delete this exception\n//  statement from your version.\n//\n//  Copyright 2013-2015 Daqri, LLC.\n//\n//  Author(s): Chris Broaddus\n//\n\n#pragma once\n\n//#include <boost/serialization/serialization.hpp>\n\nnamespace vision {\n\n    /**\n     * Represents a feature point in the visual database.\n     */\n    class FeaturePoint {\n    public:\n        \n        FeaturePoint() : x(0), y(0), angle(0), scale(0), maxima(true) {}\n        FeaturePoint(float _x, float _y, float _angle, float _scale, bool _maxima)\n        : x(_x), y(_y), angle(_angle), scale(_scale), maxima(_maxima) {}\n        ~FeaturePoint() {}\n\n        /** \n         * The (x,y) location of the center of the feature.\n         */\n        float x, y;\n\n        /**\n         * The orientation of the feature in the range [0,2*pi)\n         */\n        float angle;\n\n        /**\n         * The radius (scale) of the feature in the image.\n         */\n        float scale;\n\n        /**\n         * TRUE if this is maxima, FALSE if a minima.\n         */\n        bool maxima;\n        \n        //\n        // Serialization\n        //\n        \n        /*template<class Archive>\n        void serialize(Archive & ar, const unsigned int version)\n        {\n            ar & x;\n            ar & y;\n            ar & angle;\n            ar & scale;\n            ar & maxima;\n        }*/\n        \n    }; // FeaturePoint\n    \n} // vision","//\n//  keyframe.h\n//  ARToolKit5\n//\n//  This file is part of ARToolKit.\n//\n//  ARToolKit is free software: you can redistribute it and/or modify\n//  it under the terms of the GNU Lesser General Public License as published by\n//  the Free Software Foundation, either version 3 of the License, or\n//  (at your option) any later version.\n//\n//  ARToolKit is distributed in the hope that it will be useful,\n//  but WITHOUT ANY WARRANTY; without even the implied warranty of\n//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n//  GNU Lesser General Public License for more details.\n//\n//  You should have received a copy of the GNU Lesser General Public License\n//  along with ARToolKit.  If not, see <http://www.gnu.org/licenses/>.\n//\n//  As a special exception, the copyright holders of this library give you\n//  permission to link this library with independent modules to produce an\n//  executable, regardless of the license terms of these independent modules, and to\n//  copy and distribute the resulting executable under terms of your choice,\n//  provided that you also meet, for each linked independent module, the terms and\n//  conditions of the license of that module. An independent module is a module\n//  which is neither derived from nor based on this library. If you modify this\n//  library, you may extend this exception to your version of the library, but you\n//  are not obligated to do so. If you do not wish to do so, delete this exception\n//  statement from your version.\n//\n//  Copyright 2013-2015 Daqri, LLC.\n//\n//  Author(s): Chris Broaddus\n//\n\n#pragma once\n\n#include \"feature_store.h\"\n#include \"binary_hierarchical_clustering.h\"\n\nnamespace vision {\n    \n    template<int NUM_BYTES_PER_FEATURE>\n    class Keyframe {\n    public:\n        \n        typedef Keyframe<NUM_BYTES_PER_FEATURE> keyframe_t;\n        typedef BinaryHierarchicalClustering<NUM_BYTES_PER_FEATURE> index_t;\n        \n        Keyframe() : mWidth(0), mHeight(0) {}\n        ~Keyframe() {}\n        \n        /**\n         * Get/Set image width.\n         */\n        inline void setWidth(int width) { mWidth = width; }\n        inline int width() const { return mWidth; }\n        \n        /**\n         * Get/Set image height.\n         */\n        inline void setHeight(int height) { mHeight = height; }\n        inline int height() const { return mHeight; }\n        \n        /**\n         * @return Feature store.\n         */\n        inline BinaryFeatureStore& store() { return mStore; }\n        inline const BinaryFeatureStore& store() const { return mStore; }\n        \n        /**\n         * @return Index over the features.\n         */\n        inline const index_t& index() const { return mIndex; }\n        \n        /**\n         * Build an index for the features.\n         */\n        void buildIndex();\n        \n        /**\n         * Copy a keyframe.\n         */\n        void copy(const keyframe_t& keyframe) {\n            mWidth = keyframe.mWidth;\n            mHeight = keyframe.mHeight;\n            mStore.copy(keyframe.store());\n        }\n        \n        //\n        // Serialization\n        //\n        \n        /*template<class Archive>\n        void serialize(Archive & ar, const unsigned int version) {\n            ar & mWidth;\n            ar & mHeight;\n            ar & mStore;\n        }*/\n        \n    private:\n        \n        // Image width and height\n        int mWidth;\n        int mHeight;\n        \n        // Feature store\n        BinaryFeatureStore mStore;\n        \n        // Feature index\n        index_t mIndex;\n        \n    }; // Keyframe\n    \n    template<int NUM_BYTES_PER_FEATURE>\n    void Keyframe<NUM_BYTES_PER_FEATURE>::buildIndex() {\n        mIndex.setNumHypotheses(128);\n        mIndex.setNumCenters(8);\n        mIndex.setMaxNodesToPop(8);\n        mIndex.setMinFeaturesPerNode(16);\n        mIndex.build(&mStore.features()[0], (int)mStore.size());\n    }\n    \n} // vision","/*\n *  arMultiGetTransMat.c\n *  ARToolKit5\n *\n *  This file is part of ARToolKit.\n *\n *  ARToolKit is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation, either version 3 of the License, or\n *  (at your option) any later version.\n *\n *  ARToolKit is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public License\n *  along with ARToolKit.  If not, see <http://www.gnu.org/licenses/>.\n *\n *  As a special exception, the copyright holders of this library give you\n *  permission to link this library with independent modules to produce an\n *  executable, regardless of the license terms of these independent modules, and to\n *  copy and distribute the resulting executable under terms of your choice,\n *  provided that you also meet, for each linked independent module, the terms and\n *  conditions of the license of that module. An independent module is a module\n *  which is neither derived from nor based on this library. If you modify this\n *  library, you may extend this exception to your version of the library, but you\n *  are not obligated to do so. If you do not wish to do so, delete this exception\n *  statement from your version.\n *\n *  Copyright 2015 Daqri, LLC.\n *  Copyright 2002-2015 ARToolworks, Inc.\n *\n *  Author(s): Hirokazu Kato, Philip Lamb\n *\n */\n/*******************************************************\n *\n * Author: Hirokazu Kato\n *\n *         kato@sys.im.hiroshima-cu.ac.jp\n *\n * Revision: 1.0\n * Date: 01/09/05\n *\n *******************************************************/\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n#include <AR/ar.h>\n#include <AR/arMulti.h>\n\nstatic ARdouble  arGetTransMatMultiSquare2(AR3DHandle *handle, ARMarkerInfo *marker_info, int marker_num,\n                                         ARMultiMarkerInfoT *config, int robustFlag);\n\nARdouble  arGetTransMatMultiSquare(AR3DHandle *handle, ARMarkerInfo *marker_info, int marker_num,\n                                 ARMultiMarkerInfoT *config)\n{\n    return arGetTransMatMultiSquare2(handle, marker_info, marker_num, config, 0);\n}\n\nARdouble  arGetTransMatMultiSquareRobust(AR3DHandle *handle, ARMarkerInfo *marker_info, int marker_num,\n                                       ARMultiMarkerInfoT *config)\n{\n    return arGetTransMatMultiSquare2(handle, marker_info, marker_num, config, 1);\n}\n\nstatic ARdouble  arGetTransMatMultiSquare2(AR3DHandle *handle, ARMarkerInfo *marker_info, int marker_num,\n                                         ARMultiMarkerInfoT *config, int robustFlag)\n{\n    ARdouble              *pos2d, *pos3d;\n    ARdouble              trans1[3][4], trans2[3][4];\n    ARdouble              err, err2;\n    int                   max, maxArea;\n    int                   vnum;\n    int                   dir;\n    int                   i, j, k;\n    //char  mes[12];\n\n    //ARLOG(\"-- Pass1--\\n\");\n    for( i = 0; i < config->marker_num; i++ ) {\n        k = -1;\n        if( config->marker[i].patt_type == AR_MULTI_PATTERN_TYPE_TEMPLATE ) {\n            for( j = 0; j < marker_num; j++ ) {\n                if( marker_info[j].idPatt != config->marker[i].patt_id ) continue;\n                if( marker_info[j].cfPatt < config->cfPattCutoff ) continue;\n                if( k == -1 ) k = j;\n                else if( marker_info[k].cfPatt < marker_info[j].cfPatt ) k = j;\n            }\n            config->marker[i].visible = k;\n            if( k >= 0 ) marker_info[k].dir = marker_info[k].dirPatt;\n        }\n        else { // config->marker[i].patt_type == AR_MULTI_PATTERN_TYPE_MATRIX\n            for( j = 0; j < marker_num; j++ ) {\n                // Check if we need to examine the globalID rather than patt_id.\n                if (marker_info[j].idMatrix == 0 && marker_info[j].globalID != 0ULL) {\n                    if( marker_info[j].globalID != config->marker[i].globalID ) continue;\n                } else {\n                    if( marker_info[j].idMatrix != config->marker[i].patt_id ) continue;\n                }\n                if( marker_info[j].cfMatrix < config->cfMatrixCutoff ) continue;\n                if( k == -1 ) k = j;\n                else if( marker_info[k].cfMatrix < marker_info[j].cfMatrix ) k = j;\n            }\n            config->marker[i].visible = k;\n            if( k >= 0 ) marker_info[k].dir = marker_info[k].dirMatrix;\n        }\n        //if(k>=0) ARLOG(\" *%d\\n\",i);\n    }\n\n    //ARLOG(\"-- Pass2--\\n\");\n    vnum = 0;\n    for( i = 0; i < config->marker_num; i++ ) {\n        if( (j=config->marker[i].visible) < 0 ) continue;\n\n        //glColor3f( 1.0, 1.0, 0.0 );\n        //sprintf(mes,\"%d\",i);\n        //argDrawStringsByIdealPos( mes, marker_info[j].pos[0], marker_info[j].pos[1] );\n        err = arGetTransMatSquare(handle, &marker_info[j], config->marker[i].width, trans2);\n        //ARLOG(\" [%d:dir=%d] err = %f (%f,%f,%f)\\n\", i, marker_info[j].dir, err, trans2[0][3], trans2[1][3], trans2[2][3]);\n        if( err > AR_MULTI_POSE_ERROR_CUTOFF_EACH_DEFAULT ) {\n            config->marker[i].visible = -1;\n            if (marker_info[j].cutoffPhase == AR_MARKER_INFO_CUTOFF_PHASE_NONE) marker_info[j].cutoffPhase = AR_MARKER_INFO_CUTOFF_PHASE_POSE_ERROR;\n            continue;\n        }\n        //ARLOG(\" *%d\\n\",i);\n        \n        // Use the largest (in terms of 2D coordinates) marker's pose estimate as the\n        // input for the initial estimate for the pose estimator. \n        if( vnum == 0 || maxArea < marker_info[j].area ) {\n            maxArea = marker_info[j].area;\n            max = i; \n            for( j = 0; j < 3; j++ ) { \n                for( k = 0; k < 4; k++ ) trans1[j][k] = trans2[j][k];\n            }\n        }\n        vnum++;\n    }\n    if( vnum == 0 || vnum < config->min_submarker) { \n        config->prevF = 0;\n        return -1;\n    }\n    arUtilMatMul( (const ARdouble (*)[4])trans1, (const ARdouble (*)[4])config->marker[max].itrans, trans2 ); \n    \n    arMalloc(pos2d, ARdouble, vnum*4*2);\n    arMalloc(pos3d, ARdouble, vnum*4*3);\n    \n    j = 0; \n    for( i = 0; i < config->marker_num; i++ ) { \n        if( (k=config->marker[i].visible) < 0 ) continue;\n        \n        dir = marker_info[k].dir;\n        pos2d[j*8+0] = marker_info[k].vertex[(4-dir)%4][0];\n        pos2d[j*8+1] = marker_info[k].vertex[(4-dir)%4][1];\n        pos2d[j*8+2] = marker_info[k].vertex[(5-dir)%4][0];\n        pos2d[j*8+3] = marker_info[k].vertex[(5-dir)%4][1];\n        pos2d[j*8+4] = marker_info[k].vertex[(6-dir)%4][0];\n        pos2d[j*8+5] = marker_info[k].vertex[(6-dir)%4][1];\n        pos2d[j*8+6] = marker_info[k].vertex[(7-dir)%4][0];\n        pos2d[j*8+7] = marker_info[k].vertex[(7-dir)%4][1];\n        pos3d[j*12+0] = config->marker[i].pos3d[0][0];\n        pos3d[j*12+1] = config->marker[i].pos3d[0][1];\n        pos3d[j*12+2] = config->marker[i].pos3d[0][2];\n        pos3d[j*12+3] = config->marker[i].pos3d[1][0];\n        pos3d[j*12+4] = config->marker[i].pos3d[1][1];\n        pos3d[j*12+5] = config->marker[i].pos3d[1][2];\n        pos3d[j*12+6] = config->marker[i].pos3d[2][0];\n        pos3d[j*12+7] = config->marker[i].pos3d[2][1];\n        pos3d[j*12+8] = config->marker[i].pos3d[2][2];\n        pos3d[j*12+9] = config->marker[i].pos3d[3][0];\n        pos3d[j*12+10] = config->marker[i].pos3d[3][1];\n        pos3d[j*12+11] = config->marker[i].pos3d[3][2];\n        j++;\n    }\n    \n\n    if( config->prevF == 0 ) {\n        if( robustFlag ) {\n            err = arGetTransMat( handle, trans2, (ARdouble (*)[2])pos2d, (ARdouble (*)[3])pos3d, vnum*4, config->trans );\n            if( err >= AR_MULTI_POSE_ERROR_CUTOFF_COMBINED_DEFAULT ) {\n                icpSetInlierProbability( handle->icpHandle, 0.8 );\n                err = arGetTransMatRobust( handle, trans2, (ARdouble (*)[2])pos2d, (ARdouble (*)[3])pos3d, vnum*4, config->trans );\n                if( err >= AR_MULTI_POSE_ERROR_CUTOFF_COMBINED_DEFAULT ) {\n                    icpSetInlierProbability( handle->icpHandle, 0.6 );\n                    err = arGetTransMatRobust( handle, trans2, (ARdouble (*)[2])pos2d, (ARdouble (*)[3])pos3d, vnum*4, config->trans );\n                    if( err >= AR_MULTI_POSE_ERROR_CUTOFF_COMBINED_DEFAULT ) {\n                        icpSetInlierProbability( handle->icpHandle, 0.4 );\n                        err = arGetTransMatRobust( handle, trans2, (ARdouble (*)[2])pos2d, (ARdouble (*)[3])pos3d, vnum*4, config->trans );\n                        if( err >= AR_MULTI_POSE_ERROR_CUTOFF_COMBINED_DEFAULT ) {\n                            icpSetInlierProbability( handle->icpHandle, 0.0 );\n                            err = arGetTransMatRobust( handle, trans2, (ARdouble (*)[2])pos2d, (ARdouble (*)[3])pos3d, vnum*4, config->trans );\n                        }\n                    }\n                }\n            }\n        }\n        else {\n            err = arGetTransMat( handle, trans2, (ARdouble (*)[2])pos2d, (ARdouble (*)[3])pos3d, vnum*4, config->trans );\n        }\n        free(pos3d);\n        free(pos2d);\n    }\n    else {\n        if( robustFlag ) {\n            err2 = arGetTransMat( handle, trans2, (ARdouble (*)[2])pos2d, (ARdouble (*)[3])pos3d, vnum*4, trans1 );\n            err = arGetTransMat( handle, config->trans, (ARdouble (*)[2])pos2d, (ARdouble (*)[3])pos3d, vnum*4, config->trans );\n            if( err2 < err ) {\n                for( j = 0; j < 3; j++ ) for( i = 0; i < 4; i++ ) config->trans[j][i] = trans1[j][i];\n                err = err2;\n            }\n            if( err >= AR_MULTI_POSE_ERROR_CUTOFF_COMBINED_DEFAULT ) {\n                icpSetInlierProbability( handle->icpHandle, 0.8 );\n                err2 = arGetTransMatRobust( handle, trans2, (ARdouble (*)[2])pos2d, (ARdouble (*)[3])pos3d, vnum*4, trans1 );\n                err = arGetTransMatRobust( handle, config->trans, (ARdouble (*)[2])pos2d, (ARdouble (*)[3])pos3d, vnum*4, config->trans );\n                if( err2 < err ) {\n                    for( j = 0; j < 3; j++ ) for( i = 0; i < 4; i++ ) config->trans[j][i] = trans1[j][i];\n                    err = err2;\n                }\n                if( err >= AR_MULTI_POSE_ERROR_CUTOFF_COMBINED_DEFAULT ) {\n                    icpSetInlierProbability( handle->icpHandle, 0.6 );\n                    err2 = arGetTransMatRobust( handle, trans2, (ARdouble (*)[2])pos2d, (ARdouble (*)[3])pos3d, vnum*4, trans1 );\n                    err = arGetTransMatRobust( handle, config->trans, (ARdouble (*)[2])pos2d, (ARdouble (*)[3])pos3d, vnum*4, config->trans );\n                    if( err2 < err ) {\n                        for( j = 0; j < 3; j++ ) for( i = 0; i < 4; i++ ) config->trans[j][i] = trans1[j][i];\n                        err = err2;\n                    }\n                    if( err >= AR_MULTI_POSE_ERROR_CUTOFF_COMBINED_DEFAULT ) {\n                        icpSetInlierProbability( handle->icpHandle, 0.4 );\n                        err2 = arGetTransMatRobust( handle, trans2, (ARdouble (*)[2])pos2d, (ARdouble (*)[3])pos3d, vnum*4, trans1 );\n                        err = arGetTransMatRobust( handle, config->trans, (ARdouble (*)[2])pos2d, (ARdouble (*)[3])pos3d, vnum*4, config->trans );\n                        if( err2 < err ) {\n                            for( j = 0; j < 3; j++ ) for( i = 0; i < 4; i++ ) config->trans[j][i] = trans1[j][i];\n                            err = err2;\n                        }\n                        if( err >= AR_MULTI_POSE_ERROR_CUTOFF_COMBINED_DEFAULT ) {\n                            icpSetInlierProbability( handle->icpHandle, 0.0 );\n                            err2 = arGetTransMatRobust( handle, trans2, (ARdouble (*)[2])pos2d, (ARdouble (*)[3])pos3d, vnum*4, trans1 );\n                            err = arGetTransMatRobust( handle, config->trans, (ARdouble (*)[2])pos2d, (ARdouble (*)[3])pos3d, vnum*4, config->trans );\n                            if( err2 < err ) {\n                                for( j = 0; j < 3; j++ ) for( i = 0; i < 4; i++ ) config->trans[j][i] = trans1[j][i];\n                                err = err2;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        else {\n            err2 = arGetTransMat( handle, trans2, (ARdouble (*)[2])pos2d, (ARdouble (*)[3])pos3d, vnum*4, trans1 );\n            err = arGetTransMat( handle, config->trans, (ARdouble (*)[2])pos2d, (ARdouble (*)[3])pos3d, vnum*4, config->trans );\n            if( err2 < err ) {\n                for( j = 0; j < 3; j++ ) for( i = 0; i < 4; i++ ) config->trans[j][i] = trans1[j][i];\n                err = err2;\n            }\n        }\n        free(pos3d);\n        free(pos2d);\n    }\n    \n    if (err < AR_MULTI_POSE_ERROR_CUTOFF_COMBINED_DEFAULT) config->prevF = 1;\n    else {\n        config->prevF = 0;\n        for (i = 0; i < config->marker_num; i++) { \n            if ((k = config->marker[i].visible) < 0) continue;\n            if (marker_info[k].cutoffPhase == AR_MARKER_INFO_CUTOFF_PHASE_NONE) marker_info[k].cutoffPhase = AR_MARKER_INFO_CUTOFF_PHASE_POSE_ERROR_MULTI;\n        }\n    }\n\n    return err;\n}\n","/*\n *  arMultiReadConfigFile.c\n *  ARToolKit5\n *\n *  This file is part of ARToolKit.\n *\n *  ARToolKit is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation, either version 3 of the License, or\n *  (at your option) any later version.\n *\n *  ARToolKit is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public License\n *  along with ARToolKit.  If not, see <http://www.gnu.org/licenses/>.\n *\n *  As a special exception, the copyright holders of this library give you\n *  permission to link this library with independent modules to produce an\n *  executable, regardless of the license terms of these independent modules, and to\n *  copy and distribute the resulting executable under terms of your choice,\n *  provided that you also meet, for each linked independent module, the terms and\n *  conditions of the license of that module. An independent module is a module\n *  which is neither derived from nor based on this library. If you modify this\n *  library, you may extend this exception to your version of the library, but you\n *  are not obligated to do so. If you do not wish to do so, delete this exception\n *  statement from your version.\n *\n *  Copyright 2015 Daqri, LLC.\n *  Copyright 2002-2015 ARToolworks, Inc.\n *\n *  Author(s): Hirokazu Kato, Philip Lamb\n *\n */\n/*******************************************************\n *\n * Author: Hirokazu Kato\n *\n *         kato@sys.im.hiroshima-cu.ac.jp\n *\n * Revision: 1.0\n * Date: 01/09/05\n *\n *******************************************************/\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n#include <AR/ar.h>\n#include <AR/arMulti.h>\n\nstatic char *get_buff( char *buf, int n, FILE *fp );\n\nARMultiMarkerInfoT *arMultiReadConfigFile( const char *filename, ARPattHandle *pattHandle )\n{\n    FILE                   *fp;\n    ARMultiEachMarkerInfoT *marker;\n    ARMultiMarkerInfoT     *marker_info;\n    ARdouble               wpos3d[4][2];\n    char                   buf[256], pattPath[2048], dummy;\n    int                    num;\n    int                    patt_type = 0;\n    int                    i, j;\n\n    if ((fp = fopen(filename, \"r\")) == NULL) {\n        ARLOGe(\"Error: unable to open multimarker config file '%s'.\\n\", filename);\n        ARLOGperror(NULL);\n        return NULL;\n    }\n\n    get_buff(buf, 256, fp);\n    if( sscanf(buf, \"%d\", &num) != 1 ) {\n        ARLOGe(\"Error processing multimarker config file '%s': First line must be number of marker configs to read.\\n\", filename);\n        fclose(fp);\n        return NULL;\n    }\n    ARLOGd(\"Reading %d markers from multimarker file '%s'\\n\", num, filename);\n\n    arMalloc(marker, ARMultiEachMarkerInfoT, num);\n\n    for( i = 0; i < num; i++ ) {\n        get_buff(buf, 256, fp);\n        if (sscanf(buf, \n#if defined(__LP64__) && !defined(__APPLE__)\n                        \"%lu%c\",\n#else\n                        \"%llu%c\",\n#endif\n                         &(marker[i].globalID), &dummy) != 1) { // Try first as matrix code.\n            \n            if (!pattHandle) {\n                ARLOGe(\"Error processing multimarker config file '%s': pattern '%s' specified in multimarker configuration while in barcode-only mode.\\n\", filename, buf);\n                goto bail;\n            }\n            if (!arUtilGetDirectoryNameFromPath(pattPath, filename, sizeof(pattPath), 1)) { // Get directory prefix.\n                ARLOGe(\"Error processing multimarker config file '%s': Unable to determine directory name.\\n\", filename);\n                goto bail;\n            }\n            strncat(pattPath, buf, sizeof(pattPath) - strlen(pattPath) - 1); // Add name of file to open.\n            if ((marker[i].patt_id = arPattLoad(pattHandle, pattPath)) < 0) {\n                ARLOGe(\"Error processing multimarker config file '%s': Unable to load pattern '%s'.\\n\", filename, pattPath);\n                goto bail;\n            }\n            marker[i].patt_type = AR_MULTI_PATTERN_TYPE_TEMPLATE;\n            patt_type |= 0x01;\n        } else {\n            \n            if ((marker[i].globalID & 0xffff8000ULL) == 0ULL) marker[i].patt_id = (int)(marker[i].globalID & 0x00007fffULL); // If upper 33 bits are zero, use lower 31 bits as regular matrix code.\n            else marker[i].patt_id = 0;\n            ARLOGd(\"Marker %3d is matrix code %llu.\\n\", i + 1, marker[i].globalID);\n            marker[i].patt_type = AR_MULTI_PATTERN_TYPE_MATRIX;\n            patt_type |= 0x02;\n        }\n\n        get_buff(buf, 256, fp);\n        if( sscanf(buf,\n#ifdef ARDOUBLE_IS_FLOAT\n                   \"%f\",\n#else\n                   \"%lf\",\n#endif\n                   &marker[i].width) != 1 ) {\n            ARLOGe(\"Error processing multimarker config file '%s', marker definition %3d: First line must be pattern width.\\n\", filename, i + 1);\n            goto bail;\n        }\n        \n        j = 0;\n        get_buff(buf, 256, fp);\n        if( sscanf(buf,\n#ifdef ARDOUBLE_IS_FLOAT\n                   \"%f %f %f %f\",\n#else\n                   \"%lf %lf %lf %lf\",\n#endif\n                   &marker[i].trans[j][0],\n                   &marker[i].trans[j][1],\n                   &marker[i].trans[j][2],\n                   &marker[i].trans[j][3]) != 4 ) {\n            // Perhaps this is an old ARToolKit v2.x multimarker file?\n            // If so, then the next line is two values (center) and should be skipped.\n            float t1, t2;\n            if( sscanf(buf,\n                       \"%f %f\",\n                       &t1, &t2) != 2 ) {\n                ARLOGe(\"Error processing multimarker config file '%s', marker definition %3d: Lines 2 - 4 must be marker transform.\\n\", filename, i + 1);\n                goto bail;\n            }\n        } else j++;\n        do {\n            get_buff(buf, 256, fp);\n            if( sscanf(buf, \n#ifdef ARDOUBLE_IS_FLOAT\n                       \"%f %f %f %f\",\n#else\n                       \"%lf %lf %lf %lf\",\n#endif\n                       &marker[i].trans[j][0],\n                       &marker[i].trans[j][1],\n                       &marker[i].trans[j][2],\n                       &marker[i].trans[j][3]) != 4 ) {\n                ARLOGe(\"Error processing multimarker config file '%s', marker definition %3d: Lines 2 - 4 must be marker transform.\\n\", filename, i + 1);\n                goto bail;\n            }\n            j++;\n        } while (j < 3);\n        arUtilMatInv( (const ARdouble (*)[4])marker[i].trans, marker[i].itrans );\n\n        wpos3d[0][0] =  -marker[i].width/2.0;\n        wpos3d[0][1] =   marker[i].width/2.0;\n        wpos3d[1][0] =   marker[i].width/2.0;\n        wpos3d[1][1] =   marker[i].width/2.0;\n        wpos3d[2][0] =   marker[i].width/2.0;\n        wpos3d[2][1] =  -marker[i].width/2.0;\n        wpos3d[3][0] =  -marker[i].width/2.0;\n        wpos3d[3][1] =  -marker[i].width/2.0;\n        for( j = 0; j < 4; j++ ) {\n            marker[i].pos3d[j][0] = marker[i].trans[0][0] * wpos3d[j][0]\n                                  + marker[i].trans[0][1] * wpos3d[j][1]\n                                  + marker[i].trans[0][3];\n            marker[i].pos3d[j][1] = marker[i].trans[1][0] * wpos3d[j][0]\n                                  + marker[i].trans[1][1] * wpos3d[j][1]\n                                  + marker[i].trans[1][3];\n            marker[i].pos3d[j][2] = marker[i].trans[2][0] * wpos3d[j][0]\n                                  + marker[i].trans[2][1] * wpos3d[j][1]\n                                  + marker[i].trans[2][3];\n        }\n    }\n\n    fclose(fp);\n\n    arMalloc(marker_info, ARMultiMarkerInfoT, 1);\n    marker_info->marker     = marker;\n    marker_info->marker_num = num;\n    marker_info->prevF      = 0;\n    if( (patt_type & 0x03) == 0x03 ) marker_info->patt_type = AR_MULTI_PATTERN_DETECTION_MODE_TEMPLATE_AND_MATRIX;\n    else if( patt_type & 0x01 )    marker_info->patt_type = AR_MULTI_PATTERN_DETECTION_MODE_TEMPLATE;\n    else                           marker_info->patt_type = AR_MULTI_PATTERN_DETECTION_MODE_MATRIX;\n    marker_info->cfPattCutoff = AR_MULTI_CONFIDENCE_PATTERN_CUTOFF_DEFAULT;\n    marker_info->cfMatrixCutoff = AR_MULTI_CONFIDENCE_MATRIX_CUTOFF_DEFAULT;\n\n    return marker_info;\n    \nbail:\n    fclose(fp);\n    free(marker);\n    return NULL;\n}\n\nstatic char *get_buff(char *buf, int n, FILE *fp)\n{\n    char *ret;\n    size_t l;\n    \n    do {\n        ret = fgets(buf, n, fp);\n        if (ret == NULL) return (NULL); // EOF or error.\n        \n        // Remove NLs and CRs from end of string.\n        l = strlen(buf);\n        while (l > 0) {\n            if (buf[l - 1] != '\\n' && buf[l - 1] != '\\r') break;\n            l--;\n            buf[l] = '\\0';\n        }\n    } while (buf[0] == '#' || buf[0] == '\\0'); // Reject comments and blank lines.\n    \n    return (ret);\n}\n","/*\n *  arUtil.c\n *  ARToolKit5\n *\n *  This file is part of ARToolKit.\n *\n *  ARToolKit is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation, either version 3 of the License, or\n *  (at your option) any later version.\n *\n *  ARToolKit is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public License\n *  along with ARToolKit.  If not, see <http://www.gnu.org/licenses/>.\n *\n *  As a special exception, the copyright holders of this library give you\n *  permission to link this library with independent modules to produce an\n *  executable, regardless of the license terms of these independent modules, and to\n *  copy and distribute the resulting executable under terms of your choice,\n *  provided that you also meet, for each linked independent module, the terms and\n *  conditions of the license of that module. An independent module is a module\n *  which is neither derived from nor based on this library. If you modify this\n *  library, you may extend this exception to your version of the library, but you\n *  are not obligated to do so. If you do not wish to do so, delete this exception\n *  statement from your version.\n *\n *  Copyright 2015 Daqri, LLC.\n *  Copyright 2003-2015 ARToolworks, Inc.\n *\n *  Author(s): Hirokazu Kato, Philip Lamb\n *\n */\n/*******************************************************\n *\n * Author: Hirokazu Kato\n *\n *         kato@sys.im.hiroshima-cu.ac.jp\n *\n * Revision: 3.2\n * Date: 03/08/13\n *\n *******************************************************/\n\n#define _GNU_SOURCE   // asprintf()/vasprintf() on Linux.\n#include <AR/ar.h>\n#include <math.h>\n#include <stdarg.h>\n#include <ctype.h>    // tolower()\n#ifdef _WIN32\n#  include <sys/timeb.h>\n#  include <direct.h> // chdir(), getcwd()\n#  ifdef _WINRT\n#  else\n#    define getcwd _getcwd\n#    include <shlobj.h> // SHGetFolderPath()\n#  endif\n#  define MAXPATHLEN MAX_PATH\n#else\n#  include <time.h>\n#  include <sys/time.h>\n#  include <unistd.h> // chdir(), getcwd(), confstr()\n#  include <sys/param.h> // MAXPATHLEN\n#  ifdef __linux\n#    include <sys/utsname.h> // uname()\n#  endif\n#endif\n#ifndef _WIN32\n#  include <pthread.h>\n#endif\n#ifdef __APPLE__\n#  include <CoreFoundation/CoreFoundation.h>\n#  include <mach-o/dyld.h> // _NSGetExecutablePath()\n#  include <sys/sysctl.h> // sysctlbyname()\n#  ifdef __OBJC__\n#    import <Foundation/Foundation.h> // NSURL. N.B.: Including Foundation requires that this file be compiled as Objective-C.\n#  else\n#    warning arUtil.c not compiled as Objective C. Behaviour of function arUtilGetResourcesDirectoryPath will be different.\n#  endif\n#endif\n\n//\n// Global required for logging functions.\n//\nint arLogLevel = AR_LOG_LEVEL_DEFAULT;\nstatic AR_LOG_LOGGER_CALLBACK arLogLoggerCallback = NULL;\nstatic int arLogLoggerCallBackOnlyIfOnSameThread = 0;\n#ifndef _WIN32\nstatic pthread_t arLogLoggerThread;\n#else\nstatic DWORD arLogLoggerThreadID;\n#endif\n#define AR_LOG_WRONG_THREAD_BUFFER_SIZE 4096\nstatic char *arLogWrongThreadBuffer = NULL;\nstatic int arLogWrongThreadBufferSize = 0;\nstatic int arLogWrongThreadBufferCount = 0;\n\n// These are the load/unload handlers for the case when libAR is\n// loaded as a native library by a Java virtual machine (e.g. when\n// running on Android.\n#ifdef ANDROID\n\n// To call Java methods when running native code inside an Android activity,\n// a reference is needed to the JavaVM.\nstatic JavaVM *gJavaVM;\n\nstatic char _AndroidDeviceID[32] = { '\\0' };\n\nJNIEXPORT jint JNICALL JNI_OnLoad(JavaVM *vm, void *reserved)\n{\n    gJavaVM = vm;\n    return JNI_VERSION_1_6;\n}\n\n/*JNIEXPORT void JNICALL JNI_OnUnload(JavaVM *jvm, void *reserved)\n{\n    // Here is the right place to release statically-allocated resources,\n    // including any weak global references created in JNI_OnLoad().\n    // N.B. This routine is called from an arbitrary thread, and Java-side\n    // resources already invalid, so don't do any locking or class ops.\n}*/\n\n#endif // ANDROID\n\nARUint32 arGetVersion(char **versionStringRef)\n{\n\tconst char version[] = AR_HEADER_VERSION_STRING;\n\tchar *s;\n\n\tif (versionStringRef) {\n\t\tarMalloc(s, char, sizeof(version));\n\t\tstrncpy(s, version, sizeof(version));\n\t\t*versionStringRef = s;\n\t}\n\t// Represent full version number (major, minor, tiny, build) in\n\t// binary coded decimal. N.B: Integer division.\n\treturn (0x10000000u * ((unsigned int)AR_HEADER_VERSION_MAJOR / 10u) +\n\t\t\t0x01000000u * ((unsigned int)AR_HEADER_VERSION_MAJOR % 10u) +\n\t\t\t0x00100000u * ((unsigned int)AR_HEADER_VERSION_MINOR / 10u) +\n\t\t\t0x00010000u * ((unsigned int)AR_HEADER_VERSION_MINOR % 10u) +\n\t\t\t0x00001000u * ((unsigned int)AR_HEADER_VERSION_TINY / 10u) +\n\t\t\t0x00000100u * ((unsigned int)AR_HEADER_VERSION_TINY % 10u) +\n\t\t\t0x00000010u * ((unsigned int)AR_HEADER_VERSION_BUILD / 10u) +\n\t\t\t0x00000001u * ((unsigned int)AR_HEADER_VERSION_BUILD % 10u)\n\t\t\t);\n}\n\nvoid arLogSetLogger(AR_LOG_LOGGER_CALLBACK callback, int callBackOnlyIfOnSameThread)\n{\n    arLogLoggerCallback = callback;\n    arLogLoggerCallBackOnlyIfOnSameThread = callBackOnlyIfOnSameThread;\n    if (callback && callBackOnlyIfOnSameThread) {\n#ifndef _WIN32\n        arLogLoggerThread = pthread_self();\n#else\n        arLogLoggerThreadID = GetCurrentThreadId();\n#endif\n\t\tif (!arLogWrongThreadBuffer) {\n\t\t\tarLogWrongThreadBufferSize = AR_LOG_WRONG_THREAD_BUFFER_SIZE;\n\t\t\tarMalloc(arLogWrongThreadBuffer, char, arLogWrongThreadBufferSize);\n\t\t}\n    } else {\n\t\tif (arLogWrongThreadBuffer) {\n\t\t\tfree(arLogWrongThreadBuffer);\n\t\t\tarLogWrongThreadBuffer = NULL;\n\t\t\tarLogWrongThreadBufferSize = 0;\n\t\t}\n\t}\n}\n\nvoid arLog(const int logLevel, const char *format, ...)\n{\n    char *buf = NULL;\n    int len;\n    va_list ap;\n\n    if (logLevel < arLogLevel) return;\n    if (!format || !format[0]) return;\n\n    // Unpack msg formatting.\n    va_start(ap, format);\n#ifdef _WIN32\n    len = _vscprintf(format, ap);\n    if (len >= 0) {\n        buf = (char *)malloc((len + 1) * sizeof(char)); // +1 for nul-term.\n        vsnprintf(buf, len, format, ap);\n        buf[len] = '\\0'; // nul-terminate.\n    }\n#else\n    len = vasprintf(&buf, format, ap);\n#endif\n    va_end(ap);\n\n    if (len >= 0) {\n        if (arLogLoggerCallback) {\n\n\t\t\tif (!arLogLoggerCallBackOnlyIfOnSameThread) {\n\t\t\t\t(*arLogLoggerCallback)(buf);\n\t\t\t} else {\n#ifndef _WIN32\n\t\t\t\tif (!pthread_equal(pthread_self(), arLogLoggerThread))\n#else\n\t\t\t\tif (GetCurrentThreadId() != arLogLoggerThreadID)\n#endif\n\t\t\t\t{\n\t\t\t\t\t// On non-log thread, put it into buffer if we can.\n\t\t\t\t\tif (arLogWrongThreadBufferCount < arLogWrongThreadBufferSize) {\n\t\t\t\t\t\tif (len < (arLogWrongThreadBufferSize - (arLogWrongThreadBufferCount + 3))) { // +3 to reserve space for \"...\".\n\t\t\t\t\t\t\tstrcpy(&arLogWrongThreadBuffer[arLogWrongThreadBufferCount], buf);\n\t\t\t\t\t\t\tarLogWrongThreadBufferCount += len;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tstrcpy(&arLogWrongThreadBuffer[arLogWrongThreadBufferCount], \"...\");\n\t\t\t\t\t\t\tarLogWrongThreadBufferCount = arLogWrongThreadBufferSize; // Mark buffer as full.\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// On log thread, print buffer if anything was in it, then the current message.\n\t\t\t\t\tif (arLogWrongThreadBufferCount > 0) {\n\t\t\t\t\t\t(*arLogLoggerCallback)(arLogWrongThreadBuffer);\n\t\t\t\t\t\tarLogWrongThreadBufferCount = 0;\n\t\t\t\t\t}\n\t\t\t\t\t(*arLogLoggerCallback)(buf);\n\t\t\t\t}\n\t\t\t}\n\n        } else {\n#if defined(__ANDROID__)\n            int logLevelA;\n            switch (logLevel) {\n                case AR_LOG_LEVEL_REL_INFO:         logLevelA = ANDROID_LOG_ERROR; break;\n                case AR_LOG_LEVEL_ERROR:            logLevelA = ANDROID_LOG_ERROR; break;\n                case AR_LOG_LEVEL_WARN:             logLevelA = ANDROID_LOG_WARN;  break;\n                case AR_LOG_LEVEL_INFO:             logLevelA = ANDROID_LOG_INFO;  break;\n                case AR_LOG_LEVEL_DEBUG: default:   logLevelA = ANDROID_LOG_DEBUG; break;\n            }\n            __android_log_write(logLevelA, \"libar\", buf);\n//#elif defined(_WINRT)\n//            OutputDebugStringA(buf);\n#else\n            fprintf(stderr, \"%s\", buf);\n#endif\n        }\n        free(buf);\n    }\n}\n\nint arUtilGetSquareCenter( ARdouble vertex[4][2], ARdouble *x, ARdouble *y )\n{\n    ARdouble   x4x2, x3x1, x2x1, x1, x2;\n    ARdouble   y4y2, y3y1, y2y1, y1, y2;\n    ARdouble   w;\n\n    x4x2 = vertex[3][0] - vertex[1][0];\n    x3x1 = vertex[2][0] - vertex[0][0];\n    x2x1 = vertex[1][0] - vertex[0][0];\n    x2   = vertex[1][0];\n    x1   = vertex[0][0];\n\n    y4y2 = vertex[3][1] - vertex[1][1];\n    y3y1 = vertex[2][1] - vertex[0][1];\n    y2y1 = vertex[1][1] - vertex[0][1];\n    y2   = vertex[1][1];\n    y1   = vertex[0][1];\n\n    w = y3y1 * x4x2 - y4y2 * x3x1;\n    if( w == 0.0 ) return -1;\n\n    *x = ( y2y1 * x3x1 * x4x2 + y3y1 * x4x2 * x1 - y4y2 * x3x1 * x2 ) / w;\n    *y = ( x4x2 * y3y1 * y2 - x2x1 * y3y1 * y4y2 - x3x1 * y4y2 * y1 ) / w;\n\n    return 0;\n}\n\nint arUtilMatMul( const ARdouble s1[3][4], const ARdouble s2[3][4], ARdouble d[3][4] )\n{\n    int     i, j;\n\n    for( j = 0; j < 3; j++ ) {\n        for( i = 0; i < 4; i++) {\n            d[j][i] = s1[j][0] * s2[0][i]\n                    + s1[j][1] * s2[1][i]\n                    + s1[j][2] * s2[2][i];\n        }\n        d[j][3] += s1[j][3];\n    }\n\n    return 0;\n}\n\n#ifndef ARDOUBLE_IS_FLOAT\nint arUtilMatMuldff( const ARdouble s1[3][4], const float s2[3][4], float d[3][4] )\n{\n    int     i, j;\n\n    for( j = 0; j < 3; j++ ) {\n        for( i = 0; i < 4; i++) {\n            d[j][i] = (float)s1[j][0] * s2[0][i]\n            + (float)s1[j][1] * s2[1][i]\n            + (float)s1[j][2] * s2[2][i];\n        }\n        d[j][3] += (float)s1[j][3];\n    }\n\n    return 0;\n}\n\nint arUtilMatMulf( const float s1[3][4], const float s2[3][4], float d[3][4] )\n{\n    int     i, j;\n\n    for( j = 0; j < 3; j++ ) {\n        for( i = 0; i < 4; i++) {\n            d[j][i] = s1[j][0] * s2[0][i]\n            + s1[j][1] * s2[1][i]\n            + s1[j][2] * s2[2][i];\n        }\n        d[j][3] += s1[j][3];\n    }\n\n    return 0;\n}\n#endif\n\nint arUtilMatInv( const ARdouble s[3][4], ARdouble d[3][4] )\n{\n    ARMat       *mat;\n    int         i, j;\n\n    mat = arMatrixAlloc( 4, 4 );\n    for( j = 0; j < 3; j++ ) {\n        for( i = 0; i < 4; i++ ) {\n            mat->m[j*4+i] = s[j][i];\n        }\n    }\n    mat->m[3*4+0] = 0; mat->m[3*4+1] = 0;\n    mat->m[3*4+2] = 0; mat->m[3*4+3] = 1;\n    arMatrixSelfInv( mat );\n    for( j = 0; j < 3; j++ ) {\n        for( i = 0; i < 4; i++ ) {\n            d[j][i] = mat->m[j*4+i];\n        }\n    }\n    arMatrixFree( mat );\n\n    return 0;\n}\n\n#ifndef ARDOUBLE_IS_FLOAT\nint arUtilMatInvf( const float s[3][4], float d[3][4] )\n{\n    ARMat       *mat;\n    int         i, j;\n\n    mat = arMatrixAlloc( 4, 4 );\n    for( j = 0; j < 3; j++ ) {\n        for( i = 0; i < 4; i++ ) {\n            mat->m[j*4+i] = (ARdouble)s[j][i];\n        }\n    }\n    mat->m[3*4+0] = 0; mat->m[3*4+1] = 0;\n    mat->m[3*4+2] = 0; mat->m[3*4+3] = 1;\n    arMatrixSelfInv( mat );\n    for( j = 0; j < 3; j++ ) {\n        for( i = 0; i < 4; i++ ) {\n            d[j][i] = (float)mat->m[j*4+i];\n        }\n    }\n    arMatrixFree( mat );\n\n    return 0;\n}\n#endif\n\nint arUtilMat2QuatPos( const ARdouble m[3][4], ARdouble q[4], ARdouble p[3] )\n{\n    ARdouble   t, s;\n\n#ifdef ARDOUBLE_IS_FLOAT\n    t = m[0][0] + m[1][1] + m[2][2] + 1.0f;\n    if (t > 0.0001f) {\n        s = sqrtf(t) * 2.0f;\n        q[0] = (m[1][2] - m[2][1]) / s;\n        q[1] = (m[2][0] - m[0][2]) / s;\n        q[2] = (m[0][1] - m[1][0]) / s;\n        q[3] = 0.25f * s;\n    } else {\n        if (m[0][0] > m[1][1] && m[0][0] > m[2][2])  {\t// Column 0:\n            s  = sqrtf(1.0f + m[0][0] - m[1][1] - m[2][2]) * 2.0f;\n            q[0] = 0.25f * s;\n            q[1] = (m[0][1] + m[1][0] ) / s;\n            q[2] = (m[2][0] + m[0][2] ) / s;\n            q[3] = (m[1][2] - m[2][1] ) / s;\n        } else if (m[1][1] > m[2][2]) {\t\t\t// Column 1:\n            s  = sqrtf(1.0f + m[1][1] - m[0][0] - m[2][2]) * 2.0f;\n            q[0] = (m[0][1] + m[1][0] ) / s;\n            q[1] = 0.25f * s;\n            q[2] = (m[1][2] + m[2][1] ) / s;\n            q[3] = (m[2][0] - m[0][2] ) / s;\n        } else {\t\t\t\t\t\t// Column 2:\n            s  = sqrtf(1.0f + m[2][2] - m[0][0] - m[1][1]) * 2.0f;\n            q[0] = (m[2][0] + m[0][2] ) / s;\n            q[1] = (m[1][2] + m[2][1] ) / s;\n            q[2] = 0.25f * s;\n            q[3] = (m[0][1] - m[1][0] ) / s;\n        }\n    }\n#else\n    t = m[0][0] + m[1][1] + m[2][2] + 1.0;\n    if (t > 0.0001) {\n        s = sqrt(t) * 2.0;\n        q[0] = (m[1][2] - m[2][1]) / s;\n        q[1] = (m[2][0] - m[0][2]) / s;\n        q[2] = (m[0][1] - m[1][0]) / s;\n        q[3] = 0.25 * s;\n    } else {\n        if (m[0][0] > m[1][1] && m[0][0] > m[2][2])  {\t// Column 0:\n            s  = sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]) * 2.0;\n            q[0] = 0.25 * s;\n            q[1] = (m[0][1] + m[1][0] ) / s;\n            q[2] = (m[2][0] + m[0][2] ) / s;\n            q[3] = (m[1][2] - m[2][1] ) / s;\n        } else if (m[1][1] > m[2][2]) {\t\t\t// Column 1:\n            s  = sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]) * 2.0;\n            q[0] = (m[0][1] + m[1][0] ) / s;\n            q[1] = 0.25 * s;\n            q[2] = (m[1][2] + m[2][1] ) / s;\n            q[3] = (m[2][0] - m[0][2] ) / s;\n        } else {\t\t\t\t\t\t// Column 2:\n            s  = sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]) * 2.0;\n            q[0] = (m[2][0] + m[0][2] ) / s;\n            q[1] = (m[1][2] + m[2][1] ) / s;\n            q[2] = 0.25 * s;\n            q[3] = (m[0][1] - m[1][0] ) / s;\n        }\n    }\n#endif\n\n    p[0] = m[0][3];\n    p[1] = m[1][3];\n    p[2] = m[2][3];\n\n    return 0;\n}\n\nint arUtilQuatPos2Mat( const ARdouble q[4], const ARdouble p[3], ARdouble m[3][4] )\n{\n    ARdouble    x2, y2, z2;\n    ARdouble    xx, xy, xz;\n    ARdouble    yy, yz, zz;\n    ARdouble    wx, wy, wz;\n\n#ifdef ARDOUBLE_IS_FLOAT\n    x2 = q[0] * 2.0f;\n    y2 = q[1] * 2.0f;\n    z2 = q[2] * 2.0f;\n#else\n    x2 = q[0] * 2.0;\n    y2 = q[1] * 2.0;\n    z2 = q[2] * 2.0;\n#endif\n    xx = q[0] * x2;\n    xy = q[0] * y2;\n    xz = q[0] * z2;\n    yy = q[1] * y2;\n    yz = q[1] * z2;\n    zz = q[2] * z2;\n    wx = q[3] * x2;\n    wy = q[3] * y2;\n    wz = q[3] * z2;\n\n#ifdef ARDOUBLE_IS_FLOAT\n    m[0][0] = 1.0f - (yy + zz);\n    m[1][1] = 1.0f - (xx + zz);\n    m[2][2] = 1.0f - (xx + yy);\n#else\n    m[0][0] = 1.0 - (yy + zz);\n    m[1][1] = 1.0 - (xx + zz);\n    m[2][2] = 1.0 - (xx + yy);\n#endif\n    m[1][0] = xy - wz;\n    m[0][1] = xy + wz;\n    m[2][0] = xz + wy;\n    m[0][2] = xz - wy;\n    m[2][1] = yz - wx;\n    m[1][2] = yz + wx;\n\n    m[0][3] = p[0];\n    m[1][3] = p[1];\n    m[2][3] = p[2];\n\n    return 0;\n}\n\nint arUtilQuatNorm(ARdouble q[4])\n{\n    ARdouble mag2, mag;\n\n    // Normalise quaternion.\n    mag2 = q[0]*q[0] + q[1]*q[1] + q[2]*q[2] + q[3]*q[3];\n    if (!mag2) return (-1);\n#ifdef ARDOUBLE_IS_FLOAT\n    mag = sqrtf(mag2);\n#else\n    mag = sqrt(mag2);\n#endif\n    q[0] /= mag;\n    q[1] /= mag;\n    q[2] /= mag;\n    q[3] /= mag;\n\n    return (0);\n}\n\nstatic long ss = 0;\nstatic int sms = 0;\n\ndouble arUtilTimer(void)\n{\n    double             tt;\n    long               s1;\n    int                s2;\n#ifdef _WIN32\n    struct _timeb sys_time;\n\n    _ftime(&sys_time);\n    s1 = (long)sys_time.time  - ss;\n    s2 = sys_time.millitm - sms;\n#else\n    struct timeval     time;\n\n#  if defined(__linux) || defined(__APPLE__) || defined(EMSCRIPTEN)\n    gettimeofday( &time, NULL );\n#  else\n    gettimeofday( &time );\n#  endif\n    s1 = time.tv_sec - ss;\n    s2 = time.tv_usec/1000 - sms;\n#endif\n\n    tt = (double)s1 + (double)s2 / 1000.0;\n\n    return( tt );\n}\n\nvoid arUtilTimerReset(void)\n{\n#ifdef _WIN32\n    struct _timeb sys_time;\n\n    _ftime(&sys_time);\n    ss  = (long)sys_time.time;\n    sms = sys_time.millitm;\n#else\n    struct timeval     time;\n\n#  if defined(__linux) || defined(__APPLE__) || defined(EMSCRIPTEN)\n    gettimeofday( &time, NULL );\n#  else\n    gettimeofday( &time );\n#  endif\n    ss  = time.tv_sec;\n    sms = time.tv_usec / 1000;\n#endif\n}\n\n#ifndef _WINRT\nvoid arUtilSleep( int msec )\n{\n#ifndef _WIN32\n    struct timespec  req;\n\n    req.tv_sec = 0;\n    req.tv_nsec = msec * 1000 * 1000;\n    nanosleep( &req, NULL );\n#else\n\tSleep( msec );\n#endif\n\n    return;\n}\n#endif\n\n// N.B. This function is duplicated in libARvideo, so that libARvideo doesn't need to\n// link to libAR. Therefore, if changes are made here they should be duplicated there.\nint arUtilGetPixelSize( const AR_PIXEL_FORMAT arPixelFormat )\n{\n    switch( arPixelFormat ) {\n        case AR_PIXEL_FORMAT_RGB:\n        case AR_PIXEL_FORMAT_BGR:\n            return 3;\n        case AR_PIXEL_FORMAT_RGBA:\n        case AR_PIXEL_FORMAT_BGRA:\n        case AR_PIXEL_FORMAT_ABGR:\n        case AR_PIXEL_FORMAT_ARGB:\n            return 4;\n        case AR_PIXEL_FORMAT_MONO:\n        case AR_PIXEL_FORMAT_420v: // Report only size of luma pixels (i.e. plane 0).\n        case AR_PIXEL_FORMAT_420f: // Report only size of luma pixels (i.e. plane 0).\n        case AR_PIXEL_FORMAT_NV21: // Report only size of luma pixels (i.e. plane 0).\n            return 1;\n        case AR_PIXEL_FORMAT_2vuy:\n        case AR_PIXEL_FORMAT_yuvs:\n        case AR_PIXEL_FORMAT_RGB_565:\n        case AR_PIXEL_FORMAT_RGBA_5551:\n        case AR_PIXEL_FORMAT_RGBA_4444:\n            return 2;\n        default:\n            return (0);\n    }\n}\n\n// N.B. This function is duplicated in libARvideo, so that libARvideo doesn't need to\n// link to libAR. Therefore, if changes are made here they should be duplicated there.\nconst char *arUtilGetPixelFormatName(const AR_PIXEL_FORMAT arPixelFormat)\n{\n    const char *names[] = {\n        \"AR_PIXEL_FORMAT_RGB\",\n        \"AR_PIXEL_FORMAT_BGR\",\n        \"AR_PIXEL_FORMAT_RGBA\",\n        \"AR_PIXEL_FORMAT_BGRA\",\n        \"AR_PIXEL_FORMAT_ABGR\",\n        \"AR_PIXEL_FORMAT_MONO\",\n        \"AR_PIXEL_FORMAT_ARGB\",\n        \"AR_PIXEL_FORMAT_2vuy\",\n        \"AR_PIXEL_FORMAT_yuvs\",\n        \"AR_PIXEL_FORMAT_RGB_565\",\n        \"AR_PIXEL_FORMAT_RGBA_5551\",\n        \"AR_PIXEL_FORMAT_RGBA_4444\",\n        \"AR_PIXEL_FORMAT_420v\",\n        \"AR_PIXEL_FORMAT_420f\",\n        \"AR_PIXEL_FORMAT_NV21\"\n    };\n    if ((int)arPixelFormat < 0 || (int)arPixelFormat > AR_PIXEL_FORMAT_MAX) {\n        ARLOGe(\"arUtilGetPixelFormatName: Error, unrecognised pixel format (%d).\\n\", (int)arPixelFormat);\n        return (NULL);\n    }\n    return (names[(int)arPixelFormat]);\n}\n\nconst char *arUtilGetFileNameFromPath(const char *path)\n{\n\tchar *sep;\n#ifdef _WIN32\n    char *sep1;\n#endif\n\n    if (!path) return (NULL);\n    if (!*path) return (NULL);\n\n\tsep = strrchr(path, '/');\n#ifdef _WIN32\n    sep1 = strrchr(path, '\\\\');\n    if (sep1 > sep) sep = sep1;\n#endif\n\n\tif (!sep) return (path);\n\telse return (sep + 1);\n}\n\nchar *arUtilGetFileBasenameFromPath(const char *path, const int convertToLowercase)\n{\n    const char *file;\n    char *sep;\n    size_t len;\n    char *ret;\n    int i;\n\n    if (!path || !*path) return (NULL);\n\n    file = arUtilGetFileNameFromPath(path);\n    sep = strrchr(file, '.');\n    if (!sep) return (strdup(file));\n\n    len = sep - file;\n    ret = (char *)malloc(len + 1);\n    if (!ret) {\n        fprintf(stderr, \"Out of memory.\\n\");\n        return (NULL);\n    }\n\n    if (convertToLowercase) {\n        for (i = 0; i < len; i++) ret[i] = tolower(file[i]);\n    } else {\n        for (i = 0; i < len; i++) ret[i] = file[i];\n    }\n    ret[i] = '\\0';\n\n    return (ret);\n}\n\nchar *arUtilGetFileExtensionFromPath(const char *path, const int convertToLowercase)\n{\n    char *sep;\n    size_t len;\n    char *ret;\n    int i;\n\n    if (!path || !*path) return (NULL);\n\n    sep = strrchr(arUtilGetFileNameFromPath(path), '.');\n    if (!sep) return (NULL);\n\n    sep++; // Move past '.'\n    if (!*sep) return (NULL);\n\n    len = strlen(sep);\n    ret = (char *)malloc(len + 1);\n    if (!ret) {\n        fprintf(stderr, \"Out of memory.\\n\");\n        return (NULL);\n    }\n\n    if (convertToLowercase) {\n        for (i = 0; i < len; i++) ret[i] = tolower(sep[i]);\n    } else {\n        for (i = 0; i < len; i++) ret[i] = sep[i];\n    }\n    ret[i] = '\\0';\n\n    return (ret);\n}\n\nchar *arUtilGetDirectoryNameFromPath(char *dir, const char *path, const size_t n, const int addSeparator)\n{\n\tchar *sep;\n#ifdef _WIN32\n    char *sep1;\n#endif\n    size_t toCopy;\n\n    if (!dir || !path || !n) return (NULL);\n\n\tsep = strrchr(path, '/');\n#ifdef _WIN32\n    sep1 = strrchr(path, '\\\\');\n    if (sep1 > sep) sep = sep1;\n#endif\n\n\tif (!sep) dir[0] = '\\0';\n    else {\n        toCopy = sep + (addSeparator ? 1 : 0) - path;\n        if (toCopy + 1 > n) return (NULL); // +1 because we need space for null-terminator.\n        strncpy(dir, path, toCopy); // strlen(path) >= toCopy, so won't ever be null-terminated.\n        dir[toCopy] = '\\0';\n    }\n\treturn dir;\n}\n\nchar *arUtilGetFileURI(const char *path)\n{\n    const char method[] = \"file://\";\n    char *abspath = NULL;\n    char *uri = NULL;\n    size_t pathlen, abspathlen = 0, urilen;\n    int isAbsolute; // bool\n#ifdef _WIN32\n    int isUNC; // bool\n#endif\n    int i;\n\n    if (!path) return (NULL);\n    if (!*path) return (NULL);\n\n    pathlen = strlen(path);\n\n    // First check if we've been passed an absolute path.\n    isAbsolute = FALSE;\n#ifdef _WIN32\n    // Windows has two styles of absolute paths. The first (local Windows\n    // file path) begins with a drive letter e.g. C:, the second (UNC Windows)\n    // with a double backslash e.g. \\\\.\n    if (pathlen >= 2) {\n        if (isalpha(path[0]) && path[1] == ':') isAbsolute = TRUE;\n        else if (path[0] == '\\\\' && path[1] == '\\\\') isAbsolute = TRUE;\n    }\n#else\n    if (path[0] == '/') isAbsolute = TRUE;\n#endif\n\n    // Ensure we have an absolute path.\n    if (isAbsolute) {\n        abspath = (char *)path;\n        abspathlen = pathlen;\n    } else {\n#ifdef _WINRT\n\t\tARLOGe(\"Error: relative paths not supported by Windows Runtime.\\n\");\n\t\treturn (NULL);\n#else\n        // For relative paths, concatenate with the current working directory.\n        abspath = (char *)calloc(MAXPATHLEN, sizeof(char));\n        if (!abspath) return (NULL);\n        if (!getcwd(abspath, MAXPATHLEN)) goto bail;\n        abspathlen = strlen(abspath);\n        if (abspathlen < 1) goto bail;\n        // Ensure current working directory path has a trailing slash.\n#  ifdef _WIN32\n        if (abspath[abspathlen - 1] != '/' && abspath[abspathlen - 1] != '\\\\' )\n#  else\n        if (abspath[abspathlen - 1] != '/')\n#  endif\n        {\n            abspath[abspathlen++] = '/'; abspath[abspathlen] = '\\0';\n        }\n        if (abspathlen + pathlen >= MAXPATHLEN) goto bail;\n        strncpy(abspath + abspathlen, path, MAXPATHLEN - abspathlen - 1); abspath[MAXPATHLEN - 1] = '\\0';\n        abspathlen += pathlen;\n#endif\n    }\n\n#ifdef _WIN32\n    // Windows UNC paths will be stripped of the leading two backslashes.\n    if (abspath[0] == '\\\\' && abspath[1] == '\\\\') isUNC = TRUE;\n    else isUNC = FALSE;\n#endif\n\n    // First pass. Work out how big everything needs to be.\n    urilen = sizeof(method) - 1; // Begin with \"file://\". Don't count the nul terminator.\n#ifdef _WIN32\n    if (isUNC) i = 2;\n    else {\n        urilen++; // Prepend a slash.\n        i = 0;\n    }\n#else\n    i = 0;\n#endif\n    while (abspath[i]) {\n        // Characters not to URL encode.\n        if ((abspath[i] == '/') || (abspath[i] >= 'A' && abspath[i] <= 'Z') || (abspath[i] >= 'a' && abspath[i] <= 'z') || (abspath[i] >= '0' && abspath[i] <= '9') || (abspath[i] == '-') || (abspath[i] == '.') || (abspath[i] == '_') || (abspath[i] == '~')) {\n            urilen++;\n#ifdef _WIN32\n        // On Windows only, backslashes will be converted to forward slashes.\n        } else if (abspath[i] == '\\\\') {\n            urilen++;\n        // On Windows only, a colon which is part of a drive letter will not be encoded.\n        } else if (i == 1 && abspath[i] == ':' && isalpha(abspath[i-1])) {\n            urilen++;\n#endif\n        } else {\n            urilen += 3; // URL encoded char is 3 chars.\n        }\n        i++;\n    }\n    urilen++; // nul termination.\n    uri = (char *)malloc(urilen * sizeof(char));\n\n    // Second pass. Construct the URI.\n    sprintf(uri, method);\n    urilen = sizeof(method) - 1;\n#ifdef _WIN32\n    if (isUNC) i = 2;\n    else {\n        uri[urilen++] = '/'; // Prepend a slash.\n        i = 0;\n    }\n#else\n    i = 0;\n#endif\n    while (abspath[i]) {\n        // Characters not to URL encode.\n        if ((abspath[i] == '/') || (abspath[i] >= 'A' && abspath[i] <= 'Z') || (abspath[i] >= 'a' && abspath[i] <= 'z') || (abspath[i] >= '0' && abspath[i] <= '9') || (abspath[i] == '-') || (abspath[i] == '.') || (abspath[i] == '_') || (abspath[i] == '~')) {\n            uri[urilen++] = abspath[i];\n#ifdef _WIN32\n        } else if (abspath[i] == '\\\\') {\n            uri[urilen++] = '/';\n        } else if (i == 1 && abspath[i] == ':' && isalpha(abspath[i-1])) {\n            uri[urilen++] = ':';\n#endif\n        } else {\n            sprintf(uri + urilen, \"%%%02x\", abspath[i]);\n            urilen += 3; // URL encoded char is 3 chars.\n        }\n        i++;\n    }\n    uri[urilen] = '\\0'; // nul termination.\n\n#ifndef _WINRT\nbail:\n    if (!isAbsolute) free(abspath);\n#endif\n\n    return (uri);\n}\n\n#ifdef ANDROID\nchar *arUtilGetResourcesDirectoryPath(AR_UTIL_RESOURCES_DIRECTORY_BEHAVIOR behavior, jobject instanceOfAndroidContext)\n#else\nchar *arUtilGetResourcesDirectoryPath(AR_UTIL_RESOURCES_DIRECTORY_BEHAVIOR behavior)\n#endif\n{\n#ifndef _WINRT\n    char *wpath1;\n    char *wpath2;\n#  ifdef _WIN32\n\tDWORD len;\n#  endif\n#endif\n    AR_UTIL_RESOURCES_DIRECTORY_BEHAVIOR behaviorW;\n\n    if (behavior == AR_UTIL_RESOURCES_DIRECTORY_BEHAVIOR_BEST) {\n#if defined(__APPLE__)\n        behaviorW = AR_UTIL_RESOURCES_DIRECTORY_BEHAVIOR_USE_BUNDLE_RESOURCES_DIR;\n#elif defined(ANDROID)\n        behaviorW = AR_UTIL_RESOURCES_DIRECTORY_BEHAVIOR_USE_APP_CACHE_DIR;\n#elif defined(_WIN32) || defined(__linux)\n        behaviorW = AR_UTIL_RESOURCES_DIRECTORY_BEHAVIOR_USE_EXECUTABLE_DIR;\n#else\n        behaviorW = AR_UTIL_RESOURCES_DIRECTORY_BEHAVIOR_USE_CWD;\n#endif\n    } else {\n        behaviorW = behavior;\n    }\n\n\tswitch (behaviorW) {\n\n\n        case AR_UTIL_RESOURCES_DIRECTORY_BEHAVIOR_USE_EXECUTABLE_DIR:\n#if (defined(_WIN32) && !defined(_WINRT)) || defined(__APPLE__) || defined(__linux)\n            arMallocClear(wpath1, char, MAXPATHLEN);\n#  if defined(_WIN32)\n            len = GetModuleFileName(NULL, wpath1, MAXPATHLEN);    // NULL implies the current process.\n            if (!len) {\n                free (wpath1);\n                return (NULL);\n            }\n#  elif defined(__APPLE__)\n            uint32_t size = MAXPATHLEN;\n            if (_NSGetExecutablePath(wpath1, &size) != 0) {\n                free (wpath1);\n                return (NULL);\n            }\n#  elif defined(__linux)\n            ssize_t len;\n            len = readlink(\"/proc/self/exe\", wpath1, MAXPATHLEN - 1); // -1 as it is not NULL terminated.\n            if (len == -1) {\n                ARLOGperror(NULL);\n                free (wpath1);\n                return (NULL);\n            }\n            wpath1[len] = '\\0'; // NULL terminate.\n#  endif\n            arMallocClear(wpath2, char, MAXPATHLEN);\n            if (!arUtilGetDirectoryNameFromPath(wpath2, wpath1, MAXPATHLEN, 0)) {\n                free (wpath1);\n                free (wpath2);\n                return (NULL);\n            }\n            free (wpath1);\n            return (wpath2);\n#else\n            return (NULL); // Unsupported OS.\n#endif\n            break;\n\n\n        case AR_UTIL_RESOURCES_DIRECTORY_BEHAVIOR_USE_BUNDLE_RESOURCES_DIR:\n#if defined(__APPLE__)\n        {\n            // Change working directory to resources directory inside app bundle.\n            wpath1 = NULL;\n            CFURLRef pathCFURLRef = CFBundleCopyResourcesDirectoryURL(CFBundleGetMainBundle()); // Get relative path to resources directory.\n            if (pathCFURLRef) {\n                wpath1 = (char *)calloc(MAXPATHLEN, sizeof(char)); //getcwd(path, MAXPATHLEN);\n                if (wpath1) {\n                    if (!CFURLGetFileSystemRepresentation(pathCFURLRef, true, (UInt8*)wpath1, MAXPATHLEN)) { // true in param 2 resolves against base.\n                        ARLOGe(\"Error: Unable to get file system representation of a CFURL.\\n\");\n                        free(wpath1);\n                        wpath1 = NULL;\n                    }\n                }\n                CFRelease(pathCFURLRef);\n            }\n            return (wpath1);\n        }\n#else\n            return (NULL); // Unsupported OS.\n#endif\n            break;\n\n\n        case AR_UTIL_RESOURCES_DIRECTORY_BEHAVIOR_USE_CWD:\n#ifndef _WINRT\n\n            arMallocClear(wpath1, char, MAXPATHLEN);\n            if (!getcwd(wpath1, MAXPATHLEN)) {\n                free(wpath1);\n                return (NULL);\n            }\n            return (wpath1);\n#else\n\t\t\treturn (NULL); // Unsupported OS.\n#endif\n\t\t\tbreak;\n\n\n        case AR_UTIL_RESOURCES_DIRECTORY_BEHAVIOR_USE_USER_ROOT:\n#if defined(_WIN32) && !defined(_WINRT)\n            arMallocClear(wpath1, char, MAXPATHLEN);\n            if (!SUCCEEDED(SHGetFolderPath(NULL, CSIDL_PROFILE, NULL, 0, wpath1))) {\n                free (wpath1);\n                return (NULL);\n            }\n            return (wpath1);\n#elif defined(ANDROID)\n        {\n            // Make JNI calls to get the external storage directory.\n\n            // To begin, get a reference to the env and attach to it.\n            JNIEnv *env;\n            int isAttached = 0;\n            jthrowable exception;\n            if (((*gJavaVM)->GetEnv(gJavaVM, (void**)&env, JNI_VERSION_1_6)) < 0) {\n                // Couldn't get JNI environment, so this thread is native.\n                if (((*gJavaVM)->AttachCurrentThread(gJavaVM, &env, NULL)) < 0) {\n                    ARLOGe(\"Error: Couldn't attach to Java VM.\\n\");\n                    return (NULL);\n                }\n                isAttached = 1;\n            }\n\n            // Get File object for the external storage directory.\n            jclass classEnvironment = (*env)->FindClass(env, \"android/os/Environment\");\n            if (!classEnvironment) goto bailAndroid;\n            jmethodID methodIDgetExternalStorageDirectory = (*env)->GetStaticMethodID(env, classEnvironment, \"getExternalStorageDirectory\", \"()Ljava/io/File;\"); // public static File getExternalStorageDirectory ()\n            if (!methodIDgetExternalStorageDirectory) goto bailAndroid;\n            jobject objectFile = (*env)->CallStaticObjectMethod(env, classEnvironment, methodIDgetExternalStorageDirectory);\n            exception = (*env)->ExceptionOccurred(env);\n            if (exception) {\n                (*env)->ExceptionDescribe(env);\n                (*env)->ExceptionClear(env);\n            }\n\n            // Call method on File object to retrieve String object.\n            jclass classFile = (*env)->GetObjectClass(env, objectFile);\n            if (!classFile) goto bailAndroid;\n            jmethodID methodIDgetAbsolutePath = (*env)->GetMethodID(env, classFile, \"getAbsolutePath\", \"()Ljava/lang/String;\");\n            if (!methodIDgetAbsolutePath) goto bailAndroid;\n            jstring stringPath = (*env)->CallObjectMethod(env, objectFile, methodIDgetAbsolutePath);\n            exception = (*env)->ExceptionOccurred(env);\n            if (exception) {\n                (*env)->ExceptionDescribe(env);\n                (*env)->ExceptionClear(env);\n            }\n            // Extract a C string from the String object and copy it.\n            const char *wpath3 = (*env)->GetStringUTFChars(env, stringPath, NULL);\n            wpath1 = strdup(wpath3);\n            (*env)->ReleaseStringUTFChars(env, stringPath, wpath3);\n\n            goto retAndroid;\n\n        bailAndroid:\n            ARLOGe(\"Error: JNI call failure.\\n\");\n            wpath1 = NULL;\n        retAndroid:\n            if (isAttached) (*gJavaVM)->DetachCurrentThread(gJavaVM); // Clean up.\n            return (wpath1);\n        }\n#elif defined(__APPLE__) && defined(__OBJC__) // iOS/OS X.\n        {\n            NSString *nssHomeDir = NSHomeDirectory(); // CoreFoundation equivalent is CFCopyHomeDirectoryURL(), iOS 6.0+ only.\n            if (!nssHomeDir) {\n                return (NULL);\n            }\n            wpath1 = strdup([nssHomeDir UTF8String]);\n            return wpath1;\n        }\n#elif defined(__linux)\n            if (!((wpath1 = getenv(\"HOME\")))) {\n                return (NULL);\n            }\n            return (strdup(wpath1));\n#else\n            return (NULL); // Unsupported OS.\n#endif\n            break;\n\n\n        case AR_UTIL_RESOURCES_DIRECTORY_BEHAVIOR_USE_APP_CACHE_DIR:\n#if defined(_WIN32)\n            return (NULL);\n#elif defined(__APPLE__) // iOS/OS X.\n        {\n#  ifdef __OBJC__\n            NSURL *cacheDir = [[[NSFileManager defaultManager] URLsForDirectory:NSCachesDirectory inDomains:NSUserDomainMask] objectAtIndex:0];\n            if (!cacheDir) {\n                return (NULL);\n            }\n            wpath1 = strdup([[cacheDir path] UTF8String]);\n#  else\n            size_t len = confstr(_CS_DARWIN_USER_CACHE_DIR, NULL, 0);\n            if (!len) return (NULL);\n            wpath1 = (char *)malloc(len);\n            len = confstr(_CS_DARWIN_USER_CACHE_DIR, wpath1, len); // On OS X, returns a folder in the sandbox hierachy under /var/folders/.\n            if (!len) return (NULL);\n#  endif\n            return (wpath1);\n        }\n#elif defined(ANDROID)\n        {\n            // Make JNI calls to get the Context's cache directory.\n\n            // To begin, get a reference to the env and attach to it.\n            JNIEnv *env;\n            int isAttached = 0;\n            int ret = 0;\n            jthrowable exception;\n            if (((*gJavaVM)->GetEnv(gJavaVM, (void**)&env, JNI_VERSION_1_6)) < 0) {\n                // Couldn't get JNI environment, so this thread is native.\n                if (((*gJavaVM)->AttachCurrentThread(gJavaVM, &env, NULL)) < 0) {\n                    ARLOGe(\"Error: Couldn't attach to Java VM.\\n\");\n                    return (NULL);\n                }\n                isAttached = 1;\n            }\n\n            // Get File object for the Context's files directory. This only works\n            // if a subclass of Context is supplied.\n            // e.g. JNIEXPORT void JNICALL Java_com_test_TestActivity_test(JNIEnv * env, jobject obj)\n            // so make sure before call.\n            jclass classOfSuppliedObject = (*env)->GetObjectClass(env, instanceOfAndroidContext);\n            if (!classOfSuppliedObject) goto bailAndroid1;\n            jclass classContext = (*env)->FindClass(env, \"android/content/Context\");\n            if (!classContext) goto bailAndroid1;\n            if (!(*env)->IsInstanceOf(env, instanceOfAndroidContext, classContext)) {\n                ARLOGe(\"Error: supplied object is not an instance of android/content/Context.\\n\");\n                wpath1 = NULL; // Bad parameter.\n                goto retAndroid1;\n            }\n            jmethodID methodGetDir = (*env)->GetMethodID(env, classOfSuppliedObject, \"getCacheDir\", \"()Ljava/io/File;\"); // public abstract File getCacheDir();\n            //jmethodID methodGetDir = (*env)->GetMethodID(env, classOfSuppliedObject, \"getFilesDir\", \"(Ljava/lang/String;)Ljava/io/File;\"); // public abstract File getFilesDir(String type);\n            if (!methodGetDir) goto bailAndroid1;\n            jobject objectFile = (*env)->CallObjectMethod(env, instanceOfAndroidContext, methodGetDir);\n            exception = (*env)->ExceptionOccurred(env);\n            if (exception) {\n                (*env)->ExceptionDescribe(env);\n                (*env)->ExceptionClear(env);\n            }\n\n            // Call method on File object to retrieve String object.\n            jclass classFile = (*env)->GetObjectClass(env, objectFile);\n            if (!classFile) goto bailAndroid1;\n            jmethodID methodIDgetAbsolutePath = (*env)->GetMethodID(env, classFile, \"getAbsolutePath\", \"()Ljava/lang/String;\");\n            if (!methodIDgetAbsolutePath) goto bailAndroid1;\n            jstring stringPath = (*env)->CallObjectMethod(env, objectFile, methodIDgetAbsolutePath);\n            exception = (*env)->ExceptionOccurred(env);\n            if (exception) {\n                (*env)->ExceptionDescribe(env);\n                (*env)->ExceptionClear(env);\n            }\n            // Extract a C string from the String object, and chdir() to it.\n            const char *wpath3 = (*env)->GetStringUTFChars(env, stringPath, NULL);\n            wpath1 = strdup(wpath3);\n            (*env)->ReleaseStringUTFChars(env, stringPath, wpath3);\n\n            goto retAndroid1;\n\n        bailAndroid1:\n            ARLOGe(\"Error: JNI call failure.\\n\");\n            wpath1 = NULL;\n        retAndroid1:\n            if (isAttached) (*gJavaVM)->DetachCurrentThread(gJavaVM); // Clean up.\n            return (wpath1);\n        }\n#else\n            return (NULL); // Unsupported OS.\n#endif\n            break;\n\n\t\tcase AR_UTIL_RESOURCES_DIRECTORY_BEHAVIOR_USE_APP_DATA_DIR:\n#ifdef _WINRT\n\t\t\t//auto folder = Windows::Storage::ApplicationData::Current->LocalFolder;\n\t\t\t//wpath1 = strdup(folder->Path->Data().c_str());\n\t\t\t//return (wpath1);\n\t\t\treturn (NULL); // Unsupported OS.\n#else\n\t\t\treturn (NULL); // Unsupported OS.\n#endif\n\t\t\tbreak;\n\n        case AR_UTIL_RESOURCES_DIRECTORY_BEHAVIOR_USE_SUPPLIED_PATH:\n        default:\n            return (NULL); // Undefined behaviour.\n            break;\n    }\n}\n\n#ifndef _WINRT\n#ifdef ANDROID\nint arUtilChangeToResourcesDirectory(AR_UTIL_RESOURCES_DIRECTORY_BEHAVIOR behavior, const char *path, jobject instanceOfAndroidContext)\n#else\nint arUtilChangeToResourcesDirectory(AR_UTIL_RESOURCES_DIRECTORY_BEHAVIOR behavior, const char *path)\n#endif\n{\n    char *wpath;\n    AR_UTIL_RESOURCES_DIRECTORY_BEHAVIOR behaviorW;\n\n    if (behavior == AR_UTIL_RESOURCES_DIRECTORY_BEHAVIOR_BEST) {\n#if defined(__APPLE__)\n        behaviorW = AR_UTIL_RESOURCES_DIRECTORY_BEHAVIOR_USE_BUNDLE_RESOURCES_DIR;\n#elif defined(ANDROID)\n        behaviorW = AR_UTIL_RESOURCES_DIRECTORY_BEHAVIOR_USE_APP_CACHE_DIR;\n#elif defined(_WIN32) || defined(__linux)\n        behaviorW = AR_UTIL_RESOURCES_DIRECTORY_BEHAVIOR_USE_EXECUTABLE_DIR;\n#else\n        behaviorW = AR_UTIL_RESOURCES_DIRECTORY_BEHAVIOR_USE_CWD;\n#endif\n    } else {\n        behaviorW = behavior;\n    }\n\n    if (behaviorW != AR_UTIL_RESOURCES_DIRECTORY_BEHAVIOR_USE_SUPPLIED_PATH) {\n#ifdef ANDROID\n        wpath = arUtilGetResourcesDirectoryPath(behavior, instanceOfAndroidContext);\n#else\n        wpath = arUtilGetResourcesDirectoryPath(behavior);\n#endif\n        if (wpath) {\n            if (chdir(wpath) != 0) {\n                ARLOGe(\"Error: Unable to change working directory to '%s'.\\n\", wpath);\n                ARLOGperror(NULL);\n                free (wpath);\n                return (-1);\n            }\n            free(wpath);\n        }\n    }\n    if (path) {\n        if (chdir(path) != 0) {\n            ARLOGe(\"Error: Unable to change working directory to '%s'.\\n\", path);\n            ARLOGperror(NULL);\n            return (-1);\n        }\n    }\n\n    return (0);\n}\n#endif // !_WINRT\n\n//\n// For AR2.\n//\n\nint arUtilReplaceExt( char *filename, int n, char *ext )\n{\n    int   i, j;\n\n    for( i = j = 0; filename[i] != '\\0'; i++ ) {\n        if( filename[i] == '.' ) j = i;\n    }\n    if( j == 0 ) {\n        if( i + (int)strlen(ext) + 2 > n ) return -1;\n        j = i;\n        filename[j] = '.';\n    }\n    else {\n        if( j + (int)strlen(ext) + 2 > n ) return -1;\n    }\n\n    filename[j+1] = '\\0';\n    strcat( filename, ext );\n\n    return 0;\n}\n\nint arUtilRemoveExt( char *filename )\n{\n    int   i, j;\n\n    j = -1;\n    for( i = 0; filename[i] != '\\0'; i++ ) {\n        if( filename[i] == '.' ) j = i;\n    }\n    if( j != -1 ) filename[j] = '\\0';\n\n    return 0;\n}\n\nint arUtilDivideExt( const char *filename, char *s1, char *s2 )\n{\n    int   j, k;\n\n    for(j=0;;j++) {\n        s1[j] = filename[j];\n        if( s1[j] == '\\0' || s1[j] == '.' ) break;\n    }\n    s1[j] = '\\0';\n    if( filename[j] == '\\0' ) s2[0] = '\\0';\n    else {\n        j++;\n        for(k=0;;k++) {\n            s2[k] = filename[j+k];\n            if( s2[k] == '\\0' ) break;\n        }\n    }\n\n    return 0;\n}\n\nchar *arUtilGetMachineType(void)\n{\n    char *ret = NULL;\n#if defined(__APPLE__)\n    size_t  size;\n    sysctlbyname(\"hw.machine\", NULL, &size, NULL, 0);\n    arMalloc(ret, char, size);\n    sysctlbyname(\"hw.machine\", ret, &size, NULL, 0);\n#elif defined(_WIN32) // Windows.\n#  if defined(_M_IX86)\n    ret = strdup(\"x86\");\n#  elif defined(_M_X64)\n    ret = strdup(\"x86_64\");\n#  elif defined(_M_IA64)\n    ret = strdup(\"ia64\");\n#  elif defined(_M_ARM)\n    ret = strdup(\"arm\");\n#  else\n    ret = strdup(\"unknown\");\n#  endif\n#elif defined(__linux) // Linux.\n    struct utsname un;\n    if (uname(&un) < 0) {\n        ret = strdup(un.machine);\n    }\n#endif\n    return (ret);\n}\n\nvoid arUtilPrintTransMat(const ARdouble trans[3][4])\n{\n    int i;\n    for (i = 0; i < 3; i++) {\n        ARLOG(\"[% .3f % .3f % .3f] [% 6.1f]\\n\", trans[i][0], trans[i][1], trans[i][2], trans[i][3]);\n    }\n}\n\nvoid arUtilPrintMtx16(const ARdouble mtx16[16])\n{\n    int i;\n    for (i = 0; i < 4; i++) {\n        ARLOG(\"[% .3f % .3f % .3f] [% 6.1f]\\n\", mtx16[i], mtx16[i + 4], mtx16[i + 8], mtx16[i + 12]);\n    }\n}\n\n#ifdef ANDROID\n//Call from native code to do the following in Java source:\n//    import android.provider.Settings.Secure;\n//    private String android_id = Secure.getString(getContext().getContentResolver(),\n//                                                 Secure.ANDROID_ID);\n//        Component parts of the above call:\n//            public static final class Settings\n//            Settings inner class - public static final Secure\n//            static method: String Secure.getString(ContentResolver resolver, String name);\n//            via application/activity Context object, get reference to public abstract class ContentResolver object\n//            Use Secure.ANDROID_ID constant label string as key into app Content to retrieve unique Android ID string\nchar* arUtilGetAndroidDevID()\n{\n    int bailAndroidStep = 0;\n    // To begin, get a reference to the env and attach to it.\n    if ('\\0' != _AndroidDeviceID[0]) {\n        ARLOG(\"arUtilGetAndroidDevID() Success 2: %s\", _AndroidDeviceID);\n        return(_AndroidDeviceID);\n    }\n\n    ARLOG(\"arUtilGetAndroidDevID():02\");\n\n    JNIEnv* env;\n    int isAttached = 0;\n    if (((*gJavaVM)->GetEnv(gJavaVM, (void**)&env, JNI_VERSION_1_6)) < 0) {\n        // Couldn't get JNI environment, so this thread is native.\n        if (((*gJavaVM)->AttachCurrentThread(gJavaVM, &env, NULL)) < 0) {\n            ARLOGe(\"arUtilGetAndroidDevID(): Couldn't attach to Java VM.\\n\");\n            bailAndroidStep = 1;\n            goto bailAndroid;\n        }\n        isAttached = 1;\n    }\n\n    ARLOG(\"arUtilGetAndroidDevID():03\");\n\n    //1.1: Get the ActivityThread class by name. Then using an undocumented static method, by way of a static method id, get the\n    //     application/activity context instance to facilitate the reference to application's ContentResolver.\n    jclass activityThreadClass = (*env)->FindClass(env, \"android/app/ActivityThread\");\n    if (activityThreadClass == NULL) {\n        bailAndroidStep = 2;\n        goto bailAndroid;\n    }\n    jmethodID currentAppMethodID = (*env)->GetStaticMethodID(env, activityThreadClass, \"currentApplication\", \"()Landroid/app/Application;\");\n    if (currentAppMethodID == NULL) {\n        bailAndroidStep = 3;\n        goto bailAndroid;\n    }\n    jobject activityContextObj = (*env)->CallStaticObjectMethod(env, activityThreadClass, currentAppMethodID);\n    if (activityContextObj == NULL) {\n        bailAndroidStep = 4;\n        goto bailAndroid;\n    }\n\n    ARLOG(\"arUtilGetAndroidDevID():04\");\n\n    //1.2: Get Java Context class reference by name.\n    jclass contextClass = (*env)->FindClass(env, \"android/content/Context\");\n    if (contextClass == NULL) {\n        bailAndroidStep = 5;\n        goto bailAndroid;\n    }\n\n    ARLOG(\"arUtilGetAndroidDevID():05\");\n\n    //1.3 Using the application/activity instance context and the Context class, get the Method ID for the method getContentResolver()\n    jmethodID getContentResolverMethodID = (*env)->GetMethodID(env, contextClass, \"getContentResolver\", \"()Landroid/content/ContentResolver;\");\n    if (getContentResolverMethodID == NULL) {\n        bailAndroidStep = 6;\n        goto bailAndroid;\n    }\n\n    ARLOG(\"arUtilGetAndroidDevID():06\");\n\n    //1.4: Using the application/activity instance context and the getContentResolver method id, call the method and get the content resolver instance\n    jobject contentResolverObj = (*env)->CallObjectMethod(env, activityContextObj, getContentResolverMethodID);\n    if (contentResolverObj == NULL) {\n        bailAndroidStep = 7;\n        goto bailAndroid;\n    }\n\n    ARLOG(\"arUtilGetAndroidDevID():07\");\n\n    //2.1: Get the Secure class found in the android.provider.Settings namespace by name\n    jclass settingsSecureClass = (*env)->FindClass(env, \"android/provider/Settings$Secure\");\n    if (settingsSecureClass == NULL) {\n        bailAndroidStep = 8;\n        goto bailAndroid;\n    }\n\n    ARLOG(\"arUtilGetAndroidDevID():08\");\n\n    //2.2: Get the static Method ID for the Secure class's getString() method. The method takes a content resolver object as the 1st arg,\n    //     a Java String for the 2nd arg and returns a Java string.\n    jmethodID secureClass_getStringMethodID = (*env)->GetStaticMethodID(env, settingsSecureClass, \"getString\",\n                                                                        \"(Landroid/content/ContentResolver;Ljava/lang/String;)Ljava/lang/String;\");\n    if (secureClass_getStringMethodID == NULL) {\n        bailAndroidStep = 9;\n        goto bailAndroid;\n    }\n\n    ARLOG(\"arUtilGetAndroidDevID():09\");\n\n    //2.3: Create a Java string representing the Secure class predefined Android_ID string Label constant\n    jstring androidDeviceID_LabelJavaStr = (jstring)(*env)->NewStringUTF(env, \"android_id\");\n    if (androidDeviceID_LabelJavaStr == NULL) {\n        bailAndroidStep = 10;\n        goto bailAndroid;\n    }\n\n    ARLOG(\"arUtilGetAndroidDevID():10\");\n\n    //2.4: Using the Secure static class reference and the Secure.getString() method id, call Secure.getString(contentResolverInstance,\n    //     the predefined Android_ID string constant.\n    jstring androidDeviceID_ValueJavaStr = (jstring)(*env)->CallStaticObjectMethod(env, settingsSecureClass, secureClass_getStringMethodID,\n                                                                                   contentResolverObj, androidDeviceID_LabelJavaStr);\n    if (androidDeviceID_ValueJavaStr == NULL) {\n        bailAndroidStep = 11;\n        goto bailAndroid;\n    }\n\n    ARLOG(\"arUtilGetAndroidDevID():11\");\n\n    //3.1: Convert the Java string to a char* buf. Copy the C char* buf to a global char array.\n    const char* androidDeviceID_ValueC_CharStr = (*env)->GetStringUTFChars(env, androidDeviceID_ValueJavaStr, NULL);\n    if (androidDeviceID_ValueC_CharStr == NULL) {\n        bailAndroidStep = 12;\n        goto bailAndroid;\n    }\n    else {\n        ARLOG(\"arUtilGetAndroidDevID():12\");\n        (void)strcpy(_AndroidDeviceID, androidDeviceID_ValueC_CharStr);\n        (*env)->ReleaseStringUTFChars(env, androidDeviceID_ValueJavaStr, androidDeviceID_ValueC_CharStr);\n        ARLOG(\"arUtilGetAndroidDevID():13 = %s\", _AndroidDeviceID);\n    }\n\n    ARLOG(\"arUtilGetAndroidDevID():14\");\n\n    //4: clean up allocated resources and return the char array if a string was retrieved. Else return char* NULL.\n    bailAndroid:\n    {\n        ARLOG(\"arUtilGetAndroidDevID():15\");\n        if (isAttached)\n            (*gJavaVM)->DetachCurrentThread(gJavaVM); // Clean up.\n        if (androidDeviceID_LabelJavaStr != NULL) {\n            (*env)->DeleteLocalRef(env, androidDeviceID_LabelJavaStr);\n        }\n        if ('\\0' != _AndroidDeviceID[0]) {\n            ARLOG(\"arUtilGetAndroidDevID() Success 1: %s\", _AndroidDeviceID);\n            return(_AndroidDeviceID);\n        }\n        ARLOGe(\"arUtilGetAndroidDevID(): bailed at step: %d\", bailAndroidStep);\n        return((char*)NULL);\n    }\n}\n\n/*\n * Class:     org_artoolkit_ar_samples_ARSimple_ARSimpleApplication\n * Method:    testArUtilGetAndroidDevID\n * Signature: ()Ljava/lang/String;\n */\nJNIEXPORT jstring JNICALL Java_org_artoolkit_ar_samples_ARSimple_ARSimpleApplication_testArUtilGetAndroidDevID(JNIEnv *env,\n                                                                                                               jobject context)\n{\n    ARLOG(\"testArUtilGetAndroidDevID():01\");\n    char * foo = arUtilGetAndroidDevID();\n    ARLOG(\"testArUtilGetAndroidDevID():02\");\n    return((jstring)NULL);\n}\n#endif //ANDROID\n","/*\n *  mAlloc.c\n *  ARToolKit5\n *\n *  This file is part of ARToolKit.\n *\n *  ARToolKit is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation, either version 3 of the License, or\n *  (at your option) any later version.\n *\n *  ARToolKit is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public License\n *  along with ARToolKit.  If not, see <http://www.gnu.org/licenses/>.\n *\n *  As a special exception, the copyright holders of this library give you\n *  permission to link this library with independent modules to produce an\n *  executable, regardless of the license terms of these independent modules, and to\n *  copy and distribute the resulting executable under terms of your choice,\n *  provided that you also meet, for each linked independent module, the terms and\n *  conditions of the license of that module. An independent module is a module\n *  which is neither derived from nor based on this library. If you modify this\n *  library, you may extend this exception to your version of the library, but you\n *  are not obligated to do so. If you do not wish to do so, delete this exception\n *  statement from your version.\n *\n *  Copyright 2015 Daqri, LLC.\n *  Copyright 2002-2015 ARToolworks, Inc.\n *\n *  Author(s): Shinsaku Hiura, Hirokazu Kato, Philip Lamb\n *\n */\n/*******************************************************\n *\n * Author: Shinsaku Hiura, Hirokazu Kato\n *\n *         shinsaku@sys.es.osaka-u.ac.jp\n *         kato@sys.im.hiroshima-cu.ac.jp\n *\n * Revision: 2.1\n * Date: 99/07/16\n *\n *******************************************************/\n\n#include <stdio.h>\n#include <math.h>\n#ifndef __APPLE__\n#include <malloc.h>\n#else\n#include <stdlib.h>\n#endif\n#include <AR/ar.h>\n\nARMat *arMatrixAlloc(int row, int clm)\n{\n\tARMat *m;\n\n\tm = (ARMat *)malloc(sizeof(ARMat));\n\tif( m == NULL ) return NULL;\n\n\tm->m = (ARdouble *)malloc(sizeof(ARdouble) * row * clm);\n\tif(m->m == NULL) {\n\t\tfree(m);\n\t\treturn NULL;\n\t}\n\telse {\n\t\tm->row = row;\n\t\tm->clm = clm;\n\t}\n\n\treturn m;\n}\n\n#ifndef ARDOUBLE_IS_FLOAT\nARMatf *arMatrixAllocf(int row, int clm)\n{\n\tARMatf *m;\n    \n\tm = (ARMatf *)malloc(sizeof(ARMatf));\n\tif( m == NULL ) return NULL;\n    \n\tm->m = (float *)malloc(sizeof(float) * row * clm);\n\tif(m->m == NULL) {\n\t\tfree(m);\n\t\treturn NULL;\n\t}\n\telse {\n\t\tm->row = row;\n\t\tm->clm = clm;\n\t}\n    \n\treturn m;\n}\n#endif","/*\n *  mAllocDup.c\n *  ARToolKit5\n *\n *  This file is part of ARToolKit.\n *\n *  ARToolKit is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation, either version 3 of the License, or\n *  (at your option) any later version.\n *\n *  ARToolKit is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public License\n *  along with ARToolKit.  If not, see <http://www.gnu.org/licenses/>.\n *\n *  As a special exception, the copyright holders of this library give you\n *  permission to link this library with independent modules to produce an\n *  executable, regardless of the license terms of these independent modules, and to\n *  copy and distribute the resulting executable under terms of your choice,\n *  provided that you also meet, for each linked independent module, the terms and\n *  conditions of the license of that module. An independent module is a module\n *  which is neither derived from nor based on this library. If you modify this\n *  library, you may extend this exception to your version of the library, but you\n *  are not obligated to do so. If you do not wish to do so, delete this exception\n *  statement from your version.\n *\n *  Copyright 2015 Daqri, LLC.\n *  Copyright 2002-2015 ARToolworks, Inc.\n *\n *  Author(s): Shinsaku Hiura, Hirokazu Kato\n *\n */\n/*******************************************************\n *\n * Author: Shinsaku Hiura, Hirokazu Kato\n *\n *         shinsaku@sys.es.osaka-u.ac.jp\n *         kato@sys.im.hiroshima-cu.ac.jp\n *\n * Revision: 2.1\n * Date: 99/07/16\n *\n *******************************************************/\n\n#include <stdio.h>\n#include <math.h>\n#ifndef __APPLE__\n#include <malloc.h>\n#else\n#include <stdlib.h>\n#endif\n#include <AR/ar.h>\n\nARMat *arMatrixAllocDup(ARMat *source)\n{\n\tARMat *dest;\n\n\tdest = arMatrixAlloc(source->row, source->clm);\n        if( dest == NULL ) return NULL;\n\n\tif( arMatrixDup(dest, source) < 0 ) {\n\t\tarMatrixFree(dest);\n\t\treturn NULL;\n\t}\n\n\treturn dest;\n}\n","/*\n *  mAllocMul.c\n *  ARToolKit5\n *\n *  This file is part of ARToolKit.\n *\n *  ARToolKit is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation, either version 3 of the License, or\n *  (at your option) any later version.\n *\n *  ARToolKit is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public License\n *  along with ARToolKit.  If not, see <http://www.gnu.org/licenses/>.\n *\n *  As a special exception, the copyright holders of this library give you\n *  permission to link this library with independent modules to produce an\n *  executable, regardless of the license terms of these independent modules, and to\n *  copy and distribute the resulting executable under terms of your choice,\n *  provided that you also meet, for each linked independent module, the terms and\n *  conditions of the license of that module. An independent module is a module\n *  which is neither derived from nor based on this library. If you modify this\n *  library, you may extend this exception to your version of the library, but you\n *  are not obligated to do so. If you do not wish to do so, delete this exception\n *  statement from your version.\n *\n *  Copyright 2015 Daqri, LLC.\n *  Copyright 2002-2015 ARToolworks, Inc.\n *\n *  Author(s): Shinsaku Hiura, Hirokazu Kato, Philip Lamb\n *\n */\n/*******************************************************\n *\n * Author: Shinsaku Hiura, Hirokazu Kato\n *\n *         shinsaku@sys.es.osaka-u.ac.jp\n *         kato@sys.im.hiroshima-cu.ac.jp\n *\n * Revision: 2.1\n * Date: 99/07/16\n *\n *******************************************************/\n\n#include <stdio.h>\n#include <math.h>\n#ifndef __APPLE__\n#include <malloc.h>\n#else\n#include <stdlib.h>\n#endif\n#include <AR/ar.h>\n\nARMat *arMatrixAllocMul(ARMat *a, ARMat *b)\n{\n\tARMat *dest;\n\n\tdest = arMatrixAlloc(a->row, b->clm);\n\tif( dest == NULL ) return NULL;\n\n\tif( arMatrixMul(dest, a, b) < 0 ) {\n\t\tarMatrixFree(dest);\n\t\treturn NULL;\n\t}\n\n\treturn dest;\n}\n\n#ifndef ARDOUBLE_IS_FLOAT\nARMatf *arMatrixAllocMulf(ARMatf *a, ARMatf *b)\n{\n\tARMatf *dest;\n\n\tdest = arMatrixAllocf(a->row, b->clm);\n\tif( dest == NULL ) return NULL;\n\n\tif( arMatrixMulf(dest, a, b) < 0 ) {\n\t\tarMatrixFreef(dest);\n\t\treturn NULL;\n\t}\n\n\treturn dest;\n}\n#endif","/*\n *  mAllocTrans.c\n *  ARToolKit5\n *\n *  This file is part of ARToolKit.\n *\n *  ARToolKit is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation, either version 3 of the License, or\n *  (at your option) any later version.\n *\n *  ARToolKit is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public License\n *  along with ARToolKit.  If not, see <http://www.gnu.org/licenses/>.\n *\n *  As a special exception, the copyright holders of this library give you\n *  permission to link this library with independent modules to produce an\n *  executable, regardless of the license terms of these independent modules, and to\n *  copy and distribute the resulting executable under terms of your choice,\n *  provided that you also meet, for each linked independent module, the terms and\n *  conditions of the license of that module. An independent module is a module\n *  which is neither derived from nor based on this library. If you modify this\n *  library, you may extend this exception to your version of the library, but you\n *  are not obligated to do so. If you do not wish to do so, delete this exception\n *  statement from your version.\n *\n *  Copyright 2015 Daqri, LLC.\n *  Copyright 2002-2015 ARToolworks, Inc.\n *\n *  Author(s): Shinsaku Hiura, Hirokazu Kato, Philip Lamb\n *\n */\n/*******************************************************\n *\n * Author: Shinsaku Hiura, Hirokazu Kato\n *\n *         shinsaku@sys.es.osaka-u.ac.jp\n *         kato@sys.im.hiroshima-cu.ac.jp\n *\n * Revision: 2.1\n * Date: 99/07/16\n *\n *******************************************************/\n\n#include <stdio.h>\n#include <math.h>\n#ifndef __APPLE__\n#include <malloc.h>\n#else\n#include <stdlib.h>\n#endif\n#include <AR/ar.h>\n\nARMat *arMatrixAllocTrans(ARMat *source)\n{\n\tARMat *dest;\n\n\tdest = arMatrixAlloc(source->clm, source->row);\n\tif( dest == NULL ) return NULL;\n\n\tif( arMatrixTrans(dest, source) < 0 ) {\n\t\tarMatrixFree(dest);\n\t\treturn NULL;\n\t}\n\n\treturn dest;\n}\n\n#ifndef ARDOUBLE_IS_FLOAT\nARMatf *arMatrixAllocTransf(ARMatf *source)\n{\n\tARMatf *dest;\n\n\tdest = arMatrixAllocf(source->clm, source->row);\n\tif( dest == NULL ) return NULL;\n\n\tif( arMatrixTransf(dest, source) < 0 ) {\n\t\tarMatrixFreef(dest);\n\t\treturn NULL;\n\t}\n\n\treturn dest;\n}\n#endif","/*\n *  mDup.c\n *  ARToolKit5\n *\n *  This file is part of ARToolKit.\n *\n *  ARToolKit is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation, either version 3 of the License, or\n *  (at your option) any later version.\n *\n *  ARToolKit is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public License\n *  along with ARToolKit.  If not, see <http://www.gnu.org/licenses/>.\n *\n *  As a special exception, the copyright holders of this library give you\n *  permission to link this library with independent modules to produce an\n *  executable, regardless of the license terms of these independent modules, and to\n *  copy and distribute the resulting executable under terms of your choice,\n *  provided that you also meet, for each linked independent module, the terms and\n *  conditions of the license of that module. An independent module is a module\n *  which is neither derived from nor based on this library. If you modify this\n *  library, you may extend this exception to your version of the library, but you\n *  are not obligated to do so. If you do not wish to do so, delete this exception\n *  statement from your version.\n *\n *  Copyright 2015 Daqri, LLC.\n *  Copyright 2002-2015 ARToolworks, Inc.\n *\n *  Author(s): Shinsaku Hiura, Hirokazu Kato\n *\n */\n/*******************************************************\n *\n * Author: Shinsaku Hiura, Hirokazu Kato\n *\n *         shinsaku@sys.es.osaka-u.ac.jp\n *         kato@sys.im.hiroshima-cu.ac.jp\n *\n * Revision: 2.1\n * Date: 99/07/16\n *\n *******************************************************/\n\n#include <stdio.h>\n#include <math.h>\n#include <AR/ar.h>\n\nint arMatrixDup(ARMat *dest, ARMat *source)\n{\n\tint r,c;\n\n\tif(dest->row != source->row || dest->clm != source->clm) {\n\t\treturn -1;\n\t}\n\tfor(r = 0; r < source->row; r++) {\n\t\tfor(c = 0; c < source->clm; c++) {\n\t\t\tARELEM0(dest, r, c) = ARELEM0(source, r, c);\n\t\t}\n\t}\n\treturn 0;\n}\n","/*\n *  mFree.c\n *  ARToolKit5\n *\n *  This file is part of ARToolKit.\n *\n *  ARToolKit is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation, either version 3 of the License, or\n *  (at your option) any later version.\n *\n *  ARToolKit is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public License\n *  along with ARToolKit.  If not, see <http://www.gnu.org/licenses/>.\n *\n *  As a special exception, the copyright holders of this library give you\n *  permission to link this library with independent modules to produce an\n *  executable, regardless of the license terms of these independent modules, and to\n *  copy and distribute the resulting executable under terms of your choice,\n *  provided that you also meet, for each linked independent module, the terms and\n *  conditions of the license of that module. An independent module is a module\n *  which is neither derived from nor based on this library. If you modify this\n *  library, you may extend this exception to your version of the library, but you\n *  are not obligated to do so. If you do not wish to do so, delete this exception\n *  statement from your version.\n *\n *  Copyright 2015 Daqri, LLC.\n *  Copyright 2002-2015 ARToolworks, Inc.\n *\n *  Author(s): Shinsaku Hiura, Hirokazu Kato, Philip Lamb\n *\n */\n/*******************************************************\n *\n * Author: Shinsaku Hiura, Hirokazu Kato\n *\n *         shinsaku@sys.es.osaka-u.ac.jp\n *         kato@sys.im.hiroshima-cu.ac.jp\n *\n * Revision: 2.1\n * Date: 99/07/16\n *\n *******************************************************/\n\n#include <stdio.h>\n#include <math.h>\n#ifndef __APPLE__\n#include <malloc.h>\n#else \n#include <stdlib.h>\n#endif  \n#include <AR/ar.h>\n\nint arMatrixFree(ARMat *m)\n{\n    if (m) {\n        free(m->m);\n\t    free(m);\n    }\n\n\treturn 0;\n}\n\n#ifndef ARDOUBLE_IS_FLOAT\nint arMatrixFreef(ARMatf *m)\n{\n    if (m) {\n        free(m->m);\n\t    free(m);\n    }\n\n\treturn 0;\n}\n#endif","/*\n *  mMul.c\n *  ARToolKit5\n *\n *  This file is part of ARToolKit.\n *\n *  ARToolKit is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation, either version 3 of the License, or\n *  (at your option) any later version.\n *\n *  ARToolKit is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public License\n *  along with ARToolKit.  If not, see <http://www.gnu.org/licenses/>.\n *\n *  As a special exception, the copyright holders of this library give you\n *  permission to link this library with independent modules to produce an\n *  executable, regardless of the license terms of these independent modules, and to\n *  copy and distribute the resulting executable under terms of your choice,\n *  provided that you also meet, for each linked independent module, the terms and\n *  conditions of the license of that module. An independent module is a module\n *  which is neither derived from nor based on this library. If you modify this\n *  library, you may extend this exception to your version of the library, but you\n *  are not obligated to do so. If you do not wish to do so, delete this exception\n *  statement from your version.\n *\n *  Copyright 2015 Daqri, LLC.\n *  Copyright 2002-2015 ARToolworks, Inc.\n *\n *  Author(s): Shinsaku Hiura, Hirokazu Kato, Philip Lamb\n *\n */\n/*******************************************************\n *\n * Author: Shinsaku Hiura, Hirokazu Kato\n *\n *         shinsaku@sys.es.osaka-u.ac.jp\n *         kato@sys.im.hiroshima-cu.ac.jp\n *\n * Revision: 2.1\n * Date: 99/07/16\n *\n *******************************************************/\n\n#include <stdio.h>\n#include <math.h>\n#include <AR/ar.h>\n\nint arMatrixMul(ARMat *dest, ARMat *a, ARMat *b)\n{\n#if 0\n\tint r, c, i;\n\n\tif(a->clm != b->row || dest->row != a->row || dest->clm != b->clm) return -1;\n\n\tfor(r = 0; r < dest->row; r++) {\n\t\tfor(c = 0; c < dest->clm; c++) {\n\t\t\tARELEM0(dest, r, c) = 0.0;\n\t\t\tfor(i = 0; i < a->clm; i++) {\n\t\t\t\tARELEM0(dest, r, c) += ARELEM0(a, r, i) * ARELEM0(b, i, c);\n\t\t\t}\n\t\t}\n\t}\n#else\n    int       r, c, i;\n    ARdouble *p1, *p2, *p3;\n    \n    if(a->clm != b->row || dest->row != a->row || dest->clm != b->clm) return -1;\n    \n    p3 = dest->m;\n    for(r = 0; r < dest->row; r++) {\n        for(c = 0; c < dest->clm; c++) {\n            *p3 = 0.0;\n            p1 = &a->m[r*a->clm];\n            p2 = &b->m[c];\n            for(i = 0; i < a->clm; i++) {\n                *p3 += *p1 * *p2;\n                p1++;\n                p2 += b->clm;\n            }\n            p3++;\n        }\n    }\n#endif\n\n\treturn 0;\n}\n\n#ifndef ARDOUBLE_IS_FLOAT\nint arMatrixMulf(ARMatf *dest, ARMatf *a, ARMatf *b)\n{\n#if 0\n\tint r, c, i;\n\n\tif(a->clm != b->row || dest->row != a->row || dest->clm != b->clm) return -1;\n\n\tfor(r = 0; r < dest->row; r++) {\n\t\tfor(c = 0; c < dest->clm; c++) {\n\t\t\tARELEM0(dest, r, c) = 0.0;\n\t\t\tfor(i = 0; i < a->clm; i++) {\n\t\t\t\tARELEM0(dest, r, c) += ARELEM0(a, r, i) * ARELEM0(b, i, c);\n\t\t\t}\n\t\t}\n\t}\n#else\n    int       r, c, i;\n    float    *p1, *p2, *p3;\n    \n    if(a->clm != b->row || dest->row != a->row || dest->clm != b->clm) return -1;\n    \n    p3 = dest->m;\n    for(r = 0; r < dest->row; r++) {\n        for(c = 0; c < dest->clm; c++) {\n            *p3 = 0.0f;\n            p1 = &a->m[r*a->clm];\n            p2 = &b->m[c];\n            for(i = 0; i < a->clm; i++) {\n                *p3 += *p1 * *p2;\n                p1++;\n                p2 += b->clm;\n            }\n            p3++;\n        }\n    }\n#endif\n\n\treturn 0;\n}\n#endif","/*\n *  mPCA.c\n *  ARToolKit5\n *\n *  This file is part of ARToolKit.\n *\n *  ARToolKit is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation, either version 3 of the License, or\n *  (at your option) any later version.\n *\n *  ARToolKit is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public License\n *  along with ARToolKit.  If not, see <http://www.gnu.org/licenses/>.\n *\n *  As a special exception, the copyright holders of this library give you\n *  permission to link this library with independent modules to produce an\n *  executable, regardless of the license terms of these independent modules, and to\n *  copy and distribute the resulting executable under terms of your choice,\n *  provided that you also meet, for each linked independent module, the terms and\n *  conditions of the license of that module. An independent module is a module\n *  which is neither derived from nor based on this library. If you modify this\n *  library, you may extend this exception to your version of the library, but you\n *  are not obligated to do so. If you do not wish to do so, delete this exception\n *  statement from your version.\n *\n *  Copyright 2015 Daqri, LLC.\n *  Copyright 2002-2015 ARToolworks, Inc.\n *\n *  Author(s): Shinsaku Hiura, Hirokazu Kato\n *\n */\n\n#include <stdio.h>\n#include <math.h>\n#include <AR/ar.h>\n\n#define     VZERO           1e-16\n#define     EPS             1e-6\n#define     MAX_ITER        100\n\n#ifdef ARDOUBLE_IS_FLOAT\n#  define SQRT sqrtf\n#else\n#  define SQRT sqrt\n#endif\n\nstatic int EX(ARMat *input, ARVec *mean);\nstatic int CENTER(ARMat *inout, ARVec *mean);\nstatic int PCA(ARMat *input, ARMat *output, ARVec *ev);\nstatic int x_by_xt(ARMat *input, ARMat *output);\nstatic int xt_by_x(ARMat *input, ARMat *output);\nstatic int EV_create(ARMat *input, ARMat *u, ARMat *output, ARVec *ev);\nstatic int QRM(ARMat *u, ARVec *ev);\n\n\n/* === matrix definition ===\n\nInput:\n  <---- clm (Data dimention)--->\n  [ 10  20  30 ] ^\n  [ 20  10  15 ] |\n  [ 12  23  13 ] row\n  [ 20  10  15 ] |(Sample number)\n  [ 13  14  15 ] v\n\nEvec:\n  <---- clm (Eigen vector)--->\n  [ 10  20  30 ] ^\n  [ 20  10  15 ] |\n  [ 12  23  13 ] row\n  [ 20  10  15 ] |(Number of egen vec)\n  [ 13  14  15 ] v\n\nEv:\n  <---- clm (Number of eigen vector)--->\n  [ 10  20  30 ] eigen value\n\nMean:\n  <---- clm (Data dimention)--->\n  [ 10  20  30 ] mean value\n\n=========================== */\n\n\nint arMatrixPCA(ARMat *input, ARMat *evec, ARVec *ev, ARVec *mean)\n{\n    ARMat     *work;\n    ARdouble  srow, sum;\n    int     row, clm;\n    int     check, rval;\n    int     i;\n\n    row = input->row;\n    clm = input->clm;\n    check = (row < clm)? row: clm;\n    if (row < 2 || clm < 2) return (-1);\n    if (evec->clm != input->clm || evec->row != check) return (-1);\n    if (ev->clm   != check)      return (-1);\n    if (mean->clm != input->clm) return (-1);\n\n    work = arMatrixAllocDup(input);\n    if (work == NULL) return -1;\n\n    srow = sqrt((ARdouble)row);\n    if (EX(work, mean) < 0) {\n        arMatrixFree(work);\n        return (-1);\n    }\n    if (CENTER(work, mean) < 0) {\n        arMatrixFree(work);\n        return (-1);\n    }\n    for (i=0; i<row*clm; i++) work->m[i] /= srow;\n\n    rval = PCA(work, evec, ev);\n    arMatrixFree(work);\n\n    sum = 0.0;\n    for (i = 0; i < ev->clm; i++) sum += ev->v[i];\n    for (i = 0; i < ev->clm; i++) ev->v[i] /= sum;\n\n    return (rval);\n}\n\nint arMatrixPCA2(ARMat *input, ARMat *evec, ARVec *ev)\n{\n    ARMat   *work;\n/*    ARdouble  srow;   */\n    ARdouble  sum;\n    int     row, clm;\n    int     check, rval;\n    int     i;\n\n    row = input->row;\n    clm = input->clm;\n    check = (row < clm)? row: clm;\n    if (row < 2 || clm < 2) return (-1);\n    if (evec->clm != input->clm || evec->row != check) return (-1);\n    if (ev->clm   != check)      return (-1);\n\n    work = arMatrixAllocDup(input);\n    if (work == NULL) return -1;\n\n/*\n    srow = sqrt((ARdouble)row);\n    for(i=0; i<row*clm; i++) work->m[i] /= srow;\n*/\n\n    rval = PCA(work, evec, ev);\n    arMatrixFree(work);\n\n    sum = 0.0;\n    for (i = 0; i < ev->clm; i++) sum += ev->v[i];\n    for (i = 0; i < ev->clm; i++) ev->v[i] /= sum;\n\n    return (rval);\n}\n\nstatic int PCA(ARMat *input, ARMat *output, ARVec *ev)\n{\n    //COVHI10384\n    ARMat    *u = NULL;\n    ARdouble *m1, *m2;\n    int      row, clm, min;\n    int      i, j;\n\n    row = input->row;\n    clm = input->clm;\n    min = (clm < row)? clm: row;\n    if (row < 2 || clm < 2)        return (-1);\n    if (output->clm != input->clm) return (-1);\n    if (output->row != min)        return (-1);\n    if (ev->clm != min)            return (-1);\n\n    u = arMatrixAlloc(min, min);\n    if (u->row != min || u->clm != min) {\n        arMatrixFree(u);\n        return (-1);\n    }\n    if (row < clm) {\n        if (x_by_xt(input, u) < 0) {\n            arMatrixFree(u);\n            return (-1);\n        }\n    } else {\n        if (xt_by_x( input, u) < 0) {\n            arMatrixFree(u);\n            return (-1);\n        }\n    }\n\n    if (QRM(u, ev) < 0) {\n        arMatrixFree(u);\n        return (-1);\n    }\n\n    if (row < clm) {\n        if (EV_create( input, u, output, ev) < 0) {\n            arMatrixFree(u);\n            return (-1);\n        }\n    } else {\n        m1 = u->m;\n        m2 = output->m;\n        for (i = 0; i < min; i++) {\n            if (ev->v[i] < VZERO) break;\n            for (j = 0; j < min; j++) *(m2++) = *(m1++);\n        }\n        for (; i < min; i++) {\n            ev->v[i] = 0.0;\n            for (j = 0; j < min; j++) *(m2++) = 0.0;\n        }\n    }\n\n    arMatrixFree(u);\n    return (0);\n}\n\nstatic int EX(ARMat *input, ARVec *mean)\n{\n    ARdouble  *m, *v;\n    int     row, clm;\n    int     i, j;\n\n    row = input->row;\n    clm = input->clm;\n    if (row <= 0 || clm <= 0)  return (-1);\n    if (mean->clm != clm)      return (-1);\n\n    for (i = 0; i < clm; i++) mean->v[i] = 0.0;\n\n    m = input->m;\n    for (i = 0; i < row; i++) {\n        v = mean->v;\n        for (j = 0; j < clm; j++) *(v++) += *(m++);\n    }\n\n    for (i = 0; i < clm; i++) mean->v[i] /= row;\n\n    return (0);\n}\n\nstatic int CENTER(ARMat *inout, ARVec *mean)\n{\n    ARdouble  *m, *v;\n    int     row, clm;\n    int     i, j;\n\n    row = inout->row;\n    clm = inout->clm;\n    if (mean->clm != clm) return (-1);\n\n    m = inout->m;\n    for (i = 0; i < row; i++) {\n        v = mean->v;\n        for (j = 0; j < clm; j++) *(m++) -= *(v++);\n    }\n\n    return (0);\n}\n\nstatic int x_by_xt(ARMat *input, ARMat *output)\n{\n    ARdouble  *in1, *in2, *out;\n    int     row, clm;\n    int     i, j, k;\n\n    row = input->row;\n    clm = input->clm;\n    if (output->row != row || output->clm != row) return (-1);\n\n    out = output->m;\n    for (i = 0; i < row; i++) {\n        for (j = 0; j < row; j++) {\n            if (j < i) {\n                *out = output->m[j*row+i];\n            }\n            else {\n                in1 = &(input->m[clm*i]);\n                in2 = &(input->m[clm*j]);\n                *out = 0.0;\n                for (k = 0; k < clm; k++) {\n                    *out += *(in1++) * *(in2++);\n                }\n            }\n            out++;\n        }\n    }\n\n    return (0);\n}\n\nstatic int xt_by_x(ARMat *input, ARMat *output)\n{\n    ARdouble  *in1, *in2, *out;\n    int     row, clm;\n    int     i, j, k;\n\n    row = input->row;\n    clm = input->clm;\n    if (output->row != clm || output->clm != clm) return (-1);\n\n    out = output->m;\n    for (i = 0; i < clm; i++) {\n        for (j = 0; j < clm; j++) {\n            if (j < i) {\n                *out = output->m[j*clm+i];\n            }\n            else {\n                in1 = &(input->m[i]);\n                in2 = &(input->m[j]);\n                *out = 0.0;\n                for (k = 0; k < row; k++) {\n                    *out += *in1 * *in2;\n                    in1 += clm;\n                    in2 += clm;\n                }\n            }\n            out++;\n        }\n    }\n\n    return (0);\n}\n\nstatic int EV_create(ARMat *input, ARMat *u, ARMat *output, ARVec *ev)\n{\n    ARdouble  *m, *m1, *m2;\n    ARdouble  sum, work;\n    int     row, clm;\n    int     i, j, k;\n\n    row = input->row;\n    clm = input->clm;\n    if (row <= 0 || clm <= 0) return (-1);\n    if (u->row != row || u->clm != row) return (-1);\n    if (output->row != row || output->clm != clm) return (-1);\n    if (ev->clm != row) return (-1);\n\n    m = output->m;\n    for (i = 0; i < row; i++) {\n        if (ev->v[i] < VZERO) break;\n        work = 1 / sqrt(fabs(ev->v[i]));\n        for (j = 0; j < clm; j++) {\n            sum = 0.0;\n            m1 = &(u->m[i*row]);\n            m2 = &(input->m[j]);\n            for (k = 0; k < row; k++) {\n                sum += *m1 * *m2;\n                m1++;\n                m2 += clm;\n            }\n            *(m++) = sum * work;\n        }\n    }\n    for (; i < row; i++) {\n        ev->v[i] = 0.0;\n        for (j = 0; j < clm; j++) *(m++) = 0.0;\n    }\n\n    return (0);\n}\n\nstatic int QRM(ARMat *a, ARVec *dv)\n{\n    ARVec     *ev, ev1;\n    ARdouble  w, t, s, x, y, c;\n    ARdouble  *v1, *v2;\n    int     dim, iter;\n    int     i, j, k, h;\n\n    dim = a->row;\n    if (dim != a->clm || dim < 2) return (-1);\n    if (dv->clm != dim) return (-1);\n\n    ev = arVecAlloc(dim);\n    if (ev == NULL) return (-1);\n\n    ev1.clm = dim-1;\n    ev1.v = &(ev->v[1]);\n    if (arVecTridiagonalize(a, dv, &ev1) < 0) {\n        arVecFree(ev);\n        return (-1);\n    }\n\n    ev->v[0] = 0.0;\n    for (h = dim-1; h > 0; h--) {\n        j = h;\n        while (j>0 && fabs(ev->v[j]) > EPS*(fabs(dv->v[j-1])+fabs(dv->v[j]))) j--;\n        if (j == h) continue;\n\n        iter = 0;\n        do {\n            iter++;\n            if (iter > MAX_ITER) break;\n            \n            w = (dv->v[h-1] - dv->v[h]) / 2;\n            t = ev->v[h] * ev->v[h];\n            s = sqrt(w*w+t);\n            if (w < 0) s = -s;\n            x = dv->v[j] - dv->v[h] + t/(w+s);\n            y = ev->v[j+1];\n            for (k = j; k < h; k++) {\n                if (fabs(x) >= fabs(y)) {\n                    if (fabs(x) > VZERO) {\n                        t = -y / x;\n                        c = 1 / sqrt(t*t+1);\n                        s = t * c;\n                    } else{\n                        c = 1.0;\n                        s = 0.0;\n                    }\n                } else{\n                    t = -x / y;\n                    s = 1.0 / sqrt(t*t+1);\n                    c = t * s;\n                }\n                w = dv->v[k] - dv->v[k+1];\n                t = (w * s + 2 * c * ev->v[k+1]) * s;\n                dv->v[k]   -= t;\n                dv->v[k+1] += t;\n                if( k > j) ev->v[k] = c * ev->v[k] - s * y;\n                ev->v[k+1] += s * (c * w - 2 * s * ev->v[k+1]);\n                \n                for (i = 0; i < dim; i++) {\n                    x = a->m[k*dim+i];\n                    y = a->m[(k+1)*dim+i];\n                    a->m[k*dim+i]     = c * x - s * y;\n                    a->m[(k+1)*dim+i] = s * x + c * y;\n                }\n                if (k < h-1) {\n                    x = ev->v[k+1];\n                    y = -s * ev->v[k+2];\n                    ev->v[k+2] *= c;\n                }\n            }\n        } while (fabs(ev->v[h]) > EPS*(fabs(dv->v[h-1])+fabs(dv->v[h])));\n    }\n\n    for (k = 0; k < dim-1; k++) {\n        h = k;\n        t = dv->v[h];\n        for (i = k+1; i < dim; i++) {\n            if (dv->v[i] > t) {\n                h = i;\n                t = dv->v[h];\n            }\n        }\n        dv->v[h] = dv->v[k];\n        dv->v[k] = t;\n        v1 = &(a->m[h*dim]);\n        v2 = &(a->m[k*dim]);\n        for (i = 0; i < dim; i++) {\n            w = *v1;\n            *v1 = *v2;\n            *v2 = w;\n            v1++;\n            v2++;\n        }\n    }\n\n    arVecFree(ev);\n    return (0);\n}\n","//\n//  orientation_assignment.cpp\n//  ARToolKit5\n//\n//  This file is part of ARToolKit.\n//\n//  ARToolKit is free software: you can redistribute it and/or modify\n//  it under the terms of the GNU Lesser General Public License as published by\n//  the Free Software Foundation, either version 3 of the License, or\n//  (at your option) any later version.\n//\n//  ARToolKit is distributed in the hope that it will be useful,\n//  but WITHOUT ANY WARRANTY; without even the implied warranty of\n//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n//  GNU Lesser General Public License for more details.\n//\n//  You should have received a copy of the GNU Lesser General Public License\n//  along with ARToolKit.  If not, see <http://www.gnu.org/licenses/>.\n//\n//  As a special exception, the copyright holders of this library give you\n//  permission to link this library with independent modules to produce an\n//  executable, regardless of the license terms of these independent modules, and to\n//  copy and distribute the resulting executable under terms of your choice,\n//  provided that you also meet, for each linked independent module, the terms and\n//  conditions of the license of that module. An independent module is a module\n//  which is neither derived from nor based on this library. If you modify this\n//  library, you may extend this exception to your version of the library, but you\n//  are not obligated to do so. If you do not wish to do so, delete this exception\n//  statement from your version.\n//\n//  Copyright 2013-2015 Daqri, LLC.\n//\n//  Author(s): Chris Broaddus\n//\n\n#include \"orientation_assignment.h\"\n#include \"gradients.h\"\n\n#include <framework/error.h>\n#include <math/indexing.h>\n#include <math/polynomial.h>\n#include <math/math_utils.h>\n#include <math/math_io.h>\n\nusing namespace vision;\n\nOrientationAssignment::OrientationAssignment()\n: mNumOctaves(0)\n, mNumScalesPerOctave(0)\n, mGaussianExpansionFactor(0)\n, mSupportRegionExpansionFactor(0)\n, mNumSmoothingIterations(0)\n, mPeakThreshold(0) {\n}\n\nOrientationAssignment::~OrientationAssignment() {}\n\nvoid OrientationAssignment::alloc(size_t fine_width,\n                                  size_t fine_height,\n                                  int num_octaves,\n                                  int num_scales_per_octave,\n                                  int num_bins,\n                                  float gaussian_expansion_factor,\n                                  float support_region_expansion_factor,\n                                  int num_smoothing_iterations,\n                                  float peak_threshold) {\n    mNumOctaves = num_octaves;\n    mNumScalesPerOctave = num_scales_per_octave;\n    mNumBins = num_bins;\n    mGaussianExpansionFactor = gaussian_expansion_factor;\n    mSupportRegionExpansionFactor = support_region_expansion_factor;\n    mNumSmoothingIterations = num_smoothing_iterations;\n    mPeakThreshold = peak_threshold;\n    \n    mHistogram.resize(num_bins);\n    \n    // Allocate gradient images\n    mGradients.resize(mNumOctaves*mNumScalesPerOctave);\n    for(size_t i = 0; i < num_octaves; i++) {\n        for(size_t j = 0; j < num_scales_per_octave; j++) {\n            mGradients[i*num_scales_per_octave+j].alloc(IMAGE_F32,\n                                                        fine_width>>i,\n                                                        fine_height>>i,\n                                                        AUTO_STEP,\n                                                        2);\n        }\n    }\n}\n\nvoid OrientationAssignment::computeGradients(const GaussianScaleSpacePyramid* pyramid) {\n    // Loop over each pyramid image and compute the gradients\n    for(size_t i = 0; i < pyramid->images().size(); i++) {\n        const Image& im = pyramid->images()[i];\n\n        // Compute gradient image\n        ASSERT(im.width() == im.step()/sizeof(float), \"Step size must be equal to width for now\");\n        ComputePolarGradients(mGradients[i].get<float>(),\n                              im.get<float>(),\n                              im.width(),\n                              im.height());\n    }\n}\n\nvoid OrientationAssignment::compute(float* angles,\n                                    int& num_angles,\n                                    int octave,\n                                    int scale,\n                                    float x,\n                                    float y,\n                                    float sigma) {  \n    int xi, yi;\n    float radius;\n    float radius2;\n    int x0, y0;\n    int x1, y1;\n    float max_height;\n    float gw_sigma, gw_scale;\n    \n    ASSERT(x >= 0, \"x must be positive\");\n    ASSERT(x < mGradients[octave*mNumScalesPerOctave+scale].width(), \"x must be less than the image width\");\n    ASSERT(y >= 0, \"y must be positive\");\n    ASSERT(y < mGradients[octave*mNumScalesPerOctave+scale].height(), \"y must be less than the image height\");\n    \n    int level = octave*mNumScalesPerOctave+scale;\n    const Image& g = mGradients[level];\n    ASSERT(g.channels() == 2, \"Number of channels should be 2\");\n    \n    max_height = 0;\n    num_angles = 0;\n    \n    xi = (int)(x+0.5f);\n    yi = (int)(y+0.5f);\n    \n    // Check that the position is with the image bounds\n    if(xi < 0 ||\n       xi >= g.width() ||\n       yi < 0 ||\n       yi >= g.height())\n    {\n        return;\n    }\n    \n    gw_sigma = max2<float>(1.f, mGaussianExpansionFactor*sigma);\n    gw_scale = -1.f/(2*sqr(gw_sigma));\n    \n    // Radius of the support region\n    radius  = mSupportRegionExpansionFactor*gw_sigma;\n    radius2 = std::ceil(sqr(radius));\n    \n    // Box around feature point\n    x0 = xi-(int)(radius+0.5f);\n    x1 = xi+(int)(radius+0.5f);\n    y0 = yi-(int)(radius+0.5f);\n    y1 = yi+(int)(radius+0.5f);\n    \n    // Clip the box to be within the bounds of the image\n    x0 = max2<int>(0, x0);\n    x1 = min2<int>(x1, (int)g.width()-1);\n    y0 = max2<int>(0, y0);\n    y1 = min2<int>(y1, (int)g.height()-1);\n    \n    // Zero out the orientation histogram\n    ZeroVector(&mHistogram[0], mHistogram.size());\n    \n    // Build up the orientation histogram\n    for(int yp = y0; yp <= y1; yp++) {\n        float dy = yp-y;\n        float dy2 = sqr(dy);\n        \n        const float* y_ptr = g.get<float>(yp);\n        \n        for(int xp = x0; xp <= x1; xp++) {\n            float dx = xp-x;\n            float r2 = sqr(dx)+dy2;\n            \n            // Only use the gradients within the circular window\n            if(r2 > radius2) {\n                continue;\n            }\n            \n            const float* g = &y_ptr[xp<<1];\n            const float& angle = g[0];\n            const float& mag   = g[1];\n            \n            // Compute the gaussian weight based on distance from center of keypoint\n            float w = fastexp6(r2*gw_scale);\n            \n            // Compute the sub-bin location\n            float fbin  = mNumBins*angle*ONE_OVER_2PI;\n            \n            // Vote to the orientation histogram with a bilinear update\n            bilinear_histogram_update(&mHistogram[0], fbin, w*mag, mNumBins);\n        }\n    }\n    \n    // The orientation histogram is smoothed with a Gaussian\n    for(int iter = 0; iter < mNumSmoothingIterations; iter++) {\n        // sigma=1\n        const float kernel[] = {\n            0.274068619061197f,\n            0.451862761877606f,\n            0.274068619061197f};\n        SmoothOrientationHistogram(&mHistogram[0], &mHistogram[0], mNumBins, kernel);\n    }\n    \n    // Find the peak of the histogram.\n    for(int i = 0; i < mNumBins; i++) {\n        if(mHistogram[i] > max_height) {\n            max_height = mHistogram[i];\n        }\n    }\n    \n    // The max height should be positive.\n    if(max_height == 0) {\n        return;\n    }\n    \n    ASSERT(max_height > 0, \"Maximum bin should be positive\");\n    \n    // Find all the peaks.\n    for(int i = 0; i < mNumBins; i++) {\n        const float p0[]  = {(float)i, mHistogram[i]};\n        const float pm1[] = {(float)(i-1), mHistogram[(i-1+mNumBins)%mNumBins]};\n        const float pp1[] = {(float)(i+1), mHistogram[(i+1+mNumBins)%mNumBins]};\n        \n        // Ensure that \"p0\" is a relative peak w.r.t. the two neighbors\n        if((mHistogram[i] > mPeakThreshold*max_height) && (p0[1] > pm1[1]) && (p0[1] > pp1[1])) {\n            float A, B, C, fbin;\n            \n            // The default sub-pixel bin location is the discrete location if the quadratic\n            // fitting fails.\n            fbin = i;\n            \n            // Fit a quatratic to the three bins\n            if(Quadratic3Points(A, B, C, pm1, p0, pp1)) {\n                // If \"QuadraticCriticalPoint\" fails, then \"fbin\" is not updated.\n                QuadraticCriticalPoint(fbin, A, B, C);\n            }\n            \n            // The sub-pixel angle needs to be in the range [0,2*pi)\n            angles[num_angles] = std::fmod((2.f*PI)*((fbin+0.5f+(float)mNumBins)/(float)mNumBins), 2.f*PI);\n            \n            // Increment the number of angles\n            num_angles++;\n        }\n    }\n}","//\n//  indexing.h\n//  ARToolKit5\n//\n//  This file is part of ARToolKit.\n//\n//  ARToolKit is free software: you can redistribute it and/or modify\n//  it under the terms of the GNU Lesser General Public License as published by\n//  the Free Software Foundation, either version 3 of the License, or\n//  (at your option) any later version.\n//\n//  ARToolKit is distributed in the hope that it will be useful,\n//  but WITHOUT ANY WARRANTY; without even the implied warranty of\n//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n//  GNU Lesser General Public License for more details.\n//\n//  You should have received a copy of the GNU Lesser General Public License\n//  along with ARToolKit.  If not, see <http://www.gnu.org/licenses/>.\n//\n//  As a special exception, the copyright holders of this library give you\n//  permission to link this library with independent modules to produce an\n//  executable, regardless of the license terms of these independent modules, and to\n//  copy and distribute the resulting executable under terms of your choice,\n//  provided that you also meet, for each linked independent module, the terms and\n//  conditions of the license of that module. An independent module is a module\n//  which is neither derived from nor based on this library. If you modify this\n//  library, you may extend this exception to your version of the library, but you\n//  are not obligated to do so. If you do not wish to do so, delete this exception\n//  statement from your version.\n//\n//  Copyright 2013-2015 Daqri, LLC.\n//\n//  Author(s): Chris Broaddus\n//\n\n#pragma once\n\n#include <memory>\n#include <cstddef>\n#include <string.h>\nnamespace vision {\n\n    template<typename T>\n    inline void ZeroVector3(T* x) {\n        memset(x, 0, sizeof(T)*3);\n    }\n    \n    template<typename T>\n    inline void ZeroVector(T* x, size_t num_elements) {\n        memset(x, 0, sizeof(T)*num_elements);\n    }\n\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    // min/max\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    \n    template<typename T>\n    inline T max2(T a, T b) {\n        return a > b ? a : b;\n    }\n    \n    template<typename T>\n    inline T min2(T a, T b) {\n        return a < b ? a : b;\n    }\n    \n\ttemplate<typename T>\n\tinline T min3(T x, T y, T z) {\n\t\treturn min2(min2(x, y), z);\n\t}\n\t\n\ttemplate<typename T>\n\tinline T min4(T a1, T a2, T a3, T a4) {\n\t\treturn min2(min3(a1, a2, a3), a4);\n\t}\n    \n    ////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    // MaxIndex\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    \n    template<typename T>\n    inline int MaxIndex2(const T x[2]) {\n        int index = 0;\n        if(x[1] > x[index]) index = 1;\n        return index;\n    }\n    \n    template<typename T>\n    inline int MaxIndex3(const T x[3]) {\n        int index = 0;\n        if(x[1] > x[index]) index = 1;\n        if(x[2] > x[index]) index = 2;\n        return index;\n    }\n    \n    template<typename T>\n    inline int MaxIndex4(const T x[4]) {\n        int index = 0;\n        if(x[1] > x[index]) index = 1;\n        if(x[2] > x[index]) index = 2;\n        if(x[3] > x[index]) index = 3;\n        return index;\n    }\n    \n    template<typename T>\n    inline int MaxIndex5(const T x[5]) {\n        int index = 0;\n        if(x[1] > x[index]) index = 1;\n        if(x[2] > x[index]) index = 2;\n        if(x[3] > x[index]) index = 3;\n        if(x[4] > x[index]) index = 4;\n        return index;\n    }\n    \n    template<typename T>\n    inline int MaxIndex6(const T x[6]) {\n        int index = 0;\n        if(x[1] > x[index]) index = 1;\n        if(x[2] > x[index]) index = 2;\n        if(x[3] > x[index]) index = 3;\n        if(x[4] > x[index]) index = 4;\n        if(x[5] > x[index]) index = 5;\n        return index;\n    }\n    \n    template<typename T>\n    inline int MaxIndex7(const T x[7]) {\n        int index = 0;\n        if(x[1] > x[index]) index = 1;\n        if(x[2] > x[index]) index = 2;\n        if(x[3] > x[index]) index = 3;\n        if(x[4] > x[index]) index = 4;\n        if(x[5] > x[index]) index = 5;\n        if(x[6] > x[index]) index = 6;\n        return index;\n    }\n    \n    template<typename T>\n    inline int MaxIndex8(const T x[8]) {\n        int index = 0;\n        if(x[1] > x[index]) index = 1;\n        if(x[2] > x[index]) index = 2;\n        if(x[3] > x[index]) index = 3;\n        if(x[4] > x[index]) index = 4;\n        if(x[5] > x[index]) index = 5;\n        if(x[6] > x[index]) index = 6;\n        if(x[7] > x[index]) index = 7;\n        return index;\n    }\n    \n    template<typename T>\n    inline int MaxIndex9(const T x[9]) {\n        int index = 0;\n        if(x[1] > x[index]) index = 1;\n        if(x[2] > x[index]) index = 2;\n        if(x[3] > x[index]) index = 3;\n        if(x[4] > x[index]) index = 4;\n        if(x[5] > x[index]) index = 5;\n        if(x[6] > x[index]) index = 6;\n        if(x[7] > x[index]) index = 7;\n        if(x[8] > x[index]) index = 8;\n        return index;\n    }\n    \n    /**\n     * Vector copy functions.\n     */\n    \n    template<typename T>\n    inline void CopyVector2(T dst[2], const T src[2]) {\n        memcpy(dst, src, sizeof(T)*2);\n    }\n    template<typename T>\n    inline void CopyVector3(T dst[3], const T src[3]) {\n        memcpy(dst, src, sizeof(T)*3);\n    }\n    template<typename T>\n    inline void CopyVector4(T dst[4], const T src[4]) {\n        memcpy(dst, src, sizeof(T)*4);\n    }\n    template<typename T>\n    inline void CopyVector5(T dst[5], const T src[5]) {\n        memcpy(dst, src, sizeof(T)*5);\n    }\n    template<typename T>\n    inline void CopyVector6(T dst[6], const T src[6]) {\n        memcpy(dst, src, sizeof(T)*6);\n    }\n    template<typename T>\n    inline void CopyVector7(T dst[7], const T src[7]) {\n        memcpy(dst, src, sizeof(T)*7);\n    }\n    template<typename T>\n    inline void CopyVector8(T dst[8], const T src[8]) {\n        memcpy(dst, src, sizeof(T)*8);\n    }\n    template<typename T>\n    inline void CopyVector9(T dst[9], const T src[9]) {\n        memcpy(dst, src, sizeof(T)*9);\n    }\n    \n    template<typename T>\n    inline void CopyVector(T* dst, const T* src, size_t size) {\n        memcpy(dst, src, sizeof(T)*size);\n    }\n    \n    /**\n     * Swap the contents of two vectors.\n     */\n    template<typename T>\n    inline void Swap9(T a[9], T b[9]) {\n        T tmp;\n        tmp = *a; *a++ = *b; *b++ = tmp;\n        tmp = *a; *a++ = *b; *b++ = tmp;\n        tmp = *a; *a++ = *b; *b++ = tmp;\n        tmp = *a; *a++ = *b; *b++ = tmp;\n        tmp = *a; *a++ = *b; *b++ = tmp;\n        tmp = *a; *a++ = *b; *b++ = tmp;\n        tmp = *a; *a++ = *b; *b++ = tmp;\n        tmp = *a; *a++ = *b; *b++ = tmp;\n        tmp = *a; *a++ = *b; *b++ = tmp;\n    }\n    \n    /**\n     * Set a bit in a bit string represented as an array of UNSIGNED CHAR bytes. The ordering\n     * on the bits is as follows:\n     *\n     * [7 6 5 4 3 2 1 0, 15 14 13 12 11 10 9 8, 23 22 21 20 19 18 17 15, ...] \n     */\n    inline void bitstring_set_bit(unsigned char* bitstring, int pos, unsigned char bit) {\n        bitstring[pos/8] |= (bit << (pos%8));\n    }\n    inline unsigned char bitstring_get_bit(const unsigned char* bitstring, int pos) {\n        return (bitstring[pos/8] >> (pos%8)) & 1;\n    }\n    \n    /**\n     * Create a sequential vector {x0+0, x0+1, x0+2, ...}\n     */\n    template<typename T>\n    inline void SequentialVector(T* x, int n, T x0) {\n        if(n < 1) {\n            return;\n        }\n        x[0] = x0;\n        for(int i = 1; i < n; i++) {\n            x[i] = x[i-1]+1;\n        }\n    }\n    \n} // vision\n","//\n//  orientation_assignment.h\n//  ARToolKit5\n//\n//  This file is part of ARToolKit.\n//\n//  ARToolKit is free software: you can redistribute it and/or modify\n//  it under the terms of the GNU Lesser General Public License as published by\n//  the Free Software Foundation, either version 3 of the License, or\n//  (at your option) any later version.\n//\n//  ARToolKit is distributed in the hope that it will be useful,\n//  but WITHOUT ANY WARRANTY; without even the implied warranty of\n//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n//  GNU Lesser General Public License for more details.\n//\n//  You should have received a copy of the GNU Lesser General Public License\n//  along with ARToolKit.  If not, see <http://www.gnu.org/licenses/>.\n//\n//  As a special exception, the copyright holders of this library give you\n//  permission to link this library with independent modules to produce an\n//  executable, regardless of the license terms of these independent modules, and to\n//  copy and distribute the resulting executable under terms of your choice,\n//  provided that you also meet, for each linked independent module, the terms and\n//  conditions of the license of that module. An independent module is a module\n//  which is neither derived from nor based on this library. If you modify this\n//  library, you may extend this exception to your version of the library, but you\n//  are not obligated to do so. If you do not wish to do so, delete this exception\n//  statement from your version.\n//\n//  Copyright 2013-2015 Daqri, LLC.\n//\n//  Author(s): Chris Broaddus\n//\n\n#pragma once\n\n#include <framework/image.h>\n#include <framework/error.h>\n#include <vector>\n\n#include \"gaussian_scale_space_pyramid.h\"\n\nnamespace vision {\n    \n    /**\n     * Implements orientation assignment to feature points based on dominant gradients. \n     */\n    class OrientationAssignment {\n    public:\n        \n        OrientationAssignment();\n        ~OrientationAssignment();\n        \n        /**\n         * Allocate memory.\n         */\n        void alloc(size_t fine_width,\n                   size_t fine_height,\n                   int num_octaves,\n                   int num_scales_per_octave,\n                   int num_bins,\n                   float gaussian_expansion_factor,\n                   float support_region_expansion_factor,\n                   int num_smoothing_iterations,\n                   float peak_threshold);\n        \n        /**\n         * Compute the gradients given a pyramid.\n         */\n        void computeGradients(const GaussianScaleSpacePyramid* pyramid);\n        \n        /**\n         * Compute orientations for a keypont.\n         */\n        void compute(float* angles,\n                     int& num_angles,\n                     int octave,\n                     int scale,\n                     float x,\n                     float y,\n                     float sigma);\n        \n        /**\n         * @return Vector of images.\n         */\n        inline const std::vector<Image>& images() const { return mGradients; }\n        \n        /**\n         * Get a gradient image at an index.\n         */\n        inline const Image& get(size_t i) const { return mGradients[i]; }\n        \n    private:\n        \n        int mNumOctaves;\n        int mNumScalesPerOctave;\n        \n        // Number of bins in the histogram\n        int mNumBins;\n        \n        // Factor to expand the Gaussian weighting function. The Gaussian sigma is computed\n        // by expanding the feature point scale. The feature point scale represents the isometric\n        // size of the feature. \n        float mGaussianExpansionFactor;\n        \n        // Factor to expand the support region. This factor is multipled by the expanded\n        // Gaussian sigma. It essentially acts at the \"window\" to collect gradients in.\n        float mSupportRegionExpansionFactor;\n        \n        // Number of binomial smoothing iterations of the orientation histogram. The histogram\n        // is smoothed before find the peaks.\n        int mNumSmoothingIterations;\n        \n        // All the supporting peaks which are X percent of the absolute peak are considered\n        // dominant orientations. \n        float mPeakThreshold;\n        \n        // Orientation histogram\n        std::vector<float> mHistogram;\n        \n        // Vector of gradient images\n        std::vector<Image> mGradients;\n        \n    }; // OrientationAssignment\n    \n    /**\n     * Update a histogram with bilinear interpolation.\n     *\n     * @param[in/out] hist Histogram\n     * @param[in] fbin Decimal bin position to vote\n     * @param[in] magnitude Magnitude of the vote\n     * @param[in] num_bin Number of bins in the histogram\n     */\n    inline void bilinear_histogram_update(float* hist,\n                                          float fbin,\n                                          float magnitude,\n                                          int num_bins) {\n        ASSERT(hist != NULL, \"Histogram pointer is NULL\");\n        ASSERT((fbin+0.5f) > 0 && (fbin-0.5f) < num_bins, \"Decimal bin position index out of range\");\n        ASSERT(magnitude >= 0, \"Magnitude cannot be negative\");\n        ASSERT(num_bins >= 0, \"Number bins must be positive\");\n        \n        int bin = (int)std::floor(fbin-0.5f);\n        float w2 = fbin-(float)bin-0.5f;\n        float w1 = (1.f-w2);\n        int b1 = (bin+num_bins)%num_bins;\n        int b2 = (bin+1)%num_bins;\n        \n        ASSERT(w1 >= 0, \"w1 must be positive\");\n        ASSERT(w2 >= 0, \"w2 must be positive\");        \n        ASSERT(b1 >= 0 && b1 < num_bins, \"b1 bin index out of range\");\n        ASSERT(b2 >= 0 && b2 < num_bins, \"b2 bin index out of range\");\n        \n        // Vote to 2 weighted bins\n        hist[b1] += w1*magnitude;\n        hist[b2] += w2*magnitude;\n    }\n    \n    /**\n     * Smooth the orientation histogram with a kernel.\n     *\n     * @param[out] y Destination histogram (in-place processing supported) \n     * @param[in] x Source histogram\n     * @param[in] kernel\n     */\n    template<typename T>\n    inline void SmoothOrientationHistogram(T* y, const T* x, size_t n, const T kernel[3]) {\n        T first = x[0];\n        T prev = x[n-1];\n        for(size_t i = 0; i < n-1; i++) {\n            T cur = x[i];\n            y[i] = kernel[0]*prev + kernel[1]*cur + kernel[2]*x[i+1];\n            prev = cur;\n        }\n        y[n-1] = kernel[0]*prev + kernel[1]*x[n-1] + kernel[2]*first;\n    }\n    \n} // vision\n","//\n//  visual_database.h\n//  ARToolKit5\n//\n//  This file is part of ARToolKit.\n//\n//  ARToolKit is free software: you can redistribute it and/or modify\n//  it under the terms of the GNU Lesser General Public License as published by\n//  the Free Software Foundation, either version 3 of the License, or\n//  (at your option) any later version.\n//\n//  ARToolKit is distributed in the hope that it will be useful,\n//  but WITHOUT ANY WARRANTY; without even the implied warranty of\n//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n//  GNU Lesser General Public License for more details.\n//\n//  You should have received a copy of the GNU Lesser General Public License\n//  along with ARToolKit.  If not, see <http://www.gnu.org/licenses/>.\n//\n//  As a special exception, the copyright holders of this library give you\n//  permission to link this library with independent modules to produce an\n//  executable, regardless of the license terms of these independent modules, and to\n//  copy and distribute the resulting executable under terms of your choice,\n//  provided that you also meet, for each linked independent module, the terms and\n//  conditions of the license of that module. An independent module is a module\n//  which is neither derived from nor based on this library. If you modify this\n//  library, you may extend this exception to your version of the library, but you\n//  are not obligated to do so. If you do not wish to do so, delete this exception\n//  statement from your version.\n//\n//  Copyright 2013-2015 Daqri, LLC.\n//\n//  Author(s): Chris Broaddus\n//\n\n#pragma once\n\n#include <framework/image.h>\n#include <framework/exception.h>\n#include <detectors/DoG_scale_invariant_detector.h>\n#include <matchers/keyframe.h>\n#include <matchers/feature_matcher-inline.h>\n#include <matchers/hough_similarity_voting.h>\n#include <homography_estimation/robust_homography.h>\n#include <utils/point.h>\n#include <math/homography.h>\n#include <math/indexing.h>\n\n#include <vector>\n#include <memory>\n#include <unordered_map>\n\n#include \"feature_point.h\"\n\n#ifdef USE_OPENCV\n#  include <opencv2/calib3d/calib3d.hpp>\n#endif\n\nnamespace vision {\n\n    /**\n     * The visual database provides functionality to insert and query images.\n     */\n    template<typename FEATURE_EXTRACTOR, typename STORE, typename MATCHER>\n    class VisualDatabase {\n    public:\n        \n        typedef int id_t;\n        \n        typedef Keyframe<96> keyframe_t;\n        typedef std::shared_ptr<keyframe_t> keyframe_ptr_t;\n        typedef std::unordered_map<id_t, keyframe_ptr_t> keyframe_map_t;\n        \n        typedef BinomialPyramid32f pyramid_t;\n        typedef DoGScaleInvariantDetector detector_t;\n        \n        VisualDatabase();\n        ~VisualDatabase();\n        \n        /**\n         * Add an image to the database with a specific ID.\n         */\n        void addImage(const Image& image, id_t id) throw(Exception);\n        \n        /**\n         * Add an image to the database with a specific ID.\n         */\n        void addImage(const GaussianScaleSpacePyramid* pyramid, id_t id) throw(Exception);\n        \n        /**\n         * Add a keyframe to the database.\n         */\n        void addKeyframe(keyframe_ptr_t keyframe , id_t id) throw(Exception);\n    \n        /**\n         * Query the visual database.\n         */\n        bool query(const Image& image) throw(Exception);\n        \n        /**\n         * Query the visual database.\n         */\n        bool query(const GaussianScaleSpacePyramid* pyramid) throw(Exception);\n        bool query(const keyframe_t* query_keyframe) throw(Exception);\n        \n        /**\n         * Erase an ID.\n         */\n        bool erase(id_t id);\n        \n        /**\n         * @return Keyframe\n         */\n        const keyframe_ptr_t keyframe(id_t id) {\n            typename keyframe_map_t::const_iterator it = mKeyframeMap.find(id);\n            if(it != mKeyframeMap.end()) {\n                return it->second;\n            } else {\n                return keyframe_ptr_t();\n            }\n        }\n        \n        /**\n         * @return Query store\n         */\n        const keyframe_ptr_t queryKeyframe() const { return mQueryKeyframe; }\n        \n        const size_t databaseCount() const { return mKeyframeMap.size(); }\n        \n        /**\n         * @return Matcher\n         */\n        const MATCHER& matcher() const { return mMatcher; }\n        \n        /**\n         * @return Feature extractor\n         */\n        const FEATURE_EXTRACTOR& featureExtractor() const { return mFeatureExtractor; }\n        \n        /**\n         * @return Inlier\n         */\n        const matches_t& inliers() const { return mMatchedInliers; }\n        \n        /**\n         * Get the mathced id.\n         */\n        inline id_t matchedId() const { return mMatchedId; }\n        \n        /**\n         * @return Matched geometry matrix\n         */\n        const float* matchedGeometry() const { return mMatchedGeometry; }\n        \n        /**\n         * Get the detector.\n         */\n        inline detector_t& detector() { return mDetector; }\n        inline const detector_t& detector() const { return mDetector; }\n        \n        /**\n         * Set/Get minimum number of inliers.\n         */\n        inline void setMinNumInliers(size_t n) { mMinNumInliers = n; }\n        inline size_t minNumInliers() const { return mMinNumInliers; }\n        \n    private:\n        \n        size_t mMinNumInliers;\n        float mHomographyInlierThreshold;\n        \n        // Set to true if the feature index is enabled\n        bool mUseFeatureIndex;\n        \n        matches_t mMatchedInliers;\n        id_t mMatchedId;\n        float mMatchedGeometry[9];\n        \n        keyframe_ptr_t mQueryKeyframe;\n    \n        // Map of keyframe\n        keyframe_map_t mKeyframeMap;\n        \n        // Pyramid builder\n        pyramid_t mPyramid;\n        \n        // Interest point detector (DoG, etc)\n        detector_t mDetector;\n        \n        // Feature Extractor (FREAK, etc).\n        FEATURE_EXTRACTOR mFeatureExtractor;\n        \n        // Feature matcher\n        MATCHER mMatcher;\n        \n        // Similarity voter\n        HoughSimilarityVoting mHoughSimilarityVoting;\n        \n        // Robust homography estimation\n        RobustHomography<float> mRobustHomography;\n        \n    }; // VisualDatabase\n    \n    /**\n     * Find feature points in an image.\n     */\n    template<typename FEATURE_EXTRACTOR, int NUM_BYTES_PER_FEATURE>\n    void FindFeatures(Keyframe<NUM_BYTES_PER_FEATURE>* keyframe,\n                      const GaussianScaleSpacePyramid* pyramid,\n                      DoGScaleInvariantDetector* detector,\n                      FEATURE_EXTRACTOR* extractor) {\n        ASSERT(pyramid, \"Pyramid is NULL\");\n        ASSERT(detector, \"Detector is NULL\");\n        ASSERT(pyramid->images().size() > 0, \"Pyramid is empty\");\n        ASSERT(pyramid->images()[0].width() == detector->width(), \"Pyramid and detector size mismatch\");\n        ASSERT(pyramid->images()[0].height() == detector->height(), \"Pyramid and detector size mismatch\");\n        \n        //\n        // Detect feature points\n        //\n        \n        detector->detect(pyramid);\n        \n        //\n        // Copy the points\n        //\n        \n        std::vector<FeaturePoint> points(detector->features().size());\n        for(size_t i = 0; i < detector->features().size(); i++) {\n            const DoGScaleInvariantDetector::FeaturePoint& p = detector->features()[i];\n            points[i] = FeaturePoint(p.x, p.y, p.angle, p.sigma, p.score > 0);\n        }\n        \n        //\n        // Extract features\n        //\n        \n        extractor->extract(keyframe->store(), pyramid, points);\n    }\n    \n    /**\n     * Check if a homography is valid based on some heuristics.\n     */\n    inline bool CheckHomographyHeuristics(float H[9], int refWidth, int refHeight) {\n        float p0p[2];\n        float p1p[2];\n        float p2p[2];\n        float p3p[2];\n        \n        float Hinv[9];\n        if(!MatrixInverse3x3<float>(Hinv, H, 1e-5)) {\n            return false;\n        }\n        \n        const float p0[] = {0, 0};\n        const float p1[] = {(float)refWidth, 0};\n        const float p2[] = {(float)refWidth, (float)refHeight};\n        const float p3[] = {0, (float)refHeight};\n        \n        MultiplyPointHomographyInhomogenous(p0p, Hinv, p0);\n        MultiplyPointHomographyInhomogenous(p1p, Hinv, p1);\n        MultiplyPointHomographyInhomogenous(p2p, Hinv, p2);\n        MultiplyPointHomographyInhomogenous(p3p, Hinv, p3);\n        \n        const float tr = refWidth*refHeight*0.0001;\n        if(SmallestTriangleArea(p0p, p1p, p2p, p3p) < tr) {\n            return false;\n        }\n        \n        if(!QuadrilateralConvex(p0p, p1p, p2p, p3p)) {\n            return false;\n        }\n        \n        return true;\n    }\n    \n    /**\n     * Vote for a similarity transformation.\n     */\n    inline int FindHoughSimilarity(HoughSimilarityVoting& hough,\n                                   const std::vector<FeaturePoint>& p1,\n                                   const std::vector<FeaturePoint>& p2,\n                                   const matches_t& matches,\n                                   int insWidth,\n                                   int insHeigth,\n                                   int refWidth,\n                                   int refHeight) {\n        std::vector<float> query(4*matches.size());\n        std::vector<float> ref(4*matches.size());\n        \n        // Extract the data from the features\n        for(size_t i = 0; i < matches.size(); i++) {\n            const FeaturePoint& query_point = p1[matches[i].ins];\n            const FeaturePoint& ref_point = p2[matches[i].ref];\n            \n            float* q = &query[i*4];\n            q[0] = query_point.x;\n            q[1] = query_point.y;\n            q[2] = query_point.angle;\n            q[3] = query_point.scale;\n            \n            float* r = &ref[i*4];\n            r[0] = ref_point.x;\n            r[1] = ref_point.y;\n            r[2] = ref_point.angle;\n            r[3] = ref_point.scale;\n        }\n        \n        float dx = insWidth+(insWidth*0.2f);\n        float dy = insHeigth+(insHeigth*0.2f);\n        \n        hough.init(-dx, dx, -dy, dy, 0, 0, 12, 10);        \n        hough.setObjectCenterInReference(refWidth>>1, refHeight>>1);\n        hough.setRefImageDimensions(refWidth, refHeight);\n        hough.vote((float*)&query[0], (float*)&ref[0], (int)matches.size());\n\n        float maxVotes;\n        int maxIndex;\n        hough.getMaximumNumberOfVotes(maxVotes, maxIndex);\n        \n        return (maxVotes < 3) ? -1 : maxIndex;\n    }\n    \n    /**\n     * Get only the matches that are consistent based on the hough votes.\n     */\n    inline void FindHoughMatches(matches_t& out_matches,\n                                 const HoughSimilarityVoting& hough,\n                                 const matches_t& in_matches,\n                                 int binIndex,\n                                 float binDelta) {\n        \n        float dx, dy, dangle, dscale;\n        int bin_x, bin_y, bin_angle, bin_scale;\n        hough.getBinsFromIndex(bin_x, bin_y, bin_angle, bin_scale, binIndex);\n        \n        out_matches.clear();\n        \n        int n = (int)hough.getSubBinLocationIndices().size();\n        const float* vote_loc = hough.getSubBinLocations().data();\n        \n        ASSERT(n <= in_matches.size(), \"Should be the same\");\n        \n        for(int i = 0; i < n; i++, vote_loc+=4) {\n            hough.getBinDistance(dx,            dy,            dangle,        dscale,\n                                 vote_loc[0],   vote_loc[1],   vote_loc[2],   vote_loc[3],\n                                 bin_x+.5,      bin_y+.5,      bin_angle+.5,  bin_scale+.5);\n            \n            if (dx < binDelta && dy < binDelta && dangle < binDelta && dscale < binDelta) {\n                int idx = hough.getSubBinLocationIndices()[i];\n                out_matches.push_back(in_matches[idx]);\n            }\n        }\n    }\n    \n    /**\n     * Estimate the homography between a set of correspondences.\n     */\n    inline bool EstimateHomography(float H[9],\n                                   const std::vector<FeaturePoint>& p1,\n                                   const std::vector<FeaturePoint>& p2,\n                                   const matches_t& matches,\n                                   RobustHomography<float>& estimator,\n                                   int refWidth,\n                                   int refHeight) {\n        \n        std::vector<vision::Point2d<float> > srcPoints(matches.size());\n        std::vector<vision::Point2d<float> > dstPoints(matches.size());\n        \n        //\n        // Copy correspondences\n        //\n        \n        for(size_t i = 0; i < matches.size(); i++) {\n            dstPoints[i].x = p1[matches[i].ins].x;\n            dstPoints[i].y = p1[matches[i].ins].y;\n            srcPoints[i].x = p2[matches[i].ref].x;\n            srcPoints[i].y = p2[matches[i].ref].y;\n        }\n        \n        //\n        // Create test points for geometric verification\n        //\n        \n        float test_points[8];\n        test_points[0] = 0;\n        test_points[1] = 0;\n        test_points[2] = refWidth;\n        test_points[3] = 0;\n        test_points[4] = refWidth;\n        test_points[5] = refHeight;\n        test_points[6] = 0;\n        test_points[7] = refHeight;\n        \n        //\n        // Compute the homography\n        //\n        \n        if(!estimator.find(H, (float*)&srcPoints[0], (float*)&dstPoints[0], (int)matches.size(), test_points, 4)) {\n            return false;\n        }\n        \n        //\n        // Apply some heuristics to the homography\n        //\n        \n        if(!CheckHomographyHeuristics(H, refWidth, refHeight)) {\n            return false;\n        }\n        \n        return true;\n    }\n    \n    /**\n     * Find the inliers given a homography and a set of correspondences.\n     */\n    inline void FindInliers(matches_t& inliers,\n                            const float H[9],\n                            const std::vector<FeaturePoint>& p1,\n                            const std::vector<FeaturePoint>& p2,\n                            const matches_t& matches,\n                            float threshold) {\n        float threshold2 = sqr(threshold);\n        inliers.reserve(matches.size());\n        for(size_t i = 0; i < matches.size(); i++) {\n            float xp[2];\n            MultiplyPointHomographyInhomogenous(xp[0],\n                                                xp[1],\n                                                H,\n                                                p2[matches[i].ref].x,\n                                                p2[matches[i].ref].y);\n            float d2 = sqr(xp[0]-p1[matches[i].ins].x) + sqr(xp[1]-p1[matches[i].ins].y);\n            if(d2 <= threshold2) {\n                inliers.push_back(matches[i]);\n            }\n        }\n    }\n    \n} // vision\n","//\n//  visual_database.h\n//  ARToolKit5\n//\n//  This file is part of ARToolKit.\n//\n//  ARToolKit is free software: you can redistribute it and/or modify\n//  it under the terms of the GNU Lesser General Public License as published by\n//  the Free Software Foundation, either version 3 of the License, or\n//  (at your option) any later version.\n//\n//  ARToolKit is distributed in the hope that it will be useful,\n//  but WITHOUT ANY WARRANTY; without even the implied warranty of\n//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n//  GNU Lesser General Public License for more details.\n//\n//  You should have received a copy of the GNU Lesser General Public License\n//  along with ARToolKit.  If not, see <http://www.gnu.org/licenses/>.\n//\n//  As a special exception, the copyright holders of this library give you\n//  permission to link this library with independent modules to produce an\n//  executable, regardless of the license terms of these independent modules, and to\n//  copy and distribute the resulting executable under terms of your choice,\n//  provided that you also meet, for each linked independent module, the terms and\n//  conditions of the license of that module. An independent module is a module\n//  which is neither derived from nor based on this library. If you modify this\n//  library, you may extend this exception to your version of the library, but you\n//  are not obligated to do so. If you do not wish to do so, delete this exception\n//  statement from your version.\n//\n//  Copyright 2013-2015 Daqri, LLC.\n//\n//  Author(s): Chris Broaddus\n//\n\n#pragma once\n\n#include <AR/ar.h>\n\n#include <math/indexing.h>\n\n#include <framework/timers.h>\n#include <framework/logger.h>\n#include <framework/image_utils.h>\n#include <math/math_io.h>\n#include <matchers/visual_database.h>\n\n\nnamespace vision {\n\n    static const float kLaplacianThreshold = 3;\n    static const float kEdgeThreshold = 4;\n    static const size_t kMaxNumFeatures = 500;\n    static const int kMinCoarseSize = 8;\n\n    static const int kHomographyInlierThreshold = 3;\n    static const int kMinNumInliers = 8;\n\n    static const float kHoughBinDelta = 1;\n\n    static const int kBytesPerFeature = 96;\n\n    static const bool kUseFeatureIndex = true;\n\n    template<typename FEATURE_EXTRACTOR, typename STORE, typename MATCHER>\n    VisualDatabase<FEATURE_EXTRACTOR, STORE, MATCHER>::VisualDatabase() {\n        mDetector.setLaplacianThreshold(kLaplacianThreshold);\n        mDetector.setEdgeThreshold(kEdgeThreshold);\n        mDetector.setMaxNumFeaturePoints(kMaxNumFeatures);\n\n        mHomographyInlierThreshold = kHomographyInlierThreshold;\n        mMinNumInliers = kMinNumInliers;\n\n        mUseFeatureIndex = kUseFeatureIndex;\n    }\n\n    template<typename FEATURE_EXTRACTOR, typename STORE, typename MATCHER>\n    VisualDatabase<FEATURE_EXTRACTOR, STORE, MATCHER>::~VisualDatabase() {}\n\n    template<typename FEATURE_EXTRACTOR, typename STORE, typename MATCHER>\n    void VisualDatabase<FEATURE_EXTRACTOR, STORE, MATCHER>::addImage(const vision::Image& image, id_t id) throw(Exception) {\n        if(mKeyframeMap.find(id) != mKeyframeMap.end()) {\n            throw EXCEPTION(\"ID already exists\");\n        }\n\n        // Allocate pyramid\n        if(mPyramid.images().size() == 0 ||\n           mPyramid.images()[0].width() != image.width() ||\n           mPyramid.images()[0].height() != image.height()) {\n            int num_octaves = numOctaves((int)image.width(), (int)image.height(), kMinCoarseSize);\n            mPyramid.alloc(image.width(), image.height(), num_octaves);\n        }\n\n        // Build the pyramid\n        TIMED(\"Build Pyramid\") {\n            mPyramid.build(image);\n        }\n\n        // Add the image with a pyramid\n        addImage(&mPyramid, id);\n    }\n\n    template<typename FEATURE_EXTRACTOR, typename STORE, typename MATCHER>\n    void VisualDatabase<FEATURE_EXTRACTOR, STORE, MATCHER>::addImage(const GaussianScaleSpacePyramid* pyramid, id_t id) throw(Exception) {\n        if(mKeyframeMap.find(id) != mKeyframeMap.end()) {\n            throw EXCEPTION(\"ID already exists\");\n        }\n\n        // Allocate detector\n        if(mDetector.width() != pyramid->images()[0].width() ||\n           mDetector.height() != pyramid->images()[0].height()) {\n            mDetector.alloc(pyramid);\n        }\n\n        // Find the features on the image\n        keyframe_ptr_t keyframe(new keyframe_t());\n        keyframe->setWidth((int)pyramid->images()[0].width());\n        keyframe->setHeight((int)pyramid->images()[0].height());\n        TIMED(\"Extract Features\") {\n            FindFeatures<FEATURE_EXTRACTOR, kBytesPerFeature>(keyframe.get(), pyramid, &mDetector, &mFeatureExtractor);\n        }\n        LOG_INFO(\"Found %d features\", keyframe->store().size());\n\n        // Build the feature index\n        TIMED(\"Build Index\") {\n            keyframe->buildIndex();\n        }\n\n        // Store the keyframe\n        mKeyframeMap[id] = keyframe;\n    }\n\n    template<typename FEATURE_EXTRACTOR, typename STORE, typename MATCHER>\n    void VisualDatabase<FEATURE_EXTRACTOR, STORE, MATCHER>::addKeyframe(keyframe_ptr_t keyframe , id_t id) throw(Exception) {\n        typename keyframe_map_t::iterator it = mKeyframeMap.find(id);\n        if(it != mKeyframeMap.end()) {\n          // TODO eachtime update this db to add new marker, now rewrite existing keyframes besides new one.\n            /* throw EXCEPTION(\"ID already exists\"); */\n        }\n\n        mKeyframeMap[id] = keyframe;\n    }\n\n    template<typename FEATURE_EXTRACTOR, typename STORE, typename MATCHER>\n    bool VisualDatabase<FEATURE_EXTRACTOR, STORE, MATCHER>::query(const vision::Image& image) throw(Exception) {\n        // Allocate pyramid\n        if(mPyramid.images().size() == 0 ||\n           mPyramid.images()[0].width() != image.width() ||\n           mPyramid.images()[0].height() != image.height()) {\n            int num_octaves = numOctaves((int)image.width(), (int)image.height(), kMinCoarseSize);\n            mPyramid.alloc(image.width(), image.height(), num_octaves);\n        }\n\n        // Build the pyramid\n        TIMED(\"Build Pyramid\") {\n            mPyramid.build(image);\n        }\n\n        return query(&mPyramid);\n    }\n\n    template<typename FEATURE_EXTRACTOR, typename STORE, typename MATCHER>\n    bool VisualDatabase<FEATURE_EXTRACTOR, STORE, MATCHER>::query(const GaussianScaleSpacePyramid* pyramid) throw(Exception) {\n        // Allocate detector\n        if(mDetector.width() != pyramid->images()[0].width() ||\n           mDetector.height() != pyramid->images()[0].height()) {\n            mDetector.alloc(pyramid);\n        }\n\n        // Find the features on the image\n        mQueryKeyframe.reset(new keyframe_t());\n        mQueryKeyframe->setWidth((int)pyramid->images()[0].width());\n        mQueryKeyframe->setHeight((int)pyramid->images()[0].height());\n        TIMED(\"Extract Features\") {\n            FindFeatures<FEATURE_EXTRACTOR, kBytesPerFeature>(mQueryKeyframe.get(), pyramid, &mDetector, &mFeatureExtractor);\n        }\n        LOG_INFO(\"Found %d features in query\", mQueryKeyframe->store().size());\n\n        return query(mQueryKeyframe.get());\n    }\n\n    template<typename FEATURE_EXTRACTOR, typename STORE, typename MATCHER>\n    bool VisualDatabase<FEATURE_EXTRACTOR, STORE, MATCHER>::query(const keyframe_t* query_keyframe) throw(Exception) {\n        mMatchedInliers.clear();\n        mMatchedId = -1;\n\n        const std::vector<FeaturePoint>& query_points = query_keyframe->store().points();\n\n        // Loop over all the images in the database\n        typename keyframe_map_t::const_iterator it = mKeyframeMap.begin();\n        for(; it != mKeyframeMap.end(); it++) {\n            TIMED(\"Find Matches (1)\") {\n                if(mUseFeatureIndex) {\n                    if(mMatcher.match(&query_keyframe->store(), &it->second->store(), it->second->index()) < mMinNumInliers) {\n                        continue;\n                    }\n                } else {\n                    if(mMatcher.match(&query_keyframe->store(), &it->second->store()) < mMinNumInliers) {\n                        continue;\n                    }\n                }\n            }\n\n            const std::vector<FeaturePoint>& ref_points = it->second->store().points();\n            //std::cout<<\"ref_points-\"<<ref_points.size()<<std::endl;\n            //std::cout<<\"query_points-\"<<query_points.size()<<std::endl;\n\n            //\n            // Vote for a transformation based on the correspondences\n            //\n\n            int max_hough_index = -1;\n            TIMED(\"Hough Voting (1)\") {\n                max_hough_index = FindHoughSimilarity(mHoughSimilarityVoting,\n                                                      query_points,\n                                                      ref_points,\n                                                      mMatcher.matches(),\n                                                      query_keyframe->width(),\n                                                      query_keyframe->height(),\n                                                      it->second->width(),\n                                                      it->second->height());\n                if(max_hough_index < 0) {\n                    continue;\n                }\n            }\n\n            matches_t hough_matches;\n            TIMED(\"Find Hough Matches (1)\") {\n                FindHoughMatches(hough_matches,\n                                 mHoughSimilarityVoting,\n                                 mMatcher.matches(),\n                                 max_hough_index,\n                                 kHoughBinDelta);\n            }\n\n            //\n            // Estimate the transformation between the two images\n            //\n\n            float H[9];\n            TIMED(\"Estimate Homography (1)\") {\n                if(!EstimateHomography(H,\n                                       query_points,\n                                       ref_points,\n                                       hough_matches,\n                                       mRobustHomography,\n                                       it->second->width(),\n                                       it->second->height())) {\n                    continue;\n                }\n            }\n\n            //\n            // Find the inliers\n            //\n\n            matches_t inliers;\n            TIMED(\"Find Inliers (1)\") {\n                FindInliers(inliers, H, query_points, ref_points, hough_matches, mHomographyInlierThreshold);\n                if(inliers.size() < mMinNumInliers) {\n                    continue;\n                }\n            }\n\n            //\n            // Use the estimated homography to find more inliers\n            //\n\n            TIMED(\"Find Matches (2)\") {\n                if(mMatcher.match(&query_keyframe->store(),\n                                  &it->second->store(),\n                                  H,\n                                  10) < mMinNumInliers) {\n                    continue;\n                }\n            }\n\n            //\n            // Vote for a similarity with new matches\n            //\n\n            TIMED(\"Hough Voting (2)\") {\n                max_hough_index = FindHoughSimilarity(mHoughSimilarityVoting,\n                                                      query_points,\n                                                      ref_points,\n                                                      mMatcher.matches(),\n                                                      query_keyframe->width(),\n                                                      query_keyframe->height(),\n                                                      it->second->width(),\n                                                      it->second->height());\n                if(max_hough_index < 0) {\n                    continue;\n                }\n            }\n\n            TIMED(\"Find Hough Matches (2)\") {\n                FindHoughMatches(hough_matches,\n                                 mHoughSimilarityVoting,\n                                 mMatcher.matches(),\n                                 max_hough_index,\n                                 kHoughBinDelta);\n            }\n\n            //\n            // Re-estimate the homography\n            //\n\n            TIMED(\"Estimate Homography (2)\") {\n                if(!EstimateHomography(H,\n                                       query_points,\n                                       ref_points,\n                                       hough_matches,\n                                       mRobustHomography,\n                                       it->second->width(),\n                                       it->second->height())) {\n                    continue;\n                }\n            }\n\n            //\n            // Check if this is the best match based on number of inliers\n            //\n\n            inliers.clear();\n            TIMED(\"Find Inliers (2)\") {\n                FindInliers(inliers, H, query_points, ref_points, hough_matches, mHomographyInlierThreshold);\n            }\n\n            //std::cout<<\"inliers-\"<<inliers.size()<<std::endl;\n            if(inliers.size() >= mMinNumInliers && inliers.size() > mMatchedInliers.size()) {\n                CopyVector9(mMatchedGeometry, H);\n                mMatchedInliers.swap(inliers);\n                mMatchedId = it->first;\n            }\n        }\n\n        return mMatchedId >= 0;\n    }\n\n    template<typename FEATURE_EXTRACTOR, typename STORE, typename MATCHER>\n    bool VisualDatabase<FEATURE_EXTRACTOR, STORE, MATCHER>::erase(id_t id) {\n        typename keyframe_map_t::iterator it = mKeyframeMap.find(id);\n        if(it == mKeyframeMap.end()) {\n            return false;\n        }\n        mKeyframeMap.erase(it);\n        return true;\n    }\n\n} // vision\n","//\n//  feature_matcher-inline.h\n//  ARToolKit5\n//\n//  This file is part of ARToolKit.\n//\n//  ARToolKit is free software: you can redistribute it and/or modify\n//  it under the terms of the GNU Lesser General Public License as published by\n//  the Free Software Foundation, either version 3 of the License, or\n//  (at your option) any later version.\n//\n//  ARToolKit is distributed in the hope that it will be useful,\n//  but WITHOUT ANY WARRANTY; without even the implied warranty of\n//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n//  GNU Lesser General Public License for more details.\n//\n//  You should have received a copy of the GNU Lesser General Public License\n//  along with ARToolKit.  If not, see <http://www.gnu.org/licenses/>.\n//\n//  As a special exception, the copyright holders of this library give you\n//  permission to link this library with independent modules to produce an\n//  executable, regardless of the license terms of these independent modules, and to\n//  copy and distribute the resulting executable under terms of your choice,\n//  provided that you also meet, for each linked independent module, the terms and\n//  conditions of the license of that module. An independent module is a module\n//  which is neither derived from nor based on this library. If you modify this\n//  library, you may extend this exception to your version of the library, but you\n//  are not obligated to do so. If you do not wish to do so, delete this exception\n//  statement from your version.\n//\n//  Copyright 2013-2015 Daqri, LLC.\n//\n//  Author(s): Chris Broaddus\n//\n\n#include \"feature_matcher.h\"\n#include \"feature_store.h\"\n#include <math/hamming.h>\n#include <math/indexing.h>\n#include <math/homography.h>\n#include <math/linear_algebra.h>\n#include <framework/error.h>\n#include <utility>\nnamespace vision {\n\n    /************************************************************************************************************************\n     *\n     * BinaryFeatureMatcher\n     *\n     ***********************************************************************************************************************/\n    \n    template<int FEATURE_SIZE>\n    BinaryFeatureMatcher<FEATURE_SIZE>::BinaryFeatureMatcher()\n    : mThreshold(0.7) {}\n\n    template<int FEATURE_SIZE>\n    BinaryFeatureMatcher<FEATURE_SIZE>::~BinaryFeatureMatcher() {}\n\n    template<int FEATURE_SIZE>\n    size_t BinaryFeatureMatcher<FEATURE_SIZE>::match(const BinaryFeatureStore* features1,\n                                                     const BinaryFeatureStore* features2) {\n        \n        mMatches.clear();\n        \n        if(features1->size() == 0 ||\n           features2->size() == 0) {\n            return 0;\n        }\n        \n        mMatches.reserve(features1->size());\n        for(size_t i = 0; i < features1->size(); i++) {\n            unsigned int first_best = std::numeric_limits<unsigned int>::max();\n            unsigned int second_best = std::numeric_limits<unsigned int>::max();\n            int best_index = std::numeric_limits<int>::max();\n            \n            // Search for 1st and 2nd best match\n            const unsigned char* f1 = features1->feature(i);\n            const FeaturePoint& p1 = features1->point(i);\n            for(size_t j = 0; j < features2->size(); j++) {\n                // Both points should be a MINIMA or MAXIMA\n                if(p1.maxima != features2->point(j).maxima) {\n                    continue;\n                }\n                \n                ASSERT(FEATURE_SIZE == 96, \"Only 96 bytes supported now\");\n                unsigned int d = HammingDistance<FEATURE_SIZE>(f1,\n                                                               (unsigned char*)features2->feature(j));\n                if(d < first_best) {\n                    second_best = first_best;\n                    first_best = d;\n                    best_index = (int)j;\n                } else if(d < second_best) {\n                    second_best = d;\n                }\n            }\n            \n            // Check if FIRST_BEST has been set\n            if(first_best != std::numeric_limits<unsigned int>::max()) {\n                // If there isn't a SECOND_BEST, then always choose the FIRST_BEST.\n                // Otherwise, do a ratio test.\n                if(second_best == std::numeric_limits<unsigned int>::max()) {\n                    mMatches.push_back(match_t((int)i, best_index));\n                } else {\n                    // Ratio test\n                    float r = (float)first_best / (float)second_best;\n                    if(r < mThreshold) {\n                        mMatches.push_back(match_t((int)i, best_index));\n                    }\n                }\n            }\n        }\n        ASSERT(mMatches.size() <= features1->size(), \"Number of matches should be lower\");\n        return mMatches.size();\n    }\n    \n    template<int FEATURE_SIZE>\n    size_t BinaryFeatureMatcher<FEATURE_SIZE>::match(const BinaryFeatureStore* features1,\n                                                     const BinaryFeatureStore* features2,\n                                                     const index_t& index2) {\n        mMatches.clear();\n        \n        if(features1->size() == 0 ||\n           features2->size() == 0) {\n            return 0;\n        }\n        \n        mMatches.reserve(features1->size());\n        for(size_t i = 0; i < features1->size(); i++) {\n            unsigned int first_best = std::numeric_limits<unsigned int>::max();\n            unsigned int second_best = std::numeric_limits<unsigned int>::max();\n            int best_index = std::numeric_limits<int>::max();\n            \n            // Perform an indexed nearest neighbor lookup\n            const unsigned char* f1 = features1->feature(i);\n            index2.query(f1);\n            \n            const FeaturePoint& p1 = features1->point(i);\n            \n            // Search for 1st and 2nd best match\n            const std::vector<int>& v = index2.reverseIndex();\n            for(size_t j = 0; j < v.size(); j++) {\n                // Both points should be a MINIMA or MAXIMA\n                if(p1.maxima != features2->point(v[j]).maxima) {\n                    continue;\n                }\n                \n                ASSERT(FEATURE_SIZE == 96, \"Only 96 bytes supported now\");\n                unsigned int d = HammingDistance<FEATURE_SIZE>(f1, (unsigned char*)features2->feature(v[j]));\n                if(d < first_best) {\n                    second_best = first_best;\n                    first_best = d;\n                    best_index = v[j];\n                } else if(d < second_best) {\n                    second_best = d;\n                }\n            }\n            \n            // Check if FIRST_BEST has been set\n            if(first_best != std::numeric_limits<unsigned int>::max()) {\n                ASSERT(best_index != std::numeric_limits<size_t>::max(), \"Something strange\");\n                \n                // If there isn't a SECOND_BEST, then always choose the FIRST_BEST.\n                // Otherwise, do a ratio test.\n                if(second_best == std::numeric_limits<unsigned int>::max()) {\n                    mMatches.push_back(match_t((int)i, best_index));\n                } else {\n                    // Ratio test\n                    float r = (float)first_best / (float)second_best;\n                    if(r < mThreshold) {\n                        mMatches.push_back(match_t((int)i, best_index));\n                    }\n                }\n            }\n        }\n        ASSERT(mMatches.size() <= features1->size(), \"Number of matches should be lower\");\n        return mMatches.size();\n    }\n    \n    template<int FEATURE_SIZE>\n    size_t BinaryFeatureMatcher<FEATURE_SIZE>::match(const BinaryFeatureStore* features1,\n                                                     const BinaryFeatureStore* features2,\n                                                     const float H[9],\n                                                     float tr) {\n\n        mMatches.clear();\n        \n        if(features1->size() == 0 ||\n           features2->size() == 0) {\n            return 0;\n        }\n        \n        float tr_sqr = sqr(tr);\n        \n        float Hinv[9];\n        if(!MatrixInverse3x3(Hinv, H, 0.f)) {\n            ASSERT(0, \"Failed to compute matrix inverse\");\n            return 0;\n        }\n        \n        mMatches.reserve(features1->size());\n        for(size_t i = 0; i < features1->size(); i++) {\n            unsigned int first_best = std::numeric_limits<unsigned int>::max();\n            unsigned int second_best = std::numeric_limits<unsigned int>::max();\n            int best_index = std::numeric_limits<int>::max();\n            \n            const unsigned char* f1 = features1->feature(i);\n            const FeaturePoint& p1 = features1->point(i);\n            \n            // Map p1 to p2 space through H\n            float xp1, yp1;\n            MultiplyPointHomographyInhomogenous(xp1, yp1, Hinv, p1.x, p1.y);\n            \n            // Search for 1st and 2nd best match\n            for(size_t j = 0; j < features2->size(); j++) {\n                const FeaturePoint& p2 = features2->point(j);\n                \n                // Both points should be a MINIMA or MAXIMA\n                if(p1.maxima != p2.maxima) {\n                    continue;\n                }\n                \n                // Check spatial constraint\n                if(sqr(xp1-p2.x) + sqr(yp1-p2.y) > tr_sqr) {\n                    continue;\n                }\n                \n                ASSERT(FEATURE_SIZE == 96, \"Only 96 bytes supported now\");\n                unsigned int d = HammingDistance768((unsigned int*)f1,\n                                                    (unsigned int*)features2->feature(j));\n                if(d < first_best) {\n                    second_best = first_best;\n                    first_best = d;\n                    best_index = (int)j;\n                } else if(d < second_best) {\n                    second_best = d;\n                }\n            }\n            \n            // Check if FIRST_BEST has been set\n            if(first_best != std::numeric_limits<unsigned int>::max()) {\n                ASSERT(best_index != std::numeric_limits<size_t>::max(), \"Something strange\");\n                \n                // If there isn't a SECOND_BEST, then always choose the FIRST_BEST.\n                // Otherwise, do a ratio test.\n                if(second_best == std::numeric_limits<unsigned int>::max()) {\n                    mMatches.push_back(match_t((int)i, best_index));\n                } else {\n                    // Ratio test\n                    float r = (float)first_best / (float)second_best;\n                    if(r < mThreshold) {\n                        mMatches.push_back(match_t((int)i, best_index));\n                    }\n                }\n            }\n        }\n        ASSERT(mMatches.size() <= features1->size(), \"Number of matches should be lower\");\n        return mMatches.size();\n    }\n    \n    /************************************************************************************************************************\n     *\n     * MutualCorrespondenceBinaryFeatureMatcher\n     *\n     ***********************************************************************************************************************/\n    \n    template<int FEATURE_SIZE>\n    size_t MutualCorrespondenceBinaryFeatureMatcher<FEATURE_SIZE>::match(const BinaryFeatureStore* features1,\n                                                                         const BinaryFeatureStore* features2,\n                                                                         float tr) {\n        mMatches.clear();\n        \n        if(features1->size() == 0 ||\n           features2->size() == 0) {\n            return 0;\n        }\n        \n        float tr2 = sqr(tr);\n        \n        mMatches.reserve(features2->size());\n        mIndices.resize(features1->size(), -1);\n        \n        // Assign features in \"1\" to best feature from \"2\"\n        for(size_t i = 0; i < features1->size(); i++) {\n            int best_index = -1;\n            unsigned int best_d = std::numeric_limits<unsigned int>::max();\n            const unsigned int* f1 = (unsigned int*)features1->feature(i);\n            \n            const FeaturePoint& p1 = features1->point(i);\n            for(size_t j = 0; j < features2->size(); j++) {\n                const FeaturePoint& p2 = features2->point(j);\n                \n                // Both points should be a MINIMA or MAXIMA\n                if(p1.maxima != p2.maxima) {\n                    continue;\n                }\n                \n                // Check spatial constraint\n                if(sqr(p1.x-p2.x) + sqr(p1.y-p2.y) > tr2) {\n                    continue;\n                }\n                \n                ASSERT(FEATURE_SIZE == 96, \"Only 96 bytes supported now\");\n                unsigned int d = HammingDistance768(f1,\n                                                    (unsigned int*)features2->feature(j));\n                if(d < best_d) {\n                    best_d = d;\n                    best_index = (int)j;\n                }\n            }\n            mIndices[i] = best_index;\n        }\n        \n        // Assign features in \"2\" to best feature from \"1\"\n        for(size_t i = 0; i < features2->size(); i++) {\n            int best_index = -1;\n            unsigned int best_d = std::numeric_limits<unsigned int>::max();\n            const unsigned int* f2 = (unsigned int*)features2->feature(i);\n            \n            const FeaturePoint& p2 = features2->point(i);\n            for(size_t j = 0; j < features1->size(); j++) {\n                const FeaturePoint& p1 = features1->point(j);\n                \n                // Both points should be a MINIMA or MAXIMA\n                if(p1.maxima != p2.maxima) {\n                    continue;\n                }\n                \n                // Check spatial constraint\n                if(sqr(p1.x-p2.x) + sqr(p1.y-p2.y) > tr2) {\n                    continue;\n                }\n                \n                ASSERT(FEATURE_SIZE == 96, \"Only 96 bytes supported now\");\n                unsigned int d = HammingDistance768((unsigned int*)features1->feature(j),\n                                                    f2);\n                if(d < best_d) {\n                    best_d = d;\n                    best_index = (int)j;\n                }\n            }\n            \n            if(best_index >= 0 && mIndices[best_index] == (int)i) {\n                mMatches.push_back(match_t(best_index, (int)i));\n            }\n        }\n        return mMatches.size();\n    }\n\n    template<int FEATURE_SIZE>\n    size_t MutualCorrespondenceBinaryFeatureMatcher<FEATURE_SIZE>::match(const BinaryFeatureStore* features1,\n                                                                         const BinaryFeatureStore* features2,\n                                                                         const float H[9],\n                                                                         float tr1,\n                                                                         float tr2) {\n        mMatches.clear();\n        \n        if(features1->size() == 0 ||\n           features2->size() == 0) {\n            return 0;\n        }\n        \n        float Hinv[9];\n        if(!MatrixInverse3x3(Hinv, H, 0.f)) {\n            ASSERT(0, \"Failed to compute matrix inverse\");\n            return 0;\n        }\n        \n        float tr1_sqr = sqr(tr1);\n        float tr2_sqr = sqr(tr2);\n        \n        mMatches.reserve(features2->size());\n        mIndices.resize(features1->size(), -1);\n        \n        // Assign features in \"1\" to best feature from \"2\" within the spatial threshold\n        for(size_t i = 0; i < features1->size(); i++) {\n            int best_index = -1;\n            unsigned int best_d = std::numeric_limits<unsigned int>::max();\n            \n            const FeaturePoint& p1 = features1->point(i);\n            \n            // Map p1 to p2 space through H\n            float xp1, yp1;\n            MultiplyPointHomographyInhomogenous(xp1, yp1, H, p1.x, p1.y);\n            \n            for(size_t j = 0; j < features2->size(); j++) {\n                const FeaturePoint& p2 = features1->point(j);\n                \n                // Both points should be a MINIMA or MAXIMA\n                if(p1.maxima != p2.maxima) {\n                    continue;\n                }\n                \n                // Check spatial constraint\n                if(sqr(xp1-p2.x) + sqr(yp1-p2.y) > tr2_sqr) {\n                    continue;\n                }\n                \n                ASSERT(FEATURE_SIZE == 96, \"Only 96 bytes supported now\");\n                unsigned int d = HammingDistance768((unsigned int*)features1->feature(i),\n                                                    (unsigned int*)features2->feature(j));\n                if(d < best_d) {\n                    best_d = d;\n                    best_index = (int)j;\n                }\n            }\n            mIndices[i] = best_index;\n        }\n        \n        // Assign features in \"2\" to best feature from \"1\"\n        for(size_t i = 0; i < features2->size(); i++) {\n            int best_index = -1;\n            unsigned int best_d = std::numeric_limits<unsigned int>::max();\n            \n            const FeaturePoint& p2 = features2->point(i);\n            \n            // Map p2 to p1 space through inv(H)\n            float xp2, yp2;\n            MultiplyPointHomographyInhomogenous(xp2, yp2, Hinv, p2.x, p2.y);\n            \n            for(size_t j = 0; j < features1->size(); j++) {\n                const FeaturePoint& p1 = features1->point(j);\n                \n                // Both points should be a MINIMA or MAXIMA\n                if(p1.maxima != p2.maxima) {\n                    continue;\n                }\n                \n                // Check spatial constraint\n                if(sqr(xp2-p1.x) + sqr(yp2-p1.y) > tr1_sqr) {\n                    continue;\n                }\n                \n                ASSERT(FEATURE_SIZE == 96, \"Only 96 bytes supported now\");\n                unsigned int d = HammingDistance768((unsigned int*)features1->feature(j),\n                                                    (unsigned int*)features2->feature(i));\n                if(d < best_d) {\n                    best_d = d;\n                    best_index = (int)j;\n                }\n            }\n            \n            if(best_index >= 0 && mIndices[best_index] == (int)i) {\n                ASSERT(mIndices[best_index] >= 0, \"Index not set correctly\");\n                mMatches.push_back(match_t(best_index, i));\n            }\n        }\n        return mMatches.size();\n    }\n    \n} // vision\n","//\n//  robust_homography.h\n//  ARToolKit5\n//\n//  This file is part of ARToolKit.\n//\n//  ARToolKit is free software: you can redistribute it and/or modify\n//  it under the terms of the GNU Lesser General Public License as published by\n//  the Free Software Foundation, either version 3 of the License, or\n//  (at your option) any later version.\n//\n//  ARToolKit is distributed in the hope that it will be useful,\n//  but WITHOUT ANY WARRANTY; without even the implied warranty of\n//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n//  GNU Lesser General Public License for more details.\n//\n//  You should have received a copy of the GNU Lesser General Public License\n//  along with ARToolKit.  If not, see <http://www.gnu.org/licenses/>.\n//\n//  As a special exception, the copyright holders of this library give you\n//  permission to link this library with independent modules to produce an\n//  executable, regardless of the license terms of these independent modules, and to\n//  copy and distribute the resulting executable under terms of your choice,\n//  provided that you also meet, for each linked independent module, the terms and\n//  conditions of the license of that module. An independent module is a module\n//  which is neither derived from nor based on this library. If you modify this\n//  library, you may extend this exception to your version of the library, but you\n//  are not obligated to do so. If you do not wish to do so, delete this exception\n//  statement from your version.\n//\n//  Copyright 2013-2015 Daqri, LLC.\n//\n//  Author(s): Chris Broaddus\n//\n\n#pragma once\n\n#include \"homography_solver.h\"\n#include <math/rand.h>\n#include <math/homography.h>\n#include <math/cholesky_linear_solvers.h>\n#include <math/robustifiers.h>\n#include <utils/partial_sort.h>\n\n#include <Eigen/Core>\n#include <Eigen/LU>\n#include <Eigen/Eigen>\n#include <unsupported/Eigen/MatrixFunctions>\n\nnamespace vision {\n    \n#define HOMOGRAPHY_DEFAULT_CAUCHY_SCALE         0.01\n#define HOMOGRAPHY_DEFAULT_NUM_HYPOTHESES       1024\n#define HOMOGRAPHY_DEFAULT_MAX_TRIALS           1064\n#define HOMOGRAPHY_DEFAULT_CHUNK_SIZE           50\n    \n    /**\n     * Compute the Cauchy reprojection cost for H*p-q.\n     */\n    template<typename T>\n    inline T CauchyProjectiveReprojectionCost(const T H[9], const T p[2], const T q[2], T one_over_scale2) {\n        T pp[2];\n        T f[2];\n        \n        MultiplyPointHomographyInhomogenous(pp[0], pp[1], H, p[0], p[1]);\n        \n        f[0] = pp[0] - q[0];\n        f[1] = pp[1] - q[1];\n        \n        return CauchyCost(f, one_over_scale2);\n    }\n    \n    /**\n     * Compute the Cauchy reprojection cost for H*p_i-q_i.\n     */\n    template<typename T>\n    inline T CauchyProjectiveReprojectionCost(const T H[9],\n                                              const T* p,\n                                              const T* q,\n                                              int num_points,\n                                              T one_over_scale2) {\n        int i;\n        T total_cost;\n        \n        total_cost = 0;\n        for(i = 0; i < num_points; i++, p+=2, q+=2) {\n            total_cost += CauchyProjectiveReprojectionCost(H, p, q, one_over_scale2);\n        }\n        \n        return total_cost;\n    }\n    \n    /**\n     * Robustly solve for the homography given a set of correspondences. \n     */\n    template<typename T>\n    bool PreemptiveRobustHomography(T H[9],\n                                    const T* p,\n                                    const T* q,\n                                    int num_points,\n                                    const T* test_points,\n                                    int num_test_points,\n                                    std::vector<T> &hyp /* 9*max_num_hypotheses */,\n                                    std::vector<int> &tmp_i /* num_points */,\n                                    std::vector< std::pair<T, int> > &hyp_costs /* max_num_hypotheses */,\n                                    T scale = HOMOGRAPHY_DEFAULT_CAUCHY_SCALE,\n                                    int max_num_hypotheses = HOMOGRAPHY_DEFAULT_NUM_HYPOTHESES,\n                                    int max_trials = HOMOGRAPHY_DEFAULT_MAX_TRIALS,\n                                    int chunk_size = HOMOGRAPHY_DEFAULT_CHUNK_SIZE) {\n        int* hyp_perm;\n        T one_over_scale2;\n        T min_cost;\n        int num_hypotheses, num_hypotheses_remaining, min_index;\n        int cur_chunk_size, this_chunk_end;\n        int trial;\n        int seed;\n        int sample_size = 4;\n        \n        ASSERT(hyp.size() >= 9*max_num_hypotheses, \"hyp vector should be of size 9*max_num_hypotheses\");\n        ASSERT(tmp_i.size() >= num_points, \"tmp_i vector should be of size num_points\");\n        ASSERT(hyp_costs.size() >= max_num_hypotheses, \"hyp_costs vector should be of size max_num_hypotheses\");\n        \n        // We need at least SAMPLE_SIZE points to sample from\n        if(num_points < sample_size) {\n            return false;\n        }\n        \n        seed = 1234;\n        \n        hyp_perm = &tmp_i[0];\n\n        one_over_scale2 = 1/sqr(scale);\n        chunk_size = min2(chunk_size, num_points);\n        \n        // Fill arrays from [0)\n        SequentialVector(hyp_perm, num_points, 0);\n\n        // Shuffle the indices\n        ArrayShuffle(hyp_perm, num_points, num_points, seed);\n\n        // Compute a set of hypotheses\n        for(trial = 0, num_hypotheses = 0;\n            trial < max_trials && num_hypotheses < max_num_hypotheses;\n            trial++) {\n            \n            // Shuffle the first SAMPLE_SIZE indices\n            ArrayShuffle(hyp_perm, num_points, sample_size, seed);\n            \n            // Check if the four points are geometrically valid\n            if(!Homography4PointsGeometricallyConsistent(&p[hyp_perm[0]<<1],\n                                                         &p[hyp_perm[1]<<1],\n                                                         &p[hyp_perm[2]<<1],\n                                                         &p[hyp_perm[3]<<1],\n                                                         &q[hyp_perm[0]<<1],\n                                                         &q[hyp_perm[1]<<1],\n                                                         &q[hyp_perm[2]<<1],\n                                                         &q[hyp_perm[3]<<1])) {\n                continue;\n            }\n            \n            // Compute the homography\n            if(!SolveHomography4Points(&hyp[num_hypotheses*9],\n                                       &p[hyp_perm[0]<<1],\n                                       &p[hyp_perm[1]<<1],\n                                       &p[hyp_perm[2]<<1],\n                                       &p[hyp_perm[3]<<1],\n                                       &q[hyp_perm[0]<<1],\n                                       &q[hyp_perm[1]<<1],\n                                       &q[hyp_perm[2]<<1],\n                                       &q[hyp_perm[3]<<1])) {\n                continue;\n            }\n            \n            // Check the test points\n            if(num_test_points > 0) {\n                if(!HomographyPointsGeometricallyConsistent(&hyp[num_hypotheses*9], test_points, num_test_points)) {\n                    continue;\n                }\n            }\n            \n            num_hypotheses++;\n        }\n        \n        // We fail if no hypotheses could be computed\n        if(num_hypotheses == 0) {\n            return false;\n        }\n        \n        // Initialize the hypotheses costs\n        for(int i = 0; i < num_hypotheses; i++) {\n            hyp_costs[i].first = 0;\n            hyp_costs[i].second = i;\n        }\n        \n        num_hypotheses_remaining = num_hypotheses;\n        cur_chunk_size = chunk_size;\n        \n        for(int i = 0;\n            i < num_points && num_hypotheses_remaining > 2;\n            i+=cur_chunk_size) {\n            \n            // Size of the current chunk\n            cur_chunk_size = min2(chunk_size, num_points-i);\n            \n            // End of the current chunk\n            this_chunk_end = i+cur_chunk_size;\n            \n            // Score each of the remaining hypotheses\n            for(int j = 0; j < num_hypotheses_remaining; j++) {\n                const T* H_cur = &hyp[hyp_costs[j].second*9];\n                for(int k = i; k < this_chunk_end; k++) {\n                    hyp_costs[j].first += CauchyProjectiveReprojectionCost(H_cur,\n                                                                           &p[hyp_perm[k]<<1],\n                                                                           &q[hyp_perm[k]<<1],\n                                                                           one_over_scale2);\n                }\n            }\n            \n            // Cut out half of the hypotheses\n            FastMedian(&hyp_costs[0], num_hypotheses_remaining);\n            num_hypotheses_remaining = num_hypotheses_remaining>>1;\n        }\n        \n        // Find the best hypothesis\n        min_index = hyp_costs[0].second;\n        min_cost = hyp_costs[0].first;\n        for(int i = 1; i < num_hypotheses_remaining; i++) {\n            if(hyp_costs[i].first < min_cost ) {\n                min_cost = hyp_costs[i].first;\n                min_index = hyp_costs[i].second;\n            }\n        }\n        \n        // Move the best hypothesis\n        CopyVector9(H, &hyp[min_index*9]);\n        NormalizeHomography(H);\n        \n        return true;\n    }\n    \n    /**\n     * Compute the Lie Basis Jacobian for the homography.\n     *\n     * @param[out] J 2x8 jacobian\n     * @param[out] f error\n     * @param[in] pp pp=H*p\n     * @param[in] p point to linearize\n     * @param[in] q\n     */\n    template<typename T>\n    inline void HomographyLieJacobian(T J[16], T f[2], const T pp[2], const T p[2], const T q[2]) {\n        // [ 1, 0, y,  0,  x,   -x,  -x^2, -x*y]\n        // [ 0, 1,  0, x, -y, -2*y, -x*y,  -y^2]\n        \n        const T& x = p[0];\n        const T& y = p[1];\n        \n        J[0] = 1;\n        J[1] = 0;\n        J[2] = y;\n        J[3] = 0;\n        J[4] = x;\n        J[5] = -x;\n        J[6] = -x*x;\n        J[7] = -x*y;\n        J[8] = 0;\n        J[9] = 1;\n        J[10] = 0;\n        J[11] = x;\n        J[12] = -y;\n        J[13] = -2*y;\n        J[14] = -x*y;\n        J[15] = -y*y;\n        \n        f[0] = pp[0]-q[0];\n        f[1] = pp[1]-q[1];\n    }\n    \n    /**\n     * Compute the Cauchy Derivative\n     *\n     * xp = sqrt(log(1+(x^+y^2)*one_over_scale2))*(x/sqrt(x^2+y^2))\n     * yp = sqrt(log(1+(x^+y^2)*one_over_scale2))*(y/sqrt(x^2+y^2))\n     *\n     * d(xp)/x = d(xp)/f * df/dx\n     * d(yp)/y = d(yp)/f * df/dy\n     *\n     * where f = log(1+(x^2+y^2)*one_over_scale2)/(x^2+y^2)\n     *\n     * d(xp)/f = x/(2*sqrt(f))\n     * d(yp)/f = y/(2*sqrt(f))\n     */\n    template<typename T>\n    inline void CauchyDerivative(T J_r[4], T fp[2], const T f[2], T one_over_scale2) {\n        T dqdf[2];\n        T dfdp[2];\n        \n        const T& x = f[0];\n        const T& y = f[1];\n        T x2 = x*x;\n        T y2 = y*y;\n        T r2 = x2+y2;\n        \n        bool fu_at_zero = false;\n        \n        if(r2 <= 0) {\n            fu_at_zero = true;\n        }\n        else {\n            T one_over_r2 = 1/r2;\n            T t = 1+r2*one_over_scale2;\n            T one_over_r2_times_t = 1/(r2*t);\n            T fu = std::log(t)*one_over_r2;\n            \n            if(fu <= 0) {\n                fu_at_zero = true;\n            }\n            else {\n                T sqrt_fu = std::sqrt(fu);\n                T fu_times_one_over_r2 = fu*one_over_r2;\n                T one_over_denom = 1./(2.*sqrt_fu);\n                \n                // dqdf\n                dqdf[0] = x*one_over_denom;\n                dqdf[1] = y*one_over_denom;\n                \n                // dfdp\n                dfdp[0] = 2*(one_over_scale2*x*one_over_r2_times_t - (x*fu_times_one_over_r2));\n                dfdp[1] = 2*(one_over_scale2*y*one_over_r2_times_t - (y*fu_times_one_over_r2));\n                \n                // J_r\n                J_r[0] = dqdf[0]*dfdp[0]+sqrt_fu;    J_r[1] = dqdf[0]*dfdp[1];\n                J_r[2] = J_r[1];                     J_r[3] = dqdf[1]*dfdp[1]+sqrt_fu;\n                \n                // error\n                fp[0] = sqrt_fu*f[0];\n                fp[1] = sqrt_fu*f[1];\n            }\n        }\n        \n        if(fu_at_zero) {\n            fp[0] = 0;\n            fp[1] = 0;\n            \n            J_r[0] = std::sqrt(one_over_scale2);\n            J_r[1] = 0;\n            J_r[2] = 0;\n            J_r[3] = J_r[0];\n        }\n    }\n    \n    /**\n     * Compute the Homography Jacobian of the Post Multiplied Update equation.\n     *\n     * H_delta*H0\n     */\n    template<typename T>\n    inline void RobustHomographyLieJacobianPostMultiply(T Jp[16],\n                                                        T fp[2],\n                                                        const T H[9],\n                                                        const T p[2],\n                                                        const T q[2],\n                                                        T one_over_scale2) {\n        T pp[2];\n        T f[2];\n        T J[16];\n        T J_r[4];\n        \n        // pp=H*p\n        MultiplyPointHomographyInhomogenous(pp[0], pp[1], H, p[0], p[1]);\n        // Linearize at the point \"pp\"\n        HomographyLieJacobian(J, f, pp, pp, q);\n        CauchyDerivative(J_r, fp, f, one_over_scale2);\n        \n        // Jp = Jr*J\n        Jp[0]  = J_r[0]*J[0];\n        Jp[1]  =               J_r[1]*J[9];\n        Jp[2]  = J_r[0]*J[2];\n        Jp[3]  =               J_r[1]*J[11];\n        Jp[4]  = J_r[0]*J[4] + J_r[1]*J[12];\n        Jp[5]  = J_r[0]*J[5] + J_r[1]*J[13];\n        Jp[6]  = J_r[0]*J[6] + J_r[1]*J[14];\n        Jp[7]  = J_r[0]*J[7] + J_r[1]*J[15];\n        Jp[8]  = J_r[2]*J[0];\n        Jp[9]  =               J_r[3]*J[9];\n        Jp[10] = J_r[2]*J[2];\n        Jp[11] =               J_r[3]*J[11];\n        Jp[12] = J_r[2]*J[4] + J_r[3]*J[12];\n        Jp[13] = J_r[2]*J[5] + J_r[3]*J[13];\n        Jp[14] = J_r[2]*J[6] + J_r[3]*J[14];\n        Jp[15] = J_r[2]*J[7] + J_r[3]*J[15];\n    }\n    \n    /**\n     * Compute the normal equations for the post multiplied homography update.\n     */\n    template<typename T>\n    void ComputeHomographyNormalEquationsPostMultiply(T JtJ[64],\n                                                      T Jtr[8],\n                                                      const T H[9],\n                                                      const T* p,\n                                                      const T* q,\n                                                      int num_points,\n                                                      T one_over_scale2) {\n        T J[16];\n        T fp[2];\n        \n        ZeroVector(JtJ, 64);\n        ZeroVector(Jtr, 8);\n        \n        for(int i = 0; i < num_points; i++, p+=2, q+=2) {\n            // Jacobian\n            RobustHomographyLieJacobianPostMultiply(J, fp, H, p, q, one_over_scale2);\n            \n            // JtJ += J'*J\n            MultiplyAndAccumulateAtA(JtJ, J, 2, 8);\n            \n            // Jtr += J'*r\n            MultiplyAndAccumulateAtx(Jtr, J, 2, 8, fp);\n        }\n        \n        SymmetricExtendUpperToLower(JtJ, 8);\n        ScaleVector8<T>(Jtr, Jtr, -1);\n    }\n    \n    /**\n\t * Regularize the 8x8 system with Levenberg-Marquardt.\n\t *\n\t * JtJ+diag(lambda*diag(JtJ))\n\t */\n\ttemplate<typename T>\n\tinline void RegularizeLevenbergMarquardt8x8(T JtJ[64], const T in_JtJ[64], T lambda) {\n\t\tJtJ[0]  = in_JtJ[0]  + (lambda*in_JtJ[0]);\n\t\tJtJ[9]  = in_JtJ[9]  + (lambda*in_JtJ[9]);\n\t\tJtJ[18] = in_JtJ[18] + (lambda*in_JtJ[18]);\n\t\tJtJ[27] = in_JtJ[27] + (lambda*in_JtJ[27]);\n\t\tJtJ[36] = in_JtJ[36] + (lambda*in_JtJ[36]);\n\t\tJtJ[45] = in_JtJ[45] + (lambda*in_JtJ[45]);\n\t\tJtJ[54] = in_JtJ[54] + (lambda*in_JtJ[54]);\n\t\tJtJ[63] = in_JtJ[63] + (lambda*in_JtJ[63]);\n\t}\n    \n    /**\n\t * This is the Lie Basis summation.\n     * \"Homography-based 2d visual tracking and servoing\", S. Benhimane, E. Malis\n\t */\n\ttemplate<typename T>\n\tinline void LieAlgebraSum(T A[9], const T x[8]) {\n\t\tA[0] = x[4];\tA[1] = x[2];\t\tA[2] = x[0];\n\t\tA[3] = x[3];\tA[4] = -x[4]-x[5];\tA[5] = x[1];\n\t\tA[6] = x[6];\tA[7] = x[7];\t\tA[8] = x[5];\n\t}\n    \n    /**\n\t * Compute the incremental update from the Lie Algebra Basis\n\t */\n\ttemplate<typename T>\n\tinline void IncrementalHomographyFromLieWeights(T H[9], const T x[8]) {\n\t\tLieAlgebraSum(H, x);\n\t\t\n\t\t// TODO: remove Eigen\n\t\tEigen::Matrix<T, 3, 3> eigenMat;\n\t\tCopyVector9<T>(eigenMat.data(), H);\n\t\tEigen::Matrix<T, 3, 3> matExp;\n\t\tmatExp = eigenMat.exp();\n\t\tCopyVector9(H, matExp.data());\n\t}\n    \n    /**\n\t * Update homography with projective motion\n     *\n     * Hp = (I+H)*H0\n     *\n     * @param[out] Hp\n     * @param[in] H\n     * @param[in] motion Lie weights\n\t */\n\ttemplate<typename T>\n\tinline void UpdateProjectiveMotionPostMultiply(T Hp[9], const T H[9], const T x0[8]) {\n        T tmp[9];\n\t\tT H_delta[9];\n\t\t\n        CopyVector9(tmp, H);\n\t\tIncrementalHomographyFromLieWeights(H_delta, x0);\n\t\tMultiply3x3_3x3(Hp, H_delta, tmp);\n\t}\n    \n    /**\n     * Minimizes the Cauchy Robustified error between points H*p and q in the functional f(Hp-q).\n     *\n     * @param[in/out] H input homography should be the initial estimate\n     * @param[in] p array of points in [x1,y1,x2,y2,...,xk,yk] format\n     * @param[in] q array of points in [x1,y1,x2,y2,...,xk,yk] format\n     * @param[in] type motion type\n     * @param[in] scale Cauchy scale\n     * @param[in] max_iterations max number of iterations\n     * @param[in] max_stops max number of non-converging iterations before stopping\n     * @parms[in] improvement min amount of improvement on each iteration causing stops to be incremented\n     */\n    template<typename T>\n    bool PolishHomography(T H[9],\n                           const T* p,\n                           const T* q,\n                           int num_points,\n                           T scale = HOMOGRAPHY_DEFAULT_CAUCHY_SCALE,\n                           int max_iterations = 500,\n                           int max_stops = 20,\n                           T improvement = 0.0001)\n    {\n        T one_over_scale2;\n        T JtJ[64];\n        T reg_JtJ[64];\n        T Jtr[8];\n        T delta[8];\n        T cost, last_cost;\n        bool update;\n        T lambda;\n        T Hp[9];\n        int stops;\n        int num_params;\n        \n        stops = 0;\n        lambda = 0.01;\n        update = true;\n        one_over_scale2 = 1/(scale*scale);\n        \n        num_params = 8;\n        \n        last_cost = CauchyProjectiveReprojectionCost(H, p, q, num_points, one_over_scale2);\n        \n        int i;\n        for(i = 0; i < max_iterations && stops < max_stops; i++) {\n            if(update) {\n                ComputeHomographyNormalEquationsPostMultiply(JtJ, Jtr, H, p, q, num_points, one_over_scale2);\n                CopyVector(reg_JtJ, JtJ, num_params*num_params);\n            }\n            \n            //\n            // Solve the linear system\n            //\n            RegularizeLevenbergMarquardt8x8(reg_JtJ, JtJ, lambda);\n            if(!SolvePositiveDefiniteSystem<T, 8>(delta, reg_JtJ, Jtr, 0)) {\n                return false;\n            }\n            UpdateProjectiveMotionPostMultiply(Hp, H, delta);\n\t\t\t\n            //\n            // Compute robust error function\n            //\n            cost = CauchyProjectiveReprojectionCost(Hp, p, q, num_points, one_over_scale2);\n            \n\t\t\tif(cost < last_cost) {\n\t\t\t\tCopyVector9(H, Hp);\n\t\t\t\tstops = (last_cost - cost) < improvement ? stops + 1 : 0;\n\t\t\t\tlast_cost = cost;\n                lambda = max2<T>(lambda*0.1, 0.000001);\n\t\t\t\tupdate = true;\n\t\t\t}\n\t\t\telse {\n                lambda = min2<T>(lambda*10, 100000);\n\t\t\t\tstops++;\n\t\t\t\tupdate = false;\n\t\t\t}\n        }\n        \n        return true;\n    }\n    \n    /**\n     * Robust homography estimation.\n     */\n    template<typename T>\n    class RobustHomography {\n    public:\n        \n        RobustHomography(T cauchyScale          = HOMOGRAPHY_DEFAULT_CAUCHY_SCALE,\n                         int maxNumHypotheses   = HOMOGRAPHY_DEFAULT_NUM_HYPOTHESES,\n                         int maxTrials          = HOMOGRAPHY_DEFAULT_MAX_TRIALS,\n                         int chunkSize          = HOMOGRAPHY_DEFAULT_CHUNK_SIZE);\n        ~RobustHomography() {}\n        \n        /**\n         * Initalize the RANSAC parameters.\n         */\n        void init(T cauchyScale,\n                  int maxNumHypotheses,\n                  int maxTrials,\n                  int chunkSize);\n        \n        /**\n         * Find the homography from a set of 2D correspondences.\n         */\n        bool find(float H[9], const T* p, const T* q, int num_points);\n        bool find(float H[9], const T* p, const T* q, int num_points, const T* test_points, int num_test_points);\n        \n    private:\n        \n        // Temporary memory for RANSAC\n        std::vector<T> mHyp;\n        std::vector<int> mTmpi;\n        std::vector< std::pair<T, int> > mHypCosts;\n        \n        // RANSAC params\n        T mCauchyScale;\n        int mMaxNumHypotheses;\n        int mMaxTrials;\n        int mChunkSize;\n        \n    }; // RobustHomography\n    \n    template<typename T>\n    RobustHomography<T>::RobustHomography(T cauchyScale,\n                                          int maxNumHypotheses,\n                                          int maxTrials,\n                                          int chunkSize) {\n        init(cauchyScale, maxNumHypotheses, maxTrials, chunkSize);\n    }\n    \n    template<typename T>\n    void RobustHomography<T>::init(T cauchyScale,\n                                   int maxNumHypotheses,\n                                   int maxTrials,\n                                   int chunkSize) {\n        mHyp.resize(9*maxNumHypotheses);\n        mHypCosts.resize(maxNumHypotheses);\n        \n        mCauchyScale = cauchyScale;\n        mMaxNumHypotheses = maxNumHypotheses;\n        mMaxTrials = maxTrials;\n        mChunkSize = chunkSize;\n    }\n    \n    template<typename T>\n    bool RobustHomography<T>::find(float H[9], const T* p, const T* q, int num_points) {\n        mTmpi.resize(num_points);\n        if(!PreemptiveRobustHomography<T>(H,\n                                          p,\n                                          q,\n                                          num_points,\n                                          0,\n                                          0,\n                                          mHyp,\n                                          mTmpi,\n                                          mHypCosts,\n                                          mCauchyScale,\n                                          mMaxNumHypotheses,\n                                          mMaxTrials,\n                                          mChunkSize)) {\n            return false;\n        }\n        \n        return PolishHomography(H, p, q, num_points);\n    }\n    \n    template<typename T>\n    bool RobustHomography<T>::find(float H[9], const T* p, const T* q, int num_points, const T* test_points, int num_test_points) {\n        mTmpi.resize(num_points);\n        return PreemptiveRobustHomography<T>(H,\n                                             p,\n                                             q,\n                                             num_points,\n                                             test_points,\n                                             num_test_points,\n                                             mHyp,\n                                             mTmpi,\n                                             mHypCosts,\n                                             mCauchyScale,\n                                             mMaxNumHypotheses,\n                                             mMaxTrials,\n                                             mChunkSize);\n    }\n    \n} // vision\n","//\n//  DoG_scale_invariant_detector.cpp\n//  ARToolKit5\n//\n//  This file is part of ARToolKit.\n//\n//  ARToolKit is free software: you can redistribute it and/or modify\n//  it under the terms of the GNU Lesser General Public License as published by\n//  the Free Software Foundation, either version 3 of the License, or\n//  (at your option) any later version.\n//\n//  ARToolKit is distributed in the hope that it will be useful,\n//  but WITHOUT ANY WARRANTY; without even the implied warranty of\n//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n//  GNU Lesser General Public License for more details.\n//\n//  You should have received a copy of the GNU Lesser General Public License\n//  along with ARToolKit.  If not, see <http://www.gnu.org/licenses/>.\n//\n//  As a special exception, the copyright holders of this library give you\n//  permission to link this library with independent modules to produce an\n//  executable, regardless of the license terms of these independent modules, and to\n//  copy and distribute the resulting executable under terms of your choice,\n//  provided that you also meet, for each linked independent module, the terms and\n//  conditions of the license of that module. An independent module is a module\n//  which is neither derived from nor based on this library. If you modify this\n//  library, you may extend this exception to your version of the library, but you\n//  are not obligated to do so. If you do not wish to do so, delete this exception\n//  statement from your version.\n//\n//  Copyright 2013-2015 Daqri, LLC.\n//\n//  Author(s): Chris Broaddus\n//\n\n#include \"DoG_scale_invariant_detector.h\"\n#include <framework/error.h>\n#include <framework/timers.h>\n#include <math/math_utils.h>\n#include <math/linear_algebra.h>\n#include <algorithm>\n#include <functional>\n#include \"interpolate.h\"\n\nusing namespace vision;\n\nDoGPyramid::DoGPyramid()\n: mNumOctaves(0)\n, mNumScalesPerOctave(0)\n{}\n\nvoid DoGPyramid::alloc(const GaussianScaleSpacePyramid* pyramid) {\n    ASSERT(pyramid->size() > 0, \"Pyramid is not allocated\");\n   \n    ImageType type = pyramid->get(0, 0).type();\n    size_t width = pyramid->get(0, 0).width();\n    size_t height = pyramid->get(0, 0).height();\n    \n    mNumOctaves = pyramid->numOctaves();;\n    mNumScalesPerOctave = pyramid->numScalesPerOctave()-1;\n    \n    // Allocate DoG images\n    mImages.resize(mNumOctaves*mNumScalesPerOctave);\n    for(size_t i = 0; i < mNumOctaves; i++) {\n        for(size_t j = 0; j < mNumScalesPerOctave; j++) {\n            mImages[i*mNumScalesPerOctave+j].alloc(type, width>>i, height>>i, AUTO_STEP, 1);\n        }\n    }\n}\n\nvoid DoGPyramid::compute(const GaussianScaleSpacePyramid* pyramid) {\n    ASSERT(mImages.size() > 0, \"Laplacian pyramid has not been allocated\");\n    ASSERT(pyramid->numOctaves() > 0, \"Pyramid does not contain any levels\");\n    ASSERT(dynamic_cast<const BinomialPyramid32f*>(pyramid), \"Only binomial pyramid is supported\");\n    \n    for(size_t i = 0; i < mNumOctaves; i++) {\n        for(size_t j = 0; j < mNumScalesPerOctave; j++) {\n            difference_image_binomial(get(i, j),\n                                      pyramid->get(i, j),\n                                      pyramid->get(i, j+1));\n        }\n    }\n}\n\nvoid DoGPyramid::difference_image_binomial(Image& d, const Image& im1, const Image& im2) {\n    ASSERT(d.type() == IMAGE_F32, \"Only F32 images supported\");\n    ASSERT(im1.type() == IMAGE_F32, \"Only F32 images supported\");\n    ASSERT(im2.type() == IMAGE_F32, \"Only F32 images supported\");\n    ASSERT(d.channels() == 1, \"Only single channel images supported\");\n    ASSERT(im1.channels() == 1, \"Only single channel images supported\");\n    ASSERT(im2.channels() == 1, \"Only single channel images supported\");\n    ASSERT(d.width() == im2.width(), \"Images must have the same width\");\n    ASSERT(d.height() == im2.height(), \"Images must have the same height\");\n    ASSERT(im1.width() == im2.width(), \"Images must have the same width\");\n    ASSERT(im1.height() == im2.height(), \"Images must have the same height\");\n    \n    // Compute diff\n    for(size_t i = 0; i < im1.height(); i++) {\n        float* p0 = d.get<float>(i);\n        const float* p1 = im1.get<float>(i);\n        const float* p2 = im2.get<float>(i);\n        for(size_t j = 0; j < im1.width(); j++) {\n            p0[j] = p1[j]-p2[j];\n        }\n    }\n}\n\nDoGScaleInvariantDetector::DoGScaleInvariantDetector()\n: mWidth(0)\n, mHeight(0)\n, mNumBucketsX(10)\n, mNumBucketsY(10)\n, mFindOrientation(true)\n, mLaplacianThreshold(0)\n, mEdgeThreshold(10)\n, mMaxSubpixelDistanceSqr(3*3) {\n    setMaxNumFeaturePoints(kMaxNumFeaturePoints);\n    mOrientations.resize(kMaxNumOrientations);\n}\n\nDoGScaleInvariantDetector::~DoGScaleInvariantDetector() {}\n\nvoid DoGScaleInvariantDetector::alloc(const GaussianScaleSpacePyramid* pyramid) {\n    mLaplacianPyramid.alloc(pyramid);\n    \n    mOrientationAssignment.alloc(pyramid->images()[0].width(),\n                                 pyramid->images()[0].height(),\n                                 pyramid->numOctaves(),\n                                 pyramid->numScalesPerOctave(),\n                                 kMaxNumOrientations,\n                                 3,\n                                 1.5,\n                                 5,\n                                 0.8);\n    \n    mWidth = pyramid->images()[0].width();\n    mHeight = pyramid->images()[0].height();\n    \n    // Allocate bucket container\n    mBuckets.resize(mNumBucketsX);\n    for(size_t i = 0; i < mBuckets.size(); i++) {\n        mBuckets[i].resize(mNumBucketsY);\n    }\n}\n\nvoid DoGScaleInvariantDetector::detect(const GaussianScaleSpacePyramid* pyramid) {\n    ASSERT(pyramid->numOctaves() > 0, \"Pyramid does not contain any levels\");\n    \n    // Compute Laplacian images (DoG)\n    TIMED(\"DoG Pyramid\") {\n        mLaplacianPyramid.compute(pyramid);\n    }\n    \n    // Detect minima and maximum in Laplacian images\n    TIMED(\"Non-max suppression\") {\n        extractFeatures(pyramid, &mLaplacianPyramid);\n    }\n    \n    // Sub-pixel refinement\n    TIMED(\"Subpixel\") {\n        findSubpixelLocations(pyramid);\n    }\n    \n    // Prune features\n    TIMED(\"pruneFeatures\") {\n        pruneFeatures();\n    }\n    \n    // Compute dominant angles\n    TIMED(\"Find Orientations\") {\n        findFeatureOrientations(pyramid);\n    }\n}\n\nvoid DoGScaleInvariantDetector::extractFeatures(const GaussianScaleSpacePyramid* pyramid,\n                                                const DoGPyramid* laplacian) {\n    \n    // Clear old features\n    mFeaturePoints.clear();\n    \n    float laplacianSqrThreshold = sqr(mLaplacianThreshold);\n    \n    for(size_t i = 1; i < mLaplacianPyramid.size()-1; i++) {\n        const Image& im0 = laplacian->get(i-1);\n        const Image& im1 = laplacian->get(i);\n        const Image& im2 = laplacian->get(i+1);\n        \n        int octave = laplacian->octaveFromIndex((int)i);\n        int scale = laplacian->scaleFromIndex((int)i);\n        \n        if(im0.width() == im1.width() && im0.width() == im2.width()) { // All images are the same size\n            ASSERT(im0.height() == im1.height(), \"Height is inconsistent\");\n            ASSERT(im0.height() == im2.height(), \"Height is inconsistent\");\n            \n            size_t width_minus_1 = im1.width() - 1;\n            size_t heigh_minus_1 = im1.height() - 1;\n            \n            for(size_t row = 1; row < heigh_minus_1; row++) {\n                const float* im0_ym1 = im0.get<float>(row-1);\n                const float* im0_y   = im0.get<float>(row);\n                const float* im0_yp1 = im0.get<float>(row+1);\n                \n                const float* im1_ym1 = im1.get<float>(row-1);\n                const float* im1_y   = im1.get<float>(row);\n                const float* im1_yp1 = im1.get<float>(row+1);\n                \n                const float* im2_ym1 = im2.get<float>(row-1);\n                const float* im2_y   = im2.get<float>(row);\n                const float* im2_yp1 = im2.get<float>(row+1);\n                \n                for(size_t col = 1; col < width_minus_1; col++) {\n                    const float& value = im1_y[col];\n                    FeaturePoint fp;\n                    \n                    // Check laplacian score\n                    if(sqr(value) < laplacianSqrThreshold) {\n                        continue;\n                    }\n                    \n#define NONMAX_CHECK(OPERATOR, VALUE)                  \\\n                    /* im0 - 9 evaluations */          \\\n                    VALUE OPERATOR im0_ym1[col-1]   && \\\n                    VALUE OPERATOR im0_ym1[col]     && \\\n                    VALUE OPERATOR im0_ym1[col+1]   && \\\n                    VALUE OPERATOR im0_y[col-1]     && \\\n                    VALUE OPERATOR im0_y[col]       && \\\n                    VALUE OPERATOR im0_y[col+1]     && \\\n                    VALUE OPERATOR im0_yp1[col-1]   && \\\n                    VALUE OPERATOR im0_yp1[col]     && \\\n                    VALUE OPERATOR im0_yp1[col+1]   && \\\n                    /* im1 - 8 evaluations */          \\\n                    VALUE OPERATOR im1_ym1[col-1]   && \\\n                    VALUE OPERATOR im1_ym1[col]     && \\\n                    VALUE OPERATOR im1_ym1[col+1]   && \\\n                    VALUE OPERATOR im1_y[col-1]     && \\\n                    VALUE OPERATOR im1_y[col+1]     && \\\n                    VALUE OPERATOR im1_yp1[col-1]   && \\\n                    VALUE OPERATOR im1_yp1[col]     && \\\n                    VALUE OPERATOR im1_yp1[col+1]   && \\\n                    /* im2 - 9 evaluations */          \\\n                    VALUE OPERATOR im2_ym1[col-1]   && \\\n                    VALUE OPERATOR im2_ym1[col]     && \\\n                    VALUE OPERATOR im2_ym1[col+1]   && \\\n                    VALUE OPERATOR im2_y[col-1]     && \\\n                    VALUE OPERATOR im2_y[col]       && \\\n                    VALUE OPERATOR im2_y[col+1]     && \\\n                    VALUE OPERATOR im2_yp1[col-1]   && \\\n                    VALUE OPERATOR im2_yp1[col]     && \\\n                    VALUE OPERATOR im2_yp1[col+1]\n                    \n                    bool extrema = false;\n                    if(NONMAX_CHECK(>, value)) { // strictly greater than\n                        extrema = true;\n                    } else if(NONMAX_CHECK(<, value)) { // strictly less than\n                        extrema = true;\n                    }\n                    \n                    if(extrema) {\n                        fp.octave = octave;\n                        fp.scale  = scale;\n                        fp.score  = value;\n                        fp.sigma  = pyramid->effectiveSigma(octave, scale);\n                        \n                        bilinear_upsample_point(fp.x,\n                                                fp.y,\n                                                col,\n                                                row,\n                                                octave);\n                        \n                        mFeaturePoints.push_back(fp);\n                    }\n                    \n#undef NONMAX_CHECK\n                }\n            }\n        } else if(im0.width() == im1.width() && (im1.width()>>1) == im2.width()) { // 0,1 are the same size, 2 is half size\n            ASSERT(im0.height() == im1.height(), \"Height is inconsistent\");\n            ASSERT((im1.height()>>1) == im2.height(), \"Height is inconsistent\");\n    \n            size_t end_x = std::floor(((im2.width()-1)-0.5f)*2.f+0.5f);\n            size_t end_y = std::floor(((im2.height()-1)-0.5f)*2.f+0.5f);\n\n            for(size_t row = 2; row < end_y; row++) {\n                const float* im0_ym1 = im0.get<float>(row-1);\n                const float* im0_y   = im0.get<float>(row);\n                const float* im0_yp1 = im0.get<float>(row+1);\n                \n                const float* im1_ym1 = im1.get<float>(row-1);\n                const float* im1_y   = im1.get<float>(row);\n                const float* im1_yp1 = im1.get<float>(row+1);\n\n                for(size_t col = 2; col < end_x; col++) {\n                    const float& value = im1_y[col];\n                    FeaturePoint fp;\n                    \n                    // Check laplacian score\n                    if(sqr(value) < laplacianSqrThreshold) {\n                        continue;\n                    }\n                    \n                    // Compute downsampled point location\n                    float ds_x = col*0.5f-0.25f;\n                    float ds_y = row*0.5f-0.25f;\n                                        \n#define NONMAX_CHECK(OPERATOR, VALUE)                  \\\n                    /* im0 - 9 evaluations */          \\\n                    VALUE OPERATOR im0_ym1[col-1]   && \\\n                    VALUE OPERATOR im0_ym1[col]     && \\\n                    VALUE OPERATOR im0_ym1[col+1]   && \\\n                    VALUE OPERATOR im0_y[col-1]     && \\\n                    VALUE OPERATOR im0_y[col]       && \\\n                    VALUE OPERATOR im0_y[col+1]     && \\\n                    VALUE OPERATOR im0_yp1[col-1]   && \\\n                    VALUE OPERATOR im0_yp1[col]     && \\\n                    VALUE OPERATOR im0_yp1[col+1]   && \\\n                    /* im1 - 8 evaluations */          \\\n                    VALUE OPERATOR im1_ym1[col-1]   && \\\n                    VALUE OPERATOR im1_ym1[col]     && \\\n                    VALUE OPERATOR im1_ym1[col+1]   && \\\n                    VALUE OPERATOR im1_y[col-1]     && \\\n                    VALUE OPERATOR im1_y[col+1]     && \\\n                    VALUE OPERATOR im1_yp1[col-1]   && \\\n                    VALUE OPERATOR im1_yp1[col]     && \\\n                    VALUE OPERATOR im1_yp1[col+1]   && \\\n                    /* im2 - 9 evaluations */          \\\n                    VALUE OPERATOR bilinear_interpolation<float>(im2, ds_x-0.5f, ds_y-0.5f)   && \\\n                    VALUE OPERATOR bilinear_interpolation<float>(im2, ds_x,      ds_y-0.5f)   && \\\n                    VALUE OPERATOR bilinear_interpolation<float>(im2, ds_x+0.5f, ds_y-0.5f)   && \\\n                    VALUE OPERATOR bilinear_interpolation<float>(im2, ds_x-0.5f, ds_y)        && \\\n                    VALUE OPERATOR bilinear_interpolation<float>(im2, ds_x,      ds_y)        && \\\n                    VALUE OPERATOR bilinear_interpolation<float>(im2, ds_x+0.5f, ds_y)        && \\\n                    VALUE OPERATOR bilinear_interpolation<float>(im2, ds_x-0.5f, ds_y+0.5f)   && \\\n                    VALUE OPERATOR bilinear_interpolation<float>(im2, ds_x,      ds_y+0.5f)   && \\\n                    VALUE OPERATOR bilinear_interpolation<float>(im2, ds_x+0.5f, ds_y+0.5f)\n\n                    bool extrema = false;\n                    if(NONMAX_CHECK(>, value)) { // strictly greater than\n                        extrema = true;\n                    } else if(NONMAX_CHECK(<, value)) { // strictly less than\n                        extrema = true;\n                    }\n                    \n                    if(extrema) {\n                        fp.octave = octave;\n                        fp.scale  = scale;\n                        fp.score  = value;\n                        fp.sigma  = pyramid->effectiveSigma(octave, scale);\n                        \n                        bilinear_upsample_point(fp.x,\n                                                fp.y,\n                                                col,\n                                                row,\n                                                octave);\n                        \n                        mFeaturePoints.push_back(fp);\n                    }\n                    \n#undef NONMAX_CHECK\n                }\n            }\n        } else if((im0.width()>>1) == im1.width() && (im0.width()>>1) == im2.width()) { // 0 is twice the size of 1 and 2\n            ASSERT((im0.height()>>1) == im1.height(), \"Height is inconsistent\");\n            ASSERT((im0.height()>>1) == im2.height(), \"Height is inconsistent\");\n            \n            size_t width_minus_1 = im1.width() - 1;\n            size_t height_minus_1 = im1.height() - 1;\n            \n            for(size_t row = 1; row < height_minus_1; row++) {\n                const float* im1_ym1 = im1.get<float>(row-1);\n                const float* im1_y   = im1.get<float>(row);\n                const float* im1_yp1 = im1.get<float>(row+1);\n                \n                const float* im2_ym1 = im2.get<float>(row-1);\n                const float* im2_y   = im2.get<float>(row);\n                const float* im2_yp1 = im2.get<float>(row+1);\n                \n                for(size_t col = 1; col < width_minus_1; col++) {\n                    const float& value = im1_y[col];\n                    FeaturePoint fp;\n                    \n                    // Check laplacian score\n                    if(sqr(value) < laplacianSqrThreshold) {\n                        continue;\n                    }\n                    \n                    float us_x = (col<<1)+0.5f;\n                    float us_y = (row<<1)+0.5f;\n                    \n#define NONMAX_CHECK(OPERATOR, VALUE)                  \\\n                    /* im1 - 8 evaluations */          \\\n                    VALUE OPERATOR im1_ym1[col-1]   && \\\n                    VALUE OPERATOR im1_ym1[col]     && \\\n                    VALUE OPERATOR im1_ym1[col+1]   && \\\n                    VALUE OPERATOR im1_y[col-1]     && \\\n                    VALUE OPERATOR im1_y[col+1]     && \\\n                    VALUE OPERATOR im1_yp1[col-1]   && \\\n                    VALUE OPERATOR im1_yp1[col]     && \\\n                    VALUE OPERATOR im1_yp1[col+1]   && \\\n                    /* im2 - 9 evaluations */          \\\n                    VALUE OPERATOR im2_ym1[col-1]   && \\\n                    VALUE OPERATOR im2_ym1[col]     && \\\n                    VALUE OPERATOR im2_ym1[col+1]   && \\\n                    VALUE OPERATOR im2_y[col-1]     && \\\n                    VALUE OPERATOR im2_y[col]       && \\\n                    VALUE OPERATOR im2_y[col+1]     && \\\n                    VALUE OPERATOR im2_yp1[col-1]   && \\\n                    VALUE OPERATOR im2_yp1[col]     && \\\n                    VALUE OPERATOR im2_yp1[col+1]   && \\\n                    /* im2 - 9 evaluations */          \\\n                    VALUE OPERATOR bilinear_interpolation<float>(im0, us_x-2.f, us_y-2.f)   && \\\n                    VALUE OPERATOR bilinear_interpolation<float>(im0, us_x,     us_y-2.f)   && \\\n                    VALUE OPERATOR bilinear_interpolation<float>(im0, us_x+2.f, us_y-2.f)   && \\\n                    VALUE OPERATOR bilinear_interpolation<float>(im0, us_x-2.f, us_y)       && \\\n                    VALUE OPERATOR bilinear_interpolation<float>(im0, us_x,     us_y)       && \\\n                    VALUE OPERATOR bilinear_interpolation<float>(im0, us_x+2.f, us_y)       && \\\n                    VALUE OPERATOR bilinear_interpolation<float>(im0, us_x-2.f, us_y+2.f)   && \\\n                    VALUE OPERATOR bilinear_interpolation<float>(im0, us_x,     us_y+2.f)   && \\\n                    VALUE OPERATOR bilinear_interpolation<float>(im0, us_x+2.f, us_y+2.f)\n                    \n                    bool extrema = false;\n                    if(NONMAX_CHECK(>, value)) { // strictly greater than\n                        extrema = true;\n                    } else if(NONMAX_CHECK(<, value)) { // strictly less than\n                        extrema = true;\n                    }\n                    \n                    if(extrema) {\n                        fp.octave = octave;\n                        fp.scale  = scale;\n                        fp.score  = value;\n                        fp.sigma  = pyramid->effectiveSigma(octave, scale);\n                        \n                        bilinear_upsample_point(fp.x,\n                                                fp.y,\n                                                col,\n                                                row,\n                                                octave);\n                        \n                        mFeaturePoints.push_back(fp);\n                    }\n                    \n#undef NONMAX_CHECK\n                }\n            }\n        }\n    }\n}\n\nvoid DoGScaleInvariantDetector::pruneFeatures() {\n    if(mFeaturePoints.size() <= mMaxNumFeaturePoints) {\n        return;\n    }\n    \n    ASSERT(mBuckets.size() == mNumBucketsX, \"Buckets are not allocated\");\n    ASSERT(mBuckets[0].size() == mNumBucketsY, \"Buckets are not allocated\");\n    \n    std::vector<FeaturePoint> points;\n    PruneDoGFeatures(mBuckets,\n                     points,\n                     mFeaturePoints,\n                     (int)mNumBucketsX,\n                     (int)mNumBucketsY,\n                     (int)mWidth,\n                     (int)mHeight,\n                     (int)mMaxNumFeaturePoints);\n    \n    mFeaturePoints.swap(points);\n    \n    ASSERT(mFeaturePoints.size() <= mMaxNumFeaturePoints, \"Too many feature points\");\n}\n\nvoid DoGScaleInvariantDetector::findSubpixelLocations(const GaussianScaleSpacePyramid* pyramid) {\n    float A[9];\n    float b[3];\n    float u[3];\n    int x, y;\n    float xp, yp;\n    int num_points;\n    float laplacianSqrThreshold;\n    float hessianThreshold;\n    \n    num_points = 0;\n    laplacianSqrThreshold = sqr(mLaplacianThreshold);\n    hessianThreshold = (sqr(mEdgeThreshold+1)/mEdgeThreshold);\n    \n    for(size_t i = 0; i < mFeaturePoints.size(); i++) {\n        FeaturePoint& kp = mFeaturePoints[i];\n        \n        ASSERT(kp.scale < mLaplacianPyramid.numScalePerOctave(), \"Feature point scale is out of bounds\");\n        int lap_index = kp.octave*mLaplacianPyramid.numScalePerOctave()+kp.scale;\n        \n        // Downsample the feature point to the detection octave\n        bilinear_downsample_point(xp, yp, kp.x, kp.y, kp.octave);\n        \n        // Compute the discrete pixel location TODO\n        x = (int)(xp+0.5f);\n        y = (int)(yp+0.5f);\n        \n        // Get Laplacian images\n        const Image& lap0 = mLaplacianPyramid.images()[lap_index-1];\n        const Image& lap1 = mLaplacianPyramid.images()[lap_index];\n        const Image& lap2 = mLaplacianPyramid.images()[lap_index+1];\n        \n        // Compute the Hessian\n        if(!ComputeSubpixelHessian(A, b, lap0, lap1, lap2, x, y)) {\n            continue;\n        }\n        \n        // A*u=b\n        if(!SolveSymmetricLinearSystem3x3(u, A, b)) {\n            continue;\n        }\n        \n        // If points move too much in the sub-pixel update, then the point probably\n        // unstable.\n        if(sqr(u[0])+sqr(u[1]) > mMaxSubpixelDistanceSqr) {\n            continue;\n        }\n        \n        // Compute the edge score\n        if(!ComputeEdgeScore(kp.edge_score, A)) {\n            continue;\n        }\n        \n        // Compute a linear estimate of the intensity\n        ASSERT(kp.score == lap1.get<float>(y)[x], \"Score is not consistent with the DoG image\");\n        kp.score = lap1.get<float>(y)[x] - (b[0]*u[0] + b[1]*u[1] + b[2]*u[2]);\n        \n        // Update the location:\n        // Apply the update on the downsampled location and then upsample the result.\n        bilinear_upsample_point(kp.x, kp.y, xp+u[0], yp+u[1], kp.octave);\n        \n        // Update the scale\n        kp.sp_scale = kp.scale + u[2];\n        kp.sp_scale = ClipScalar<float>(kp.sp_scale, 0, mLaplacianPyramid.numScalePerOctave());\n        \n        if(std::abs(kp.edge_score)  < hessianThreshold &&\n           sqr(kp.score)            >= laplacianSqrThreshold &&\n           kp.x                     >= 0 &&\n           kp.x                     < mLaplacianPyramid.images()[0].width() &&\n           kp.y                     >= 0 &&\n           kp.y                     < mLaplacianPyramid.images()[0].height()) {\n            // Update the sigma\n            kp.sigma = pyramid->effectiveSigma(kp.octave, kp.sp_scale);\n            mFeaturePoints[num_points++] = kp;\n        }\n    }\n    \n    mFeaturePoints.resize(num_points);\n}\n\nvoid DoGScaleInvariantDetector::findFeatureOrientations(const GaussianScaleSpacePyramid* pyramid) {\n    if(!mFindOrientation) {\n        for(size_t i = 0; i < mFeaturePoints.size(); i++) {\n            mFeaturePoints[i].angle = 0;\n        }\n        return;\n    }\n\n    int num_angles;\n    mTmpOrientatedFeaturePoints.clear();\n    mTmpOrientatedFeaturePoints.reserve(mFeaturePoints.size()*kMaxNumOrientations);\n    \n    // Compute the gradient pyramid\n    mOrientationAssignment.computeGradients(pyramid);\n    \n    // Compute an orientation for each feature point\n    for(size_t i = 0; i < mFeaturePoints.size(); i++) {\n        float x, y, s;\n        \n        // Down sample the point to the detected octave\n        bilinear_downsample_point(x,\n                                  y,\n                                  s, \n                                  mFeaturePoints[i].x,\n                                  mFeaturePoints[i].y,\n                                  mFeaturePoints[i].sigma,\n                                  mFeaturePoints[i].octave);\n        \n        // Downsampling the point can cause (x,y) to leave the image bounds by\n        // a tiny amount. Here we just clip it to be within the image bounds.\n        x = ClipScalar<float>(x, 0, pyramid->get(mFeaturePoints[i].octave, 0).width()-1);\n        y = ClipScalar<float>(y, 0, pyramid->get(mFeaturePoints[i].octave, 0).height()-1);\n        \n        // Compute dominant orientations\n        mOrientationAssignment.compute(&mOrientations[0],\n                                       num_angles,\n                                       mFeaturePoints[i].octave,\n                                       mFeaturePoints[i].scale,\n                                       x,\n                                       y,\n                                       s);\n        \n        // Create a feature point for each angle\n        for(int j = 0; j < num_angles; j++) {\n            // Copy the feature point\n            FeaturePoint fp = mFeaturePoints[i];\n            // Update the orientation\n            fp.angle = mOrientations[j];\n            // Store oriented feature point\n            mTmpOrientatedFeaturePoints.push_back(fp);\n        }\n    }\n    \n    mFeaturePoints.swap(mTmpOrientatedFeaturePoints);\n}\n\nnamespace vision {\n    \n    void PruneDoGFeatures(std::vector<std::vector<std::vector<std::pair<float, size_t> > > >& buckets,\n                          std::vector<DoGScaleInvariantDetector::FeaturePoint>& outPoints,\n                          const std::vector<DoGScaleInvariantDetector::FeaturePoint>& inPoints,\n                          int num_buckets_X,\n                          int num_buckets_Y,\n                          int width,\n                          int height,\n                          int max_points) {\n        \n        int num_buckets = num_buckets_X*num_buckets_Y;\n        int num_points_per_bucket = max_points/num_buckets;\n        // TODO\n        int dx = (int)std::ceil((float)width/num_buckets_X);\n        int dy = (int)std::ceil((float)height/num_buckets_Y);\n        \n        //\n        // Clear the previous state\n        //\n        outPoints.clear();\n        outPoints.reserve(max_points);\n        for(size_t i = 0; i < buckets.size(); i++) {\n            for(size_t j = 0; j < buckets[i].size(); j++) {\n                buckets[i][j].clear();\n            }\n        }\n        \n        //\n        // Insert each features into a bucket\n        //\n        for(size_t i = 0; i < inPoints.size(); i++) {\n            const DoGScaleInvariantDetector::FeaturePoint& p = inPoints[i];\n            int binX = p.x/dx;\n            int binY = p.y/dy;\n            buckets[binX][binY].push_back(std::make_pair(std::abs(p.score), i));\n        }\n        \n        //\n        // Do a partial sort on the first N points of each bucket\n        //\n        for(size_t i = 0; i < buckets.size(); i++) {\n            for(size_t j = 0; j < buckets[i].size(); j++) {\n                std::vector<std::pair<float, size_t> >& bucket = buckets[i][j];\n                size_t n = std::min<size_t>(bucket.size(), num_points_per_bucket);\n                if(n == 0) {\n                    continue;\n                }\n                std::nth_element(bucket.begin(),\n                                 bucket.begin()+n,\n                                 bucket.end(), std::greater<std::pair<float, size_t> >());\n                \n                DEBUG_BLOCK(\n                            if(n > bucket.size()) {\n                                ASSERT(bucket[0].first >= bucket[n].first, \"nth_element failed\");\n                            }\n                            )\n                \n                for(size_t k = 0; k < n; k++) {\n                    outPoints.push_back(inPoints[bucket[k].second]);\n                }\n            }\n        }\n    }\n    \n}","/*\n *  icpUtil.c\n *  ARToolKit5\n *\n *  This file is part of ARToolKit.\n *\n *  ARToolKit is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation, either version 3 of the License, or\n *  (at your option) any later version.\n *\n *  ARToolKit is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public License\n *  along with ARToolKit.  If not, see <http://www.gnu.org/licenses/>.\n *\n *  As a special exception, the copyright holders of this library give you\n *  permission to link this library with independent modules to produce an\n *  executable, regardless of the license terms of these independent modules, and to\n *  copy and distribute the resulting executable under terms of your choice,\n *  provided that you also meet, for each linked independent module, the terms and\n *  conditions of the license of that module. An independent module is a module\n *  which is neither derived from nor based on this library. If you modify this\n *  library, you may extend this exception to your version of the library, but you\n *  are not obligated to do so. If you do not wish to do so, delete this exception\n *  statement from your version.\n *\n *  Copyright 2015 Daqri, LLC.\n *  Copyright 2007-2015 ARToolworks, Inc.\n *\n *  Author(s): Hirokazu Kato\n *\n */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n#include <AR/ar.h>\n#include <AR/icp.h>\n\n#ifdef ARDOUBLE_IS_FLOAT\n#  define SQRT sqrtf\n#  define _0_0 0.0f\n#  define _0_5 0.5f\n#  define _1_0 1.0f\n#  define _2_0 2.0f\n#else\n#  define SQRT sqrt\n#  define _0_0 0.0\n#  define _0_5 0.5\n#  define _1_0 1.0\n#  define _2_0 2.0\n#endif\n\nstatic int check_rotation( ARdouble rot[2][3] );\n\n#if 0\nstatic void icpGetInitXw2XcSub( ARdouble       rot[3][4],\n                                ICP2DCoordT  pos2d[],\n                                ICP3DCoordT  ppos3d[],\n                                int          num,\n                                ARdouble       cpara[3][4],\n                                ARdouble       conv[3][4] );\nstatic int check_dir( ARdouble dir[3], ARdouble st[2], ARdouble ed[2],\n                      ARdouble cpara[3][4] );\n#endif\n\nint icpGetInitXw2Xc_from_PlanarData( ARdouble       matXc2U[3][4],\n                                     ICP2DCoordT  screenCoord[],\n                                     ICP3DCoordT  worldCoord[],\n                                     int          num,\n                                     ARdouble       initMatXw2Xc[3][4] )\n{\n    ARMat   *matA, *matB;\n    ARMat   *matAt, *matAtA, *matAtB, *matC;\n    ARdouble   v[3][3], t[3];\n    ARdouble   l1, l2;\n    int      i;\n\n    if( num < 4 ) return -1;\n    for( i = 0; i < num; i++ ) {\n        if( worldCoord[i].z != 0.0 ) return -1;\n    }\n    if( matXc2U[0][0] == 0.0 ) return -1;\n    if( matXc2U[1][0] != 0.0 ) return -1;\n    if( matXc2U[1][1] == 0.0 ) return -1;\n    if( matXc2U[2][0] != 0.0 ) return -1;\n    if( matXc2U[2][1] != 0.0 ) return -1;\n    if( matXc2U[2][2] != 1.0 ) return -1;\n    if( matXc2U[0][3] != 0.0 ) return -1;\n    if( matXc2U[1][3] != 0.0 ) return -1;\n    if( matXc2U[2][3] != 0.0 ) return -1;\n\n    matA = arMatrixAlloc( num*2, 8 );\n    if( matA == NULL ) {\n        ARLOGe(\"Error 1: icpGetInitXw2Xc\\n\");\n        return -1;\n    }\n    matB = arMatrixAlloc( num*2, 1 );\n    if( matB == NULL ) {\n        arMatrixFree(matA);\n        ARLOGe(\"Error 2: icpGetInitXw2Xc\\n\");\n        return -1;\n    }\n\n    for( i = 0; i < num; i++ ) {\n        matA->m[i*16+0]  = worldCoord[i].x;\n        matA->m[i*16+1]  = worldCoord[i].y;\n        matA->m[i*16+2]  = 1.0;\n        matA->m[i*16+3]  = 0.0;\n        matA->m[i*16+4]  = 0.0;\n        matA->m[i*16+5]  = 0.0;\n        matA->m[i*16+6]  = -(worldCoord[i].x)*(screenCoord[i].x);\n        matA->m[i*16+7]  = -(worldCoord[i].y)*(screenCoord[i].x);\n        matA->m[i*16+8]  = 0.0;\n        matA->m[i*16+9]  = 0.0;\n        matA->m[i*16+10] = 0.0;\n        matA->m[i*16+11] = worldCoord[i].x;\n        matA->m[i*16+12] = worldCoord[i].y;\n        matA->m[i*16+13] = 1.0;\n        matA->m[i*16+14] = -(worldCoord[i].x)*(screenCoord[i].y);\n        matA->m[i*16+15] = -(worldCoord[i].y)*(screenCoord[i].y);\n\n        matB->m[i*2+0] = screenCoord[i].x;\n        matB->m[i*2+1] = screenCoord[i].y;\n    }\n\n    matAt = arMatrixAllocTrans( matA );\n    if( matAt == NULL ) {\n        arMatrixFree(matA);\n        arMatrixFree(matB);\n        ARLOGe(\"Error 3: icpGetInitXw2Xc\\n\");\n        return -1;\n    }\n    matAtA = arMatrixAllocMul( matAt, matA );\n    if( matAtA == NULL ) {\n        arMatrixFree(matA);\n        arMatrixFree(matB);\n        arMatrixFree(matAt);\n        ARLOGe(\"Error 4: icpGetInitXw2Xc\\n\");\n        return -1;\n    }\n    matAtB = arMatrixAllocMul( matAt, matB );\n    if( matAtB == NULL ) {\n        arMatrixFree(matA);\n        arMatrixFree(matB);\n        arMatrixFree(matAt);\n        arMatrixFree(matAtA);\n        ARLOGe(\"Error 5: icpGetInitXw2Xc\\n\");\n        return -1;\n    }\n    if( arMatrixSelfInv(matAtA) < 0 ) {\n        arMatrixFree(matA);\n        arMatrixFree(matB);\n        arMatrixFree(matAt);\n        arMatrixFree(matAtA);\n        arMatrixFree(matAtB);\n        ARLOGe(\"Error 6: icpGetInitXw2Xc\\n\");\n        return -1;\n    }\n    matC = arMatrixAllocMul( matAtA, matAtB );\n    if( matC == NULL ) {\n        arMatrixFree(matA);\n        arMatrixFree(matB);\n        arMatrixFree(matAt);\n        arMatrixFree(matAtA);\n        arMatrixFree(matAtB);\n        ARLOGe(\"Error 7: icpGetInitXw2Xc\\n\");\n        return -1;\n    }\n\n    v[0][2] =  matC->m[6];\n    v[0][1] = (matC->m[3] - matXc2U[1][2] * v[0][2]) / matXc2U[1][1];\n    v[0][0] = (matC->m[0] - matXc2U[0][2] * v[0][2] - matXc2U[0][1] * v[0][1]) / matXc2U[0][0];\n    v[1][2] =  matC->m[7];\n    v[1][1] = (matC->m[4] - matXc2U[1][2] * v[1][2]) / matXc2U[1][1];\n    v[1][0] = (matC->m[1] - matXc2U[0][2] * v[1][2] - matXc2U[0][1] * v[1][1]) / matXc2U[0][0];\n    t[2]  =  1.0;\n    t[1]  = (matC->m[5] - matXc2U[1][2] * t[2]) / matXc2U[1][1];\n    t[0]  = (matC->m[2] - matXc2U[0][2] * t[2] - matXc2U[0][1] * t[1]) / matXc2U[0][0];\n\n    arMatrixFree(matA);\n    arMatrixFree(matB);\n    arMatrixFree(matAt);\n    arMatrixFree(matAtA);\n    arMatrixFree(matAtB);\n    arMatrixFree(matC);\n\n    l1 = SQRT( v[0][0]*v[0][0] + v[0][1]*v[0][1] + v[0][2]*v[0][2] );\n    l2 = SQRT( v[1][0]*v[1][0] + v[1][1]*v[1][1] + v[1][2]*v[1][2] );\n    v[0][0] /= l1;\n    v[0][1] /= l1;\n    v[0][2] /= l1;\n    v[1][0] /= l2;\n    v[1][1] /= l2;\n    v[1][2] /= l2;\n    t[0] /= (l1+l2)/_2_0;\n    t[1] /= (l1+l2)/_2_0;\n    t[2] /= (l1+l2)/_2_0;\n    if( t[2] < 0.0 ) {\n        v[0][0] = -v[0][0];\n        v[0][1] = -v[0][1];\n        v[0][2] = -v[0][2];\n        v[1][0] = -v[1][0];\n        v[1][1] = -v[1][1];\n        v[1][2] = -v[1][2];\n        t[0] = -t[0];\n        t[1] = -t[1];\n        t[1] = -t[2];\n    }\n\n    check_rotation( v );\n    v[2][0] = v[0][1]*v[1][2] - v[0][2]*v[1][1];\n    v[2][1] = v[0][2]*v[1][0] - v[0][0]*v[1][2];\n    v[2][2] = v[0][0]*v[1][1] - v[0][1]*v[1][0];\n    l1 = SQRT( v[2][0]*v[2][0] + v[2][1]*v[2][1] + v[2][2]*v[2][2] );\n    v[2][0] /= l1;\n    v[2][1] /= l1;\n    v[2][2] /= l1;\n\n    initMatXw2Xc[0][0] = v[0][0];\n    initMatXw2Xc[1][0] = v[0][1];\n    initMatXw2Xc[2][0] = v[0][2];\n    initMatXw2Xc[0][1] = v[1][0];\n    initMatXw2Xc[1][1] = v[1][1];\n    initMatXw2Xc[2][1] = v[1][2];\n    initMatXw2Xc[0][2] = v[2][0];\n    initMatXw2Xc[1][2] = v[2][1];\n    initMatXw2Xc[2][2] = v[2][2];\n    initMatXw2Xc[0][3] = t[0];\n    initMatXw2Xc[1][3] = t[1];\n    initMatXw2Xc[2][3] = t[2];\n\n#if 0\n//ARLOGe(\"   %f %f %f --->\", t[0], t[1], t[2]);\n    icpGetInitXw2XcSub( initMatXw2Xc, screenCoord, worldCoord, num, matXc2U, initMatXw2Xc );\n//ARLOGe(\"%f %f %f\\n\", initMatXw2Xc[0][3], initMatXw2Xc[1][3], initMatXw2Xc[2][3]);\n#endif\n\n    return 0;\n}\n\n\n\nstatic int check_rotation( ARdouble rot[2][3] )\n{\n    ARdouble  v1[3], v2[3], v3[3];\n    ARdouble  ca, cb, k1, k2, k3, k4;\n    ARdouble  a, b, c, d;\n    ARdouble  p1, q1, r1;\n    ARdouble  p2, q2, r2;\n    ARdouble  p3, q3, r3;\n    ARdouble  p4, q4, r4;\n    ARdouble  w;\n    ARdouble  e1, e2, e3, e4;\n    int     f;\n\n    v1[0] = rot[0][0];\n    v1[1] = rot[0][1];\n    v1[2] = rot[0][2];\n    v2[0] = rot[1][0];\n    v2[1] = rot[1][1];\n    v2[2] = rot[1][2];\n    v3[0] = v1[1]*v2[2] - v1[2]*v2[1];\n    v3[1] = v1[2]*v2[0] - v1[0]*v2[2];\n    v3[2] = v1[0]*v2[1] - v1[1]*v2[0];\n    w = SQRT( v3[0]*v3[0]+v3[1]*v3[1]+v3[2]*v3[2] );\n    if( w == _0_0 ) return -1;\n    v3[0] /= w;\n    v3[1] /= w;\n    v3[2] /= w;\n\n    cb = v1[0]*v2[0] + v1[1]*v2[1] + v1[2]*v2[2];\n    if( cb < 0 ) cb *= -_1_0;\n    ca = (SQRT(cb+_1_0) + SQRT(_1_0-cb)) * _0_5;\n\n    if( v3[1]*v1[0] - v1[1]*v3[0] != 0.0 ) {\n        f = 0;\n    }\n    else {\n        if( v3[2]*v1[0] - v1[2]*v3[0] != _0_0 ) {\n            w = v1[1]; v1[1] = v1[2]; v1[2] = w;\n            w = v3[1]; v3[1] = v3[2]; v3[2] = w;\n            f = 1;\n        }\n        else {\n            w = v1[0]; v1[0] = v1[2]; v1[2] = w;\n            w = v3[0]; v3[0] = v3[2]; v3[2] = w;\n            f = 2;\n        }\n    }\n    if( v3[1]*v1[0] - v1[1]*v3[0] == _0_0 ) return -1;\n    k1 = (v1[1]*v3[2] - v3[1]*v1[2]) / (v3[1]*v1[0] - v1[1]*v3[0]);\n    k2 = (v3[1] * ca) / (v3[1]*v1[0] - v1[1]*v3[0]);\n    k3 = (v1[0]*v3[2] - v3[0]*v1[2]) / (v3[0]*v1[1] - v1[0]*v3[1]);\n    k4 = (v3[0] * ca) / (v3[0]*v1[1] - v1[0]*v3[1]);\n\n    a = k1*k1 + k3*k3 + 1;\n    b = k1*k2 + k3*k4;\n    c = k2*k2 + k4*k4 - 1;\n\n    d = b*b - a*c;\n    if( d < 0 ) return -1;\n    r1 = (-b + SQRT(d))/a;\n    p1 = k1*r1 + k2;\n    q1 = k3*r1 + k4;\n    r2 = (-b - SQRT(d))/a;\n    p2 = k1*r2 + k2;\n    q2 = k3*r2 + k4;\n    if( f == 1 ) {\n        w = q1; q1 = r1; r1 = w;\n        w = q2; q2 = r2; r2 = w;\n        w = v1[1]; v1[1] = v1[2]; v1[2] = w;\n        w = v3[1]; v3[1] = v3[2]; v3[2] = w;\n        f = 0;\n    }\n    if( f == 2 ) {\n        w = p1; p1 = r1; r1 = w;\n        w = p2; p2 = r2; r2 = w;\n        w = v1[0]; v1[0] = v1[2]; v1[2] = w;\n        w = v3[0]; v3[0] = v3[2]; v3[2] = w;\n        f = 0;\n    }\n\n    if( v3[1]*v2[0] - v2[1]*v3[0] != 0.0 ) {\n        f = 0;\n    }\n    else {\n        if( v3[2]*v2[0] - v2[2]*v3[0] != 0.0 ) {\n            w = v2[1]; v2[1] = v2[2]; v2[2] = w;\n            w = v3[1]; v3[1] = v3[2]; v3[2] = w;\n            f = 1;\n        }\n        else {\n            w = v2[0]; v2[0] = v2[2]; v2[2] = w;\n            w = v3[0]; v3[0] = v3[2]; v3[2] = w;\n            f = 2;\n        }\n    }\n    if( v3[1]*v2[0] - v2[1]*v3[0] == _0_0 ) return -1;\n    k1 = (v2[1]*v3[2] - v3[1]*v2[2]) / (v3[1]*v2[0] - v2[1]*v3[0]);\n    k2 = (v3[1] * ca) / (v3[1]*v2[0] - v2[1]*v3[0]);\n    k3 = (v2[0]*v3[2] - v3[0]*v2[2]) / (v3[0]*v2[1] - v2[0]*v3[1]);\n    k4 = (v3[0] * ca) / (v3[0]*v2[1] - v2[0]*v3[1]);\n\n    a = k1*k1 + k3*k3 + 1;\n    b = k1*k2 + k3*k4;\n    c = k2*k2 + k4*k4 - 1;\n\n    d = b*b - a*c;\n    if( d < 0 ) return -1;\n    r3 = (-b + SQRT(d))/a;\n    p3 = k1*r3 + k2;\n    q3 = k3*r3 + k4;\n    r4 = (-b - SQRT(d))/a;\n    p4 = k1*r4 + k2;\n    q4 = k3*r4 + k4;\n    if( f == 1 ) {\n        w = q3; q3 = r3; r3 = w;\n        w = q4; q4 = r4; r4 = w;\n        w = v2[1]; v2[1] = v2[2]; v2[2] = w;\n        w = v3[1]; v3[1] = v3[2]; v3[2] = w;\n        f = 0;\n    }\n    if( f == 2 ) {\n        w = p3; p3 = r3; r3 = w;\n        w = p4; p4 = r4; r4 = w;\n        w = v2[0]; v2[0] = v2[2]; v2[2] = w;\n        w = v3[0]; v3[0] = v3[2]; v3[2] = w;\n        f = 0;\n    }\n\n    e1 = p1*p3+q1*q3+r1*r3; if( e1 < 0 ) e1 = -e1;\n    e2 = p1*p4+q1*q4+r1*r4; if( e2 < 0 ) e2 = -e2;\n    e3 = p2*p3+q2*q3+r2*r3; if( e3 < 0 ) e3 = -e3;\n    e4 = p2*p4+q2*q4+r2*r4; if( e4 < 0 ) e4 = -e4;\n    if( e1 < e2 ) {\n        if( e1 < e3 ) {\n            if( e1 < e4 ) {\n                rot[0][0] = p1;\n                rot[0][1] = q1;\n                rot[0][2] = r1;\n                rot[1][0] = p3;\n                rot[1][1] = q3;\n                rot[1][2] = r3;\n            }\n            else {\n                rot[0][0] = p2;\n                rot[0][1] = q2;\n                rot[0][2] = r2;\n                rot[1][0] = p4;\n                rot[1][1] = q4;\n                rot[1][2] = r4;\n            }\n        }\n        else {\n            if( e3 < e4 ) {\n                rot[0][0] = p2;\n                rot[0][1] = q2;\n                rot[0][2] = r2;\n                rot[1][0] = p3;\n                rot[1][1] = q3;\n                rot[1][2] = r3;\n            }\n            else {\n                rot[0][0] = p2;\n                rot[0][1] = q2;\n                rot[0][2] = r2;\n                rot[1][0] = p4;\n                rot[1][1] = q4;\n                rot[1][2] = r4;\n            }\n        }\n    }\n    else {\n        if( e2 < e3 ) {\n            if( e2 < e4 ) {\n                rot[0][0] = p1;\n                rot[0][1] = q1;\n                rot[0][2] = r1;\n                rot[1][0] = p4;\n                rot[1][1] = q4;\n                rot[1][2] = r4;\n            }\n            else {\n                rot[0][0] = p2;\n                rot[0][1] = q2;\n                rot[0][2] = r2;\n                rot[1][0] = p4;\n                rot[1][1] = q4;\n                rot[1][2] = r4;\n            }\n        }\n        else {\n            if( e3 < e4 ) {\n                rot[0][0] = p2;\n                rot[0][1] = q2;\n                rot[0][2] = r2;\n                rot[1][0] = p3;\n                rot[1][1] = q3;\n                rot[1][2] = r3;\n            }\n            else {\n                rot[0][0] = p2;\n                rot[0][1] = q2;\n                rot[0][2] = r2;\n                rot[1][0] = p4;\n                rot[1][1] = q4;\n                rot[1][2] = r4;\n            }\n        }\n    }\n\n    return 0;\n}\n\n#if 0\nstatic void icpGetInitXw2XcSub( ARdouble       rot[3][4],\n                                ICP2DCoordT  pos2d[],\n                                ICP3DCoordT  ppos3d[],\n                                int          num,\n                                ARdouble       cpara[3][4],\n                                ARdouble       conv[3][4] )\n{\n    ICP3DCoordT  *pos3d;\n    ARMat        *mat_a, *mat_b, *mat_c, *mat_d, *mat_e, *mat_f;\n    ARdouble        trans[3];\n    ARdouble        wx, wy, wz;\n    ARdouble        off[3], pmax[3], pmin[3];\n    int           i, j;\n    \n    arMalloc(pos3d, ICP3DCoordT, num);\n    mat_a = arMatrixAlloc( num*2, 3 );\n    mat_b = arMatrixAlloc( 3, num*2 );\n    mat_c = arMatrixAlloc( num*2, 1 );\n    mat_d = arMatrixAlloc( 3, 3 );\n    mat_e = arMatrixAlloc( 3, 1 );\n    mat_f = arMatrixAlloc( 3, 1 );\n\n    pmax[0]=pmax[1]=pmax[2] = -10000000000.0;\n    pmin[0]=pmin[1]=pmin[2] =  10000000000.0;\n    for( i = 0; i < num; i++ ) {\n        if( ppos3d[i].x > pmax[0] ) pmax[0] = ppos3d[i].x;\n        if( ppos3d[i].x < pmin[0] ) pmin[0] = ppos3d[i].x;\n        if( ppos3d[i].y > pmax[1] ) pmax[1] = ppos3d[i].y;\n        if( ppos3d[i].y < pmin[1] ) pmin[1] = ppos3d[i].y;\n        if( ppos3d[i].z > pmax[2] ) pmax[2] = ppos3d[i].z;\n        if( ppos3d[i].z < pmin[2] ) pmin[2] = ppos3d[i].z;\n    }\n    off[0] = -(pmax[0] + pmin[0]) / _2_0;\n    off[1] = -(pmax[1] + pmin[1]) / _2_0;\n    off[2] = -(pmax[2] + pmin[2]) / _2_0;\n    for( i = 0; i < num; i++ ) {\n        pos3d[i].x = ppos3d[i].x + off[0];\n        pos3d[i].y = ppos3d[i].y + off[1];\n        pos3d[i].z = ppos3d[i].z + off[2];\n    }\n\n    for( j = 0; j < num; j++ ) {\n        wx = rot[0][0] * pos3d[j].x\n           + rot[0][1] * pos3d[j].y\n           + rot[0][2] * pos3d[j].z;\n        wy = rot[1][0] * pos3d[j].x\n           + rot[1][1] * pos3d[j].y\n           + rot[1][2] * pos3d[j].z;\n        wz = rot[2][0] * pos3d[j].x\n           + rot[2][1] * pos3d[j].y\n           + rot[2][2] * pos3d[j].z;\n        mat_a->m[j*6+0] = mat_b->m[num*0+j*2] = cpara[0][0];\n        mat_a->m[j*6+1] = mat_b->m[num*2+j*2] = cpara[0][1];\n        mat_a->m[j*6+2] = mat_b->m[num*4+j*2] = cpara[0][2] - pos2d[j].x;\n        mat_c->m[j*2+0] = wz * pos2d[j].x\n               - cpara[0][0]*wx - cpara[0][1]*wy - cpara[0][2]*wz;\n        mat_a->m[j*6+3] = mat_b->m[num*0+j*2+1] = 0.0;\n        mat_a->m[j*6+4] = mat_b->m[num*2+j*2+1] = cpara[1][1];\n        mat_a->m[j*6+5] = mat_b->m[num*4+j*2+1] = cpara[1][2] - pos2d[j].y;\n        mat_c->m[j*2+1] = wz * pos2d[j].y\n               - cpara[1][1]*wy - cpara[1][2]*wz;\n    }\n    arMatrixMul( mat_d, mat_b, mat_a );\n    arMatrixMul( mat_e, mat_b, mat_c );\n    arMatrixSelfInv( mat_d );\n    arMatrixMul( mat_f, mat_d, mat_e );\n    trans[0] = mat_f->m[0];\n    trans[1] = mat_f->m[1];\n    trans[2] = mat_f->m[2];\n\n    free(pos3d);\n    arMatrixFree( mat_a );\n    arMatrixFree( mat_b );\n    arMatrixFree( mat_c );\n    arMatrixFree( mat_d );\n    arMatrixFree( mat_e );\n    arMatrixFree( mat_f );\n\n    for( j = 0; j < 3; j++ ) {\n        for( i = 0; i < 3; i++ ) conv[j][i] = rot[j][i];\n        conv[j][3] = trans[j];\n    }\n\n    conv[0][3] = conv[0][0]*off[0] + conv[0][1]*off[1] + conv[0][2]*off[2] + conv[0][3];\n    conv[1][3] = conv[1][0]*off[0] + conv[1][1]*off[1] + conv[1][2]*off[2] + conv[1][3];\n    conv[2][3] = conv[2][0]*off[0] + conv[2][1]*off[1] + conv[2][2]*off[2] + conv[2][3];\n\n    return;\n}\n\n#if 0\nint arGetInitRot( ARdouble cpara[3][4], ARdouble rot[3][4],\n                  ICP2DCoordT  pos2d[],\n                  ICP3DCoordT  ppos3d[] )\n{\n    ARdouble  wdir[3][3];\n    ARdouble  w, w1, w2, w3;\n    int     dir;\n    int     j;\n    \n    dir = marker_info->dir;\n    \n    for( j = 0; j < 2; j++ ) {\n        w1 = marker_info->line[(4-dir+j)%4][0] * marker_info->line[(6-dir+j)%4][1]\n           - marker_info->line[(6-dir+j)%4][0] * marker_info->line[(4-dir+j)%4][1];\n        w2 = marker_info->line[(4-dir+j)%4][1] * marker_info->line[(6-dir+j)%4][2]\n           - marker_info->line[(6-dir+j)%4][1] * marker_info->line[(4-dir+j)%4][2];\n        w3 = marker_info->line[(4-dir+j)%4][2] * marker_info->line[(6-dir+j)%4][0]\n           - marker_info->line[(6-dir+j)%4][2] * marker_info->line[(4-dir+j)%4][0];\n\n        wdir[j][0] =  w1*(cpara[0][1]*cpara[1][2]-cpara[0][2]*cpara[1][1])\n                   +  w2*cpara[1][1]\n                   -  w3*cpara[0][1];\n        wdir[j][1] = -w1*cpara[0][0]*cpara[1][2]\n                   +  w3*cpara[0][0];\n        wdir[j][2] =  w1*cpara[0][0]*cpara[1][1];\n        w = SQRT( wdir[j][0]*wdir[j][0]\n                + wdir[j][1]*wdir[j][1]\n                + wdir[j][2]*wdir[j][2] );\n        wdir[j][0] /= w;\n        wdir[j][1] /= w;\n        wdir[j][2] /= w;\n    }\n                \n    if( check_dir(wdir[0], marker_info->vertex[(4-dir)%4],\n                  marker_info->vertex[(5-dir)%4], cpara) < 0 ) return -1;\n    if( check_dir(wdir[1], marker_info->vertex[(7-dir)%4],\n                  marker_info->vertex[(4-dir)%4], cpara) < 0 ) return -1;\n    if( check_rotation(wdir) < 0 ) return -1;\n                \n    wdir[2][0] = wdir[0][1]*wdir[1][2] - wdir[0][2]*wdir[1][1];\n    wdir[2][1] = wdir[0][2]*wdir[1][0] - wdir[0][0]*wdir[1][2];\n    wdir[2][2] = wdir[0][0]*wdir[1][1] - wdir[0][1]*wdir[1][0];\n    w = SQRT( wdir[2][0]*wdir[2][0]\n            + wdir[2][1]*wdir[2][1]\n            + wdir[2][2]*wdir[2][2] );\n    wdir[2][0] /= w;\n    wdir[2][1] /= w;\n    wdir[2][2] /= w;\n/*        \n    if( wdir[2][2] < 0 ) {\n        wdir[2][0] /= -w;\n        wdir[2][1] /= -w;\n        wdir[2][2] /= -w;\n    }   \n    else {            \n        wdir[2][0] /= w;\n        wdir[2][1] /= w;\n        wdir[2][2] /= w;\n    }\n*/\n\n    rot[0][0] = wdir[0][0];\n    rot[1][0] = wdir[0][1];\n    rot[2][0] = wdir[0][2];\n    rot[0][1] = wdir[1][0];\n    rot[1][1] = wdir[1][1];\n    rot[2][1] = wdir[1][2];\n    rot[0][2] = wdir[2][0];\n    rot[1][2] = wdir[2][1];\n    rot[2][2] = wdir[2][2];\n\n    return 0;\n}\n\nstatic int check_dir( ARdouble dir[3], ARdouble st[2], ARdouble ed[2],\n                      ARdouble cpara[3][4] )\n{\n    ARMat     *mat_a;\n    ARdouble    world[2][3];\n    ARdouble    camera[2][2];\n    ARdouble    v[2][2];\n    ARdouble    h;\n    int       i, j;\n\n    mat_a = arMatrixAlloc( 3, 3 );\n    for(j=0;j<3;j++) for(i=0;i<3;i++) mat_a->m[j*3+i] = cpara[j][i];\n    arMatrixSelfInv( mat_a );\n    world[0][0] = mat_a->m[0]*st[0]*10.0\n                + mat_a->m[1]*st[1]*10.0\n                + mat_a->m[2]*10.0;\n    world[0][1] = mat_a->m[3]*st[0]*10.0\n                + mat_a->m[4]*st[1]*10.0\n                + mat_a->m[5]*10.0;\n    world[0][2] = mat_a->m[6]*st[0]*10.0\n                + mat_a->m[7]*st[1]*10.0\n                + mat_a->m[8]*10.0;\n    arMatrixFree( mat_a );\n    world[1][0] = world[0][0] + dir[0];\n    world[1][1] = world[0][1] + dir[1];\n    world[1][2] = world[0][2] + dir[2];\n    \n    for( i = 0; i < 2; i++ ) {\n        h = cpara[2][0] * world[i][0]\n          + cpara[2][1] * world[i][1]\n          + cpara[2][2] * world[i][2];\n        if( h == 0.0 ) return -1;\n        camera[i][0] = (cpara[0][0] * world[i][0]\n                      + cpara[0][1] * world[i][1]\n                      + cpara[0][2] * world[i][2]) / h;\n        camera[i][1] = (cpara[1][0] * world[i][0]\n                      + cpara[1][1] * world[i][1]\n                      + cpara[1][2] * world[i][2]) / h;\n    }\n    \n    v[0][0] = ed[0] - st[0];\n    v[0][1] = ed[1] - st[1]; \n    v[1][0] = camera[1][0] - camera[0][0];\n    v[1][1] = camera[1][1] - camera[0][1];\n    \n    if( v[0][0]*v[1][0] + v[0][1]*v[1][1] < 0 ) {\n        dir[0] = -dir[0];\n        dir[1] = -dir[1];\n        dir[2] = -dir[2];\n    }\n    \n    return 0;\n}\n#endif\n#endif\n","/*\n *  arMultiFreeConfig.c\n *  ARToolKit5\n *\n *  This file is part of ARToolKit.\n *\n *  ARToolKit is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation, either version 3 of the License, or\n *  (at your option) any later version.\n *\n *  ARToolKit is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public License\n *  along with ARToolKit.  If not, see <http://www.gnu.org/licenses/>.\n *\n *  As a special exception, the copyright holders of this library give you\n *  permission to link this library with independent modules to produce an\n *  executable, regardless of the license terms of these independent modules, and to\n *  copy and distribute the resulting executable under terms of your choice,\n *  provided that you also meet, for each linked independent module, the terms and\n *  conditions of the license of that module. An independent module is a module\n *  which is neither derived from nor based on this library. If you modify this\n *  library, you may extend this exception to your version of the library, but you\n *  are not obligated to do so. If you do not wish to do so, delete this exception\n *  statement from your version.\n *\n *  Copyright 2015 Daqri, LLC.\n *  Copyright 2002-2015 ARToolworks, Inc.\n *\n *  Author(s): Hirokazu Kato\n *\n */\n/*******************************************************\n *\n * Author: Hirokazu Kato\n *\n *         kato@sys.im.hiroshima-cu.ac.jp\n *\n * Revision: 1.0\n * Date: 01/09/05\n *\n *******************************************************/\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n#include <AR/ar.h>\n#include <AR/arMulti.h>\n\nint arMultiFreeConfig( ARMultiMarkerInfoT *config )\n{\n    free( config->marker );\n    free( config );\n    config = NULL;\n\n    return 0;\n}\n\n","/*\n *  kpmMatching.cpp\n *  ARToolKit5\n *\n *  This file is part of ARToolKit.\n *\n *  ARToolKit is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation, either version 3 of the License, or\n *  (at your option) any later version.\n *\n *  ARToolKit is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public License\n *  along with ARToolKit.  If not, see <http://www.gnu.org/licenses/>.\n *\n *  As a special exception, the copyright holders of this library give you\n *  permission to link this library with independent modules to produce an\n *  executable, regardless of the license terms of these independent modules, and to\n *  copy and distribute the resulting executable under terms of your choice,\n *  provided that you also meet, for each linked independent module, the terms and\n *  conditions of the license of that module. An independent module is a module\n *  which is neither derived from nor based on this library. If you modify this\n *  library, you may extend this exception to your version of the library, but you\n *  are not obligated to do so. If you do not wish to do so, delete this exception\n *  statement from your version.\n *\n *  Copyright 2015 Daqri, LLC. All rights reserved.\n *  Copyright 2006-2015 ARToolworks, Inc. All rights reserved.\n *  Author(s): Hirokazu Kato, Philip Lamb, Nalin Senthamil\n *\n */\n\n#include <stdio.h>\n#include <AR/ar.h>\n#include <string>\n#include <sstream>\n#include <algorithm>\n\n#include <KPM/kpm.h>\n#include \"kpmPrivate.h\"\n#if BINARY_FEATURE\nextern \"C\" {\n#  include <jpeglib.h>\n}\n#else\n#  include \"HomographyEst.h\"\n#  include \"AnnMatch.h\"\n#  include \"AnnMatch2.h\"\n#endif\n\nint kpmUtilGetPose_binary( ARParamLT *cparamLT, const vision::matches_t &matchData, const std::vector<vision::Point3d<float> > &refDataSet, const std::vector<vision::FeaturePoint> &inputDataSet, float  camPose[3][4], float  *error );\n\ntemplate<typename T>\nstd::string arrayToString(T *v, size_t size){\n    std::stringstream ss;\n    for(size_t i = 0; i < size; ++i){\n        if(i != 0)\n            ss << \",\";\n        ss << v[i];\n    }\n    std::string s = ss.str();\n    return s;\n}\n\nstd::string arrayToString2(float pose[3][4]){\n    std::stringstream ss;\n    for(int i = 0; i < 3; ++i){\n        for(int j = 0; j < 4; ++j){\n            if(j != 0 )\n                ss << \",\";\n            ss << pose[i][j];\n        }\n        ss << \"\\n\";\n    }\n    std::string s = ss.str();\n    return s;\n}\n\n#ifdef HAVE_LIBJPEG\nstatic unsigned char *kpmReadJPEGMono(FILE *fp, int *width, int *height)\n{\n    unsigned char                   *buf;\n    struct jpeg_decompress_struct    cinfo;\n    struct jpeg_error_mgr            jerr;\n    unsigned char                  **decompressBufRowPtrs = NULL;\n    int                              decompressBufRows, rowsToRead;\n    int                              row;\n    int                              i;\n\n    if (!fp || !width || !height) return (NULL);\n\n    memset(&cinfo, 0, sizeof(cinfo));\n    cinfo.err = jpeg_std_error(&jerr);\n    jpeg_create_decompress(&cinfo);\n    jpeg_stdio_src(&cinfo, fp);\n    (void) jpeg_read_header(&cinfo, TRUE);\n\n    // Adjust decompression parameters to match requested.\n    if (cinfo.num_components != 3 && cinfo.num_components != 4 && cinfo.num_components != 1) {\n        ARLOGe(\"JPEG file has unsupported %d-component pixels\\n\", cinfo.num_components);\n        jpeg_destroy_decompress(&cinfo);\n        return (NULL);\n    }\n    cinfo.out_color_space = JCS_GRAYSCALE;// Converting to mono, let libjpeg handle it.\n\n    // Start decompression. This gives us access to the JPEG size.\n    (void) jpeg_start_decompress(&cinfo);\n    *height = cinfo.output_height;\n    *width = cinfo.output_width;\n    buf = (unsigned char *)malloc(*width * *height);\n    if (!buf) {\n        ARLOGe(\"Out of memory!!\\n\");\n        jpeg_destroy_decompress(&cinfo);\n        return (NULL);\n    }\n\n    // Decompression requires a bunch of pointers to where to output the decompressed pixels. Create an array to hold the pointers.\n    decompressBufRows = cinfo.rec_outbuf_height;\n    arMalloc(decompressBufRowPtrs, unsigned char *, decompressBufRows);\n\n    // Decompress straight into user-supplied buffer (i.e. buf).\n    row = 0;\n    while (cinfo.output_scanline < *height) {\n        rowsToRead = std::min<int>(*height - cinfo.output_scanline, decompressBufRows);\n        // Update the set of pointers to decompress into.\n        for (i = 0; i < rowsToRead; i++) decompressBufRowPtrs[i] = &(buf[*width * (row + i)]);\n        // Decompress.\n        row += jpeg_read_scanlines(&cinfo, decompressBufRowPtrs, rowsToRead);\n    }\n\n    (void) jpeg_finish_decompress(&cinfo);\n    jpeg_destroy_decompress(&cinfo);\n    free(decompressBufRowPtrs);\n\n    return (buf);\n}\n#endif // HAVE_LIBJPEG\n\nint kpmLoadImageDb(KpmHandle *kpmHandle, const char *filename)\n{\n    FILE                *fp;\n    unsigned char       *image = NULL;\n    int                  width, height;\n\n    if (!kpmHandle || !filename) {\n        ARLOGe(\"kpmSetRefDataSet(): NULL kpmHandle/filename.\\n\");\n        return -1;\n    }\n\n    if ((fp = fopen(filename, \"rb\")) == NULL) {\n        ARLOGe(\"Can't open JPEG file '%s'\\n\", filename);\n        ARLOGperror(NULL);\n        return (0);\n    } else {\n        image = kpmReadJPEGMono(fp, &width, &height);\n        fclose(fp);\n        if (!image) {\n            ARLOGe(\"Can't read JPEG file '%s'\\n\", filename);\n            return (0);\n        }\n    }\n\n    kpmHandle->freakMatcher->addImage(image, width, height, 1);\n    free(image);\n\n    return 1;\n}\n\nint kpmSetRefDataSet( KpmHandle *kpmHandle, KpmRefDataSet *refDataSet )\n{\n#if !BINARY_FEATURE\n    CAnnMatch2         *ann2;\n#endif\n\n    FeatureVector       featureVector;\n    int                 i, j;\n\n    if (!kpmHandle || !refDataSet) {\n        ARLOGe(\"kpmSetRefDataSet(): NULL kpmHandle/refDataSet.\\n\");\n        return -1;\n    }\n    if (!refDataSet->num) {\n        ARLOGe(\"kpmSetRefDataSet(): refDataSet.\\n\");\n        return -1;\n    }\n    // Copy the refPoints into the kpmHandle's dataset.\n    if( kpmHandle->refDataSet.refPoint != NULL ) {\n        // Discard any old points first.\n        free( kpmHandle->refDataSet.refPoint );\n    }\n    if( refDataSet->num != 0 ) {\n        arMalloc( kpmHandle->refDataSet.refPoint, KpmRefData, refDataSet->num );\n        for( i = 0; i < refDataSet->num; i++ ) {\n            kpmHandle->refDataSet.refPoint[i] = refDataSet->refPoint[i];\n        }\n    }\n    else {\n        kpmHandle->refDataSet.refPoint = NULL;\n    }\n    kpmHandle->refDataSet.num = refDataSet->num;\n\n    // Copy the pageInfo into the kpmHandle's dataset.\n    if( kpmHandle->refDataSet.pageInfo != NULL ) {\n        // Discard any old pageInfo (and imageInfo) first.\n        for( i = 0; i < kpmHandle->refDataSet.pageNum; i++ ) {\n            if( kpmHandle->refDataSet.pageInfo[i].imageInfo != NULL ) {\n                free( kpmHandle->refDataSet.pageInfo[i].imageInfo );\n            }\n        }\n        free( kpmHandle->refDataSet.pageInfo );\n    }\n    if( refDataSet->pageNum != 0 ) {\n        arMalloc( kpmHandle->refDataSet.pageInfo, KpmPageInfo, refDataSet->pageNum );\n        for( i = 0; i < refDataSet->pageNum; i++ ) {\n            kpmHandle->refDataSet.pageInfo[i].pageNo = refDataSet->pageInfo[i].pageNo;\n            kpmHandle->refDataSet.pageInfo[i].imageNum = refDataSet->pageInfo[i].imageNum;\n            if( refDataSet->pageInfo[i].imageNum != 0 ) {\n                arMalloc( kpmHandle->refDataSet.pageInfo[i].imageInfo, KpmImageInfo, refDataSet->pageInfo[i].imageNum );\n                for( j = 0; j < refDataSet->pageInfo[i].imageNum; j++ ) {\n                    kpmHandle->refDataSet.pageInfo[i].imageInfo[j] = refDataSet->pageInfo[i].imageInfo[j];\n                }\n            }\n            else {\n                refDataSet->pageInfo[i].imageInfo = NULL;\n            }\n        }\n    }\n    else {\n        kpmHandle->refDataSet.pageInfo = NULL;\n    }\n    kpmHandle->refDataSet.pageNum = refDataSet->pageNum;\n\n\n    if( kpmHandle->result != NULL ) {\n        free( kpmHandle->result );\n        kpmHandle->result = NULL;\n        kpmHandle->resultNum = 0;\n    }\n    if( refDataSet->pageNum > 0 ) {\n        kpmHandle->resultNum = refDataSet->pageNum;\n        arMalloc( kpmHandle->result, KpmResult, refDataSet->pageNum );\n\t\tfor (int i = 0; i < refDataSet->pageNum;i++){\n\t\t\tkpmHandle->result[i].skipF = 0;\n\t\t}\n    }\n\n    // Create feature vectors.\n#if !BINARY_FEATURE\n    if (kpmHandle->ann2) {\n        delete (CAnnMatch2 *)(kpmHandle->ann2);\n        kpmHandle->ann2 = NULL;\n    }\n    if (kpmHandle->refDataSet.num != 0) {\n        ann2 = new CAnnMatch2();\n        kpmHandle->ann2 = (void *)ann2;\n        arMalloc( featureVector.sf, SurfFeature, kpmHandle->refDataSet.num );\n        for( int l = 0; l < kpmHandle->refDataSet.num; l++ ) {\n            featureVector.sf[l] = kpmHandle->refDataSet.refPoint[l].featureVec;\n        }\n        featureVector.num = kpmHandle->refDataSet.num;\n        ann2->Construct(&featureVector);\n        free(featureVector.sf);\n    }\n#else\n    if (kpmHandle->refDataSet.num != 0) {\n        featureVector.num = kpmHandle->refDataSet.num;\n\n        int db_id = 0;\n        for (int k = 0; k < kpmHandle->refDataSet.pageNum; k++) {\n            for (int m = 0; m < kpmHandle->refDataSet.pageInfo[k].imageNum; m++) {\n                std::vector<vision::FeaturePoint> points;\n                std::vector<vision::Point3d<float> > points_3d;\n                std::vector<unsigned char> descriptors;\n\n                for (int i = 0; i < featureVector.num; i++) {\n                    if (kpmHandle->refDataSet.refPoint[i].refImageNo == kpmHandle->refDataSet.pageInfo[k].imageInfo[m].imageNo\n                    && kpmHandle->refDataSet.refPoint[i].pageNo == kpmHandle->refDataSet.pageInfo[k].pageNo) {\n                        points.push_back(vision::FeaturePoint(kpmHandle->refDataSet.refPoint[i].coord2D.x,\n                                                          kpmHandle->refDataSet.refPoint[i].coord2D.y,\n                                                          kpmHandle->refDataSet.refPoint[i].featureVec.angle,\n                                                          kpmHandle->refDataSet.refPoint[i].featureVec.scale,\n                                                          kpmHandle->refDataSet.refPoint[i].featureVec.maxima));\n                        points_3d.push_back(vision::Point3d<float>(kpmHandle->refDataSet.refPoint[i].coord3D.x,\n                                                                   kpmHandle->refDataSet.refPoint[i].coord3D.y,                                                                  0));\n                        for (int j = 0; j < FREAK_SUB_DIMENSION; j++)\n                            descriptors.push_back(kpmHandle->refDataSet.refPoint[i].featureVec.v[j]);\n                    }\n                }\n                // TODO duplicated db_id in non-first call\n                  kpmHandle->pageIDs[db_id] = kpmHandle->refDataSet.pageInfo[k].pageNo;\n               kpmHandle->freakMatcher->addFreakFeaturesAndDescriptors(\n                   points,descriptors,points_3d,\n                   kpmHandle->refDataSet.pageInfo[k].imageInfo[m].width,\n                   kpmHandle->refDataSet.pageInfo[k].imageInfo[m].height,\n                   db_id++);\n            }\n        }\n    }\n#endif\n\n    return 0;\n}\n\nint kpmSetRefDataSetFile( KpmHandle *kpmHandle, const char *filename, const char *ext )\n{\n    KpmRefDataSet   *refDataSet;\n\n    if (!kpmHandle || !filename) {\n        ARLOGe(\"kpmSetRefDataSetFile(): NULL kpmHandle/filename.\\n\");\n        return -1;\n    }\n\n    if( kpmLoadRefDataSet(filename, ext, &refDataSet) < 0 ) return -1;\n    if( kpmSetRefDataSet(kpmHandle, refDataSet) < 0 ) {\n        kpmDeleteRefDataSet(&refDataSet);\n        return -1;\n    }\n    kpmDeleteRefDataSet(&refDataSet);\n\n    return 0;\n}\n\nint kpmSetRefDataSetFileOld( KpmHandle *kpmHandle, const char *filename, const char *ext )\n{\n    KpmRefDataSet   *refDataSet;\n\n    if( kpmHandle == NULL )  return -1;\n\n    if( kpmLoadRefDataSetOld(filename, ext, &refDataSet) < 0 ) return -1;\n    if( kpmSetRefDataSet(kpmHandle, refDataSet) < 0 ) {\n        kpmDeleteRefDataSet(&refDataSet);\n        return -1;\n    }\n    kpmDeleteRefDataSet(&refDataSet);\n\n    return 0;\n}\n\nint kpmSetMatchingSkipPage( KpmHandle *kpmHandle, int skipPages[], int num )\n{\n    int    i, j;\n\n    if( kpmHandle == NULL ) return -1;\n\n    for( i = 0; i < num; i++ ) {\n        for( j = 0; j < kpmHandle->refDataSet.pageNum; j++ ) {\n            if( skipPages[i] == kpmHandle->refDataSet.pageInfo[j].pageNo ) {\n                kpmHandle->result[j].skipF = 1;\n                break;\n            }\n        }\n        if( j == kpmHandle->refDataSet.pageNum ) {\n            ARLOGe(\"Cannot find the page for skipping.\\n\");\n            return -1;\n        }\n    }\n\n    return 0;\n}\n\n#if !BINARY_FEATURE\nint kpmSetMatchingSkipRegion( KpmHandle *kpmHandle, SurfSubRect *skipRegion, int regionNum)\n{\n    if( kpmHandle->skipRegion.regionMax < regionNum ) {\n        if( kpmHandle->skipRegion.region != NULL ) free(kpmHandle->skipRegion.region);\n        kpmHandle->skipRegion.regionMax = ((regionNum-1)/10+1) * 10;\n        arMalloc(kpmHandle->skipRegion.region, SurfSubSkipRegion, kpmHandle->skipRegion.regionMax);\n    }\n    kpmHandle->skipRegion.regionNum = regionNum;\n    for(int i = 0; i < regionNum; i++ ) {\n        kpmHandle->skipRegion.region[i].rect = skipRegion[i];\n        for(int j = 0; j < 4; j++) {\n            kpmHandle->skipRegion.region[i].param[j][0] = skipRegion[i].vertex[(j+1)%4].y - skipRegion[i].vertex[j].y;\n            kpmHandle->skipRegion.region[i].param[j][1] = skipRegion[i].vertex[j].x - skipRegion[i].vertex[(j+1)%4].x;\n            kpmHandle->skipRegion.region[i].param[j][2] = skipRegion[i].vertex[(j+1)%4].x * skipRegion[i].vertex[j].y\n                                                        - skipRegion[i].vertex[j].x * skipRegion[i].vertex[(j+1)%4].y;\n        }\n    }\n    return 0;\n}\n#endif\n\nint kpmMatching( KpmHandle *kpmHandle, ARUint8 *inImage )\n{\n    int               xsize, ysize;\n    int               xsize2, ysize2;\n    int               procMode;\n    ARUint8          *inImageBW;\n    int               i;\n#if !BINARY_FEATURE\n    FeatureVector     featureVector;\n    int              *inlierIndex;\n    CorspMap          preRANSAC;\n    int               inlierNum;\n    CAnnMatch2       *ann2;\n    int              *annMatch2;\n    int               knn;\n    float             h[3][3];\n    int               j;\n#endif\n    int               ret;\n\n    if (!kpmHandle || !inImage) {\n        ARLOGe(\"kpmMatching(): NULL kpmHandle/inImage.\\n\");\n        return -1;\n    }\n\n\n    xsize           = kpmHandle->xsize;\n    ysize           = kpmHandle->ysize;\n    procMode        = kpmHandle->procMode;\n\n    if (procMode == KpmProcFullSize && (kpmHandle->pixFormat == AR_PIXEL_FORMAT_MONO || kpmHandle->pixFormat == AR_PIXEL_FORMAT_420v || kpmHandle->pixFormat == AR_PIXEL_FORMAT_420f || kpmHandle->pixFormat == AR_PIXEL_FORMAT_NV21)) {\n        inImageBW = inImage;\n    } else {\n        inImageBW = kpmUtilGenBWImage( inImage, kpmHandle->pixFormat, xsize, ysize, procMode, &xsize2, &ysize2 );\n        if( inImageBW == NULL ) return -1;\n    }\n\n#if BINARY_FEATURE\n    // TODO\n    kpmHandle->freakMatcher->query(inImageBW, xsize ,ysize);\n\n    kpmHandle->inDataSet.num = (int)kpmHandle->freakMatcher->getQueryFeaturePoints().size();\n\n#else\n\n    surfSubExtractFeaturePoint( kpmHandle->surfHandle, inImageBW, kpmHandle->skipRegion.region, kpmHandle->skipRegion.regionNum );\n\n    kpmHandle->skipRegion.regionNum = 0;\n\n    kpmHandle->inDataSet.num = featureVector.num = surfSubGetFeaturePointNum( kpmHandle->surfHandle );\n\n#endif\n\n    if( kpmHandle->inDataSet.num != 0 ) {\n        if( kpmHandle->inDataSet.coord != NULL ) free(kpmHandle->inDataSet.coord);\n#if !BINARY_FEATURE\n        if( kpmHandle->preRANSAC.match != NULL ) free(kpmHandle->preRANSAC.match);\n        if( kpmHandle->aftRANSAC.match != NULL ) free(kpmHandle->aftRANSAC.match);\n#endif\n        arMalloc( kpmHandle->inDataSet.coord, KpmCoord2D,     kpmHandle->inDataSet.num );\n#if !BINARY_FEATURE\n        arMalloc( kpmHandle->preRANSAC.match, KpmMatchData,   kpmHandle->inDataSet.num );\n        arMalloc( kpmHandle->aftRANSAC.match, KpmMatchData,   kpmHandle->inDataSet.num );\n#endif\n#if BINARY_FEATURE\n#else\n        arMalloc( featureVector.sf,           SurfFeature,    kpmHandle->inDataSet.num );\n        arMalloc( preRANSAC.mp,               MatchPoint,     kpmHandle->inDataSet.num );\n        arMalloc( inlierIndex,                int,            kpmHandle->inDataSet.num );\n\n        knn = 1;\n        arMalloc( annMatch2,                  int,            kpmHandle->inDataSet.num*knn);\n#endif\n\n\n#if BINARY_FEATURE\n        const std::vector<vision::FeaturePoint>& points = kpmHandle->freakMatcher->getQueryFeaturePoints();\n        //const std::vector<unsigned char>& descriptors = kpmHandle->freakMatcher->getQueryDescriptors();\n#endif\n        if( procMode == KpmProcFullSize ) {\n            for( i = 0 ; i < kpmHandle->inDataSet.num; i++ ) {\n\n\n#if BINARY_FEATURE\n                float  x = points[i].x, y = points[i].y;\n#else\n                float  x, y, *desc;\n                surfSubGetFeaturePosition( kpmHandle->surfHandle, i, &x, &y );\n                desc = surfSubGetFeatureDescPtr( kpmHandle->surfHandle, i );\n                for( j = 0; j < SURF_SUB_DIMENSION; j++ ) {\n                    featureVector.sf[i].v[j] = desc[j];\n                }\n                featureVector.sf[i].l = surfSubGetFeatureSign( kpmHandle->surfHandle, i );\n#endif\n                if( kpmHandle->cparamLT != NULL ) {\n                    arParamObserv2IdealLTf( &(kpmHandle->cparamLT->paramLTf), x, y, &(kpmHandle->inDataSet.coord[i].x), &(kpmHandle->inDataSet.coord[i].y) );\n                }\n                else {\n                    kpmHandle->inDataSet.coord[i].x = x;\n                    kpmHandle->inDataSet.coord[i].y = y;\n                }\n            }\n        }\n        else if( procMode == KpmProcTwoThirdSize ) {\n            for( i = 0 ; i < kpmHandle->inDataSet.num; i++ ) {\n\n#if BINARY_FEATURE\n                float  x = points[i].x, y = points[i].y;\n#else\n                float  x, y, *desc;\n                surfSubGetFeaturePosition( kpmHandle->surfHandle, i, &x, &y );\n                desc = surfSubGetFeatureDescPtr( kpmHandle->surfHandle, i );\n                for( j = 0; j < SURF_SUB_DIMENSION; j++ ) {\n                    featureVector.sf[i].v[j] = desc[j];\n                }\n                featureVector.sf[i].l = surfSubGetFeatureSign( kpmHandle->surfHandle, i );\n#endif\n                if( kpmHandle->cparamLT != NULL ) {\n                    arParamObserv2IdealLTf( &(kpmHandle->cparamLT->paramLTf), x*1.5f, y*1.5f, &(kpmHandle->inDataSet.coord[i].x), &(kpmHandle->inDataSet.coord[i].y) );\n                }\n                else {\n                    kpmHandle->inDataSet.coord[i].x = x*1.5f;\n                    kpmHandle->inDataSet.coord[i].y = y*1.5f;\n                }\n            }\n        }\n        else if( procMode == KpmProcHalfSize ) {\n            for( i = 0 ; i < kpmHandle->inDataSet.num; i++ ) {\n\n#if BINARY_FEATURE\n                float  x = points[i].x, y = points[i].y;\n#else\n                float  x, y, *desc;\n                surfSubGetFeaturePosition( kpmHandle->surfHandle, i, &x, &y );\n                desc = surfSubGetFeatureDescPtr( kpmHandle->surfHandle, i );\n                for( j = 0; j < SURF_SUB_DIMENSION; j++ ) {\n                    featureVector.sf[i].v[j] = desc[j];\n                }\n                featureVector.sf[i].l = surfSubGetFeatureSign( kpmHandle->surfHandle, i );\n#endif\n                if( kpmHandle->cparamLT != NULL ) {\n                    arParamObserv2IdealLTf( &(kpmHandle->cparamLT->paramLTf), x*2.0f, y*2.0f, &(kpmHandle->inDataSet.coord[i].x), &(kpmHandle->inDataSet.coord[i].y) );\n                }\n                else {\n                    kpmHandle->inDataSet.coord[i].x = x*2.0f;\n                    kpmHandle->inDataSet.coord[i].y = y*2.0f;\n                }\n            }\n        }\n        else if( procMode == KpmProcOneThirdSize ) {\n            for( i = 0 ; i < kpmHandle->inDataSet.num; i++ ) {\n\n#if BINARY_FEATURE\n                float  x = points[i].x, y = points[i].y;\n#else\n                float  x, y, *desc;\n                surfSubGetFeaturePosition( kpmHandle->surfHandle, i, &x, &y );\n                desc = surfSubGetFeatureDescPtr( kpmHandle->surfHandle, i );\n                for( j = 0; j < SURF_SUB_DIMENSION; j++ ) {\n                    featureVector.sf[i].v[j] = desc[j];\n                }\n                featureVector.sf[i].l = surfSubGetFeatureSign( kpmHandle->surfHandle, i );\n#endif\n                if( kpmHandle->cparamLT != NULL ) {\n                    arParamObserv2IdealLTf( &(kpmHandle->cparamLT->paramLTf), x*3.0f, y*3.0f, &(kpmHandle->inDataSet.coord[i].x), &(kpmHandle->inDataSet.coord[i].y) );\n                }\n                else {\n                    kpmHandle->inDataSet.coord[i].x = x*3.0f;\n                    kpmHandle->inDataSet.coord[i].y = y*3.0f;\n                }\n            }\n        }\n        else { // procMode == KpmProcQuatSize\n            for( i = 0 ; i < kpmHandle->inDataSet.num; i++ ) {\n#if BINARY_FEATURE\n                float  x = points[i].x, y = points[i].y;\n#else\n                float  x, y, *desc;\n                surfSubGetFeaturePosition( kpmHandle->surfHandle, i, &x, &y );\n                desc = surfSubGetFeatureDescPtr( kpmHandle->surfHandle, i );\n                for( j = 0; j < SURF_SUB_DIMENSION; j++ ) {\n                    featureVector.sf[i].v[j] = desc[j];\n                }\n                featureVector.sf[i].l = surfSubGetFeatureSign( kpmHandle->surfHandle, i );\n#endif\n                if( kpmHandle->cparamLT != NULL ) {\n                    arParamObserv2IdealLTf( &(kpmHandle->cparamLT->paramLTf), x*4.0f, y*4.0f, &(kpmHandle->inDataSet.coord[i].x), &(kpmHandle->inDataSet.coord[i].y) );\n                }\n                else {\n                    kpmHandle->inDataSet.coord[i].x = x*4.0f;\n                    kpmHandle->inDataSet.coord[i].y = y*4.0f;\n                }\n            }\n        }\n\n#if !BINARY_FEATURE\n        ann2 = (CAnnMatch2*)kpmHandle->ann2;\n        ann2->Match(&featureVector, knn, annMatch2);\n        for(int pageLoop = 0; pageLoop < kpmHandle->resultNum; pageLoop++ ) {\n            kpmHandle->preRANSAC.num = 0;\n            kpmHandle->aftRANSAC.num = 0;\n\n            kpmHandle->result[pageLoop].pageNo = kpmHandle->refDataSet.pageInfo[pageLoop].pageNo;\n            kpmHandle->result[pageLoop].camPoseF = -1;\n            if( kpmHandle->result[pageLoop].skipF ) continue;\n\n            int featureNum = 0;\n            int *annMatch2Ptr = annMatch2;\n            int pageNo = kpmHandle->refDataSet.pageInfo[pageLoop].pageNo;\n            for( i = 0; i < kpmHandle->inDataSet.num; i++ ) {\n                for( j = 0; j < knn; j++ ) {\n                    if( *annMatch2Ptr >= 0 && kpmHandle->refDataSet.refPoint[*annMatch2Ptr].pageNo == pageNo ) {\n                        kpmHandle->preRANSAC.match[featureNum].inIndex = i;\n                        kpmHandle->preRANSAC.match[featureNum].refIndex = *annMatch2Ptr;\n                        preRANSAC.mp[featureNum].x1 = kpmHandle->inDataSet.coord[i].x;\n                        preRANSAC.mp[featureNum].y1 = kpmHandle->inDataSet.coord[i].y;\n                        preRANSAC.mp[featureNum].x2 = kpmHandle->refDataSet.refPoint[*annMatch2Ptr].coord3D.x;\n                        preRANSAC.mp[featureNum].y2 = kpmHandle->refDataSet.refPoint[*annMatch2Ptr].coord3D.y;\n                        featureNum++;\n                        annMatch2Ptr += knn-j;\n                        break;\n                    }\n                    annMatch2Ptr++;\n                }\n            }\n            //printf(\"Page[%d] %d\\n\", pageLoop, featureNum);\n            preRANSAC.num = featureNum;\n            if( featureNum < 6 ) continue;\n\n            if( kpmRansacHomograhyEstimation(&preRANSAC, inlierIndex, &inlierNum, h) < 0 ) {\n                inlierNum = 0;\n            }\n            //printf(\" --> page[%d] %d  pre:%3d, aft:%3d\\n\", pageLoop, kpmHandle->inDataSet.num, preRANSAC.num, inlierNum);\n            if( inlierNum < 6 ) continue;\n\n            kpmHandle->preRANSAC.num = preRANSAC.num;\n            kpmHandle->aftRANSAC.num = inlierNum;\n            for( i = 0; i < inlierNum; i++ ) {\n                kpmHandle->aftRANSAC.match[i].inIndex = kpmHandle->preRANSAC.match[inlierIndex[i]].inIndex;\n                kpmHandle->aftRANSAC.match[i].refIndex = kpmHandle->preRANSAC.match[inlierIndex[i]].refIndex;\n            }\n            //printf(\" ---> %d %d %d\\n\", kpmHandle->inDataSet.num, kpmHandle->preRANSAC.num, kpmHandle->aftRANSAC.num);\n            if( kpmHandle->poseMode == KpmPose6DOF ) {\n                //printf(\"----- Page %d ------\\n\", pageLoop);\n                ret = kpmUtilGetPose(kpmHandle->cparamLT, &(kpmHandle->aftRANSAC), &(kpmHandle->refDataSet), &(kpmHandle->inDataSet),\n                                     kpmHandle->result[pageLoop].camPose,  &(kpmHandle->result[pageLoop].error) );\n                ARLOGi(\"Pose - %s\",arrayToString2(kpmHandle->result[pageLoop].camPose).c_str());\n                //printf(\"----- End. ------\\n\");\n            }\n            else {\n                ret = kpmUtilGetPoseHomography(&(kpmHandle->aftRANSAC), &(kpmHandle->refDataSet), &(kpmHandle->inDataSet),\n                                         kpmHandle->result[pageLoop].camPose,  &(kpmHandle->result[pageLoop].error) );\n            }\n            if( ret == 0 ) {\n                kpmHandle->result[pageLoop].camPoseF = 0;\n                kpmHandle->result[pageLoop].inlierNum = inlierNum;\n                // TODO for performance\n                // ARLOGi(\"Page[%d]  pre:%3d, aft:%3d, error = %f\\n\", pageLoop, preRANSAC.num, inlierNum, kpmHandle->result[pageLoop].error);\n            }\n        }\n        free(annMatch2);\n#else\n        for (int pageLoop = 0; pageLoop < kpmHandle->resultNum; pageLoop++) {\n\n            kpmHandle->result[pageLoop].pageNo = kpmHandle->refDataSet.pageInfo[pageLoop].pageNo;\n            kpmHandle->result[pageLoop].camPoseF = -1;\n            if( kpmHandle->result[pageLoop].skipF ) continue;\n\n\n            const vision::matches_t& matches = kpmHandle->freakMatcher->inliers();\n            int matched_image_id = kpmHandle->freakMatcher->matchedId();\n            if (matched_image_id < 0) continue;\n\n            ret = kpmUtilGetPose_binary(kpmHandle->cparamLT,\n                                        matches ,\n                                        kpmHandle->freakMatcher->get3DFeaturePoints(matched_image_id),\n                                        kpmHandle->freakMatcher->getQueryFeaturePoints(),\n                                        kpmHandle->result[pageLoop].camPose,\n                                        &(kpmHandle->result[pageLoop].error) );\n            //ARLOGi(\"Pose (freak) - %s\",arrayToString2(kpmHandle->result[pageLoop].camPose).c_str());\n            if( ret == 0 ) {\n                kpmHandle->result[pageLoop].camPoseF = 0;\n                kpmHandle->result[pageLoop].inlierNum = (int)matches.size();\n                kpmHandle->result[pageLoop].pageNo = kpmHandle->pageIDs[matched_image_id];\n                // TODO delete for performance\n                //ARLOGi(\"Page[%d]  pre:%3d, aft:%3d, error = %f\\n\", pageLoop, (int)matches.size(), (int)matches.size(), kpmHandle->result[pageLoop].error);\n            }\n        }\n#endif\n#if !BINARY_FEATURE\n        free(featureVector.sf);\n        free(preRANSAC.mp);\n        free(inlierIndex);\n#endif\n    }\n    else {\n#if !BINARY_FEATURE\n        kpmHandle->preRANSAC.num = 0;\n        kpmHandle->aftRANSAC.num = 0;\n#endif\n        for( i = 0; i < kpmHandle->resultNum; i++ ) {\n            kpmHandle->result[i].camPoseF = -1;\n        }\n    }\n\n    for( i = 0; i < kpmHandle->resultNum; i++ ) kpmHandle->result[i].skipF = 0;\n\n    if (inImageBW != inImage) free( inImageBW );\n\n    return 0;\n}\n\n\nint kpmUtilGetPose_binary(ARParamLT *cparamLT, const vision::matches_t &matchData, const std::vector<vision::Point3d<float> > &refDataSet, const std::vector<vision::FeaturePoint> &inputDataSet, float camPose[3][4], float *error)\n{\n    ICPHandleT    *icpHandle;\n    ICPDataT       icpData;\n    ICP2DCoordT   *sCoord;\n    ICP3DCoordT   *wCoord;\n    ARdouble       initMatXw2Xc[3][4];\n    ARdouble       err;\n    int            i;\n\n\n    if( matchData.size() < 4 ) return -1;\n\n    arMalloc( sCoord, ICP2DCoordT, matchData.size() );\n    arMalloc( wCoord, ICP3DCoordT, matchData.size() );\n    for( i = 0; i < matchData.size(); i++ ) {\n        sCoord[i].x = inputDataSet[matchData[i].ins].x;\n        sCoord[i].y = inputDataSet[matchData[i].ins].y;\n\n        wCoord[i].x = refDataSet[matchData[i].ref].x;\n        wCoord[i].y = refDataSet[matchData[i].ref].y;\n        wCoord[i].z = 0.0;\n    }\n\n    icpData.num = i;\n    icpData.screenCoord = &sCoord[0];\n    icpData.worldCoord  = &wCoord[0];\n\n    if( icpGetInitXw2Xc_from_PlanarData( cparamLT->param.mat, sCoord, wCoord, (int)matchData.size(), initMatXw2Xc ) < 0 ) {\n        //printf(\"Error!! at icpGetInitXw2Xc_from_PlanarData.\\n\");\n        free( sCoord );\n        free( wCoord );\n        return -1;\n    }\n    /*\n    printf(\"--- Init pose ---\\n\");\n    for( int j = 0; j < 3; j++ ) {\n        for( i = 0; i < 4; i++ )  printf(\" %8.3f\", initMatXw2Xc[j][i]);\n        printf(\"\\n\");\n    }\n    */\n    if( (icpHandle = icpCreateHandle( cparamLT->param.mat )) == NULL ) {\n        free( sCoord );\n        free( wCoord );\n        return -1;\n    }\n#if 0\n    if( icpData.num > 10 ) {\n        icpSetInlierProbability( icpHandle, 0.7 );\n        if( icpPointRobust( icpHandle, &icpData, initMatXw2Xc, camPose, &err ) < 0 ) {\n            ARLOGe(\"Error!! at icpPoint.\\n\");\n            free( sCoord );\n            free( wCoord );\n            icpDeleteHandle( &icpHandle );\n            return -1;\n        }\n    }\n    else {\n        if( icpPoint( icpHandle, &icpData, initMatXw2Xc, camPose, &err ) < 0 ) {\n            ARLOGe(\"Error!! at icpPoint.\\n\");\n            free( sCoord );\n            free( wCoord );\n            icpDeleteHandle( &icpHandle );\n            return -1;\n        }\n    }\n#else\n#  ifdef ARDOUBLE_IS_FLOAT\n    if( icpPoint( icpHandle, &icpData, initMatXw2Xc, camPose, &err ) < 0 ) {\n        //ARLOGe(\"Error!! at icpPoint.\\n\");\n        free( sCoord );\n        free( wCoord );\n        icpDeleteHandle( &icpHandle );\n        return -1;\n    }\n#  else\n    ARdouble camPosed[3][4];\n    if( icpPoint( icpHandle, &icpData, initMatXw2Xc, camPosed, &err ) < 0 ) {\n        //ARLOGe(\"Error!! at icpPoint.\\n\");\n        free( sCoord );\n        free( wCoord );\n        icpDeleteHandle( &icpHandle );\n        return -1;\n    }\n    for (int r = 0; r < 3; r++) for (int c = 0; c < 4; c++) camPose[r][c] = (float)camPosed[r][c];\n#  endif\n#endif\n    icpDeleteHandle( &icpHandle );\n\n    /*\n    printf(\"error = %f\\n\", err);\n    for( int j = 0; j < 3; j++ ) {\n        for( i = 0; i < 4; i++ )  printf(\" %8.3f\", camPose[j][i]);\n        printf(\"\\n\");\n    }\n    if( err > 10.0f ) {\n        for( i = 0; i < matchData->num; i++ ) {\n            printf(\"%d\\t%f\\t%f\\t%f\\t%f\\n\", i+1, sCoord[i].x, sCoord[i].y, wCoord[i].x, wCoord[i].y);\n        }\n    }\n    */\n\n\n    free( sCoord );\n    free( wCoord );\n\n    *error = (float)err;\n    if( *error > 10.0f ) return -1;\n\n    return 0;\n}\n","/*\n *  kpmUtil.cpp\n *  ARToolKit5\n *\n *  This file is part of ARToolKit.\n *\n *  ARToolKit is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation, either version 3 of the License, or\n *  (at your option) any later version.\n *\n *  ARToolKit is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public License\n *  along with ARToolKit.  If not, see <http://www.gnu.org/licenses/>.\n *\n *  As a special exception, the copyright holders of this library give you\n *  permission to link this library with independent modules to produce an\n *  executable, regardless of the license terms of these independent modules, and to\n *  copy and distribute the resulting executable under terms of your choice,\n *  provided that you also meet, for each linked independent module, the terms and\n *  conditions of the license of that module. An independent module is a module\n *  which is neither derived from nor based on this library. If you modify this\n *  library, you may extend this exception to your version of the library, but you\n *  are not obligated to do so. If you do not wish to do so, delete this exception\n *  statement from your version.\n *\n *  Copyright 2015 Daqri, LLC. All rights reserved.\n *  Copyright 2006-2015 ARToolworks, Inc. All rights reserved.\n *  Author(s): Hirokazu Kato, Philip Lamb\n *\n */\n\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <AR/ar.h>\n#include <AR/icp.h>\n#include <KPM/kpm.h>\n#include <KPM/kpmType.h>\n\n#if BINARY_FEATURE\n#include <facade/visual_database_facade.h>\n#else\n#include <KPM/surfSub.h>\n#endif\n\nstatic ARUint8 *genBWImageFull      ( ARUint8 *image, AR_PIXEL_FORMAT pixFormat, int xsize, int ysize, int *newXsize, int *newYsize );\nstatic ARUint8 *genBWImageHalf      ( ARUint8 *image, AR_PIXEL_FORMAT pixFormat, int xsize, int ysize, int *newXsize, int *newYsize );\nstatic ARUint8 *genBWImageOneThird  ( ARUint8 *image, AR_PIXEL_FORMAT pixFormat, int xsize, int ysize, int *newXsize, int *newYsize );\nstatic ARUint8 *genBWImageTwoThird  ( ARUint8 *image, AR_PIXEL_FORMAT pixFormat, int xsize, int ysize, int *newXsize, int *newYsize );\nstatic ARUint8 *genBWImageQuart     ( ARUint8 *image, AR_PIXEL_FORMAT pixFormat, int xsize, int ysize, int *newXsize, int *newYsize );\n\n\n#if !BINARY_FEATURE\nstatic int kpmUtilGetInitPoseHomography( float *sCoord, float *wCoord, int num, float initPose[3][4] );\n#endif\n\nint kpmUtilGetCorner( ARUint8 *inImage, AR_PIXEL_FORMAT pixFormat, int xsize, int ysize, int procMode, int maxPointNum,\n                      CornerPoints *cornerPoints )\n{\n    ARUint8        *inImageBW;\n    int            xsize2, ysize2;\n    int            cornerNum;\n    int            i;\n\n    inImageBW = kpmUtilGenBWImage( inImage, pixFormat, xsize, ysize, procMode, &xsize2, &ysize2 ); //Eventually returns a\n                                                                                                   //malloc()'ed buffer\n    if( inImageBW == NULL ) return -1;\n    \n#if BINARY_FEATURE\n    vision::VisualDatabaseFacade *freakMatcher = new vision::VisualDatabaseFacade;\n    freakMatcher->addImage(inImageBW, xsize, ysize, 1);\n    const std::vector<vision::FeaturePoint>& points = freakMatcher->getQueryFeaturePoints();\n    cornerNum = (int)freakMatcher->getQueryFeaturePoints().size();\n#else\n    SurfSubHandleT *surfHandle;\n    surfHandle = surfSubCreateHandle(xsize2, ysize2, AR_PIXEL_FORMAT_MONO);\n    if (!surfHandle) {\n        ARLOGe(\"Error: unable to initialise KPM feature matching.\\n\");\n        free( inImageBW ); //COVHI10283\n        return -1;\n    }\n    surfSubSetMaxPointNum( surfHandle, maxPointNum );\n    surfSubExtractFeaturePoint( surfHandle, inImageBW, NULL, 0 );\n    cornerNum = surfSubGetFeaturePointNum( surfHandle );\n#endif\n    \n    if( procMode == KpmProcFullSize ) {\n        for( i = 0; i < cornerNum; i++ ) {\n            float  x, y;\n#if BINARY_FEATURE\n            x = points[i].x, y = points[i].y;\n#else\n            surfSubGetFeaturePosition( surfHandle, i, &x, &y );\n#endif\n            cornerPoints->pt[i].x = (int)x;\n            cornerPoints->pt[i].y = (int)y;\n        }\n    }\n    else if( procMode == KpmProcTwoThirdSize ) {\n        for( i = 0; i < cornerNum; i++ ) {\n            float  x, y;\n#if BINARY_FEATURE\n            x = points[i].x, y = points[i].y;\n#else\n            surfSubGetFeaturePosition( surfHandle, i, &x, &y );\n#endif\n            cornerPoints->pt[i].x = (int)(x * 1.5f);\n            cornerPoints->pt[i].y = (int)(y * 1.5f);\n        }\n    }\n    else if( procMode == KpmProcHalfSize ) {\n        for( i = 0; i < cornerNum; i++ ) {\n            float  x, y;\n#if BINARY_FEATURE\n            x = points[i].x, y = points[i].y;\n#else\n            surfSubGetFeaturePosition( surfHandle, i, &x, &y );\n#endif\n            cornerPoints->pt[i].x = (int)(x * 2.0f);\n            cornerPoints->pt[i].y = (int)(y * 2.0f);\n        }\n    }\n    else if( procMode == KpmProcOneThirdSize ) {\n        for( i = 0; i < cornerNum; i++ ) {\n            float  x, y;\n#if BINARY_FEATURE\n            x = points[i].x, y = points[i].y;\n#else\n            surfSubGetFeaturePosition( surfHandle, i, &x, &y );\n#endif\n            cornerPoints->pt[i].x = (int)(x * 3.0f);\n            cornerPoints->pt[i].y = (int)(y * 3.0f);\n        }\n    }\n    else {      \n        for( i = 0; i < cornerNum; i++ ) {\n            float  x, y;\n#if BINARY_FEATURE\n            x = points[i].x, y = points[i].y;\n#else\n            surfSubGetFeaturePosition( surfHandle, i, &x, &y );\n#endif\n            cornerPoints->pt[i].x = (int)(x * 4.0f);\n            cornerPoints->pt[i].y = (int)(y * 4.0f);\n        }\n    }\n    cornerPoints->num = cornerNum;\n\n    free( inImageBW );\n#if BINARY_FEATURE\n    delete freakMatcher;\n#else\n    surfSubDeleteHandle( &surfHandle );\n#endif\n\n    return 0;\n}\n\nARUint8 *kpmUtilGenBWImage( ARUint8 *image, AR_PIXEL_FORMAT pixFormat, int xsize, int ysize, int procMode, int *newXsize, int *newYsize )\n{\n    if( procMode == KpmProcFullSize ) {\n        return genBWImageFull( image, pixFormat, xsize, ysize, newXsize, newYsize );\n    }\n    else if( procMode == KpmProcTwoThirdSize ) {\n        return genBWImageTwoThird( image, pixFormat, xsize, ysize, newXsize, newYsize );\n    }\n    else if( procMode == KpmProcHalfSize ) {\n        return genBWImageHalf( image, pixFormat, xsize, ysize, newXsize, newYsize );\n    }\n    else if( procMode == KpmProcOneThirdSize ) {\n        return genBWImageOneThird( image, pixFormat, xsize, ysize, newXsize, newYsize );\n    }\n    else {\n        return genBWImageQuart( image, pixFormat, xsize, ysize, newXsize, newYsize );\n    }\n}\n\n#if !BINARY_FEATURE\nint kpmUtilGetPose( ARParamLT *cparamLT, KpmMatchResult *matchData, KpmRefDataSet *refDataSet, KpmInputDataSet *inputDataSet, float  camPose[3][4], float  *error )\n{\n    ICPHandleT    *icpHandle;\n    ICPDataT       icpData;\n    ICP2DCoordT   *sCoord;\n    ICP3DCoordT   *wCoord;\n    ARdouble       initMatXw2Xc[3][4];\n    ARdouble       err;\n    int            i;\n\n    if( matchData->num < 4 ) return -1;\n\n    arMalloc( sCoord, ICP2DCoordT, matchData->num );\n    arMalloc( wCoord, ICP3DCoordT, matchData->num );\n\n    for( i = 0; i < matchData->num; i++ ) {\n        sCoord[i].x = inputDataSet->coord[matchData->match[i].inIndex].x;\n        sCoord[i].y = inputDataSet->coord[matchData->match[i].inIndex].y;\n        wCoord[i].x = refDataSet->refPoint[matchData->match[i].refIndex].coord3D.x;\n        wCoord[i].y = refDataSet->refPoint[matchData->match[i].refIndex].coord3D.y;\n        wCoord[i].z = 0.0;\n        //printf(\"%3d: (%f %f) - (%f %f)\\n\", i, sCoord[i].x, sCoord[i].y, wCoord[i].x, wCoord[i].y);\n    }\n\n    icpData.num = i;\n    icpData.screenCoord = &sCoord[0];\n    icpData.worldCoord  = &wCoord[0];\n\n    if( icpGetInitXw2Xc_from_PlanarData( cparamLT->param.mat, sCoord, wCoord, matchData->num, initMatXw2Xc ) < 0 ) {\n        //printf(\"Error!! at icpGetInitXw2Xc_from_PlanarData.\\n\");\n        free( sCoord );\n        free( wCoord );\n        return -1;\n    }\n/*\n    printf(\"--- Init pose ---\\n\");\n    for( int j = 0; j < 3; j++ ) { \n        for( i = 0; i < 4; i++ )  printf(\" %8.3f\", initMatXw2Xc[j][i]);\n        printf(\"\\n\"); \n    } \n*/\n    if( (icpHandle = icpCreateHandle( cparamLT->param.mat )) == NULL ) {\n        free( sCoord );\n        free( wCoord );\n        return -1;\n    }\n#if 0\n    if( icpData.num > 10 ) {\n        icpSetInlierProbability( icpHandle, 0.7 );\n        if( icpPointRobust( icpHandle, &icpData, initMatXw2Xc, camPose, &err ) < 0 ) {\n            ARLOGe(\"Error!! at icpPoint.\\n\");\n            free( sCoord );\n            free( wCoord );\n            icpDeleteHandle( &icpHandle );\n            return -1;\n        }\n    }\n    else {\n        if( icpPoint( icpHandle, &icpData, initMatXw2Xc, camPose, &err ) < 0 ) {\n            ARLOGe(\"Error!! at icpPoint.\\n\");\n            free( sCoord );\n            free( wCoord );\n            icpDeleteHandle( &icpHandle );\n            return -1;\n        }\n    }\n#else\n#  ifdef ARDOUBLE_IS_FLOAT\n    if( icpPoint( icpHandle, &icpData, initMatXw2Xc, camPose, &err ) < 0 ) {\n        //ARLOGe(\"Error!! at icpPoint.\\n\");\n        free( sCoord );\n        free( wCoord );\n        icpDeleteHandle( &icpHandle );\n        return -1;\n    }\n#  else\n    ARdouble camPosed[3][4];\n    if( icpPoint( icpHandle, &icpData, initMatXw2Xc, camPosed, &err ) < 0 ) {\n        //ARLOGe(\"Error!! at icpPoint.\\n\");\n        free( sCoord );\n        free( wCoord );\n        icpDeleteHandle( &icpHandle );\n        return -1;\n    }\n    for (int r = 0; r < 3; r++) for (int c = 0; c < 4; c++) camPose[r][c] = (float)camPosed[r][c];\n#  endif\n#endif\n    icpDeleteHandle( &icpHandle );\n\n/*\n    printf(\"error = %f\\n\", err);\n    for( int j = 0; j < 3; j++ ) { \n        for( i = 0; i < 4; i++ )  printf(\" %8.3f\", camPose[j][i]);\n        printf(\"\\n\"); \n    } \n    if( err > 10.0f ) {\n        for( i = 0; i < matchData->num; i++ ) {\n            printf(\"%d\\t%f\\t%f\\t%f\\t%f\\n\", i+1, sCoord[i].x, sCoord[i].y, wCoord[i].x, wCoord[i].y);\n        }\n    }\n*/\n\n\n    free( sCoord );\n    free( wCoord );\n\n    *error = (float)err;\n    if( *error > 10.0f ) return -1;\n\n    return 0;\n}\n\n\nint kpmUtilGetPose2( ARParamLT *cparamLT, KpmMatchResult *matchData, KpmRefDataSet *refDataSet, int *redDataIndex, KpmInputDataSet *inputDataSet, float  camPose[3][4], float  *error )\n{\n    ICPHandleT    *icpHandle;\n    ICPDataT       icpData;\n    ICP2DCoordT   *sCoord;\n    ICP3DCoordT   *wCoord;\n    ARdouble       initMatXw2Xc[3][4];\n    ARdouble       err;\n    int            i;\n    \n    if( matchData->num < 4 ) return -1;\n    \n    arMalloc( sCoord, ICP2DCoordT, matchData->num );\n    arMalloc( wCoord, ICP3DCoordT, matchData->num );\n    \n    for( i = 0; i < matchData->num; i++ ) {\n        sCoord[i].x = inputDataSet->coord[matchData->match[i].inIndex].x;\n        sCoord[i].y = inputDataSet->coord[matchData->match[i].inIndex].y;\n        wCoord[i].x = refDataSet->refPoint[redDataIndex[matchData->match[i].refIndex]].coord3D.x;\n        wCoord[i].y = refDataSet->refPoint[redDataIndex[matchData->match[i].refIndex]].coord3D.y;\n        wCoord[i].z = 0.0;\n    }\n    \n    icpData.num = i;\n    icpData.screenCoord = &sCoord[0];\n    icpData.worldCoord  = &wCoord[0];\n    \n    if( icpGetInitXw2Xc_from_PlanarData( cparamLT->param.mat, sCoord, wCoord, matchData->num, initMatXw2Xc ) < 0 ) {\n        //ARLOGe(\"Error!! at icpGetInitXw2Xc_from_PlanarData.\\n\");\n        free( sCoord );\n        free( wCoord );\n        return -1;\n    }\n/*\n    ARLOG(\"--- Init pose ---\\n\");\n    for( int j = 0; j < 3; j++ ) { \n        for( i = 0; i < 4; i++ )  ARLOG(\" %8.3f\", initMatXw2Xc[j][i]);\n        ARLOG(\"\\n\"); \n    } \n*/\n    if( (icpHandle = icpCreateHandle( cparamLT->param.mat )) == NULL ) {\n        free( sCoord );\n        free( wCoord );\n        return -1;\n    }\n#if 0\n    if( icpData.num > 10 ) {\n        icpSetInlierProbability( icpHandle, 0.7 );\n        if( icpPointRobust( icpHandle, &icpData, initMatXw2Xc, camPose, &err ) < 0 ) {\n            ARLOGe(\"Error!! at icpPoint.\\n\");\n            free( sCoord );\n            free( wCoord );\n            icpDeleteHandle( &icpHandle );\n            return -1;\n        }\n    }\n    else {\n        if( icpPoint( icpHandle, &icpData, initMatXw2Xc, camPose, &err ) < 0 ) {\n            ARLOGe(\"Error!! at icpPoint.\\n\");\n            free( sCoord );\n            free( wCoord );\n            icpDeleteHandle( &icpHandle );\n            return -1;\n        }\n    }\n#else\n#  ifdef ARDOUBLE_IS_FLOAT\n    if( icpPoint( icpHandle, &icpData, initMatXw2Xc, camPose, &err ) < 0 ) {\n        //ARLOGe(\"Error!! at icpPoint.\\n\");\n        free( sCoord );\n        free( wCoord );\n        icpDeleteHandle( &icpHandle );\n        return -1;\n    }\n#  else\n    ARdouble camPosed[3][4];\n    if( icpPoint( icpHandle, &icpData, initMatXw2Xc, camPosed, &err ) < 0 ) {\n        //ARLOGe(\"Error!! at icpPoint.\\n\");\n        free( sCoord );\n        free( wCoord );\n        icpDeleteHandle( &icpHandle );\n        return -1;\n    }\n    for (int r = 0; r < 3; r++) for (int c = 0; c < 4; c++) camPose[r][c] = (float)camPosed[r][c];\n#  endif\n#endif\n    icpDeleteHandle( &icpHandle );\n\n/*\n    ARLOG(\"error = %f\\n\", err);\n    for( int j = 0; j < 3; j++ ) { \n        for( i = 0; i < 4; i++ )  ARLOG(\" %8.3f\", camPose[j][i]);\n        ARLOG(\"\\n\"); \n    } \n    if( err > 10.0 ) {\n        for( i = 0; i < matchData->num; i++ ) {\n            ARLOG(\"%d\\t%f\\t%f\\t%f\\t%f\\n\", i+1, sCoord[i].x, sCoord[i].y, wCoord[i].x, wCoord[i].y);\n        }\n    }\n*/\n\n\n    free( sCoord );\n    free( wCoord );\n\n    *error = (float)err;\n    if( *error > 10.0f ) return -1;\n\n    return 0;\n}\n\nint kpmUtilGetPoseHomography( KpmMatchResult *matchData, KpmRefDataSet *refDataSet, KpmInputDataSet *inputDataSet, float  camPose[3][4], float  *error )\n{   \n    float   *sCoord;\n    float   *wCoord;\n    float    initPose[3][4];\n    int      num;\n    int      i;\n    \n    if( matchData->num < 4 ) return -1;\n    num = matchData->num;\n    \n    arMalloc( sCoord, float, num*2 );\n    arMalloc( wCoord, float, num*2 );\n    \n    for( i = 0; i < num; i++ ) {\n        sCoord[i*2+0] = inputDataSet->coord[matchData->match[i].inIndex].x;\n        sCoord[i*2+1] = inputDataSet->coord[matchData->match[i].inIndex].y;\n        wCoord[i*2+0] = refDataSet->refPoint[matchData->match[i].refIndex].coord3D.x;\n        wCoord[i*2+1] = refDataSet->refPoint[matchData->match[i].refIndex].coord3D.y;\n    }\n    \n    if( kpmUtilGetInitPoseHomography( sCoord, wCoord, num, initPose ) < 0 ) {\n        free( sCoord );\n        free( wCoord );\n        return -1;\n    }\n    \n    for( int j = 0; j < 3; j++ ) {\n        for( i = 0; i < 4; i++ )  camPose[j][i] = initPose[j][i];\n    }\n    \n    *error = 0.0;\n    float  *p1 = sCoord;\n    float  *p2 = wCoord;\n    for( i = 0; i < num; i++ ) {\n        float  x, y, w;\n        x = camPose[0][0] * *p2 + camPose[0][1] * *(p2+1) + camPose[0][3];\n        y = camPose[1][0] * *p2 + camPose[1][1] * *(p2+1) + camPose[1][3];\n        w = camPose[2][0] * *p2 + camPose[2][1] * *(p2+1) + camPose[2][3];\n        if( w == 0.0 ) {\n            free( sCoord );\n            free( wCoord );\n            return -1;\n        }\n        x /= w;\n        y /= w;\n        *error += (*p1 - x)*(*p1 - x) + (*(p1+1) - y)*(*(p1+1) - y);\n    }\n    *error /= num;\n    \n    free( sCoord );\n    free( wCoord );\n    if( *error > 10.0 ) return -1;\n\n    return 0;\n}\n#endif\n\nstatic ARUint8 *genBWImageFull( ARUint8 *image, AR_PIXEL_FORMAT pixFormat, int xsize, int ysize, int *newXsize, int *newYsize )\n{\n    ARUint8  *newImage, *p;\n    int       xsize2, ysize2;\n    int       i, j;\n\n    *newXsize = xsize2 = xsize;\n    *newYsize = ysize2 = ysize;\n    arMalloc( newImage, ARUint8, xsize*ysize );\n    \n    if( pixFormat == AR_PIXEL_FORMAT_RGB || pixFormat == AR_PIXEL_FORMAT_BGR ) {\n        p = newImage;\n        for( j = 0; j < ysize2; j++ ) {\n            for( i = 0; i < xsize2; i++ ) {\n                *(p++) = ( (int)*image + (int)*(image+1) + (int)*(image+2) ) / 3;\n                image+=3;\n            }\n        }\n    }\n    else if( pixFormat == AR_PIXEL_FORMAT_RGBA || pixFormat == AR_PIXEL_FORMAT_BGRA ) {\n        p = newImage;\n        for( j = 0; j < ysize2; j++ ) {\n            for( i = 0; i < xsize2; i++ ) {\n                *(p++) = ( (int)*image + (int)*(image+1) + (int)*(image+2) ) / 3;\n                image+=4;\n            }\n        }\n    }\n    else if( pixFormat == AR_PIXEL_FORMAT_ABGR || pixFormat == AR_PIXEL_FORMAT_ARGB) {\n        p = newImage;\n        for( j = 0; j < ysize2; j++ ) {\n            for( i = 0; i < xsize2; i++ ) {\n                *(p++) = ( (int)*(image+1) + (int)*(image+2) + (int)*(image+3) ) / 3;\n                image+=4;\n            }\n        }\n    }\n    else if( pixFormat == AR_PIXEL_FORMAT_MONO || pixFormat == AR_PIXEL_FORMAT_420f || pixFormat == AR_PIXEL_FORMAT_420v || pixFormat == AR_PIXEL_FORMAT_NV21 ) {\n        p = newImage;\n        for( j = 0; j < ysize2; j++ ) {\n            for( i = 0; i < xsize2; i++ ) {\n                *(p++) = *(image++);\n            }\n        }\n    }\n    else if( pixFormat == AR_PIXEL_FORMAT_2vuy ) {\n        p = newImage;\n        for( j = 0; j < ysize2; j++ ) {\n            for( i = 0; i < xsize2; i++ ) {\n                *(p++) = *(image+1);\n                image+=2;\n            }\n        }\n    }\n    else if( pixFormat == AR_PIXEL_FORMAT_yuvs ) {\n        p = newImage;\n        for( j = 0; j < ysize2; j++ ) {\n            for( i = 0; i < xsize2; i++ ) {\n                *(p++) = *image;\n                image+=2;\n            }\n        }\n    }\n\n    return newImage;\n}\n\nstatic ARUint8 *genBWImageHalf( ARUint8 *image, AR_PIXEL_FORMAT pixFormat, int xsize, int ysize, int *newXsize, int *newYsize )\n{\n    ARUint8  *newImage;\n    ARUint8  *p, *p1, *p2;\n    int       xsize2, ysize2;\n    int       i, j;\n    \n    *newXsize = xsize2 = xsize/2;\n    *newYsize = ysize2 = ysize/2;\n    arMalloc( newImage, ARUint8, xsize2*ysize2 );\n\n    if( pixFormat == AR_PIXEL_FORMAT_RGB || pixFormat == AR_PIXEL_FORMAT_BGR ) {\n        p  = newImage;\n        for( j = 0; j < ysize2; j++ ) {\n            p1 = image + xsize*3*(j*2+0);\n            p2 = image + xsize*3*(j*2+1);\n            for( i = 0; i < xsize2; i++ ) {\n                *(p++) = ( (int)*(p1+0) + (int)*(p1+1) + (int)*(p1+2)\n                         + (int)*(p1+3) + (int)*(p1+4) + (int)*(p1+5)\n                         + (int)*(p2+0) + (int)*(p2+1) + (int)*(p2+2)\n                         + (int)*(p2+3) + (int)*(p2+4) + (int)*(p2+5) ) / 12;\n                p1+=6;\n                p2+=6;\n            }\n        }\n    }\n    else if( pixFormat == AR_PIXEL_FORMAT_RGBA || pixFormat == AR_PIXEL_FORMAT_BGRA ) {\n        p  = newImage;\n        for( j = 0; j < ysize2; j++ ) {\n            p1 = image + xsize*4*(j*2+0);\n            p2 = image + xsize*4*(j*2+1);\n            for( i = 0; i < xsize2; i++ ) {\n                *(p++) = ( (int)*(p1+0) + (int)*(p1+1) + (int)*(p1+2)\n                         + (int)*(p1+4) + (int)*(p1+5) + (int)*(p1+6)\n                         + (int)*(p2+0) + (int)*(p2+1) + (int)*(p2+2)\n                         + (int)*(p2+4) + (int)*(p2+5) + (int)*(p2+6) ) / 12;\n                p1+=8;\n                p2+=8;\n            }\n        }\n    }\n    else if( pixFormat == AR_PIXEL_FORMAT_ABGR || pixFormat == AR_PIXEL_FORMAT_ARGB) {\n        p  = newImage;\n        for( j = 0; j < ysize2; j++ ) {\n            p1 = image + xsize*4*(j*2+0);\n            p2 = image + xsize*4*(j*2+1);\n            for( i = 0; i < xsize2; i++ ) {\n                *(p++) = ( (int)*(p1+1) + (int)*(p1+2) + (int)*(p1+3)\n                         + (int)*(p1+5) + (int)*(p1+6) + (int)*(p1+7)\n                         + (int)*(p2+1) + (int)*(p2+2) + (int)*(p2+3)\n                         + (int)*(p2+5) + (int)*(p2+6) + (int)*(p2+7) ) / 12;\n                p1+=8;\n                p2+=8;\n            }\n        }\n    }\n    else if( pixFormat == AR_PIXEL_FORMAT_MONO || pixFormat == AR_PIXEL_FORMAT_420f || pixFormat == AR_PIXEL_FORMAT_420v || pixFormat == AR_PIXEL_FORMAT_NV21) {\n        p  = newImage;\n        for( j = 0; j < ysize2; j++ ) {\n            p1 = image + xsize*(j*2+0);\n            p2 = image + xsize*(j*2+1);\n            for( i = 0; i < xsize2; i++ ) {\n                *(p++) = ( (int)*(p1+0) + (int)*(p1+1)\n                         + (int)*(p2+0) + (int)*(p2+1) ) / 4;\n                p1+=2;\n                p2+=2;\n            }\n        }\n    }\n    else if( pixFormat == AR_PIXEL_FORMAT_2vuy) {\n        p  = newImage;\n        for( j = 0; j < ysize2; j++ ) {\n            p1 = image + xsize*2*(j*2+0);\n            p2 = image + xsize*2*(j*2+1);\n            for( i = 0; i < xsize2; i++ ) {\n                *(p++) = ( (int)*(p1+1) + (int)*(p1+3)\n                         + (int)*(p2+1) + (int)*(p2+3) ) / 4;\n                p1+=4;\n                p2+=4;\n            }\n        }\n    }\n    else if( pixFormat == AR_PIXEL_FORMAT_yuvs) {\n        p  = newImage;\n        for( j = 0; j < ysize2; j++ ) {\n            p1 = image + xsize*2*(j*2+0);\n            p2 = image + xsize*2*(j*2+1);\n            for( i = 0; i < xsize2; i++ ) {\n                *(p++) = ( (int)*(p1+0) + (int)*(p1+2)\n                         + (int)*(p2+0) + (int)*(p2+2) ) / 4;\n                p1+=4;\n                p2+=4;\n            }\n        }\n    }\n\n    return newImage;\n}\n\nstatic ARUint8 *genBWImageQuart( ARUint8 *image, AR_PIXEL_FORMAT pixFormat, int xsize, int ysize, int *newXsize, int *newYsize )\n{\n    ARUint8  *newImage;\n    ARUint8  *p, *p1, *p2, *p3, *p4;\n    int       xsize2, ysize2;\n    int       i, j;\n    \n    *newXsize = xsize2 = xsize/4;\n    *newYsize = ysize2 = ysize/4;\n    arMalloc( newImage, ARUint8, xsize2*ysize2 );\n    \n    if( pixFormat == AR_PIXEL_FORMAT_RGB || pixFormat == AR_PIXEL_FORMAT_BGR ) {\n        p  = newImage;\n        for( j = 0; j < ysize2; j++ ) {\n            p1 = image + xsize*3*(j*4+0);\n            p2 = image + xsize*3*(j*4+1);\n            p3 = image + xsize*3*(j*4+2);\n            p4 = image + xsize*3*(j*4+3);\n            for( i = 0; i < xsize2; i++ ) {\n                *(p++) = ( (int)*(p1+0) + (int)*(p1+1) + (int)*(p1+2)\n                         + (int)*(p1+3) + (int)*(p1+4) + (int)*(p1+5)\n                         + (int)*(p1+6) + (int)*(p1+7) + (int)*(p1+8)\n                         + (int)*(p1+9) + (int)*(p1+10) + (int)*(p1+11)\n                         + (int)*(p2+0) + (int)*(p2+1) + (int)*(p2+2)\n                         + (int)*(p2+3) + (int)*(p2+4) + (int)*(p2+5)\n                         + (int)*(p2+6) + (int)*(p2+7) + (int)*(p2+8)\n                         + (int)*(p2+9) + (int)*(p2+10) + (int)*(p2+11)\n                         + (int)*(p3+0) + (int)*(p3+1) + (int)*(p3+2)\n                         + (int)*(p3+3) + (int)*(p3+4) + (int)*(p3+5)\n                         + (int)*(p3+6) + (int)*(p3+7) + (int)*(p3+8)\n                         + (int)*(p3+9) + (int)*(p3+10) + (int)*(p3+11)\n                         + (int)*(p4+0) + (int)*(p4+1) + (int)*(p4+2)\n                         + (int)*(p4+3) + (int)*(p4+4) + (int)*(p4+5)\n                         + (int)*(p4+6) + (int)*(p4+7) + (int)*(p4+8)\n                         + (int)*(p4+9) + (int)*(p4+10) + (int)*(p4+11)) / 48;\n                p1+=12;\n                p2+=12;\n                p3+=12;\n                p4+=12;\n            }\n        }\n    }\n    else if( pixFormat == AR_PIXEL_FORMAT_RGBA || pixFormat == AR_PIXEL_FORMAT_BGRA ) {\n        p  = newImage;\n        for( j = 0; j < ysize2; j++ ) {\n            p1 = image + xsize*4*(j*4+0);\n            p2 = image + xsize*4*(j*4+1);\n            p3 = image + xsize*4*(j*4+2);\n            p4 = image + xsize*4*(j*4+3);\n            for( i = 0; i < xsize2; i++ ) {\n                *(p++) = ( (int)*(p1+0) + (int)*(p1+1) + (int)*(p1+2)\n                         + (int)*(p1+4) + (int)*(p1+5) + (int)*(p1+6)\n                         + (int)*(p1+8) + (int)*(p1+9) + (int)*(p1+10)\n                         + (int)*(p1+12) + (int)*(p1+13) + (int)*(p1+14)\n                         + (int)*(p2+0) + (int)*(p2+1) + (int)*(p2+2)\n                         + (int)*(p2+4) + (int)*(p2+5) + (int)*(p2+6)\n                         + (int)*(p2+8) + (int)*(p2+9) + (int)*(p2+10)\n                         + (int)*(p2+12) + (int)*(p2+13) + (int)*(p2+14)\n                         + (int)*(p3+0) + (int)*(p3+1) + (int)*(p3+2)\n                         + (int)*(p3+4) + (int)*(p3+5) + (int)*(p3+6)\n                         + (int)*(p3+8) + (int)*(p3+9) + (int)*(p3+10)\n                         + (int)*(p3+12) + (int)*(p3+13) + (int)*(p3+14)\n                         + (int)*(p4+0) + (int)*(p4+1) + (int)*(p4+2)\n                         + (int)*(p4+4) + (int)*(p4+5) + (int)*(p4+6)\n                         + (int)*(p4+8) + (int)*(p4+9) + (int)*(p4+10)\n                         + (int)*(p4+12) + (int)*(p4+13) + (int)*(p4+14)) / 48;\n                p1+=16;\n                p2+=16;\n                p3+=16;\n                p4+=16;\n            }\n        }\n    }\n    else if( pixFormat == AR_PIXEL_FORMAT_ABGR || pixFormat == AR_PIXEL_FORMAT_ARGB) {\n        p  = newImage;\n        for( j = 0; j < ysize2; j++ ) {\n            p1 = image + xsize*4*(j*4+0);\n            p2 = image + xsize*4*(j*4+1);\n            p3 = image + xsize*4*(j*4+2);\n            p4 = image + xsize*4*(j*4+3);\n            for( i = 0; i < xsize2; i++ ) {\n                *(p++) = ( (int)*(p1+1) + (int)*(p1+2) + (int)*(p1+3)\n                         + (int)*(p1+5) + (int)*(p1+6) + (int)*(p1+7)\n                         + (int)*(p1+9) + (int)*(p1+10) + (int)*(p1+11)\n                         + (int)*(p1+13) + (int)*(p1+14) + (int)*(p1+15)\n                         + (int)*(p2+1) + (int)*(p2+2) + (int)*(p2+3)\n                         + (int)*(p2+5) + (int)*(p2+6) + (int)*(p2+7)\n                         + (int)*(p2+9) + (int)*(p2+10) + (int)*(p2+11)\n                         + (int)*(p2+13) + (int)*(p2+14) + (int)*(p2+15)\n                         + (int)*(p3+1) + (int)*(p3+2) + (int)*(p3+3)\n                         + (int)*(p3+5) + (int)*(p3+6) + (int)*(p3+7)\n                         + (int)*(p3+9) + (int)*(p3+10) + (int)*(p3+11)\n                         + (int)*(p3+13) + (int)*(p3+14) + (int)*(p3+15)\n                         + (int)*(p4+1) + (int)*(p4+2) + (int)*(p4+3)\n                         + (int)*(p4+5) + (int)*(p4+6) + (int)*(p4+7)\n                         + (int)*(p4+9) + (int)*(p4+10) + (int)*(p4+11)\n                         + (int)*(p4+13) + (int)*(p4+14) + (int)*(p4+15)) / 48;\n                p1+=16;\n                p2+=16;\n                p3+=16;\n                p4+=16;\n            }\n        }\n    }\n    else if( pixFormat == AR_PIXEL_FORMAT_MONO || pixFormat == AR_PIXEL_FORMAT_420f || pixFormat == AR_PIXEL_FORMAT_420v || pixFormat == AR_PIXEL_FORMAT_NV21 ) {\n        p  = newImage;\n        for( j = 0; j < ysize2; j++ ) {\n            p1 = image + xsize*(j*4+0);\n            p2 = image + xsize*(j*4+1);\n            p3 = image + xsize*(j*4+2);\n            p4 = image + xsize*(j*4+3);\n            for( i = 0; i < xsize2; i++ ) {\n                *(p++) = ( (int)*(p1+0) + (int)*(p1+1) + (int)*(p1+2) + (int)*(p1+3)\n                         + (int)*(p2+0) + (int)*(p2+1) + (int)*(p2+2) + (int)*(p2+3)\n                         + (int)*(p3+0) + (int)*(p3+1) + (int)*(p3+2) + (int)*(p3+3)\n                         + (int)*(p4+0) + (int)*(p4+1) + (int)*(p4+2) + (int)*(p4+3)) / 16;\n                p1+=4;\n                p2+=4;\n                p3+=4;\n                p4+=4;\n            }\n        }\n    }\n    else if( pixFormat == AR_PIXEL_FORMAT_2vuy ) {\n        p  = newImage;\n        for( j = 0; j < ysize2; j++ ) {\n            p1 = image + xsize*2*(j*4+0);\n            p2 = image + xsize*2*(j*4+1);\n            p3 = image + xsize*2*(j*4+2);\n            p4 = image + xsize*2*(j*4+3);\n            for( i = 0; i < xsize2; i++ ) {\n                *(p++) = ( (int)*(p1+1) + (int)*(p1+3) + (int)*(p1+5) + (int)*(p1+7)\n                         + (int)*(p2+1) + (int)*(p2+3) + (int)*(p2+5) + (int)*(p2+7)\n                         + (int)*(p3+1) + (int)*(p3+3) + (int)*(p3+5) + (int)*(p3+7)\n                         + (int)*(p4+1) + (int)*(p4+3) + (int)*(p4+5) + (int)*(p4+7)) / 16;\n                p1+=8;\n                p2+=8;\n                p3+=8;\n                p4+=8;\n            }\n        }\n    }\n    else if( pixFormat == AR_PIXEL_FORMAT_yuvs ) {\n        p  = newImage;\n        for( j = 0; j < ysize2; j++ ) {\n            p1 = image + xsize*2*(j*4+0);\n            p2 = image + xsize*2*(j*4+1);\n            p3 = image + xsize*2*(j*4+2);\n            p4 = image + xsize*2*(j*4+3);\n            for( i = 0; i < xsize2; i++ ) {\n                *(p++) = ( (int)*(p1+0) + (int)*(p1+2) + (int)*(p1+4) + (int)*(p1+6)\n                         + (int)*(p2+0) + (int)*(p2+2) + (int)*(p2+4) + (int)*(p2+6)\n                         + (int)*(p3+0) + (int)*(p3+2) + (int)*(p3+4) + (int)*(p3+6)\n                         + (int)*(p4+0) + (int)*(p4+2) + (int)*(p4+4) + (int)*(p4+6)) / 16;\n                p1+=8;\n                p2+=8;\n                p3+=8;\n                p4+=8;\n            }\n        }\n    }\n\n    return newImage;\n}\n\n\nstatic ARUint8 *genBWImageOneThird( ARUint8 *image, AR_PIXEL_FORMAT pixFormat, int xsize, int ysize, int *newXsize, int *newYsize )\n{\n    ARUint8  *newImage;\n    ARUint8  *p, *p1, *p2, *p3;\n    int       xsize2, ysize2;\n    int       i, j;\n    \n    *newXsize = xsize2 = xsize/3;\n    *newYsize = ysize2 = ysize/3;\n    arMalloc( newImage, ARUint8, xsize2*ysize2 );\n\n    if( pixFormat == AR_PIXEL_FORMAT_RGB || pixFormat == AR_PIXEL_FORMAT_BGR ) {\n        p  = newImage;\n        for( j = 0; j < ysize2; j++ ) {\n            p1 = image + xsize*3*(j*3+0);\n            p2 = image + xsize*3*(j*3+1);\n            p3 = image + xsize*3*(j*3+2);\n            for( i = 0; i < xsize2; i++ ) {\n                *(p++) = ( (int)*(p1+0) + (int)*(p1+1) + (int)*(p1+2)\n                         + (int)*(p1+3) + (int)*(p1+4) + (int)*(p1+5)\n                         + (int)*(p1+6) + (int)*(p1+7) + (int)*(p1+8)\n                         + (int)*(p2+0) + (int)*(p2+1) + (int)*(p2+2)\n                         + (int)*(p2+3) + (int)*(p2+4) + (int)*(p2+5)\n                         + (int)*(p2+6) + (int)*(p2+7) + (int)*(p2+8)\n                         + (int)*(p3+0) + (int)*(p3+1) + (int)*(p3+2)\n                         + (int)*(p3+3) + (int)*(p3+4) + (int)*(p3+5)\n                         + (int)*(p3+6) + (int)*(p3+7) + (int)*(p3+8) ) / 27;\n                p1+=9;\n                p2+=9;\n                p3+=9;\n            }\n        }\n    }\n    else if( pixFormat == AR_PIXEL_FORMAT_RGBA || pixFormat == AR_PIXEL_FORMAT_BGRA ) {\n        p  = newImage;\n        for( j = 0; j < ysize2; j++ ) {\n            p1 = image + xsize*4*(j*3+0);\n            p2 = image + xsize*4*(j*3+1);\n            p3 = image + xsize*4*(j*3+2);\n            for( i = 0; i < xsize2; i++ ) {\n                *(p++) = ( (int)*(p1+0) + (int)*(p1+1) + (int)*(p1+2)\n                         + (int)*(p1+4) + (int)*(p1+5) + (int)*(p1+6)\n                         + (int)*(p1+8) + (int)*(p1+9) + (int)*(p1+10)\n                         + (int)*(p2+0) + (int)*(p2+1) + (int)*(p2+2)\n                         + (int)*(p2+4) + (int)*(p2+5) + (int)*(p2+6)\n                         + (int)*(p2+8) + (int)*(p2+9) + (int)*(p2+10)\n                         + (int)*(p3+0) + (int)*(p3+1) + (int)*(p3+2)\n                         + (int)*(p3+4) + (int)*(p3+5) + (int)*(p3+6)\n                         + (int)*(p3+8) + (int)*(p3+9) + (int)*(p3+10) ) / 27;\n                p1+=12;\n                p2+=12;\n                p3+=12;\n            }\n        }\n    }\n    else if( pixFormat == AR_PIXEL_FORMAT_ABGR || pixFormat == AR_PIXEL_FORMAT_ARGB) {\n        p  = newImage;\n        for( j = 0; j < ysize2; j++ ) {\n            p1 = image + xsize*4*(j*3+0);\n            p2 = image + xsize*4*(j*3+1);\n            p3 = image + xsize*4*(j*3+2);\n            for( i = 0; i < xsize2; i++ ) {\n                *(p++) = ( (int)*(p1+1) + (int)*(p1+2) + (int)*(p1+3)\n                         + (int)*(p1+5) + (int)*(p1+6) + (int)*(p1+7)\n                         + (int)*(p1+9) + (int)*(p1+10) + (int)*(p1+11)\n                         + (int)*(p2+1) + (int)*(p2+2) + (int)*(p2+3)\n                         + (int)*(p2+5) + (int)*(p2+6) + (int)*(p2+7)\n                         + (int)*(p2+9) + (int)*(p2+10) + (int)*(p2+11)\n                         + (int)*(p3+1) + (int)*(p3+2) + (int)*(p3+3)\n                         + (int)*(p3+5) + (int)*(p3+6) + (int)*(p3+7)\n                         + (int)*(p3+9) + (int)*(p3+10) + (int)*(p3+11) ) / 27;\n                p1+=12;\n                p2+=12;\n                p3+=12;\n            }\n        }\n    }\n    else if( pixFormat == AR_PIXEL_FORMAT_MONO || pixFormat == AR_PIXEL_FORMAT_420f || pixFormat == AR_PIXEL_FORMAT_420v || pixFormat == AR_PIXEL_FORMAT_NV21 ) {\n        p  = newImage;\n        for( j = 0; j < ysize2; j++ ) {\n            p1 = image + xsize*(j*3+0);\n            p2 = image + xsize*(j*3+1);\n            p3 = image + xsize*(j*3+2);\n            for( i = 0; i < xsize2; i++ ) {\n                *(p++) = ( (int)*(p1+0) + (int)*(p1+1) + (int)*(p1+2)\n                         + (int)*(p2+0) + (int)*(p2+1) + (int)*(p2+2)\n                         + (int)*(p3+0) + (int)*(p3+1) + (int)*(p3+2) ) / 9;\n                p1+=3;\n                p2+=3;\n                p3+=3;\n            }\n        }\n    }\n    else if( pixFormat == AR_PIXEL_FORMAT_2vuy ) {\n        p  = newImage;\n        for( j = 0; j < ysize2; j++ ) {\n            p1 = image + xsize*2*(j*3+0);\n            p2 = image + xsize*2*(j*3+1);\n            p3 = image + xsize*2*(j*3+2);\n            for( i = 0; i < xsize2; i++ ) {\n                *(p++) = ( (int)*(p1+1) + (int)*(p1+3) + (int)*(p1+5)\n                         + (int)*(p2+1) + (int)*(p2+3) + (int)*(p2+5)\n                         + (int)*(p3+1) + (int)*(p3+3) + (int)*(p3+5) ) / 9;\n                p1+=6;\n                p2+=6;\n                p3+=6;\n            }\n        }\n    }\n    else if( pixFormat == AR_PIXEL_FORMAT_yuvs ) {\n        p  = newImage;\n        for( j = 0; j < ysize2; j++ ) {\n            p1 = image + xsize*2*(j*3+0);\n            p2 = image + xsize*2*(j*3+1);\n            p3 = image + xsize*2*(j*3+2);\n            for( i = 0; i < xsize2; i++ ) {\n                *(p++) = ( (int)*(p1+0) + (int)*(p1+2) + (int)*(p1+4)\n                         + (int)*(p2+0) + (int)*(p2+2) + (int)*(p2+4)\n                         + (int)*(p3+0) + (int)*(p3+2) + (int)*(p3+4) ) / 9;\n                p1+=6;\n                p2+=6;\n                p3+=6;\n            }\n        }\n    }\n\n    return newImage;\n}\n\nstatic ARUint8 *genBWImageTwoThird  ( ARUint8 *image, AR_PIXEL_FORMAT pixFormat, int xsize, int ysize, int *newXsize, int *newYsize )\n{\n    ARUint8  *newImage;\n    ARUint8  *q1, *q2, *p1, *p2, *p3;\n    int       xsize2, ysize2;\n    int       i, j;\n    \n    *newXsize = xsize2 = xsize/3*2;\n    *newYsize = ysize2 = ysize/3*2;\n    arMalloc( newImage, ARUint8, xsize2*ysize2 );\n\n    if( pixFormat == AR_PIXEL_FORMAT_RGB || pixFormat == AR_PIXEL_FORMAT_BGR ) {\n        q1  = newImage;\n        q2  = newImage + xsize2;\n        for( j = 0; j < ysize2/2; j++ ) {\n            p1 = image + xsize*3*(j*3+0);\n            p2 = image + xsize*3*(j*3+1);\n            p3 = image + xsize*3*(j*3+2);\n            for( i = 0; i < xsize2/2; i++ ) {\n                *(q1++) = ( ((int)*(p1+0) + (int)*(p1+1) + (int)*(p1+2))\n                          + ((int)*(p1+3) + (int)*(p1+4) + (int)*(p1+5))/2\n                          + ((int)*(p2+0) + (int)*(p2+1) + (int)*(p2+2))/2\n                          + ((int)*(p2+3) + (int)*(p2+4) + (int)*(p2+5))/4 ) * 4/27;\n                *(q2++) = ( ((int)*(p2+0) + (int)*(p2+1) + (int)*(p2+2))/2\n                          + ((int)*(p2+3) + (int)*(p2+4) + (int)*(p2+5))/4\n                          + ((int)*(p3+0) + (int)*(p3+1) + (int)*(p3+2))\n                          + ((int)*(p3+3) + (int)*(p3+4) + (int)*(p3+5))/2 ) * 4/27;\n                p1+=3;\n                p2+=3;\n                p3+=3;\n                *(q1++) = ( ((int)*(p1+0) + (int)*(p1+1) + (int)*(p1+2))/2\n                          + ((int)*(p1+3) + (int)*(p1+4) + (int)*(p1+5))\n                          + ((int)*(p2+0) + (int)*(p2+1) + (int)*(p2+2))/4\n                          + ((int)*(p2+3) + (int)*(p2+4) + (int)*(p2+5))/2 ) * 4/27;\n                *(q2++) = ( ((int)*(p2+0) + (int)*(p2+1) + (int)*(p2+2))/4\n                          + ((int)*(p2+3) + (int)*(p2+4) + (int)*(p2+5))/2\n                          + ((int)*(p3+0) + (int)*(p3+1) + (int)*(p3+2))/2\n                          + ((int)*(p3+3) + (int)*(p3+4) + (int)*(p3+5))   ) * 4/27;\n\n                p1+=6;\n                p2+=6;\n                p3+=6;\n            }\n            q1 += xsize2;\n            q2 += xsize2;\n        }\n    }\n    else if( pixFormat == AR_PIXEL_FORMAT_RGBA || pixFormat == AR_PIXEL_FORMAT_BGRA ) {\n        q1  = newImage;\n        q2  = newImage + xsize2;\n        for( j = 0; j < ysize2/2; j++ ) {\n            p1 = image + xsize*4*(j*3+0);\n            p2 = image + xsize*4*(j*3+1);\n            p3 = image + xsize*4*(j*3+2);\n            for( i = 0; i < xsize2/2; i++ ) {\n                *(q1++) = ( ((int)*(p1+0) + (int)*(p1+1) + (int)*(p1+2))\n                          + ((int)*(p1+4) + (int)*(p1+5) + (int)*(p1+6))/2\n                          + ((int)*(p2+0) + (int)*(p2+1) + (int)*(p2+2))/2\n                          + ((int)*(p2+4) + (int)*(p2+5) + (int)*(p2+6))/4 ) * 4/27;\n                *(q2++) = ( ((int)*(p2+0) + (int)*(p2+1) + (int)*(p2+2))/2\n                          + ((int)*(p2+4) + (int)*(p2+5) + (int)*(p2+6))/4\n                          + ((int)*(p3+0) + (int)*(p3+1) + (int)*(p3+2))\n                          + ((int)*(p3+4) + (int)*(p3+5) + (int)*(p3+6))/2 ) * 4/27;\n                p1+=4;\n                p2+=4;\n                p3+=4;\n                *(q1++) = ( ((int)*(p1+0) + (int)*(p1+1) + (int)*(p1+2))/2\n                          + ((int)*(p1+4) + (int)*(p1+4) + (int)*(p1+4))\n                          + ((int)*(p2+0) + (int)*(p2+1) + (int)*(p2+2))/4\n                          + ((int)*(p2+4) + (int)*(p2+5) + (int)*(p2+6))/2 ) * 4/27;\n                *(q2++) = ( ((int)*(p2+0) + (int)*(p2+1) + (int)*(p2+2))/4\n                          + ((int)*(p2+4) + (int)*(p2+5) + (int)*(p2+6))/2\n                          + ((int)*(p3+0) + (int)*(p3+1) + (int)*(p3+2))/2\n                          + ((int)*(p3+4) + (int)*(p3+5) + (int)*(p3+6))   ) * 4/27;\n\n                p1+=8;\n                p2+=8;\n                p3+=8;\n            }\n            q1 += xsize2;\n            q2 += xsize2;\n        }\n    }\n    else if( pixFormat == AR_PIXEL_FORMAT_ABGR || pixFormat == AR_PIXEL_FORMAT_ARGB) {\n        q1  = newImage;\n        q2  = newImage + xsize2;\n        for( j = 0; j < ysize2/2; j++ ) {\n            p1 = image + xsize*4*(j*3+0);\n            p2 = image + xsize*4*(j*3+1);\n            p3 = image + xsize*4*(j*3+2);\n            for( i = 0; i < xsize2/2; i++ ) {\n                *(q1++) = ( ((int)*(p1+1) + (int)*(p1+2) + (int)*(p1+3))\n                          + ((int)*(p1+5) + (int)*(p1+6) + (int)*(p1+7))/2\n                          + ((int)*(p2+1) + (int)*(p2+2) + (int)*(p2+3))/2\n                          + ((int)*(p2+5) + (int)*(p2+6) + (int)*(p2+7))/4 ) * 4/27;\n                *(q2++) = ( ((int)*(p2+1) + (int)*(p2+2) + (int)*(p2+3))/2\n                          + ((int)*(p2+5) + (int)*(p2+6) + (int)*(p2+7))/4\n                          + ((int)*(p3+1) + (int)*(p3+2) + (int)*(p3+3))\n                          + ((int)*(p3+5) + (int)*(p3+6) + (int)*(p3+7))/2 ) * 4/27;\n                p1+=4;\n                p2+=4;\n                p3+=4;\n                *(q1++) = ( ((int)*(p1+1) + (int)*(p1+2) + (int)*(p1+3))/2\n                          + ((int)*(p1+5) + (int)*(p1+6) + (int)*(p1+7))\n                          + ((int)*(p2+1) + (int)*(p2+2) + (int)*(p2+3))/4\n                          + ((int)*(p2+5) + (int)*(p2+6) + (int)*(p2+7))/2 ) * 4/27;\n                *(q2++) = ( ((int)*(p2+1) + (int)*(p2+2) + (int)*(p2+3))/4\n                          + ((int)*(p2+5) + (int)*(p2+6) + (int)*(p2+7))/2\n                          + ((int)*(p3+1) + (int)*(p3+2) + (int)*(p3+3))/2\n                          + ((int)*(p3+5) + (int)*(p3+6) + (int)*(p3+7))   ) * 4/27;\n\n                p1+=8;\n                p2+=8;\n                p3+=8;\n            }\n            q1 += xsize2;\n            q2 += xsize2;\n        }\n    }\n    else if( pixFormat == AR_PIXEL_FORMAT_MONO || pixFormat == AR_PIXEL_FORMAT_420f || pixFormat == AR_PIXEL_FORMAT_420v || pixFormat == AR_PIXEL_FORMAT_NV21 ) {\n        q1  = newImage;\n        q2  = newImage + xsize2;\n        for( j = 0; j < ysize2/2; j++ ) {\n            p1 = image + xsize*(j*3+0);\n            p2 = image + xsize*(j*3+1);\n            p3 = image + xsize*(j*3+2);\n            for( i = 0; i < xsize2/2; i++ ) {\n                *(q1++) = ( (int)*(p1+0)   + (int)*(p1+1)/2\n                          + (int)*(p2+0)/2 + (int)*(p2+1)/4 ) *4/9;\n                *(q2++) = ( (int)*(p2+0)/2 + (int)*(p2+1)/4\n                          + (int)*(p3+0)   + (int)*(p3+1)/2 ) *4/9;\n                p1++;\n                p2++;\n                p3++;\n                *(q1++) = ( (int)*(p1+0)/2 + (int)*(p1+1)\n                          + (int)*(p2+0)/4 + (int)*(p2+1)/2 ) *4/9;\n                *(q2++) = ( (int)*(p2+0)/4 + (int)*(p2+1)/2\n                          + (int)*(p3+0)/2 + (int)*(p3+1)   ) *4/9;\n                p1+=2;\n                p2+=2;\n                p3+=2;\n            }\n            q1 += xsize2;\n            q2 += xsize2;\n        }\n    }\n    else if( pixFormat == AR_PIXEL_FORMAT_2vuy ) {\n        q1  = newImage;\n        q2  = newImage + xsize2;\n        for( j = 0; j < ysize2/2; j++ ) {\n            p1 = image + xsize*2*(j*3+0);\n            p2 = image + xsize*2*(j*3+1);\n            p3 = image + xsize*2*(j*3+2);\n            for( i = 0; i < xsize2/2; i++ ) {\n                *(q1++) = ( (int)*(p1+1)   + (int)*(p1+3)/2\n                          + (int)*(p2+1)/2 + (int)*(p2+3)/4 ) *4/9;\n                *(q2++) = ( (int)*(p2+1)/2 + (int)*(p2+3)/4\n                          + (int)*(p3+1)   + (int)*(p3+3)/2 ) *4/9;\n                p1+=2;\n                p2+=2;\n                p3+=2;\n                *(q1++) = ( (int)*(p1+1)/2 + (int)*(p1+3)\n                          + (int)*(p2+1)/4 + (int)*(p2+3)/2 ) *4/9;\n                *(q2++) = ( (int)*(p2+1)/4 + (int)*(p2+3)/2\n                          + (int)*(p3+1)/2 + (int)*(p3+3)   ) *4/9;\n                p1+=4;\n                p2+=4;\n                p3+=4;\n            }\n            q1 += xsize2;\n            q2 += xsize2;\n        }\n    }\n    else if( pixFormat == AR_PIXEL_FORMAT_yuvs ) {\n        q1  = newImage;\n        q2  = newImage + xsize2;\n        for( j = 0; j < ysize2/2; j++ ) {\n            p1 = image + xsize*2*(j*3+0);\n            p2 = image + xsize*2*(j*3+1);\n            p3 = image + xsize*2*(j*3+2);\n            for( i = 0; i < xsize2/2; i++ ) {\n                *(q1++) = ( (int)*(p1+0)   + (int)*(p1+2)/2\n                          + (int)*(p2+0)/2 + (int)*(p2+2)/4 ) *4/9;\n                *(q2++) = ( (int)*(p2+0)/2 + (int)*(p2+2)/4\n                          + (int)*(p3+0)   + (int)*(p3+2)/2 ) *4/9;\n                p1+=2;\n                p2+=2;\n                p3+=2;\n                *(q1++) = ( (int)*(p1+0)/2 + (int)*(p1+2)\n                          + (int)*(p2+0)/4 + (int)*(p2+2)/2 ) *4/9;\n                *(q2++) = ( (int)*(p2+0)/4 + (int)*(p2+2)/2\n                          + (int)*(p3+0)/2 + (int)*(p3+2)   ) *4/9;\n                p1+=4;\n                p2+=4;\n                p3+=4;\n            }\n            q1 += xsize2;\n            q2 += xsize2;\n        }\n    }\n\n    return newImage;\n}\n\n#if !BINARY_FEATURE\nstatic int kpmUtilGetInitPoseHomography( float *sCoord, float *wCoord, int num, float initPose[3][4] )\n{\n    float  *A, *B;\n    ARMatf  matA, matB;\n    ARMatf *matAt, *matAtA, *matAtB, *matH;\n    int     i;\n    int     ret = 0;\n\n    arMalloc( A, float, num*8*2 );\n    arMalloc( B, float, num*2 );\n\n    for( i = 0; i < num; i++ ) {\n        A[i*16+ 0] = wCoord[i*2+0];\n        A[i*16+ 1] = wCoord[i*2+1];\n        A[i*16+ 2] = 1.0;\n        A[i*16+ 3] = 0.0;\n        A[i*16+ 4] = 0.0;\n        A[i*16+ 5] = 0.0;\n        A[i*16+ 6] = -sCoord[i*2+0]*wCoord[i*2+0];\n        A[i*16+ 7] = -sCoord[i*2+0]*wCoord[i*2+1];\n        A[i*16+ 8] = 0.0;\n        A[i*16+ 9] = 0.0;\n        A[i*16+10] = 0.0;\n        A[i*16+11] = wCoord[i*2+0];\n        A[i*16+12] = wCoord[i*2+1];\n        A[i*16+13] = 1.0;\n        A[i*16+14] = -sCoord[i*2+1]*wCoord[i*2+0];\n        A[i*16+15] = -sCoord[i*2+1]*wCoord[i*2+1];\n        B[i*2+0]   = sCoord[i*2+0];\n        B[i*2+1]   = sCoord[i*2+1];\n    }\n    \n    matA.row = num*2;\n    matA.clm = 8;\n    matA.m   = A;\n\n    matB.row = num*2;\n    matB.clm = 1;\n    matB.m   = B;\n\n    matAt = arMatrixAllocTransf( &matA );\n    if( matAt == NULL ) {\n        ret = -1;\n        goto bail;\n    }\n    matAtA = arMatrixAllocMulf( matAt, &matA );\n    if( matAtA == NULL ) {\n        ret = -1;\n        goto bail1;\n    }\n    matAtB = arMatrixAllocMulf( matAt, &matB );\n    if( matAtB == NULL ) {\n        ret = -1;\n        goto bail2;\n    }\n    if( arMatrixSelfInvf(matAtA) < 0 ) {\n        ret = -1;\n        goto bail3;\n    }\n\n    matH = arMatrixAllocMulf( matAtA, matAtB );\n    if( matH == NULL ) {\n        ret = -1;\n        goto bail3;\n    }\n\n    initPose[0][0] = matH->m[0];\n    initPose[0][1] = matH->m[1];\n    initPose[0][2] = 0.0;\n    initPose[0][3] = matH->m[2];\n    initPose[1][0] = matH->m[3];\n    initPose[1][1] = matH->m[4];\n    initPose[1][2] = 0.0;\n    initPose[1][3] = matH->m[5];\n    initPose[2][0] = matH->m[6];\n    initPose[2][1] = matH->m[7];\n    initPose[2][2] = 0.0;\n    initPose[2][3] = 1.0;\n\n    arMatrixFreef( matH );\nbail3:\n    arMatrixFreef( matAtB );\nbail2:\n    arMatrixFreef( matAtA );\nbail1:\n    arMatrixFreef( matAt );\nbail:\n    free(B);\n    free(A);\n\n    return (ret);\n}\n#endif\n","/*\n *  kpmFopen.c\n *  ARToolKit5\n *\n *  This file is part of ARToolKit.\n *\n *  ARToolKit is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation, either version 3 of the License, or\n *  (at your option) any later version.\n *\n *  ARToolKit is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public License\n *  along with ARToolKit.  If not, see <http://www.gnu.org/licenses/>.\n *\n *  As a special exception, the copyright holders of this library give you\n *  permission to link this library with independent modules to produce an\n *  executable, regardless of the license terms of these independent modules, and to\n *  copy and distribute the resulting executable under terms of your choice,\n *  provided that you also meet, for each linked independent module, the terms and\n *  conditions of the license of that module. An independent module is a module\n *  which is neither derived from nor based on this library. If you modify this\n *  library, you may extend this exception to your version of the library, but you\n *  are not obligated to do so. If you do not wish to do so, delete this exception\n *  statement from your version.\n *\n *  Copyright 2015 Daqri, LLC. All rights reserved.\n *  Copyright 2006-2015 ARToolworks, Inc. All rights reserved.\n *  Author(s): Hirokazu Kato, Philip Lamb\n *\n */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <KPM/kpm.h>\n#include \"kpmFopen.h\"\n#ifdef _WIN32\n#  define MAXPATHLEN MAX_PATH\n#else\n#  include <sys/param.h> // MAXPATHLEN\n#endif\n\nFILE *kpmFopen( const char *filename, const char *ext, const char *mode )\n{\n    FILE   *fp;\n    char   *buf;\n    size_t  len;\n    \n    if (!filename) return (NULL);\n    if (ext) {\n        len = strlen(filename) + strlen(ext) + 2; // space for '.' and '\\0'.\n        arMalloc(buf, char, len)\n        sprintf(buf, \"%s.%s\", filename, ext);\n        fp = fopen(buf, mode);\n        free(buf);\n    } else {\n        fp = fopen(filename, mode);\n    }\n\n    return fp;\n}\n","// -*- C++ -*-\n//===-------------------------- __string ----------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is distributed under the University of Illinois Open Source\n// License. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP___STRING\n#define _LIBCPP___STRING\n\n/*\n    string synopsis\n\nnamespace std\n{\n\ntemplate <class charT>\nstruct char_traits\n{\n    typedef charT     char_type;\n    typedef ...       int_type;\n    typedef streamoff off_type;\n    typedef streampos pos_type;\n    typedef mbstate_t state_type;\n\n    static constexpr void assign(char_type& c1, const char_type& c2) noexcept;\n    static constexpr bool eq(char_type c1, char_type c2) noexcept;\n    static constexpr bool lt(char_type c1, char_type c2) noexcept;\n\n    static constexpr int    compare(const char_type* s1, const char_type* s2, size_t n);\n    static constexpr size_t length(const char_type* s);\n    static constexpr const char_type* \n                            find(const char_type* s, size_t n, const char_type& a);\n    static char_type*       move(char_type* s1, const char_type* s2, size_t n);\n    static char_type*       copy(char_type* s1, const char_type* s2, size_t n);\n    static char_type*       assign(char_type* s, size_t n, char_type a);\n\n    static constexpr int_type  not_eof(int_type c) noexcept;\n    static constexpr char_type to_char_type(int_type c) noexcept;\n    static constexpr int_type  to_int_type(char_type c) noexcept;\n    static constexpr bool      eq_int_type(int_type c1, int_type c2) noexcept;\n    static constexpr int_type  eof() noexcept;\n};\n\ntemplate <> struct char_traits<char>;\ntemplate <> struct char_traits<wchar_t>;\n\n}  // std\n\n*/\n\n#include <__config>\n#include <algorithm>  // for search and min\n#include <cstdio>     // For EOF.\n#include <memory>     // for __murmur2_or_cityhash\n\n#include <__undef_min_max>\n\n#include <__debug>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\n// char_traits\n\ntemplate <class _CharT>\nstruct _LIBCPP_TEMPLATE_VIS char_traits\n{\n    typedef _CharT    char_type;\n    typedef int       int_type;\n    typedef streamoff off_type;\n    typedef streampos pos_type;\n    typedef mbstate_t state_type;\n\n    static inline void _LIBCPP_CONSTEXPR_AFTER_CXX14\n        assign(char_type& __c1, const char_type& __c2) _NOEXCEPT {__c1 = __c2;}\n    static inline _LIBCPP_CONSTEXPR bool eq(char_type __c1, char_type __c2) _NOEXCEPT\n        {return __c1 == __c2;}\n    static inline _LIBCPP_CONSTEXPR bool lt(char_type __c1, char_type __c2) _NOEXCEPT\n        {return __c1 < __c2;}\n\n    static _LIBCPP_CONSTEXPR_AFTER_CXX14\n    int compare(const char_type* __s1, const char_type* __s2, size_t __n);\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR_AFTER_CXX14\n    size_t length(const char_type* __s);\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR_AFTER_CXX14\n    const char_type* find(const char_type* __s, size_t __n, const char_type& __a);\n    static char_type*       move(char_type* __s1, const char_type* __s2, size_t __n);\n    _LIBCPP_INLINE_VISIBILITY\n    static char_type*       copy(char_type* __s1, const char_type* __s2, size_t __n);\n    _LIBCPP_INLINE_VISIBILITY\n    static char_type*       assign(char_type* __s, size_t __n, char_type __a);\n\n    static inline _LIBCPP_CONSTEXPR int_type  not_eof(int_type __c) _NOEXCEPT\n        {return eq_int_type(__c, eof()) ? ~eof() : __c;}\n    static inline _LIBCPP_CONSTEXPR char_type to_char_type(int_type __c) _NOEXCEPT\n        {return char_type(__c);}\n    static inline _LIBCPP_CONSTEXPR int_type  to_int_type(char_type __c) _NOEXCEPT\n        {return int_type(__c);}\n    static inline _LIBCPP_CONSTEXPR bool      eq_int_type(int_type __c1, int_type __c2) _NOEXCEPT\n        {return __c1 == __c2;}\n    static inline _LIBCPP_CONSTEXPR int_type  eof() _NOEXCEPT\n        {return int_type(EOF);}\n};\n\ntemplate <class _CharT>\n_LIBCPP_CONSTEXPR_AFTER_CXX14 int\nchar_traits<_CharT>::compare(const char_type* __s1, const char_type* __s2, size_t __n)\n{\n    for (; __n; --__n, ++__s1, ++__s2)\n    {\n        if (lt(*__s1, *__s2))\n            return -1;\n        if (lt(*__s2, *__s1))\n            return 1;\n    }\n    return 0;\n}\n\ntemplate <class _CharT>\ninline\n_LIBCPP_CONSTEXPR_AFTER_CXX14 size_t\nchar_traits<_CharT>::length(const char_type* __s)\n{\n    size_t __len = 0;\n    for (; !eq(*__s, char_type(0)); ++__s)\n        ++__len;\n    return __len;\n}\n\ntemplate <class _CharT>\ninline\n_LIBCPP_CONSTEXPR_AFTER_CXX14 const _CharT*\nchar_traits<_CharT>::find(const char_type* __s, size_t __n, const char_type& __a)\n{\n    for (; __n; --__n)\n    {\n        if (eq(*__s, __a))\n            return __s;\n        ++__s;\n    }\n    return 0;\n}\n\ntemplate <class _CharT>\n_CharT*\nchar_traits<_CharT>::move(char_type* __s1, const char_type* __s2, size_t __n)\n{\n    char_type* __r = __s1;\n    if (__s1 < __s2)\n    {\n        for (; __n; --__n, ++__s1, ++__s2)\n            assign(*__s1, *__s2);\n    }\n    else if (__s2 < __s1)\n    {\n        __s1 += __n;\n        __s2 += __n;\n        for (; __n; --__n)\n            assign(*--__s1, *--__s2);\n    }\n    return __r;\n}\n\ntemplate <class _CharT>\ninline\n_CharT*\nchar_traits<_CharT>::copy(char_type* __s1, const char_type* __s2, size_t __n)\n{\n    _LIBCPP_ASSERT(__s2 < __s1 || __s2 >= __s1+__n, \"char_traits::copy overlapped range\");\n    char_type* __r = __s1;\n    for (; __n; --__n, ++__s1, ++__s2)\n        assign(*__s1, *__s2);\n    return __r;\n}\n\ntemplate <class _CharT>\ninline\n_CharT*\nchar_traits<_CharT>::assign(char_type* __s, size_t __n, char_type __a)\n{\n    char_type* __r = __s;\n    for (; __n; --__n, ++__s)\n        assign(*__s, __a);\n    return __r;\n}\n\n// char_traits<char>\n\ntemplate <>\nstruct _LIBCPP_TEMPLATE_VIS char_traits<char>\n{\n    typedef char      char_type;\n    typedef int       int_type;\n    typedef streamoff off_type;\n    typedef streampos pos_type;\n    typedef mbstate_t state_type;\n\n    static inline _LIBCPP_CONSTEXPR_AFTER_CXX14\n    void assign(char_type& __c1, const char_type& __c2) _NOEXCEPT {__c1 = __c2;}\n    static inline _LIBCPP_CONSTEXPR bool eq(char_type __c1, char_type __c2) _NOEXCEPT\n            {return __c1 == __c2;}\n    static inline _LIBCPP_CONSTEXPR bool lt(char_type __c1, char_type __c2) _NOEXCEPT\n        {return (unsigned char)__c1 < (unsigned char)__c2;}\n\n    static _LIBCPP_CONSTEXPR_AFTER_CXX14\n    int compare(const char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT;\n    static inline size_t _LIBCPP_CONSTEXPR_AFTER_CXX14\n    length(const char_type* __s)  _NOEXCEPT {return __builtin_strlen(__s);}\n    static _LIBCPP_CONSTEXPR_AFTER_CXX14\n    const char_type* find(const char_type* __s, size_t __n, const char_type& __a) _NOEXCEPT;\n    static inline char_type* move(char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT\n        {return __n == 0 ? __s1 : (char_type*) memmove(__s1, __s2, __n);}\n    static inline char_type* copy(char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT\n        {\n            _LIBCPP_ASSERT(__s2 < __s1 || __s2 >= __s1+__n, \"char_traits::copy overlapped range\");\n            return __n == 0 ? __s1 : (char_type*)memcpy(__s1, __s2, __n);\n        }\n    static inline char_type* assign(char_type* __s, size_t __n, char_type __a) _NOEXCEPT\n        {return __n == 0 ? __s : (char_type*)memset(__s, to_int_type(__a), __n);}\n\n    static inline _LIBCPP_CONSTEXPR int_type  not_eof(int_type __c) _NOEXCEPT\n        {return eq_int_type(__c, eof()) ? ~eof() : __c;}\n    static inline _LIBCPP_CONSTEXPR char_type to_char_type(int_type __c) _NOEXCEPT\n        {return char_type(__c);}\n    static inline _LIBCPP_CONSTEXPR int_type to_int_type(char_type __c) _NOEXCEPT\n        {return int_type((unsigned char)__c);}\n    static inline _LIBCPP_CONSTEXPR bool eq_int_type(int_type __c1, int_type __c2) _NOEXCEPT\n        {return __c1 == __c2;}\n    static inline _LIBCPP_CONSTEXPR int_type  eof() _NOEXCEPT\n        {return int_type(EOF);}\n};\n\ninline _LIBCPP_CONSTEXPR_AFTER_CXX14\nint\nchar_traits<char>::compare(const char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT\n{\n    if (__n == 0)\n        return 0;\n#if __has_feature(cxx_constexpr_string_builtins)\n    return __builtin_memcmp(__s1, __s2, __n);\n#elif _LIBCPP_STD_VER <= 14\n    return memcmp(__s1, __s2, __n);\n#else\n    for (; __n; --__n, ++__s1, ++__s2)\n    {\n        if (lt(*__s1, *__s2))\n            return -1;\n        if (lt(*__s2, *__s1))\n            return 1;\n    }\n    return 0;\n#endif\n}\n\ninline _LIBCPP_CONSTEXPR_AFTER_CXX14\nconst char*\nchar_traits<char>::find(const char_type* __s, size_t __n, const char_type& __a) _NOEXCEPT\n{\n    if (__n == 0)\n        return NULL;\n#if __has_feature(cxx_constexpr_string_builtins)\n    return __builtin_char_memchr(__s, to_int_type(__a), __n);\n#elif _LIBCPP_STD_VER <= 14\n    return (const char_type*) memchr(__s, to_int_type(__a), __n);\n#else\n    for (; __n; --__n)\n    {\n        if (eq(*__s, __a))\n            return __s;\n        ++__s;\n    }\n    return NULL;\n#endif\n}\n\n\n// char_traits<wchar_t>\n\ntemplate <>\nstruct _LIBCPP_TEMPLATE_VIS char_traits<wchar_t>\n{\n    typedef wchar_t   char_type;\n    typedef wint_t    int_type;\n    typedef streamoff off_type;\n    typedef streampos pos_type;\n    typedef mbstate_t state_type;\n\n    static inline _LIBCPP_CONSTEXPR_AFTER_CXX14\n    void assign(char_type& __c1, const char_type& __c2) _NOEXCEPT {__c1 = __c2;}\n    static inline _LIBCPP_CONSTEXPR bool eq(char_type __c1, char_type __c2) _NOEXCEPT\n        {return __c1 == __c2;}\n    static inline _LIBCPP_CONSTEXPR bool lt(char_type __c1, char_type __c2) _NOEXCEPT\n        {return __c1 < __c2;}\n\n    static _LIBCPP_CONSTEXPR_AFTER_CXX14\n    int compare(const char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT;\n    static _LIBCPP_CONSTEXPR_AFTER_CXX14\n    size_t length(const char_type* __s) _NOEXCEPT;\n    static _LIBCPP_CONSTEXPR_AFTER_CXX14\n    const char_type* find(const char_type* __s, size_t __n, const char_type& __a) _NOEXCEPT;\n    static inline char_type* move(char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT\n        {return __n == 0 ? __s1 : (char_type*)wmemmove(__s1, __s2, __n);}\n    static inline char_type* copy(char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT\n        {\n            _LIBCPP_ASSERT(__s2 < __s1 || __s2 >= __s1+__n, \"char_traits::copy overlapped range\");\n            return __n == 0 ? __s1 : (char_type*)wmemcpy(__s1, __s2, __n);\n        }\n    static inline char_type* assign(char_type* __s, size_t __n, char_type __a) _NOEXCEPT\n        {return __n == 0 ? __s : (char_type*)wmemset(__s, __a, __n);}\n\n    static inline _LIBCPP_CONSTEXPR int_type  not_eof(int_type __c) _NOEXCEPT\n        {return eq_int_type(__c, eof()) ? ~eof() : __c;}\n    static inline _LIBCPP_CONSTEXPR char_type to_char_type(int_type __c) _NOEXCEPT\n        {return char_type(__c);}\n    static inline _LIBCPP_CONSTEXPR int_type to_int_type(char_type __c) _NOEXCEPT\n        {return int_type(__c);}\n    static inline _LIBCPP_CONSTEXPR bool eq_int_type(int_type __c1, int_type __c2) _NOEXCEPT\n        {return __c1 == __c2;}\n    static inline _LIBCPP_CONSTEXPR int_type eof() _NOEXCEPT\n        {return int_type(WEOF);}\n};\n\ninline _LIBCPP_CONSTEXPR_AFTER_CXX14\nint\nchar_traits<wchar_t>::compare(const char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT\n{\n    if (__n == 0)\n        return 0;\n#if __has_feature(cxx_constexpr_string_builtins)\n    return __builtin_wmemcmp(__s1, __s2, __n);\n#elif _LIBCPP_STD_VER <= 14\n    return wmemcmp(__s1, __s2, __n);\n#else\n    for (; __n; --__n, ++__s1, ++__s2)\n    {\n        if (lt(*__s1, *__s2))\n            return -1;\n        if (lt(*__s2, *__s1))\n            return 1;\n    }\n    return 0;\n#endif\n}\n\ninline _LIBCPP_CONSTEXPR_AFTER_CXX14\nsize_t\nchar_traits<wchar_t>::length(const char_type* __s) _NOEXCEPT\n{\n#if __has_feature(cxx_constexpr_string_builtins)\n    return __builtin_wcslen(__s);\n#elif _LIBCPP_STD_VER <= 14\n    return wcslen(__s);\n#else\n    size_t __len = 0;\n    for (; !eq(*__s, char_type(0)); ++__s)\n        ++__len;\n    return __len;\n#endif\n}\n\ninline _LIBCPP_CONSTEXPR_AFTER_CXX14\nconst wchar_t*\nchar_traits<wchar_t>::find(const char_type* __s, size_t __n, const char_type& __a) _NOEXCEPT\n{\n    if (__n == 0)\n        return NULL;\n#if __has_feature(cxx_constexpr_string_builtins)\n        return __builtin_wmemchr(__s, __a, __n);\n#elif _LIBCPP_STD_VER <= 14\n    return wmemchr(__s, __a, __n);\n#else\n    for (; __n; --__n)\n    {\n        if (eq(*__s, __a))\n            return __s;\n        ++__s;\n    }\n    return NULL;\n#endif\n}\n\n\n#ifndef _LIBCPP_HAS_NO_UNICODE_CHARS\n\ntemplate <>\nstruct _LIBCPP_TEMPLATE_VIS char_traits<char16_t>\n{\n    typedef char16_t       char_type;\n    typedef uint_least16_t int_type;\n    typedef streamoff      off_type;\n    typedef u16streampos   pos_type;\n    typedef mbstate_t      state_type;\n\n    static inline _LIBCPP_CONSTEXPR_AFTER_CXX14\n    void assign(char_type& __c1, const char_type& __c2) _NOEXCEPT {__c1 = __c2;}\n    static inline _LIBCPP_CONSTEXPR bool eq(char_type __c1, char_type __c2) _NOEXCEPT\n        {return __c1 == __c2;}\n    static inline _LIBCPP_CONSTEXPR bool lt(char_type __c1, char_type __c2) _NOEXCEPT\n        {return __c1 < __c2;}\n\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR_AFTER_CXX14\n    int              compare(const char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR_AFTER_CXX14\n    size_t           length(const char_type* __s) _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR_AFTER_CXX14\n    const char_type* find(const char_type* __s, size_t __n, const char_type& __a) _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    static char_type*       move(char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    static char_type*       copy(char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    static char_type*       assign(char_type* __s, size_t __n, char_type __a) _NOEXCEPT;\n\n    static inline _LIBCPP_CONSTEXPR int_type  not_eof(int_type __c) _NOEXCEPT\n        {return eq_int_type(__c, eof()) ? ~eof() : __c;}\n    static inline _LIBCPP_CONSTEXPR char_type to_char_type(int_type __c) _NOEXCEPT\n        {return char_type(__c);}\n    static inline _LIBCPP_CONSTEXPR int_type to_int_type(char_type __c) _NOEXCEPT\n        {return int_type(__c);}\n    static inline _LIBCPP_CONSTEXPR bool eq_int_type(int_type __c1, int_type __c2) _NOEXCEPT\n        {return __c1 == __c2;}\n    static inline _LIBCPP_CONSTEXPR int_type eof() _NOEXCEPT\n        {return int_type(0xFFFF);}\n};\n\ninline _LIBCPP_CONSTEXPR_AFTER_CXX14\nint\nchar_traits<char16_t>::compare(const char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT\n{\n    for (; __n; --__n, ++__s1, ++__s2)\n    {\n        if (lt(*__s1, *__s2))\n            return -1;\n        if (lt(*__s2, *__s1))\n            return 1;\n    }\n    return 0;\n}\n\ninline _LIBCPP_CONSTEXPR_AFTER_CXX14\nsize_t\nchar_traits<char16_t>::length(const char_type* __s) _NOEXCEPT\n{\n    size_t __len = 0;\n    for (; !eq(*__s, char_type(0)); ++__s)\n        ++__len;\n    return __len;\n}\n\ninline _LIBCPP_CONSTEXPR_AFTER_CXX14\nconst char16_t*\nchar_traits<char16_t>::find(const char_type* __s, size_t __n, const char_type& __a) _NOEXCEPT\n{\n    for (; __n; --__n)\n    {\n        if (eq(*__s, __a))\n            return __s;\n        ++__s;\n    }\n    return 0;\n}\n\ninline\nchar16_t*\nchar_traits<char16_t>::move(char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT\n{\n    char_type* __r = __s1;\n    if (__s1 < __s2)\n    {\n        for (; __n; --__n, ++__s1, ++__s2)\n            assign(*__s1, *__s2);\n    }\n    else if (__s2 < __s1)\n    {\n        __s1 += __n;\n        __s2 += __n;\n        for (; __n; --__n)\n            assign(*--__s1, *--__s2);\n    }\n    return __r;\n}\n\ninline\nchar16_t*\nchar_traits<char16_t>::copy(char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__s2 < __s1 || __s2 >= __s1+__n, \"char_traits::copy overlapped range\");\n    char_type* __r = __s1;\n    for (; __n; --__n, ++__s1, ++__s2)\n        assign(*__s1, *__s2);\n    return __r;\n}\n\ninline\nchar16_t*\nchar_traits<char16_t>::assign(char_type* __s, size_t __n, char_type __a) _NOEXCEPT\n{\n    char_type* __r = __s;\n    for (; __n; --__n, ++__s)\n        assign(*__s, __a);\n    return __r;\n}\n\ntemplate <>\nstruct _LIBCPP_TEMPLATE_VIS char_traits<char32_t>\n{\n    typedef char32_t       char_type;\n    typedef uint_least32_t int_type;\n    typedef streamoff      off_type;\n    typedef u32streampos   pos_type;\n    typedef mbstate_t      state_type;\n\n    static inline _LIBCPP_CONSTEXPR_AFTER_CXX14\n    void assign(char_type& __c1, const char_type& __c2) _NOEXCEPT {__c1 = __c2;}\n    static inline _LIBCPP_CONSTEXPR bool eq(char_type __c1, char_type __c2) _NOEXCEPT\n        {return __c1 == __c2;}\n    static inline _LIBCPP_CONSTEXPR bool lt(char_type __c1, char_type __c2) _NOEXCEPT\n        {return __c1 < __c2;}\n\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR_AFTER_CXX14\n    int              compare(const char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR_AFTER_CXX14\n    size_t           length(const char_type* __s) _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR_AFTER_CXX14\n    const char_type* find(const char_type* __s, size_t __n, const char_type& __a) _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    static char_type*       move(char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    static char_type*       copy(char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    static char_type*       assign(char_type* __s, size_t __n, char_type __a) _NOEXCEPT;\n\n    static inline _LIBCPP_CONSTEXPR int_type  not_eof(int_type __c) _NOEXCEPT\n        {return eq_int_type(__c, eof()) ? ~eof() : __c;}\n    static inline _LIBCPP_CONSTEXPR char_type to_char_type(int_type __c) _NOEXCEPT\n        {return char_type(__c);}\n    static inline _LIBCPP_CONSTEXPR int_type to_int_type(char_type __c) _NOEXCEPT\n        {return int_type(__c);}\n    static inline _LIBCPP_CONSTEXPR bool eq_int_type(int_type __c1, int_type __c2) _NOEXCEPT\n        {return __c1 == __c2;}\n    static inline _LIBCPP_CONSTEXPR int_type eof() _NOEXCEPT\n        {return int_type(0xFFFFFFFF);}\n};\n\ninline _LIBCPP_CONSTEXPR_AFTER_CXX14\nint\nchar_traits<char32_t>::compare(const char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT\n{\n    for (; __n; --__n, ++__s1, ++__s2)\n    {\n        if (lt(*__s1, *__s2))\n            return -1;\n        if (lt(*__s2, *__s1))\n            return 1;\n    }\n    return 0;\n}\n\ninline _LIBCPP_CONSTEXPR_AFTER_CXX14\nsize_t\nchar_traits<char32_t>::length(const char_type* __s) _NOEXCEPT\n{\n    size_t __len = 0;\n    for (; !eq(*__s, char_type(0)); ++__s)\n        ++__len;\n    return __len;\n}\n\ninline _LIBCPP_CONSTEXPR_AFTER_CXX14\nconst char32_t*\nchar_traits<char32_t>::find(const char_type* __s, size_t __n, const char_type& __a) _NOEXCEPT\n{\n    for (; __n; --__n)\n    {\n        if (eq(*__s, __a))\n            return __s;\n        ++__s;\n    }\n    return 0;\n}\n\ninline\nchar32_t*\nchar_traits<char32_t>::move(char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT\n{\n    char_type* __r = __s1;\n    if (__s1 < __s2)\n    {\n        for (; __n; --__n, ++__s1, ++__s2)\n            assign(*__s1, *__s2);\n    }\n    else if (__s2 < __s1)\n    {\n        __s1 += __n;\n        __s2 += __n;\n        for (; __n; --__n)\n            assign(*--__s1, *--__s2);\n    }\n    return __r;\n}\n\ninline\nchar32_t*\nchar_traits<char32_t>::copy(char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__s2 < __s1 || __s2 >= __s1+__n, \"char_traits::copy overlapped range\");\n    char_type* __r = __s1;\n    for (; __n; --__n, ++__s1, ++__s2)\n        assign(*__s1, *__s2);\n    return __r;\n}\n\ninline\nchar32_t*\nchar_traits<char32_t>::assign(char_type* __s, size_t __n, char_type __a) _NOEXCEPT\n{\n    char_type* __r = __s;\n    for (; __n; --__n, ++__s)\n        assign(*__s, __a);\n    return __r;\n}\n\n#endif  // _LIBCPP_HAS_NO_UNICODE_CHARS\n\n// helper fns for basic_string and string_view\n\n// __str_find\ntemplate<class _CharT, class _SizeT, class _Traits, _SizeT __npos>\ninline _SizeT _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n__str_find(const _CharT *__p, _SizeT __sz, \n             _CharT __c, _SizeT __pos) _NOEXCEPT\n{\n    if (__pos >= __sz)\n        return __npos;\n    const _CharT* __r = _Traits::find(__p + __pos, __sz - __pos, __c);\n    if (__r == 0)\n        return __npos;\n    return static_cast<_SizeT>(__r - __p);\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_CONSTEXPR_AFTER_CXX11 const _CharT *\n__search_substring(const _CharT *__first1, const _CharT *__last1,\n                   const _CharT *__first2, const _CharT *__last2) {\n  // Take advantage of knowing source and pattern lengths.\n  // Stop short when source is smaller than pattern.\n  const ptrdiff_t __len2 = __last2 - __first2;\n  if (__len2 == 0)\n    return __first1;\n\n  ptrdiff_t __len1 = __last1 - __first1;\n  if (__len1 < __len2)\n    return __last1;\n\n  // First element of __first2 is loop invariant.\n  _CharT __f2 = *__first2;\n  while (true) {\n    __len1 = __last1 - __first1;\n    // Check whether __first1 still has at least __len2 bytes.\n    if (__len1 < __len2)\n      return __last1;\n\n    // Find __f2 the first byte matching in __first1.\n    __first1 = _Traits::find(__first1, __len1 - __len2 + 1, __f2);\n    if (__first1 == 0)\n      return __last1;\n\n    // It is faster to compare from the first byte of __first1 even if we\n    // already know that it matches the first byte of __first2: this is because\n    // __first2 is most likely aligned, as it is user's \"pattern\" string, and\n    // __first1 + 1 is most likely not aligned, as the match is in the middle of\n    // the string.\n    if (_Traits::compare(__first1, __first2, __len2) == 0)\n      return __first1;\n\n    ++__first1;\n  }\n}\n\ntemplate<class _CharT, class _SizeT, class _Traits, _SizeT __npos>\ninline _SizeT _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n__str_find(const _CharT *__p, _SizeT __sz, \n       const _CharT* __s, _SizeT __pos, _SizeT __n) _NOEXCEPT\n{\n    if (__pos > __sz)\n        return __npos;\n\n    if (__n == 0) // There is nothing to search, just return __pos.\n        return __pos;\n\n    const _CharT *__r = __search_substring<_CharT, _Traits>(\n        __p + __pos, __p + __sz, __s, __s + __n);\n\n    if (__r == __p + __sz)\n        return __npos;\n    return static_cast<_SizeT>(__r - __p);\n}\n\n\n// __str_rfind\n\ntemplate<class _CharT, class _SizeT, class _Traits, _SizeT __npos>\ninline _SizeT _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n__str_rfind(const _CharT *__p, _SizeT __sz, \n              _CharT __c, _SizeT __pos) _NOEXCEPT\n{\n    if (__sz < 1)\n        return __npos;\n    if (__pos < __sz)\n        ++__pos;\n    else\n        __pos = __sz;\n    for (const _CharT* __ps = __p + __pos; __ps != __p;)\n    {\n        if (_Traits::eq(*--__ps, __c))\n            return static_cast<_SizeT>(__ps - __p);\n    }\n    return __npos;\n}\n\ntemplate<class _CharT, class _SizeT, class _Traits, _SizeT __npos>\ninline _SizeT _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n__str_rfind(const _CharT *__p, _SizeT __sz, \n        const _CharT* __s, _SizeT __pos, _SizeT __n) _NOEXCEPT\n{\n    __pos = _VSTD::min(__pos, __sz);\n    if (__n < __sz - __pos)\n        __pos += __n;\n    else\n        __pos = __sz;\n    const _CharT* __r = _VSTD::__find_end(\n                  __p, __p + __pos, __s, __s + __n, _Traits::eq, \n                        random_access_iterator_tag(), random_access_iterator_tag());\n    if (__n > 0 && __r == __p + __pos)\n        return __npos;\n    return static_cast<_SizeT>(__r - __p);\n}\n\n// __str_find_first_of\ntemplate<class _CharT, class _SizeT, class _Traits, _SizeT __npos>\ninline _SizeT _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n__str_find_first_of(const _CharT *__p, _SizeT __sz,\n                const _CharT* __s, _SizeT __pos, _SizeT __n) _NOEXCEPT\n{\n    if (__pos >= __sz || __n == 0)\n        return __npos;\n    const _CharT* __r = _VSTD::__find_first_of_ce\n        (__p + __pos, __p + __sz, __s, __s + __n, _Traits::eq );\n    if (__r == __p + __sz)\n        return __npos;\n    return static_cast<_SizeT>(__r - __p);\n}\n\n\n// __str_find_last_of\ntemplate<class _CharT, class _SizeT, class _Traits, _SizeT __npos>\ninline _SizeT _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n__str_find_last_of(const _CharT *__p, _SizeT __sz,\n               const _CharT* __s, _SizeT __pos, _SizeT __n) _NOEXCEPT\n    {\n    if (__n != 0)\n    {\n        if (__pos < __sz)\n            ++__pos;\n        else\n            __pos = __sz;\n        for (const _CharT* __ps = __p + __pos; __ps != __p;)\n        {\n            const _CharT* __r = _Traits::find(__s, __n, *--__ps);\n            if (__r)\n                return static_cast<_SizeT>(__ps - __p);\n        }\n    }\n    return __npos;\n}\n\n\n// __str_find_first_not_of\ntemplate<class _CharT, class _SizeT, class _Traits, _SizeT __npos>\ninline _SizeT _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n__str_find_first_not_of(const _CharT *__p, _SizeT __sz,\n                    const _CharT* __s, _SizeT __pos, _SizeT __n) _NOEXCEPT\n{\n    if (__pos < __sz)\n    {\n        const _CharT* __pe = __p + __sz;\n        for (const _CharT* __ps = __p + __pos; __ps != __pe; ++__ps)\n            if (_Traits::find(__s, __n, *__ps) == 0)\n                return static_cast<_SizeT>(__ps - __p);\n    }\n    return __npos;\n}\n\n\ntemplate<class _CharT, class _SizeT, class _Traits, _SizeT __npos>\ninline _SizeT _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n__str_find_first_not_of(const _CharT *__p, _SizeT __sz,\n                          _CharT __c, _SizeT __pos) _NOEXCEPT\n{\n    if (__pos < __sz)\n    {\n        const _CharT* __pe = __p + __sz;\n        for (const _CharT* __ps = __p + __pos; __ps != __pe; ++__ps)\n            if (!_Traits::eq(*__ps, __c))\n                return static_cast<_SizeT>(__ps - __p);\n    }\n    return __npos;\n}\n\n\n// __str_find_last_not_of\ntemplate<class _CharT, class _SizeT, class _Traits, _SizeT __npos>\ninline _SizeT _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n__str_find_last_not_of(const _CharT *__p, _SizeT __sz,\n                   const _CharT* __s, _SizeT __pos, _SizeT __n) _NOEXCEPT\n{\n    if (__pos < __sz)\n        ++__pos;\n    else\n        __pos = __sz;\n    for (const _CharT* __ps = __p + __pos; __ps != __p;)\n        if (_Traits::find(__s, __n, *--__ps) == 0)\n            return static_cast<_SizeT>(__ps - __p);\n    return __npos;\n}\n\n\ntemplate<class _CharT, class _SizeT, class _Traits, _SizeT __npos>\ninline _SizeT _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n__str_find_last_not_of(const _CharT *__p, _SizeT __sz,\n                         _CharT __c, _SizeT __pos) _NOEXCEPT\n{\n    if (__pos < __sz)\n        ++__pos;\n    else\n        __pos = __sz;\n    for (const _CharT* __ps = __p + __pos; __ps != __p;)\n        if (!_Traits::eq(*--__ps, __c))\n            return static_cast<_SizeT>(__ps - __p);\n    return __npos;\n}\n\ntemplate<class _Ptr>\ninline _LIBCPP_INLINE_VISIBILITY\nsize_t __do_string_hash(_Ptr __p, _Ptr __e)\n{\n    typedef typename iterator_traits<_Ptr>::value_type value_type;\n    return __murmur2_or_cityhash<size_t>()(__p, (__e-__p)*sizeof(value_type));\n}\n\ntemplate <class _CharT, class _Iter, class _Traits=char_traits<_CharT> >\nstruct __quoted_output_proxy\n{\n    _Iter  __first;\n    _Iter  __last;\n    _CharT  __delim;\n    _CharT  __escape;\n\n    __quoted_output_proxy(_Iter __f, _Iter __l, _CharT __d, _CharT __e)\n    : __first(__f), __last(__l), __delim(__d), __escape(__e) {}\n    //  This would be a nice place for a string_ref \n};\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP___STRING\n","//\n//  exceptions.h\n//  ARToolKit5\n//\n//  This file is part of ARToolKit.\n//\n//  ARToolKit is free software: you can redistribute it and/or modify\n//  it under the terms of the GNU Lesser General Public License as published by\n//  the Free Software Foundation, either version 3 of the License, or\n//  (at your option) any later version.\n//\n//  ARToolKit is distributed in the hope that it will be useful,\n//  but WITHOUT ANY WARRANTY; without even the implied warranty of\n//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n//  GNU Lesser General Public License for more details.\n//\n//  You should have received a copy of the GNU Lesser General Public License\n//  along with ARToolKit.  If not, see <http://www.gnu.org/licenses/>.\n//\n//  As a special exception, the copyright holders of this library give you\n//  permission to link this library with independent modules to produce an\n//  executable, regardless of the license terms of these independent modules, and to\n//  copy and distribute the resulting executable under terms of your choice,\n//  provided that you also meet, for each linked independent module, the terms and\n//  conditions of the license of that module. An independent module is a module\n//  which is neither derived from nor based on this library. If you modify this\n//  library, you may extend this exception to your version of the library, but you\n//  are not obligated to do so. If you do not wish to do so, delete this exception\n//  statement from your version.\n//\n//  Copyright 2013-2015 Daqri, LLC.\n//\n//  Author(s): Chris Broaddus\n//\n\n#pragma once\n\n#include <exception>\n#include <string>\n\nnamespace vision\n{\n    \n    class Exception : public std::exception {\n    public:\n        \n        Exception(const std::string& str) : mStr(str) {}\n        virtual ~Exception() throw() {}\n        \n        virtual const char* what() const throw() {\n            return mStr.c_str();\n        }\n        \n    private:\n        \n        // String containing the message\n        std::string mStr;\n        \n    }; // Exception\n    \n#define EXCEPTION(X) (Exception(X));\n    \n} // vision","// -*- C++ -*-\n//===--------------------------- string -----------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is distributed under the University of Illinois Open Source\n// License. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_STRING\n#define _LIBCPP_STRING\n\n/*\n    string synopsis\n\nnamespace std\n{\n\ntemplate <class stateT>\nclass fpos\n{\nprivate:\n    stateT st;\npublic:\n    fpos(streamoff = streamoff());\n\n    operator streamoff() const;\n\n    stateT state() const;\n    void state(stateT);\n\n    fpos& operator+=(streamoff);\n    fpos  operator+ (streamoff) const;\n    fpos& operator-=(streamoff);\n    fpos  operator- (streamoff) const;\n};\n\ntemplate <class stateT> streamoff operator-(const fpos<stateT>& x, const fpos<stateT>& y);\n\ntemplate <class stateT> bool operator==(const fpos<stateT>& x, const fpos<stateT>& y);\ntemplate <class stateT> bool operator!=(const fpos<stateT>& x, const fpos<stateT>& y);\n\ntemplate <class charT>\nstruct char_traits\n{\n    typedef charT     char_type;\n    typedef ...       int_type;\n    typedef streamoff off_type;\n    typedef streampos pos_type;\n    typedef mbstate_t state_type;\n\n    static void assign(char_type& c1, const char_type& c2) noexcept;\n    static constexpr bool eq(char_type c1, char_type c2) noexcept;\n    static constexpr bool lt(char_type c1, char_type c2) noexcept;\n\n    static int              compare(const char_type* s1, const char_type* s2, size_t n);\n    static size_t           length(const char_type* s);\n    static const char_type* find(const char_type* s, size_t n, const char_type& a);\n    static char_type*       move(char_type* s1, const char_type* s2, size_t n);\n    static char_type*       copy(char_type* s1, const char_type* s2, size_t n);\n    static char_type*       assign(char_type* s, size_t n, char_type a);\n\n    static constexpr int_type  not_eof(int_type c) noexcept;\n    static constexpr char_type to_char_type(int_type c) noexcept;\n    static constexpr int_type  to_int_type(char_type c) noexcept;\n    static constexpr bool      eq_int_type(int_type c1, int_type c2) noexcept;\n    static constexpr int_type  eof() noexcept;\n};\n\ntemplate <> struct char_traits<char>;\ntemplate <> struct char_traits<wchar_t>;\n\ntemplate<class charT, class traits = char_traits<charT>, class Allocator = allocator<charT> >\nclass basic_string\n{\npublic:\n// types:\n    typedef traits traits_type;\n    typedef typename traits_type::char_type value_type;\n    typedef Allocator allocator_type;\n    typedef typename allocator_type::size_type size_type;\n    typedef typename allocator_type::difference_type difference_type;\n    typedef typename allocator_type::reference reference;\n    typedef typename allocator_type::const_reference const_reference;\n    typedef typename allocator_type::pointer pointer;\n    typedef typename allocator_type::const_pointer const_pointer;\n    typedef implementation-defined iterator;\n    typedef implementation-defined const_iterator;\n    typedef std::reverse_iterator<iterator> reverse_iterator;\n    typedef std::reverse_iterator<const_iterator> const_reverse_iterator;\n\n    static const size_type npos = -1;\n\n    basic_string()\n        noexcept(is_nothrow_default_constructible<allocator_type>::value);\n    explicit basic_string(const allocator_type& a);\n    basic_string(const basic_string& str);\n    basic_string(basic_string&& str)\n        noexcept(is_nothrow_move_constructible<allocator_type>::value);\n    basic_string(const basic_string& str, size_type pos,\n                 const allocator_type& a = allocator_type());\n    basic_string(const basic_string& str, size_type pos, size_type n,\n                 const Allocator& a = Allocator());\n    template<class T>\n        basic_string(const T& t, size_type pos, size_type n, const Allocator& a = Allocator()); // C++17\n    explicit basic_string(const basic_string_view<charT, traits> sv, const Allocator& a = Allocator());\n    basic_string(const value_type* s, const allocator_type& a = allocator_type());\n    basic_string(const value_type* s, size_type n, const allocator_type& a = allocator_type());\n    basic_string(size_type n, value_type c, const allocator_type& a = allocator_type());\n    template<class InputIterator>\n        basic_string(InputIterator begin, InputIterator end,\n                     const allocator_type& a = allocator_type());\n    basic_string(initializer_list<value_type>, const Allocator& = Allocator());\n    basic_string(const basic_string&, const Allocator&);\n    basic_string(basic_string&&, const Allocator&);\n\n    ~basic_string();\n\n    operator basic_string_view<charT, traits>() const noexcept;\n\n    basic_string& operator=(const basic_string& str);\n    basic_string& operator=(basic_string_view<charT, traits> sv);\n    basic_string& operator=(basic_string&& str)\n        noexcept(\n             allocator_type::propagate_on_container_move_assignment::value ||\n             allocator_type::is_always_equal::value ); // C++17\n    basic_string& operator=(const value_type* s);\n    basic_string& operator=(value_type c);\n    basic_string& operator=(initializer_list<value_type>);\n\n    iterator       begin() noexcept;\n    const_iterator begin() const noexcept;\n    iterator       end() noexcept;\n    const_iterator end() const noexcept;\n\n    reverse_iterator       rbegin() noexcept;\n    const_reverse_iterator rbegin() const noexcept;\n    reverse_iterator       rend() noexcept;\n    const_reverse_iterator rend() const noexcept;\n\n    const_iterator         cbegin() const noexcept;\n    const_iterator         cend() const noexcept;\n    const_reverse_iterator crbegin() const noexcept;\n    const_reverse_iterator crend() const noexcept;\n\n    size_type size() const noexcept;\n    size_type length() const noexcept;\n    size_type max_size() const noexcept;\n    size_type capacity() const noexcept;\n\n    void resize(size_type n, value_type c);\n    void resize(size_type n);\n\n    void reserve(size_type res_arg = 0);\n    void shrink_to_fit();\n    void clear() noexcept;\n    bool empty() const noexcept;\n\n    const_reference operator[](size_type pos) const;\n    reference       operator[](size_type pos);\n\n    const_reference at(size_type n) const;\n    reference       at(size_type n);\n\n    basic_string& operator+=(const basic_string& str);\n    basic_string& operator+=(basic_string_view<charT, traits> sv);\n    basic_string& operator+=(const value_type* s);\n    basic_string& operator+=(value_type c);\n    basic_string& operator+=(initializer_list<value_type>);\n\n    basic_string& append(const basic_string& str);\n    basic_string& append(basic_string_view<charT, traits> sv);\n    basic_string& append(const basic_string& str, size_type pos, size_type n=npos); //C++14\n    template <class T>\n        basic_string& append(const T& t, size_type pos, size_type n=npos); // C++17\n    basic_string& append(const value_type* s, size_type n);\n    basic_string& append(const value_type* s);\n    basic_string& append(size_type n, value_type c);\n    template<class InputIterator>\n        basic_string& append(InputIterator first, InputIterator last);\n    basic_string& append(initializer_list<value_type>);\n\n    void push_back(value_type c);\n    void pop_back();\n    reference       front();\n    const_reference front() const;\n    reference       back();\n    const_reference back() const;\n\n    basic_string& assign(const basic_string& str);\n    basic_string& assign(basic_string_view<charT, traits> sv);\n    basic_string& assign(basic_string&& str);\n    basic_string& assign(const basic_string& str, size_type pos, size_type n=npos); // C++14\n    template <class T>\n        basic_string& assign(const T& t, size_type pos, size_type n=npos); // C++17\n    basic_string& assign(const value_type* s, size_type n);\n    basic_string& assign(const value_type* s);\n    basic_string& assign(size_type n, value_type c);\n    template<class InputIterator>\n        basic_string& assign(InputIterator first, InputIterator last);\n    basic_string& assign(initializer_list<value_type>);\n\n    basic_string& insert(size_type pos1, const basic_string& str);\n    basic_string& insert(size_type pos1, basic_string_view<charT, traits> sv);\n    basic_string& insert(size_type pos1, const basic_string& str,\n                         size_type pos2, size_type n);\n    template <class T>\n        basic_string& insert(size_type pos1, const T& t, size_type pos2, size_type n); // C++17\n    basic_string& insert(size_type pos, const value_type* s, size_type n=npos); //C++14\n    basic_string& insert(size_type pos, const value_type* s);\n    basic_string& insert(size_type pos, size_type n, value_type c);\n    iterator      insert(const_iterator p, value_type c);\n    iterator      insert(const_iterator p, size_type n, value_type c);\n    template<class InputIterator>\n        iterator insert(const_iterator p, InputIterator first, InputIterator last);\n    iterator      insert(const_iterator p, initializer_list<value_type>);\n\n    basic_string& erase(size_type pos = 0, size_type n = npos);\n    iterator      erase(const_iterator position);\n    iterator      erase(const_iterator first, const_iterator last);\n\n    basic_string& replace(size_type pos1, size_type n1, const basic_string& str);\n    basic_string& replace(size_type pos1, size_type n1, basic_string_view<charT, traits> sv);\n    basic_string& replace(size_type pos1, size_type n1, const basic_string& str,\n                          size_type pos2, size_type n2=npos); // C++14\n    template <class T>\n        basic_string& replace(size_type pos1, size_type n1, const T& t,\n                              size_type pos2, size_type n); // C++17\n    basic_string& replace(size_type pos, size_type n1, const value_type* s, size_type n2);\n    basic_string& replace(size_type pos, size_type n1, const value_type* s);\n    basic_string& replace(size_type pos, size_type n1, size_type n2, value_type c);\n    basic_string& replace(const_iterator i1, const_iterator i2, const basic_string& str);\n    basic_string& replace(const_iterator i1, const_iterator i2, basic_string_view<charT, traits> sv);\n    basic_string& replace(const_iterator i1, const_iterator i2, const value_type* s, size_type n);\n    basic_string& replace(const_iterator i1, const_iterator i2, const value_type* s);\n    basic_string& replace(const_iterator i1, const_iterator i2, size_type n, value_type c);\n    template<class InputIterator>\n        basic_string& replace(const_iterator i1, const_iterator i2, InputIterator j1, InputIterator j2);\n    basic_string& replace(const_iterator i1, const_iterator i2, initializer_list<value_type>);\n\n    size_type copy(value_type* s, size_type n, size_type pos = 0) const;\n    basic_string substr(size_type pos = 0, size_type n = npos) const;\n\n    void swap(basic_string& str)\n        noexcept(allocator_traits<allocator_type>::propagate_on_container_swap::value ||\n                 allocator_traits<allocator_type>::is_always_equal::value);  // C++17\n\n    const value_type* c_str() const noexcept;\n    const value_type* data() const noexcept;\n          value_type* data()       noexcept;   // C++17\n\n    allocator_type get_allocator() const noexcept;\n\n    size_type find(const basic_string& str, size_type pos = 0) const noexcept;\n    size_type find(basic_string_view<charT, traits> sv, size_type pos = 0) const noexcept;\n    size_type find(const value_type* s, size_type pos, size_type n) const noexcept;\n    size_type find(const value_type* s, size_type pos = 0) const noexcept;\n    size_type find(value_type c, size_type pos = 0) const noexcept;\n\n    size_type rfind(const basic_string& str, size_type pos = npos) const noexcept;\n    size_type ffind(basic_string_view<charT, traits> sv, size_type pos = 0) const noexcept;\n    size_type rfind(const value_type* s, size_type pos, size_type n) const noexcept;\n    size_type rfind(const value_type* s, size_type pos = npos) const noexcept;\n    size_type rfind(value_type c, size_type pos = npos) const noexcept;\n\n    size_type find_first_of(const basic_string& str, size_type pos = 0) const noexcept;\n    size_type find_first_of(basic_string_view<charT, traits> sv, size_type pos = 0) const noexcept;\n    size_type find_first_of(const value_type* s, size_type pos, size_type n) const noexcept;\n    size_type find_first_of(const value_type* s, size_type pos = 0) const noexcept;\n    size_type find_first_of(value_type c, size_type pos = 0) const noexcept;\n\n    size_type find_last_of(const basic_string& str, size_type pos = npos) const noexcept;\n    size_type find_last_of(basic_string_view<charT, traits> sv, size_type pos = 0) const noexcept;\n    size_type find_last_of(const value_type* s, size_type pos, size_type n) const noexcept;\n    size_type find_last_of(const value_type* s, size_type pos = npos) const noexcept;\n    size_type find_last_of(value_type c, size_type pos = npos) const noexcept;\n\n    size_type find_first_not_of(const basic_string& str, size_type pos = 0) const noexcept;\n    size_type find_first_not_of(basic_string_view<charT, traits> sv, size_type pos = 0) const noexcept;\n    size_type find_first_not_of(const value_type* s, size_type pos, size_type n) const noexcept;\n    size_type find_first_not_of(const value_type* s, size_type pos = 0) const noexcept;\n    size_type find_first_not_of(value_type c, size_type pos = 0) const noexcept;\n\n    size_type find_last_not_of(const basic_string& str, size_type pos = npos) const noexcept;\n    size_type find_last_not_of(basic_string_view<charT, traits> sv, size_type pos = 0) const noexcept;\n    size_type find_last_not_of(const value_type* s, size_type pos, size_type n) const noexcept;\n    size_type find_last_not_of(const value_type* s, size_type pos = npos) const noexcept;\n    size_type find_last_not_of(value_type c, size_type pos = npos) const noexcept;\n\n    int compare(const basic_string& str) const noexcept;\n    int compare(basic_string_view<charT, traits> sv) const noexcept;\n    int compare(size_type pos1, size_type n1, const basic_string& str) const;\n    int compare(size_type pos1, size_type n1, basic_string_view<charT, traits> sv) const;\n    int compare(size_type pos1, size_type n1, const basic_string& str,\n                size_type pos2, size_type n2=npos) const; // C++14\n    template <class T>\n        int compare(size_type pos1, size_type n1, const T& t,\n                    size_type pos2, size_type n2=npos) const; // C++17\n    int compare(const value_type* s) const noexcept;\n    int compare(size_type pos1, size_type n1, const value_type* s) const;\n    int compare(size_type pos1, size_type n1, const value_type* s, size_type n2) const;\n\n    bool __invariants() const;\n};\n\ntemplate<class charT, class traits, class Allocator>\nbasic_string<charT, traits, Allocator>\noperator+(const basic_string<charT, traits, Allocator>& lhs,\n          const basic_string<charT, traits, Allocator>& rhs);\n\ntemplate<class charT, class traits, class Allocator>\nbasic_string<charT, traits, Allocator>\noperator+(const charT* lhs , const basic_string<charT,traits,Allocator>&rhs);\n\ntemplate<class charT, class traits, class Allocator>\nbasic_string<charT, traits, Allocator>\noperator+(charT lhs, const basic_string<charT,traits,Allocator>& rhs);\n\ntemplate<class charT, class traits, class Allocator>\nbasic_string<charT, traits, Allocator>\noperator+(const basic_string<charT, traits, Allocator>& lhs, const charT* rhs);\n\ntemplate<class charT, class traits, class Allocator>\nbasic_string<charT, traits, Allocator>\noperator+(const basic_string<charT, traits, Allocator>& lhs, charT rhs);\n\ntemplate<class charT, class traits, class Allocator>\nbool operator==(const basic_string<charT, traits, Allocator>& lhs,\n                const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator==(const charT* lhs, const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator==(const basic_string<charT,traits,Allocator>& lhs, const charT* rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator!=(const basic_string<charT,traits,Allocator>& lhs,\n                const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator!=(const charT* lhs, const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator!=(const basic_string<charT, traits, Allocator>& lhs, const charT* rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator< (const basic_string<charT, traits, Allocator>& lhs,\n                const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator< (const basic_string<charT, traits, Allocator>& lhs, const charT* rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator< (const charT* lhs, const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator> (const basic_string<charT, traits, Allocator>& lhs,\n                const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator> (const basic_string<charT, traits, Allocator>& lhs, const charT* rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator> (const charT* lhs, const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator<=(const basic_string<charT, traits, Allocator>& lhs,\n                const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator<=(const basic_string<charT, traits, Allocator>& lhs, const charT* rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator<=(const charT* lhs, const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator>=(const basic_string<charT, traits, Allocator>& lhs,\n                const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator>=(const basic_string<charT, traits, Allocator>& lhs, const charT* rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator>=(const charT* lhs, const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nvoid swap(basic_string<charT, traits, Allocator>& lhs,\n          basic_string<charT, traits, Allocator>& rhs)\n            noexcept(noexcept(lhs.swap(rhs)));\n\ntemplate<class charT, class traits, class Allocator>\nbasic_istream<charT, traits>&\noperator>>(basic_istream<charT, traits>& is, basic_string<charT, traits, Allocator>& str);\n\ntemplate<class charT, class traits, class Allocator>\nbasic_ostream<charT, traits>&\noperator<<(basic_ostream<charT, traits>& os, const basic_string<charT, traits, Allocator>& str);\n\ntemplate<class charT, class traits, class Allocator>\nbasic_istream<charT, traits>&\ngetline(basic_istream<charT, traits>& is, basic_string<charT, traits, Allocator>& str,\n        charT delim);\n\ntemplate<class charT, class traits, class Allocator>\nbasic_istream<charT, traits>&\ngetline(basic_istream<charT, traits>& is, basic_string<charT, traits, Allocator>& str);\n\ntypedef basic_string<char>    string;\ntypedef basic_string<wchar_t> wstring;\ntypedef basic_string<char16_t> u16string;\ntypedef basic_string<char32_t> u32string;\n\nint                stoi  (const string& str, size_t* idx = 0, int base = 10);\nlong               stol  (const string& str, size_t* idx = 0, int base = 10);\nunsigned long      stoul (const string& str, size_t* idx = 0, int base = 10);\nlong long          stoll (const string& str, size_t* idx = 0, int base = 10);\nunsigned long long stoull(const string& str, size_t* idx = 0, int base = 10);\n\nfloat       stof (const string& str, size_t* idx = 0);\ndouble      stod (const string& str, size_t* idx = 0);\nlong double stold(const string& str, size_t* idx = 0);\n\nstring to_string(int val);\nstring to_string(unsigned val);\nstring to_string(long val);\nstring to_string(unsigned long val);\nstring to_string(long long val);\nstring to_string(unsigned long long val);\nstring to_string(float val);\nstring to_string(double val);\nstring to_string(long double val);\n\nint                stoi  (const wstring& str, size_t* idx = 0, int base = 10);\nlong               stol  (const wstring& str, size_t* idx = 0, int base = 10);\nunsigned long      stoul (const wstring& str, size_t* idx = 0, int base = 10);\nlong long          stoll (const wstring& str, size_t* idx = 0, int base = 10);\nunsigned long long stoull(const wstring& str, size_t* idx = 0, int base = 10);\n\nfloat       stof (const wstring& str, size_t* idx = 0);\ndouble      stod (const wstring& str, size_t* idx = 0);\nlong double stold(const wstring& str, size_t* idx = 0);\n\nwstring to_wstring(int val);\nwstring to_wstring(unsigned val);\nwstring to_wstring(long val);\nwstring to_wstring(unsigned long val);\nwstring to_wstring(long long val);\nwstring to_wstring(unsigned long long val);\nwstring to_wstring(float val);\nwstring to_wstring(double val);\nwstring to_wstring(long double val);\n\ntemplate <> struct hash<string>;\ntemplate <> struct hash<u16string>;\ntemplate <> struct hash<u32string>;\ntemplate <> struct hash<wstring>;\n\nbasic_string<char>     operator \"\" s( const char *str,     size_t len ); // C++14\nbasic_string<wchar_t>  operator \"\" s( const wchar_t *str,  size_t len ); // C++14\nbasic_string<char16_t> operator \"\" s( const char16_t *str, size_t len ); // C++14\nbasic_string<char32_t> operator \"\" s( const char32_t *str, size_t len ); // C++14\n\n}  // std\n\n*/\n\n#include <__config>\n#include <string_view>\n#include <iosfwd>\n#include <cstring>\n#include <cstdio>  // For EOF.\n#include <cwchar>\n#include <algorithm>\n#include <iterator>\n#include <utility>\n#include <memory>\n#include <stdexcept>\n#include <type_traits>\n#include <initializer_list>\n#include <__functional_base>\n#ifndef _LIBCPP_HAS_NO_UNICODE_CHARS\n#include <cstdint>\n#endif\n\n#include <__undef_min_max>\n\n#include <__debug>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\n// fpos\n\ntemplate <class _StateT>\nclass _LIBCPP_TEMPLATE_VIS fpos\n{\nprivate:\n    _StateT __st_;\n    streamoff __off_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY fpos(streamoff __off = streamoff()) : __st_(), __off_(__off) {}\n\n    _LIBCPP_INLINE_VISIBILITY operator streamoff() const {return __off_;}\n\n    _LIBCPP_INLINE_VISIBILITY _StateT state() const {return __st_;}\n    _LIBCPP_INLINE_VISIBILITY void state(_StateT __st) {__st_ = __st;}\n\n    _LIBCPP_INLINE_VISIBILITY fpos& operator+=(streamoff __off) {__off_ += __off; return *this;}\n    _LIBCPP_INLINE_VISIBILITY fpos  operator+ (streamoff __off) const {fpos __t(*this); __t += __off; return __t;}\n    _LIBCPP_INLINE_VISIBILITY fpos& operator-=(streamoff __off) {__off_ -= __off; return *this;}\n    _LIBCPP_INLINE_VISIBILITY fpos  operator- (streamoff __off) const {fpos __t(*this); __t -= __off; return __t;}\n};\n\ntemplate <class _StateT>\ninline _LIBCPP_INLINE_VISIBILITY\nstreamoff operator-(const fpos<_StateT>& __x, const fpos<_StateT>& __y)\n    {return streamoff(__x) - streamoff(__y);}\n\ntemplate <class _StateT>\ninline _LIBCPP_INLINE_VISIBILITY\nbool operator==(const fpos<_StateT>& __x, const fpos<_StateT>& __y)\n    {return streamoff(__x) == streamoff(__y);}\n\ntemplate <class _StateT>\ninline _LIBCPP_INLINE_VISIBILITY\nbool operator!=(const fpos<_StateT>& __x, const fpos<_StateT>& __y)\n    {return streamoff(__x) != streamoff(__y);}\n\n// basic_string\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(const basic_string<_CharT, _Traits, _Allocator>& __x,\n          const basic_string<_CharT, _Traits, _Allocator>& __y);\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(const _CharT* __x, const basic_string<_CharT,_Traits,_Allocator>& __y);\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(_CharT __x, const basic_string<_CharT,_Traits,_Allocator>& __y);\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(const basic_string<_CharT, _Traits, _Allocator>& __x, const _CharT* __y);\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(const basic_string<_CharT, _Traits, _Allocator>& __x, _CharT __y);\n\ntemplate <bool>\nclass _LIBCPP_TEMPLATE_VIS __basic_string_common\n{\nprotected:\n    _LIBCPP_NORETURN void __throw_length_error() const;\n    _LIBCPP_NORETURN void __throw_out_of_range() const;\n};\n\ntemplate <bool __b>\nvoid\n__basic_string_common<__b>::__throw_length_error() const\n{\n    _VSTD::__throw_length_error(\"basic_string\");\n}\n\ntemplate <bool __b>\nvoid\n__basic_string_common<__b>::__throw_out_of_range() const\n{\n    _VSTD::__throw_out_of_range(\"basic_string\");\n}\n\n#ifdef _LIBCPP_MSVC\n#pragma warning( push )\n#pragma warning( disable: 4231 )\n#endif // _LIBCPP_MSVC\n_LIBCPP_EXTERN_TEMPLATE(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS __basic_string_common<true>)\n#ifdef _LIBCPP_MSVC\n#pragma warning( pop )\n#endif // _LIBCPP_MSVC\n\n#ifdef _LIBCPP_NO_EXCEPTIONS\ntemplate <class _Iter>\nstruct __libcpp_string_gets_noexcept_iterator_impl : public true_type {};\n#elif defined(_LIBCPP_HAS_NO_NOEXCEPT)\ntemplate <class _Iter>\nstruct __libcpp_string_gets_noexcept_iterator_impl : public false_type {};\n#else\ntemplate <class _Iter, bool = __is_forward_iterator<_Iter>::value>\nstruct __libcpp_string_gets_noexcept_iterator_impl : public _LIBCPP_BOOL_CONSTANT((\n    noexcept(++(declval<_Iter&>())) && \n    is_nothrow_assignable<_Iter&, _Iter>::value && \n    noexcept(declval<_Iter>() == declval<_Iter>()) && \n    noexcept(*declval<_Iter>())\n)) {};\n\ntemplate <class _Iter> \nstruct __libcpp_string_gets_noexcept_iterator_impl<_Iter, false> : public false_type {};\n#endif\n\n\ntemplate <class _Iter>\nstruct __libcpp_string_gets_noexcept_iterator\n    : public _LIBCPP_BOOL_CONSTANT(__libcpp_is_trivial_iterator<_Iter>::value || __libcpp_string_gets_noexcept_iterator_impl<_Iter>::value) {};\n\ntemplate <class _CharT, class _Traits, class _Tp>\nstruct __can_be_converted_to_string_view : public _LIBCPP_BOOL_CONSTANT(\n\t( is_convertible<const _Tp&, basic_string_view<_CharT, _Traits> >::value &&\n     !is_convertible<const _Tp&, const _CharT*>::value)) {};\n\n#ifdef _LIBCPP_ABI_ALTERNATE_STRING_LAYOUT\n\ntemplate <class _CharT, size_t = sizeof(_CharT)>\nstruct __padding\n{\n    unsigned char __xx[sizeof(_CharT)-1];\n};\n\ntemplate <class _CharT>\nstruct __padding<_CharT, 1>\n{\n};\n\n#endif  // _LIBCPP_ABI_ALTERNATE_STRING_LAYOUT\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nclass _LIBCPP_TEMPLATE_VIS basic_string\n    : private __basic_string_common<true>\n{\npublic:\n    typedef basic_string                                 __self;\n    typedef basic_string_view<_CharT, _Traits>           __self_view;\n    typedef _Traits                                      traits_type;\n    typedef typename traits_type::char_type              value_type;\n    typedef _Allocator                                   allocator_type;\n    typedef allocator_traits<allocator_type>             __alloc_traits;\n    typedef typename __alloc_traits::size_type           size_type;\n    typedef typename __alloc_traits::difference_type     difference_type;\n    typedef value_type&                                  reference;\n    typedef const value_type&                            const_reference;\n    typedef typename __alloc_traits::pointer             pointer;\n    typedef typename __alloc_traits::const_pointer       const_pointer;\n\n    static_assert(is_pod<value_type>::value, \"Character type of basic_string must be a POD\");\n    static_assert((is_same<_CharT, value_type>::value),\n                  \"traits_type::char_type must be the same type as CharT\");\n    static_assert((is_same<typename allocator_type::value_type, value_type>::value),\n                  \"Allocator::value_type must be same type as value_type\");\n#if defined(_LIBCPP_RAW_ITERATORS)\n    typedef pointer                                      iterator;\n    typedef const_pointer                                const_iterator;\n#else  // defined(_LIBCPP_RAW_ITERATORS)\n    typedef __wrap_iter<pointer>                         iterator;\n    typedef __wrap_iter<const_pointer>                   const_iterator;\n#endif  // defined(_LIBCPP_RAW_ITERATORS)\n    typedef _VSTD::reverse_iterator<iterator>             reverse_iterator;\n    typedef _VSTD::reverse_iterator<const_iterator>       const_reverse_iterator;\n\nprivate:\n\n#ifdef _LIBCPP_ABI_ALTERNATE_STRING_LAYOUT\n\n    struct __long\n    {\n        pointer   __data_;\n        size_type __size_;\n        size_type __cap_;\n    };\n\n#if _LIBCPP_BIG_ENDIAN\n    enum {__short_mask = 0x01};\n    enum {__long_mask  = 0x1ul};\n#else  // _LIBCPP_BIG_ENDIAN\n    enum {__short_mask = 0x80};\n    enum {__long_mask  = ~(size_type(~0) >> 1)};\n#endif  // _LIBCPP_BIG_ENDIAN\n\n    enum {__min_cap = (sizeof(__long) - 1)/sizeof(value_type) > 2 ?\n                      (sizeof(__long) - 1)/sizeof(value_type) : 2};\n\n    struct __short\n    {\n        value_type __data_[__min_cap];\n        struct\n            : __padding<value_type>\n        {\n            unsigned char __size_;\n        };\n    };\n\n#else\n\n    struct __long\n    {\n        size_type __cap_;\n        size_type __size_;\n        pointer   __data_;\n    };\n\n#if _LIBCPP_BIG_ENDIAN\n    enum {__short_mask = 0x80};\n    enum {__long_mask  = ~(size_type(~0) >> 1)};\n#else  // _LIBCPP_BIG_ENDIAN\n    enum {__short_mask = 0x01};\n    enum {__long_mask  = 0x1ul};\n#endif  // _LIBCPP_BIG_ENDIAN\n\n    enum {__min_cap = (sizeof(__long) - 1)/sizeof(value_type) > 2 ?\n                      (sizeof(__long) - 1)/sizeof(value_type) : 2};\n\n    struct __short\n    {\n        union\n        {\n            unsigned char __size_;\n            value_type __lx;\n        };\n        value_type __data_[__min_cap];\n    };\n\n#endif  // _LIBCPP_ABI_ALTERNATE_STRING_LAYOUT\n\n    union __ulx{__long __lx; __short __lxx;};\n\n    enum {__n_words = sizeof(__ulx) / sizeof(size_type)};\n\n    struct __raw\n    {\n        size_type __words[__n_words];\n    };\n\n    struct __rep\n    {\n        union\n        {\n            __long  __l;\n            __short __s;\n            __raw   __r;\n        };\n    };\n\n    __compressed_pair<__rep, allocator_type> __r_;\n\npublic:\n    static const size_type npos = -1;\n\n    _LIBCPP_INLINE_VISIBILITY basic_string()\n        _NOEXCEPT_(is_nothrow_default_constructible<allocator_type>::value);\n\n    _LIBCPP_INLINE_VISIBILITY explicit basic_string(const allocator_type& __a)\n#if _LIBCPP_STD_VER <= 14\n        _NOEXCEPT_(is_nothrow_copy_constructible<allocator_type>::value);\n#else\n        _NOEXCEPT;\n#endif\n\n    basic_string(const basic_string& __str);\n    basic_string(const basic_string& __str, const allocator_type& __a);\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string(basic_string&& __str)\n#if _LIBCPP_STD_VER <= 14\n        _NOEXCEPT_(is_nothrow_move_constructible<allocator_type>::value);\n#else\n        _NOEXCEPT;\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string(basic_string&& __str, const allocator_type& __a);\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY basic_string(const value_type* __s);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string(const value_type* __s, const allocator_type& __a);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string(const value_type* __s, size_type __n);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string(const value_type* __s, size_type __n, const allocator_type& __a);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string(size_type __n, value_type __c);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string(size_type __n, value_type __c, const allocator_type& __a);\n    basic_string(const basic_string& __str, size_type __pos, size_type __n,\n                 const allocator_type& __a = allocator_type());\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string(const basic_string& __str, size_type __pos,\n                 const allocator_type& __a = allocator_type());\n    template<class _Tp>\n        basic_string(const _Tp& __t, size_type __pos, size_type __n, \n                     const allocator_type& __a = allocator_type(),\n                     typename enable_if<__can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value, void>::type* = 0);\n    _LIBCPP_INLINE_VISIBILITY explicit\n    basic_string(__self_view __sv);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string(__self_view __sv, const allocator_type& __a);\n    template<class _InputIterator>\n        _LIBCPP_INLINE_VISIBILITY\n        basic_string(_InputIterator __first, _InputIterator __last);\n    template<class _InputIterator>\n        _LIBCPP_INLINE_VISIBILITY\n        basic_string(_InputIterator __first, _InputIterator __last, const allocator_type& __a);\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string(initializer_list<value_type> __il);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string(initializer_list<value_type> __il, const allocator_type& __a);\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    inline ~basic_string();\n\n    _LIBCPP_INLINE_VISIBILITY\n    operator __self_view() const _NOEXCEPT { return __self_view(data(), size()); }\n\n    basic_string& operator=(const basic_string& __str);\n\n#ifndef _LIBCPP_CXX03_LANG\n    template <class = void>\n#endif\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& operator=(__self_view __sv)  {return assign(__sv);}\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& operator=(basic_string&& __str)\n        _NOEXCEPT_((__noexcept_move_assign_container<_Allocator, __alloc_traits>::value));\n#endif\n    _LIBCPP_INLINE_VISIBILITY basic_string& operator=(const value_type* __s) {return assign(__s);}\n    basic_string& operator=(value_type __c);\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& operator=(initializer_list<value_type> __il) {return assign(__il.begin(), __il.size());}\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_INLINE_VISIBILITY\n    iterator begin() _NOEXCEPT\n        {return iterator(this, __get_pointer());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator begin() const _NOEXCEPT\n        {return const_iterator(this, __get_pointer());}\n    _LIBCPP_INLINE_VISIBILITY\n    iterator end() _NOEXCEPT\n        {return iterator(this, __get_pointer() + size());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator end() const _NOEXCEPT\n        {return const_iterator(this, __get_pointer() + size());}\n#else\n    _LIBCPP_INLINE_VISIBILITY\n    iterator begin() _NOEXCEPT\n        {return iterator(__get_pointer());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator begin() const _NOEXCEPT\n        {return const_iterator(__get_pointer());}\n    _LIBCPP_INLINE_VISIBILITY\n    iterator end() _NOEXCEPT\n        {return iterator(__get_pointer() + size());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator end() const _NOEXCEPT\n        {return const_iterator(__get_pointer() + size());}\n#endif  // _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_INLINE_VISIBILITY\n    reverse_iterator rbegin() _NOEXCEPT\n        {return reverse_iterator(end());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator rbegin() const _NOEXCEPT\n        {return const_reverse_iterator(end());}\n    _LIBCPP_INLINE_VISIBILITY\n    reverse_iterator rend() _NOEXCEPT\n        {return reverse_iterator(begin());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator rend() const _NOEXCEPT\n        {return const_reverse_iterator(begin());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator cbegin() const _NOEXCEPT\n        {return begin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator cend() const _NOEXCEPT\n        {return end();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator crbegin() const _NOEXCEPT\n        {return rbegin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator crend() const _NOEXCEPT\n        {return rend();}\n\n    _LIBCPP_INLINE_VISIBILITY size_type size() const _NOEXCEPT\n        {return __is_long() ? __get_long_size() : __get_short_size();}\n    _LIBCPP_INLINE_VISIBILITY size_type length() const _NOEXCEPT {return size();}\n    _LIBCPP_INLINE_VISIBILITY size_type max_size() const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY size_type capacity() const _NOEXCEPT\n        {return (__is_long() ? __get_long_cap()\n                             : static_cast<size_type>(__min_cap)) - 1;}\n\n    void resize(size_type __n, value_type __c);\n    _LIBCPP_INLINE_VISIBILITY void resize(size_type __n) {resize(__n, value_type());}\n\n    void reserve(size_type res_arg = 0);\n    _LIBCPP_INLINE_VISIBILITY\n    void shrink_to_fit() _NOEXCEPT {reserve();}\n    _LIBCPP_INLINE_VISIBILITY\n    void clear() _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY bool empty() const _NOEXCEPT {return size() == 0;}\n\n    _LIBCPP_INLINE_VISIBILITY const_reference operator[](size_type __pos) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY reference       operator[](size_type __pos)       _NOEXCEPT;\n\n    const_reference at(size_type __n) const;\n    reference       at(size_type __n);\n\n    _LIBCPP_INLINE_VISIBILITY basic_string& operator+=(const basic_string& __str) {return append(__str);}\n    _LIBCPP_INLINE_VISIBILITY basic_string& operator+=(__self_view __sv)          {return append(__sv);}\n    _LIBCPP_INLINE_VISIBILITY basic_string& operator+=(const value_type* __s)     {return append(__s);}\n    _LIBCPP_INLINE_VISIBILITY basic_string& operator+=(value_type __c)            {push_back(__c); return *this;}\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY basic_string& operator+=(initializer_list<value_type> __il) {return append(__il);}\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& append(const basic_string& __str);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& append(__self_view __sv) { return append(__sv.data(), __sv.size()); }\n    basic_string& append(const basic_string& __str, size_type __pos, size_type __n=npos);\n    template <class _Tp>\n        typename enable_if\n        <\n            __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,\n            basic_string&\n        >::type\n                  append(const _Tp& __t, size_type __pos, size_type __n=npos);\n    basic_string& append(const value_type* __s, size_type __n);\n    basic_string& append(const value_type* __s);\n    basic_string& append(size_type __n, value_type __c);\n    template <class _ForwardIterator>\n    inline basic_string& __append_forward_unsafe(_ForwardIterator, _ForwardIterator);\n    template<class _InputIterator>\n        typename enable_if\n        <\n            __is_exactly_input_iterator<_InputIterator>::value\n                || !__libcpp_string_gets_noexcept_iterator<_InputIterator>::value,\n            basic_string&\n        >::type\n    _LIBCPP_INLINE_VISIBILITY\n    append(_InputIterator __first, _InputIterator __last) {\n      const basic_string __temp (__first, __last, __alloc());\n      append(__temp.data(), __temp.size());\n      return *this;\n    }\n    template<class _ForwardIterator>\n        typename enable_if\n        <\n            __is_forward_iterator<_ForwardIterator>::value\n                && __libcpp_string_gets_noexcept_iterator<_ForwardIterator>::value,\n            basic_string&\n        >::type\n    _LIBCPP_INLINE_VISIBILITY\n    append(_ForwardIterator __first, _ForwardIterator __last) {\n      return __append_forward_unsafe(__first, __last);\n    }\n\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& append(initializer_list<value_type> __il) {return append(__il.begin(), __il.size());}\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    void push_back(value_type __c);\n    _LIBCPP_INLINE_VISIBILITY\n    void pop_back();\n    _LIBCPP_INLINE_VISIBILITY reference       front();\n    _LIBCPP_INLINE_VISIBILITY const_reference front() const;\n    _LIBCPP_INLINE_VISIBILITY reference       back();\n    _LIBCPP_INLINE_VISIBILITY const_reference back() const;\n\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& assign(__self_view __sv) { return assign(__sv.data(), __sv.size()); }\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& assign(const basic_string& __str) { return *this = __str; }\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& assign(basic_string&& str)\n        _NOEXCEPT_((__noexcept_move_assign_container<_Allocator, __alloc_traits>::value))\n        {*this = _VSTD::move(str); return *this;}\n#endif\n    basic_string& assign(const basic_string& __str, size_type __pos, size_type __n=npos);\n    template <class _Tp>\n        typename enable_if\n        <\n            __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,\n            basic_string&\n        >::type\n                  assign(const _Tp & __t, size_type pos, size_type n=npos);\n    basic_string& assign(const value_type* __s, size_type __n);\n    basic_string& assign(const value_type* __s);\n    basic_string& assign(size_type __n, value_type __c);\n    template<class _InputIterator>\n        typename enable_if\n        <\n           __is_exactly_input_iterator<_InputIterator>::value\n                || !__libcpp_string_gets_noexcept_iterator<_InputIterator>::value,\n            basic_string&\n        >::type\n        assign(_InputIterator __first, _InputIterator __last);\n    template<class _ForwardIterator>\n        typename enable_if\n        <\n            __is_forward_iterator<_ForwardIterator>::value\n                 && __libcpp_string_gets_noexcept_iterator<_ForwardIterator>::value,\n            basic_string&\n        >::type\n        assign(_ForwardIterator __first, _ForwardIterator __last);\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& assign(initializer_list<value_type> __il) {return assign(__il.begin(), __il.size());}\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& insert(size_type __pos1, const basic_string& __str);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& insert(size_type __pos1, __self_view __sv) { return insert(__pos1, __sv.data(), __sv.size()); }\n    template <class _Tp>\n        typename enable_if\n        <\n            __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,\n            basic_string&\n        >::type\n                  insert(size_type __pos1, const _Tp& __t, size_type __pos2, size_type __n=npos);\n    basic_string& insert(size_type __pos1, const basic_string& __str, size_type __pos2, size_type __n=npos);\n    basic_string& insert(size_type __pos, const value_type* __s, size_type __n);\n    basic_string& insert(size_type __pos, const value_type* __s);\n    basic_string& insert(size_type __pos, size_type __n, value_type __c);\n    iterator      insert(const_iterator __pos, value_type __c);\n    _LIBCPP_INLINE_VISIBILITY\n    iterator      insert(const_iterator __pos, size_type __n, value_type __c);\n    template<class _InputIterator>\n        typename enable_if\n        <\n           __is_exactly_input_iterator<_InputIterator>::value\n                || !__libcpp_string_gets_noexcept_iterator<_InputIterator>::value,\n            iterator\n        >::type\n        insert(const_iterator __pos, _InputIterator __first, _InputIterator __last);\n    template<class _ForwardIterator>\n        typename enable_if\n        <\n            __is_forward_iterator<_ForwardIterator>::value\n                 && __libcpp_string_gets_noexcept_iterator<_ForwardIterator>::value,\n            iterator\n        >::type\n        insert(const_iterator __pos, _ForwardIterator __first, _ForwardIterator __last);\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    iterator insert(const_iterator __pos, initializer_list<value_type> __il)\n                    {return insert(__pos, __il.begin(), __il.end());}\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    basic_string& erase(size_type __pos = 0, size_type __n = npos);\n    _LIBCPP_INLINE_VISIBILITY\n    iterator      erase(const_iterator __pos);\n    _LIBCPP_INLINE_VISIBILITY\n    iterator      erase(const_iterator __first, const_iterator __last);\n\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& replace(size_type __pos1, size_type __n1, const basic_string& __str);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& replace(size_type __pos1, size_type __n1, __self_view __sv) { return replace(__pos1, __n1, __sv.data(), __sv.size()); }\n    basic_string& replace(size_type __pos1, size_type __n1, const basic_string& __str, size_type __pos2, size_type __n2=npos);\n    template <class _Tp>\n        typename enable_if\n        <\n            __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,\n            basic_string&\n        >::type\n                  replace(size_type __pos1, size_type __n1, const _Tp& __t, size_type __pos2, size_type __n2=npos);\n    basic_string& replace(size_type __pos, size_type __n1, const value_type* __s, size_type __n2);\n    basic_string& replace(size_type __pos, size_type __n1, const value_type* __s);\n    basic_string& replace(size_type __pos, size_type __n1, size_type __n2, value_type __c);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& replace(const_iterator __i1, const_iterator __i2, const basic_string& __str);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& replace(const_iterator __i1, const_iterator __i2, __self_view __sv) { return replace(__i1 - begin(), __i2 - __i1, __sv); }\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& replace(const_iterator __i1, const_iterator __i2, const value_type* __s, size_type __n);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& replace(const_iterator __i1, const_iterator __i2, const value_type* __s);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& replace(const_iterator __i1, const_iterator __i2, size_type __n, value_type __c);\n    template<class _InputIterator>\n        typename enable_if\n        <\n            __is_input_iterator<_InputIterator>::value,\n            basic_string&\n        >::type\n        replace(const_iterator __i1, const_iterator __i2, _InputIterator __j1, _InputIterator __j2);\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& replace(const_iterator __i1, const_iterator __i2, initializer_list<value_type> __il)\n        {return replace(__i1, __i2, __il.begin(), __il.end());}\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    size_type copy(value_type* __s, size_type __n, size_type __pos = 0) const;\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string substr(size_type __pos = 0, size_type __n = npos) const;\n\n    _LIBCPP_INLINE_VISIBILITY\n    void swap(basic_string& __str)\n#if _LIBCPP_STD_VER >= 14\n        _NOEXCEPT_DEBUG;\n#else\n        _NOEXCEPT_DEBUG_(!__alloc_traits::propagate_on_container_swap::value ||\n                    __is_nothrow_swappable<allocator_type>::value);\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    const value_type* c_str() const _NOEXCEPT {return data();}\n    _LIBCPP_INLINE_VISIBILITY\n    const value_type* data() const _NOEXCEPT  {return _VSTD::__to_raw_pointer(__get_pointer());}\n#if _LIBCPP_STD_VER > 14\n    _LIBCPP_INLINE_VISIBILITY\n    value_type* data()             _NOEXCEPT  {return _VSTD::__to_raw_pointer(__get_pointer());}\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    allocator_type get_allocator() const _NOEXCEPT {return __alloc();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find(const basic_string& __str, size_type __pos = 0) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find(__self_view __sv, size_type __pos = 0) const _NOEXCEPT;\n    size_type find(const value_type* __s, size_type __pos, size_type __n) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find(const value_type* __s, size_type __pos = 0) const _NOEXCEPT;\n    size_type find(value_type __c, size_type __pos = 0) const _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type rfind(const basic_string& __str, size_type __pos = npos) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type rfind(__self_view __sv, size_type __pos = 0) const _NOEXCEPT;\n    size_type rfind(const value_type* __s, size_type __pos, size_type __n) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type rfind(const value_type* __s, size_type __pos = npos) const _NOEXCEPT;\n    size_type rfind(value_type __c, size_type __pos = npos) const _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_first_of(const basic_string& __str, size_type __pos = 0) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_first_of(__self_view __sv, size_type __pos = 0) const _NOEXCEPT;\n    size_type find_first_of(const value_type* __s, size_type __pos, size_type __n) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_first_of(const value_type* __s, size_type __pos = 0) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_first_of(value_type __c, size_type __pos = 0) const _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_last_of(const basic_string& __str, size_type __pos = npos) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_last_of(__self_view __sv, size_type __pos = 0) const _NOEXCEPT;\n    size_type find_last_of(const value_type* __s, size_type __pos, size_type __n) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_last_of(const value_type* __s, size_type __pos = npos) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_last_of(value_type __c, size_type __pos = npos) const _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_first_not_of(const basic_string& __str, size_type __pos = 0) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_first_not_of(__self_view __sv, size_type __pos = 0) const _NOEXCEPT;\n    size_type find_first_not_of(const value_type* __s, size_type __pos, size_type __n) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_first_not_of(const value_type* __s, size_type __pos = 0) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_first_not_of(value_type __c, size_type __pos = 0) const _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_last_not_of(const basic_string& __str, size_type __pos = npos) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_last_not_of(__self_view __sv, size_type __pos = 0) const _NOEXCEPT;\n    size_type find_last_not_of(const value_type* __s, size_type __pos, size_type __n) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_last_not_of(const value_type* __s, size_type __pos = npos) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_last_not_of(value_type __c, size_type __pos = npos) const _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    int compare(const basic_string& __str) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    int compare(__self_view __sv) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    int compare(size_type __pos1, size_type __n1, __self_view __sv) const;\n    _LIBCPP_INLINE_VISIBILITY\n    int compare(size_type __pos1, size_type __n1, const basic_string& __str) const;\n    int compare(size_type __pos1, size_type __n1, const basic_string& __str, size_type __pos2, size_type __n2=npos) const;\n    template <class _Tp>\n    inline _LIBCPP_INLINE_VISIBILITY\n        typename enable_if\n        <\n            __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,\n            int\n        >::type\n        compare(size_type __pos1, size_type __n1, const _Tp& __t, size_type __pos2, size_type __n2=npos) const;\n    int compare(const value_type* __s) const _NOEXCEPT;\n    int compare(size_type __pos1, size_type __n1, const value_type* __s) const;\n    int compare(size_type __pos1, size_type __n1, const value_type* __s, size_type __n2) const;\n\n    _LIBCPP_INLINE_VISIBILITY bool __invariants() const;\n\n    _LIBCPP_INLINE_VISIBILITY\n    bool __is_long() const _NOEXCEPT\n        {return bool(__r_.first().__s.__size_ & __short_mask);}\n\n#if _LIBCPP_DEBUG_LEVEL >= 2\n\n    bool __dereferenceable(const const_iterator* __i) const;\n    bool __decrementable(const const_iterator* __i) const;\n    bool __addable(const const_iterator* __i, ptrdiff_t __n) const;\n    bool __subscriptable(const const_iterator* __i, ptrdiff_t __n) const;\n\n#endif  // _LIBCPP_DEBUG_LEVEL >= 2\n\nprivate:\n    _LIBCPP_INLINE_VISIBILITY\n    allocator_type& __alloc() _NOEXCEPT\n        {return __r_.second();}\n    _LIBCPP_INLINE_VISIBILITY\n    const allocator_type& __alloc() const _NOEXCEPT\n        {return __r_.second();}\n\n#ifdef _LIBCPP_ABI_ALTERNATE_STRING_LAYOUT\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __set_short_size(size_type __s) _NOEXCEPT\n#   if _LIBCPP_BIG_ENDIAN\n        {__r_.first().__s.__size_ = (unsigned char)(__s << 1);}\n#   else\n        {__r_.first().__s.__size_ = (unsigned char)(__s);}\n#   endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type __get_short_size() const _NOEXCEPT\n#   if _LIBCPP_BIG_ENDIAN\n        {return __r_.first().__s.__size_ >> 1;}\n#   else\n        {return __r_.first().__s.__size_;}\n#   endif\n\n#else  // _LIBCPP_ABI_ALTERNATE_STRING_LAYOUT\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __set_short_size(size_type __s) _NOEXCEPT\n#   if _LIBCPP_BIG_ENDIAN\n        {__r_.first().__s.__size_ = (unsigned char)(__s);}\n#   else\n        {__r_.first().__s.__size_ = (unsigned char)(__s << 1);}\n#   endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type __get_short_size() const _NOEXCEPT\n#   if _LIBCPP_BIG_ENDIAN\n        {return __r_.first().__s.__size_;}\n#   else\n        {return __r_.first().__s.__size_ >> 1;}\n#   endif\n\n#endif  // _LIBCPP_ABI_ALTERNATE_STRING_LAYOUT\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __set_long_size(size_type __s) _NOEXCEPT\n        {__r_.first().__l.__size_ = __s;}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type __get_long_size() const _NOEXCEPT\n        {return __r_.first().__l.__size_;}\n    _LIBCPP_INLINE_VISIBILITY\n    void __set_size(size_type __s) _NOEXCEPT\n        {if (__is_long()) __set_long_size(__s); else __set_short_size(__s);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __set_long_cap(size_type __s) _NOEXCEPT\n        {__r_.first().__l.__cap_  = __long_mask | __s;}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type __get_long_cap() const _NOEXCEPT\n        {return __r_.first().__l.__cap_ & size_type(~__long_mask);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __set_long_pointer(pointer __p) _NOEXCEPT\n        {__r_.first().__l.__data_ = __p;}\n    _LIBCPP_INLINE_VISIBILITY\n    pointer __get_long_pointer() _NOEXCEPT\n        {return __r_.first().__l.__data_;}\n    _LIBCPP_INLINE_VISIBILITY\n    const_pointer __get_long_pointer() const _NOEXCEPT\n        {return __r_.first().__l.__data_;}\n    _LIBCPP_INLINE_VISIBILITY\n    pointer __get_short_pointer() _NOEXCEPT\n        {return pointer_traits<pointer>::pointer_to(__r_.first().__s.__data_[0]);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_pointer __get_short_pointer() const _NOEXCEPT\n        {return pointer_traits<const_pointer>::pointer_to(__r_.first().__s.__data_[0]);}\n    _LIBCPP_INLINE_VISIBILITY\n    pointer __get_pointer() _NOEXCEPT\n        {return __is_long() ? __get_long_pointer() : __get_short_pointer();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_pointer __get_pointer() const _NOEXCEPT\n        {return __is_long() ? __get_long_pointer() : __get_short_pointer();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __zero() _NOEXCEPT\n        {\n            size_type (&__a)[__n_words] = __r_.first().__r.__words;\n            for (unsigned __i = 0; __i < __n_words; ++__i)\n                __a[__i] = 0;\n        }\n\n    template <size_type __a> static\n        _LIBCPP_INLINE_VISIBILITY\n        size_type __align_it(size_type __s) _NOEXCEPT\n            {return (__s + (__a-1)) & ~(__a-1);}\n    enum {__alignment = 16};\n    static _LIBCPP_INLINE_VISIBILITY\n    size_type __recommend(size_type __s) _NOEXCEPT\n        {return (__s < __min_cap ? static_cast<size_type>(__min_cap) :\n                 __align_it<sizeof(value_type) < __alignment ?\n                            __alignment/sizeof(value_type) : 1 > (__s+1)) - 1;}\n\n    inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY\n    void __init(const value_type* __s, size_type __sz, size_type __reserve);\n    inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY\n    void __init(const value_type* __s, size_type __sz);\n    inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY\n    void __init(size_type __n, value_type __c);\n\n    template <class _InputIterator>\n    inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY\n    typename enable_if\n    <\n        __is_exactly_input_iterator<_InputIterator>::value,\n        void\n    >::type\n    __init(_InputIterator __first, _InputIterator __last);\n\n    template <class _ForwardIterator>\n    inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY\n    typename enable_if\n    <\n        __is_forward_iterator<_ForwardIterator>::value,\n        void\n    >::type\n    __init(_ForwardIterator __first, _ForwardIterator __last);\n\n    void __grow_by(size_type __old_cap, size_type __delta_cap, size_type __old_sz,\n                   size_type __n_copy,  size_type __n_del,     size_type __n_add = 0);\n    void __grow_by_and_replace(size_type __old_cap, size_type __delta_cap, size_type __old_sz,\n                               size_type __n_copy,  size_type __n_del,\n                               size_type __n_add, const value_type* __p_new_stuff);\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __erase_to_end(size_type __pos);\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __copy_assign_alloc(const basic_string& __str)\n        {__copy_assign_alloc(__str, integral_constant<bool,\n                      __alloc_traits::propagate_on_container_copy_assignment::value>());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __copy_assign_alloc(const basic_string& __str, true_type)\n        {\n            if (__alloc() != __str.__alloc())\n            {\n                clear();\n                shrink_to_fit();\n            }\n            __alloc() = __str.__alloc();\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __copy_assign_alloc(const basic_string&, false_type) _NOEXCEPT\n        {}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign(basic_string& __str, false_type)\n        _NOEXCEPT_(__alloc_traits::is_always_equal::value);\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign(basic_string& __str, true_type)\n#if _LIBCPP_STD_VER > 14\n        _NOEXCEPT;\n#else\n        _NOEXCEPT_(is_nothrow_move_assignable<allocator_type>::value);\n#endif\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    void\n    __move_assign_alloc(basic_string& __str)\n        _NOEXCEPT_(\n            !__alloc_traits::propagate_on_container_move_assignment::value ||\n            is_nothrow_move_assignable<allocator_type>::value)\n    {__move_assign_alloc(__str, integral_constant<bool,\n                      __alloc_traits::propagate_on_container_move_assignment::value>());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign_alloc(basic_string& __c, true_type)\n        _NOEXCEPT_(is_nothrow_move_assignable<allocator_type>::value)\n        {\n            __alloc() = _VSTD::move(__c.__alloc());\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign_alloc(basic_string&, false_type)\n        _NOEXCEPT\n        {}\n\n    _LIBCPP_INLINE_VISIBILITY void __invalidate_all_iterators();\n    _LIBCPP_INLINE_VISIBILITY void __invalidate_iterators_past(size_type);\n\n    friend basic_string operator+<>(const basic_string&, const basic_string&);\n    friend basic_string operator+<>(const value_type*, const basic_string&);\n    friend basic_string operator+<>(value_type, const basic_string&);\n    friend basic_string operator+<>(const basic_string&, const value_type*);\n    friend basic_string operator+<>(const basic_string&, value_type);\n};\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::__invalidate_all_iterators()\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__invalidate_all(this);\n#endif  // _LIBCPP_DEBUG_LEVEL >= 2\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::__invalidate_iterators_past(size_type\n#if _LIBCPP_DEBUG_LEVEL >= 2\n                                                                        __pos\n#endif\n                                                                      )\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __c_node* __c = __get_db()->__find_c_and_lock(this);\n    if (__c)\n    {\n        const_pointer __new_last = __get_pointer() + __pos;\n        for (__i_node** __p = __c->end_; __p != __c->beg_; )\n        {\n            --__p;\n            const_iterator* __i = static_cast<const_iterator*>((*__p)->__i_);\n            if (__i->base() > __new_last)\n            {\n                (*__p)->__c_ = nullptr;\n                if (--__c->end_ != __p)\n                    memmove(__p, __p+1, (__c->end_ - __p)*sizeof(__i_node*));\n            }\n        }\n        __get_db()->unlock();\n    }\n#endif  // _LIBCPP_DEBUG_LEVEL >= 2\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string()\n    _NOEXCEPT_(is_nothrow_default_constructible<allocator_type>::value)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    __zero();\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(const allocator_type& __a)\n#if _LIBCPP_STD_VER <= 14\n        _NOEXCEPT_(is_nothrow_copy_constructible<allocator_type>::value)\n#else\n        _NOEXCEPT\n#endif\n: __r_(__a)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    __zero();\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nvoid basic_string<_CharT, _Traits, _Allocator>::__init(const value_type* __s,\n                                                       size_type __sz,\n                                                       size_type __reserve)\n{\n    if (__reserve > max_size())\n        this->__throw_length_error();\n    pointer __p;\n    if (__reserve < __min_cap)\n    {\n        __set_short_size(__sz);\n        __p = __get_short_pointer();\n    }\n    else\n    {\n        size_type __cap = __recommend(__reserve);\n        __p = __alloc_traits::allocate(__alloc(), __cap+1);\n        __set_long_pointer(__p);\n        __set_long_cap(__cap+1);\n        __set_long_size(__sz);\n    }\n    traits_type::copy(_VSTD::__to_raw_pointer(__p), __s, __sz);\n    traits_type::assign(__p[__sz], value_type());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::__init(const value_type* __s, size_type __sz)\n{\n    if (__sz > max_size())\n        this->__throw_length_error();\n    pointer __p;\n    if (__sz < __min_cap)\n    {\n        __set_short_size(__sz);\n        __p = __get_short_pointer();\n    }\n    else\n    {\n        size_type __cap = __recommend(__sz);\n        __p = __alloc_traits::allocate(__alloc(), __cap+1);\n        __set_long_pointer(__p);\n        __set_long_cap(__cap+1);\n        __set_long_size(__sz);\n    }\n    traits_type::copy(_VSTD::__to_raw_pointer(__p), __s, __sz);\n    traits_type::assign(__p[__sz], value_type());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(const value_type* __s)\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"basic_string(const char*) detected nullptr\");\n    __init(__s, traits_type::length(__s));\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(const value_type* __s, const allocator_type& __a)\n    : __r_(__a)\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"basic_string(const char*, allocator) detected nullptr\");\n    __init(__s, traits_type::length(__s));\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(const value_type* __s, size_type __n)\n{\n    _LIBCPP_ASSERT(__n == 0 || __s != nullptr, \"basic_string(const char*, n) detected nullptr\");\n    __init(__s, __n);\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(const value_type* __s, size_type __n, const allocator_type& __a)\n    : __r_(__a)\n{\n    _LIBCPP_ASSERT(__n == 0 || __s != nullptr, \"basic_string(const char*, n, allocator) detected nullptr\");\n    __init(__s, __n);\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(const basic_string& __str)\n    : __r_(__alloc_traits::select_on_container_copy_construction(__str.__alloc()))\n{\n    if (!__str.__is_long())\n        __r_.first().__r = __str.__r_.first().__r;\n    else\n        __init(_VSTD::__to_raw_pointer(__str.__get_long_pointer()), __str.__get_long_size());\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(const basic_string& __str, const allocator_type& __a)\n    : __r_(__a)\n{\n    if (!__str.__is_long())\n        __r_.first().__r = __str.__r_.first().__r;\n    else\n        __init(_VSTD::__to_raw_pointer(__str.__get_long_pointer()), __str.__get_long_size());\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(basic_string&& __str)\n#if _LIBCPP_STD_VER <= 14\n        _NOEXCEPT_(is_nothrow_move_constructible<allocator_type>::value)\n#else\n        _NOEXCEPT\n#endif\n    : __r_(_VSTD::move(__str.__r_))\n{\n    __str.__zero();\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n    if (__is_long())\n        __get_db()->swap(this, &__str);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(basic_string&& __str, const allocator_type& __a)\n    : __r_(__a)\n{\n    if (__str.__is_long() && __a != __str.__alloc()) // copy, not move\n        __init(_VSTD::__to_raw_pointer(__str.__get_long_pointer()), __str.__get_long_size());\n    else\n    {\n        __r_.first().__r = __str.__r_.first().__r;\n        __str.__zero();\n    }\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n    if (__is_long())\n        __get_db()->swap(this, &__str);\n#endif\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::__init(size_type __n, value_type __c)\n{\n    if (__n > max_size())\n        this->__throw_length_error();\n    pointer __p;\n    if (__n < __min_cap)\n    {\n        __set_short_size(__n);\n        __p = __get_short_pointer();\n    }\n    else\n    {\n        size_type __cap = __recommend(__n);\n        __p = __alloc_traits::allocate(__alloc(), __cap+1);\n        __set_long_pointer(__p);\n        __set_long_cap(__cap+1);\n        __set_long_size(__n);\n    }\n    traits_type::assign(_VSTD::__to_raw_pointer(__p), __n, __c);\n    traits_type::assign(__p[__n], value_type());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(size_type __n, value_type __c)\n{\n    __init(__n, __c);\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(size_type __n, value_type __c, const allocator_type& __a)\n    : __r_(__a)\n{\n    __init(__n, __c);\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(const basic_string& __str, size_type __pos, size_type __n,\n                                                        const allocator_type& __a)\n    : __r_(__a)\n{\n    size_type __str_sz = __str.size();\n    if (__pos > __str_sz)\n        this->__throw_out_of_range();\n    __init(__str.data() + __pos, _VSTD::min(__n, __str_sz - __pos));\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(const basic_string& __str, size_type __pos,\n                                                        const allocator_type& __a)\n    : __r_(__a)\n{\n    size_type __str_sz = __str.size();\n    if (__pos > __str_sz)\n        this->__throw_out_of_range();\n    __init(__str.data() + __pos, __str_sz - __pos);\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate <class _Tp>\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(\n             const _Tp& __t, size_type __pos, size_type __n, const allocator_type& __a,\n\t\t\t typename enable_if<__can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value, void>::type *)\n    : __r_(__a)\n{\n\t__self_view __sv = __self_view(__t).substr(__pos, __n);\n    __init(__sv.data(), __sv.size());\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\t\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(__self_view __sv)\n{\n    __init(__sv.data(), __sv.size());\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(__self_view __sv, const allocator_type& __a)\n    : __r_(__a)\n{\n    __init(__sv.data(), __sv.size());\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate <class _InputIterator>\ntypename enable_if\n<\n    __is_exactly_input_iterator<_InputIterator>::value,\n    void\n>::type\nbasic_string<_CharT, _Traits, _Allocator>::__init(_InputIterator __first, _InputIterator __last)\n{\n    __zero();\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    for (; __first != __last; ++__first)\n        push_back(*__first);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        if (__is_long())\n            __alloc_traits::deallocate(__alloc(), __get_long_pointer(), __get_long_cap());\n        throw;\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate <class _ForwardIterator>\ntypename enable_if\n<\n    __is_forward_iterator<_ForwardIterator>::value,\n    void\n>::type\nbasic_string<_CharT, _Traits, _Allocator>::__init(_ForwardIterator __first, _ForwardIterator __last)\n{\n    size_type __sz = static_cast<size_type>(_VSTD::distance(__first, __last));\n    if (__sz > max_size())\n        this->__throw_length_error();\n    pointer __p;\n    if (__sz < __min_cap)\n    {\n        __set_short_size(__sz);\n        __p = __get_short_pointer();\n    }\n    else\n    {\n        size_type __cap = __recommend(__sz);\n        __p = __alloc_traits::allocate(__alloc(), __cap+1);\n        __set_long_pointer(__p);\n        __set_long_cap(__cap+1);\n        __set_long_size(__sz);\n    }\n    for (; __first != __last; ++__first, (void) ++__p)\n        traits_type::assign(*__p, *__first);\n    traits_type::assign(*__p, value_type());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate<class _InputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(_InputIterator __first, _InputIterator __last)\n{\n    __init(__first, __last);\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate<class _InputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(_InputIterator __first, _InputIterator __last,\n                                                        const allocator_type& __a)\n    : __r_(__a)\n{\n    __init(__first, __last);\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(initializer_list<value_type> __il)\n{\n    __init(__il.begin(), __il.end());\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(initializer_list<value_type> __il, const allocator_type& __a)\n    : __r_(__a)\n{\n    __init(__il.begin(), __il.end());\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>::~basic_string()\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__erase_c(this);\n#endif\n    if (__is_long())\n        __alloc_traits::deallocate(__alloc(), __get_long_pointer(), __get_long_cap());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::__grow_by_and_replace\n    (size_type __old_cap, size_type __delta_cap, size_type __old_sz,\n     size_type __n_copy,  size_type __n_del,     size_type __n_add, const value_type* __p_new_stuff)\n{\n    size_type __ms = max_size();\n    if (__delta_cap > __ms - __old_cap - 1)\n        this->__throw_length_error();\n    pointer __old_p = __get_pointer();\n    size_type __cap = __old_cap < __ms / 2 - __alignment ?\n                          __recommend(_VSTD::max(__old_cap + __delta_cap, 2 * __old_cap)) :\n                          __ms - 1;\n    pointer __p = __alloc_traits::allocate(__alloc(), __cap+1);\n    __invalidate_all_iterators();\n    if (__n_copy != 0)\n        traits_type::copy(_VSTD::__to_raw_pointer(__p),\n                          _VSTD::__to_raw_pointer(__old_p), __n_copy);\n    if (__n_add != 0)\n        traits_type::copy(_VSTD::__to_raw_pointer(__p) + __n_copy, __p_new_stuff, __n_add);\n    size_type __sec_cp_sz = __old_sz - __n_del - __n_copy;\n    if (__sec_cp_sz != 0)\n        traits_type::copy(_VSTD::__to_raw_pointer(__p) + __n_copy + __n_add,\n                          _VSTD::__to_raw_pointer(__old_p) + __n_copy + __n_del, __sec_cp_sz);\n    if (__old_cap+1 != __min_cap)\n        __alloc_traits::deallocate(__alloc(), __old_p, __old_cap+1);\n    __set_long_pointer(__p);\n    __set_long_cap(__cap+1);\n    __old_sz = __n_copy + __n_add + __sec_cp_sz;\n    __set_long_size(__old_sz);\n    traits_type::assign(__p[__old_sz], value_type());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::__grow_by(size_type __old_cap, size_type __delta_cap, size_type __old_sz,\n                                                     size_type __n_copy,  size_type __n_del,     size_type __n_add)\n{\n    size_type __ms = max_size();\n    if (__delta_cap > __ms - __old_cap)\n        this->__throw_length_error();\n    pointer __old_p = __get_pointer();\n    size_type __cap = __old_cap < __ms / 2 - __alignment ?\n                          __recommend(_VSTD::max(__old_cap + __delta_cap, 2 * __old_cap)) :\n                          __ms - 1;\n    pointer __p = __alloc_traits::allocate(__alloc(), __cap+1);\n    __invalidate_all_iterators();\n    if (__n_copy != 0)\n        traits_type::copy(_VSTD::__to_raw_pointer(__p),\n                          _VSTD::__to_raw_pointer(__old_p), __n_copy);\n    size_type __sec_cp_sz = __old_sz - __n_del - __n_copy;\n    if (__sec_cp_sz != 0)\n        traits_type::copy(_VSTD::__to_raw_pointer(__p) + __n_copy + __n_add,\n                          _VSTD::__to_raw_pointer(__old_p) + __n_copy + __n_del,\n                          __sec_cp_sz);\n    if (__old_cap+1 != __min_cap)\n        __alloc_traits::deallocate(__alloc(), __old_p, __old_cap+1);\n    __set_long_pointer(__p);\n    __set_long_cap(__cap+1);\n}\n\n// assign\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::assign(const value_type* __s, size_type __n)\n{\n    _LIBCPP_ASSERT(__n == 0 || __s != nullptr, \"string::assign received nullptr\");\n    size_type __cap = capacity();\n    if (__cap >= __n)\n    {\n        value_type* __p = _VSTD::__to_raw_pointer(__get_pointer());\n        traits_type::move(__p, __s, __n);\n        traits_type::assign(__p[__n], value_type());\n        __set_size(__n);\n        __invalidate_iterators_past(__n);\n    }\n    else\n    {\n        size_type __sz = size();\n        __grow_by_and_replace(__cap, __n - __cap, __sz, 0, __sz, __n, __s);\n    }\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::assign(size_type __n, value_type __c)\n{\n    size_type __cap = capacity();\n    if (__cap < __n)\n    {\n        size_type __sz = size();\n        __grow_by(__cap, __n - __cap, __sz, 0, __sz);\n    }\n    else\n        __invalidate_iterators_past(__n);\n    value_type* __p = _VSTD::__to_raw_pointer(__get_pointer());\n    traits_type::assign(__p, __n, __c);\n    traits_type::assign(__p[__n], value_type());\n    __set_size(__n);\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::operator=(value_type __c)\n{\n    pointer __p;\n    if (__is_long())\n    {\n        __p = __get_long_pointer();\n        __set_long_size(1);\n    }\n    else\n    {\n        __p = __get_short_pointer();\n        __set_short_size(1);\n    }\n    traits_type::assign(*__p, __c);\n    traits_type::assign(*++__p, value_type());\n    __invalidate_iterators_past(1);\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::operator=(const basic_string& __str)\n{\n    if (this != &__str)\n    {\n        __copy_assign_alloc(__str);\n        assign(__str.data(), __str.size());\n    }\n    return *this;\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::__move_assign(basic_string& __str, false_type)\n    _NOEXCEPT_(__alloc_traits::is_always_equal::value)\n{\n    if (__alloc() != __str.__alloc())\n        assign(__str);\n    else\n        __move_assign(__str, true_type());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::__move_assign(basic_string& __str, true_type)\n#if _LIBCPP_STD_VER > 14\n    _NOEXCEPT\n#else\n    _NOEXCEPT_(is_nothrow_move_assignable<allocator_type>::value)\n#endif\n{\n    clear();\n    shrink_to_fit();\n    __r_.first() = __str.__r_.first();\n    __move_assign_alloc(__str);\n    __str.__zero();\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::operator=(basic_string&& __str)\n    _NOEXCEPT_((__noexcept_move_assign_container<_Allocator, __alloc_traits>::value))\n{\n    __move_assign(__str, integral_constant<bool,\n          __alloc_traits::propagate_on_container_move_assignment::value>());\n    return *this;\n}\n\n#endif\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate<class _InputIterator>\ntypename enable_if\n<\n     __is_exactly_input_iterator <_InputIterator>::value\n          || !__libcpp_string_gets_noexcept_iterator<_InputIterator>::value,\n    basic_string<_CharT, _Traits, _Allocator>&\n>::type\nbasic_string<_CharT, _Traits, _Allocator>::assign(_InputIterator __first, _InputIterator __last)\n{\n    const basic_string __temp(__first, __last, __alloc());\n    assign(__temp.data(), __temp.size());\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate<class _ForwardIterator>\ntypename enable_if\n<\n    __is_forward_iterator<_ForwardIterator>::value\n         && __libcpp_string_gets_noexcept_iterator<_ForwardIterator>::value,\n    basic_string<_CharT, _Traits, _Allocator>&\n>::type\nbasic_string<_CharT, _Traits, _Allocator>::assign(_ForwardIterator __first, _ForwardIterator __last)\n{\n    size_type __n = static_cast<size_type>(_VSTD::distance(__first, __last));\n    size_type __cap = capacity();\n    if (__cap < __n)\n    {\n        size_type __sz = size();\n        __grow_by(__cap, __n - __cap, __sz, 0, __sz);\n    }\n    else\n        __invalidate_iterators_past(__n);\n    pointer __p = __get_pointer();\n    for (; __first != __last; ++__first, ++__p)\n        traits_type::assign(*__p, *__first);\n    traits_type::assign(*__p, value_type());\n    __set_size(__n);\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::assign(const basic_string& __str, size_type __pos, size_type __n)\n{\n    size_type __sz = __str.size();\n    if (__pos > __sz)\n        this->__throw_out_of_range();\n    return assign(__str.data() + __pos, _VSTD::min(__n, __sz - __pos));\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate <class _Tp>\ntypename enable_if\n<\n    __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,\n\tbasic_string<_CharT, _Traits, _Allocator>&\n>::type\nbasic_string<_CharT, _Traits, _Allocator>::assign(const _Tp & __t, size_type __pos, size_type __n)\n{\n    __self_view __sv = __t;\n    size_type __sz = __sv.size();\n    if (__pos > __sz)\n        this->__throw_out_of_range();\n    return assign(__sv.data() + __pos, _VSTD::min(__n, __sz - __pos));\n}\n\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::assign(const value_type* __s)\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"string::assign received nullptr\");\n    return assign(__s, traits_type::length(__s));\n}\n\n// append\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::append(const value_type* __s, size_type __n)\n{\n    _LIBCPP_ASSERT(__n == 0 || __s != nullptr, \"string::append received nullptr\");\n    size_type __cap = capacity();\n    size_type __sz = size();\n    if (__cap - __sz >= __n)\n    {\n        if (__n)\n        {\n            value_type* __p = _VSTD::__to_raw_pointer(__get_pointer());\n            traits_type::copy(__p + __sz, __s, __n);\n            __sz += __n;\n            __set_size(__sz);\n            traits_type::assign(__p[__sz], value_type());\n        }\n    }\n    else\n        __grow_by_and_replace(__cap, __sz + __n - __cap, __sz, __sz, 0, __n, __s);\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::append(size_type __n, value_type __c)\n{\n    if (__n)\n    {\n        size_type __cap = capacity();\n        size_type __sz = size();\n        if (__cap - __sz < __n)\n            __grow_by(__cap, __sz + __n - __cap, __sz, __sz, 0);\n        pointer __p = __get_pointer();\n        traits_type::assign(_VSTD::__to_raw_pointer(__p) + __sz, __n, __c);\n        __sz += __n;\n        __set_size(__sz);\n        traits_type::assign(__p[__sz], value_type());\n    }\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::push_back(value_type __c)\n{\n    bool __is_short = !__is_long();\n    size_type __cap;\n    size_type __sz;\n    if (__is_short)\n    {\n        __cap = __min_cap - 1;\n        __sz = __get_short_size();\n    }\n    else\n    {\n        __cap = __get_long_cap() - 1;\n        __sz = __get_long_size();\n    }\n    if (__sz == __cap)\n    {\n        __grow_by(__cap, 1, __sz, __sz, 0);\n        __is_short = !__is_long();\n    }\n    pointer __p;\n    if (__is_short)\n    {\n        __p = __get_short_pointer() + __sz;\n        __set_short_size(__sz+1);\n    }\n    else\n    {\n        __p = __get_long_pointer() + __sz;\n        __set_long_size(__sz+1);\n    }\n    traits_type::assign(*__p, __c);\n    traits_type::assign(*++__p, value_type());\n}\n\ntemplate <class _Tp>\nbool __ptr_in_range (const _Tp* __p, const _Tp* __first, const _Tp* __last)\n{\n    return __first <= __p && __p < __last;\n}\n\ntemplate <class _Tp1, class _Tp2>\nbool __ptr_in_range (const _Tp1*, const _Tp2*, const _Tp2*)\n{\n    return false;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate<class _ForwardIterator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::__append_forward_unsafe(\n    _ForwardIterator __first, _ForwardIterator __last)\n{\n    static_assert(__is_forward_iterator<_ForwardIterator>::value,\n                  \"function requires a ForwardIterator\");\n    size_type __sz = size();\n    size_type __cap = capacity();\n    size_type __n = static_cast<size_type>(_VSTD::distance(__first, __last));\n    if (__n)\n    {\n        typedef typename iterator_traits<_ForwardIterator>::reference _CharRef;\n        _CharRef __tmp_ref = *__first;\n        if (__ptr_in_range(_VSTD::addressof(__tmp_ref), data(), data() + size()))\n        {\n            const basic_string __temp (__first, __last, __alloc());\n            append(__temp.data(), __temp.size());\n        }\n        else \n        {\n            if (__cap - __sz < __n)\n                __grow_by(__cap, __sz + __n - __cap, __sz, __sz, 0);\n            pointer __p = __get_pointer() + __sz;\n            for (; __first != __last; ++__p, ++__first)\n                traits_type::assign(*__p, *__first);\n            traits_type::assign(*__p, value_type());\n            __set_size(__sz + __n);\n        }\n    }\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::append(const basic_string& __str)\n{\n    return append(__str.data(), __str.size());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::append(const basic_string& __str, size_type __pos, size_type __n)\n{\n    size_type __sz = __str.size();\n    if (__pos > __sz)\n        this->__throw_out_of_range();\n    return append(__str.data() + __pos, _VSTD::min(__n, __sz - __pos));\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate <class _Tp>\n    typename enable_if\n    <\n        __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,\n        basic_string<_CharT, _Traits, _Allocator>&\n    >::type\nbasic_string<_CharT, _Traits, _Allocator>::append(const _Tp & __t, size_type __pos, size_type __n)\n{\n    __self_view __sv = __t;\n    size_type __sz = __sv.size();\n    if (__pos > __sz)\n        this->__throw_out_of_range();\n    return append(__sv.data() + __pos, _VSTD::min(__n, __sz - __pos));\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::append(const value_type* __s)\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"string::append received nullptr\");\n    return append(__s, traits_type::length(__s));\n}\n\n// insert\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::insert(size_type __pos, const value_type* __s, size_type __n)\n{\n    _LIBCPP_ASSERT(__n == 0 || __s != nullptr, \"string::insert received nullptr\");\n    size_type __sz = size();\n    if (__pos > __sz)\n        this->__throw_out_of_range();\n    size_type __cap = capacity();\n    if (__cap - __sz >= __n)\n    {\n        if (__n)\n        {\n            value_type* __p = _VSTD::__to_raw_pointer(__get_pointer());\n            size_type __n_move = __sz - __pos;\n            if (__n_move != 0)\n            {\n                if (__p + __pos <= __s && __s < __p + __sz)\n                    __s += __n;\n                traits_type::move(__p + __pos + __n, __p + __pos, __n_move);\n            }\n            traits_type::move(__p + __pos, __s, __n);\n            __sz += __n;\n            __set_size(__sz);\n            traits_type::assign(__p[__sz], value_type());\n        }\n    }\n    else\n        __grow_by_and_replace(__cap, __sz + __n - __cap, __sz, __pos, 0, __n, __s);\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::insert(size_type __pos, size_type __n, value_type __c)\n{\n    size_type __sz = size();\n    if (__pos > __sz)\n        this->__throw_out_of_range();\n    if (__n)\n    {\n        size_type __cap = capacity();\n        value_type* __p;\n        if (__cap - __sz >= __n)\n        {\n            __p = _VSTD::__to_raw_pointer(__get_pointer());\n            size_type __n_move = __sz - __pos;\n            if (__n_move != 0)\n                traits_type::move(__p + __pos + __n, __p + __pos, __n_move);\n        }\n        else\n        {\n            __grow_by(__cap, __sz + __n - __cap, __sz, __pos, 0, __n);\n            __p = _VSTD::__to_raw_pointer(__get_long_pointer());\n        }\n        traits_type::assign(__p + __pos, __n, __c);\n        __sz += __n;\n        __set_size(__sz);\n        traits_type::assign(__p[__sz], value_type());\n    }\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate<class _InputIterator>\ntypename enable_if\n<\n   __is_exactly_input_iterator<_InputIterator>::value\n        || !__libcpp_string_gets_noexcept_iterator<_InputIterator>::value,\n   typename basic_string<_CharT, _Traits, _Allocator>::iterator\n>::type\nbasic_string<_CharT, _Traits, _Allocator>::insert(const_iterator __pos, _InputIterator __first, _InputIterator __last)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__pos) == this,\n        \"string::insert(iterator, range) called with an iterator not\"\n        \" referring to this string\");\n#endif\n    const basic_string __temp(__first, __last, __alloc());\n    return insert(__pos, __temp.data(), __temp.data() + __temp.size());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate<class _ForwardIterator>\ntypename enable_if\n<\n    __is_forward_iterator<_ForwardIterator>::value\n        && __libcpp_string_gets_noexcept_iterator<_ForwardIterator>::value,\n    typename basic_string<_CharT, _Traits, _Allocator>::iterator\n>::type\nbasic_string<_CharT, _Traits, _Allocator>::insert(const_iterator __pos, _ForwardIterator __first, _ForwardIterator __last)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__pos) == this,\n        \"string::insert(iterator, range) called with an iterator not\"\n        \" referring to this string\");\n#endif\n    size_type __ip = static_cast<size_type>(__pos - begin());\n    size_type __n = static_cast<size_type>(_VSTD::distance(__first, __last));\n    if (__n)\n    {\n        typedef typename iterator_traits<_ForwardIterator>::reference _CharRef;\n        _CharRef __tmp_char = *__first;\n        if (__ptr_in_range(_VSTD::addressof(__tmp_char), data(), data() + size()))\n        {\n            const basic_string __temp(__first, __last, __alloc());\n            return insert(__pos, __temp.data(), __temp.data() + __temp.size());\n        }\n\n        size_type __sz = size();\n        size_type __cap = capacity();\n        value_type* __p;\n        if (__cap - __sz >= __n)\n        {\n            __p = _VSTD::__to_raw_pointer(__get_pointer());\n            size_type __n_move = __sz - __ip;\n            if (__n_move != 0)\n                traits_type::move(__p + __ip + __n, __p + __ip, __n_move);\n        }\n        else\n        {\n            __grow_by(__cap, __sz + __n - __cap, __sz, __ip, 0, __n);\n            __p = _VSTD::__to_raw_pointer(__get_long_pointer());\n        }\n        __sz += __n;\n        __set_size(__sz);\n        traits_type::assign(__p[__sz], value_type());\n        for (__p += __ip; __first != __last; ++__p, ++__first)\n            traits_type::assign(*__p, *__first);\n    }\n    return begin() + __ip;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::insert(size_type __pos1, const basic_string& __str)\n{\n    return insert(__pos1, __str.data(), __str.size());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::insert(size_type __pos1, const basic_string& __str,\n                                                  size_type __pos2, size_type __n)\n{\n    size_type __str_sz = __str.size();\n    if (__pos2 > __str_sz)\n        this->__throw_out_of_range();\n    return insert(__pos1, __str.data() + __pos2, _VSTD::min(__n, __str_sz - __pos2));\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate <class _Tp>\ntypename enable_if\n<\n    __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,\n\tbasic_string<_CharT, _Traits, _Allocator>&\n>::type\nbasic_string<_CharT, _Traits, _Allocator>::insert(size_type __pos1, const _Tp& __t,\n                                                  size_type __pos2, size_type __n)\n{\n    __self_view __sv = __t;\n    size_type __str_sz = __sv.size();\n    if (__pos2 > __str_sz)\n        this->__throw_out_of_range();\n    return insert(__pos1, __sv.data() + __pos2, _VSTD::min(__n, __str_sz - __pos2));\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::insert(size_type __pos, const value_type* __s)\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"string::insert received nullptr\");\n    return insert(__pos, __s, traits_type::length(__s));\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::iterator\nbasic_string<_CharT, _Traits, _Allocator>::insert(const_iterator __pos, value_type __c)\n{\n    size_type __ip = static_cast<size_type>(__pos - begin());\n    size_type __sz = size();\n    size_type __cap = capacity();\n    value_type* __p;\n    if (__cap == __sz)\n    {\n        __grow_by(__cap, 1, __sz, __ip, 0, 1);\n        __p = _VSTD::__to_raw_pointer(__get_long_pointer());\n    }\n    else\n    {\n        __p = _VSTD::__to_raw_pointer(__get_pointer());\n        size_type __n_move = __sz - __ip;\n        if (__n_move != 0)\n            traits_type::move(__p + __ip + 1, __p + __ip, __n_move);\n    }\n    traits_type::assign(__p[__ip], __c);\n    traits_type::assign(__p[++__sz], value_type());\n    __set_size(__sz);\n    return begin() + static_cast<difference_type>(__ip);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::iterator\nbasic_string<_CharT, _Traits, _Allocator>::insert(const_iterator __pos, size_type __n, value_type __c)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__pos) == this,\n        \"string::insert(iterator, n, value) called with an iterator not\"\n        \" referring to this string\");\n#endif\n    difference_type __p = __pos - begin();\n    insert(static_cast<size_type>(__p), __n, __c);\n    return begin() + __p;\n}\n\n// replace\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::replace(size_type __pos, size_type __n1, const value_type* __s, size_type __n2)\n{\n    _LIBCPP_ASSERT(__n2 == 0 || __s != nullptr, \"string::replace received nullptr\");\n    size_type __sz = size();\n    if (__pos > __sz)\n        this->__throw_out_of_range();\n    __n1 = _VSTD::min(__n1, __sz - __pos);\n    size_type __cap = capacity();\n    if (__cap - __sz + __n1 >= __n2)\n    {\n        value_type* __p = _VSTD::__to_raw_pointer(__get_pointer());\n        if (__n1 != __n2)\n        {\n            size_type __n_move = __sz - __pos - __n1;\n            if (__n_move != 0)\n            {\n                if (__n1 > __n2)\n                {\n                    traits_type::move(__p + __pos, __s, __n2);\n                    traits_type::move(__p + __pos + __n2, __p + __pos + __n1, __n_move);\n                    goto __finish;\n                }\n                if (__p + __pos < __s && __s < __p + __sz)\n                {\n                    if (__p + __pos + __n1 <= __s)\n                        __s += __n2 - __n1;\n                    else // __p + __pos < __s < __p + __pos + __n1\n                    {\n                        traits_type::move(__p + __pos, __s, __n1);\n                        __pos += __n1;\n                        __s += __n2;\n                        __n2 -= __n1;\n                        __n1 = 0;\n                    }\n                }\n                traits_type::move(__p + __pos + __n2, __p + __pos + __n1, __n_move);\n            }\n        }\n        traits_type::move(__p + __pos, __s, __n2);\n__finish:\n        __sz += __n2 - __n1;\n        __set_size(__sz);\n        __invalidate_iterators_past(__sz);\n        traits_type::assign(__p[__sz], value_type());\n    }\n    else\n        __grow_by_and_replace(__cap, __sz - __n1 + __n2 - __cap, __sz, __pos, __n1, __n2, __s);\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::replace(size_type __pos, size_type __n1, size_type __n2, value_type __c)\n{\n    size_type __sz = size();\n    if (__pos > __sz)\n        this->__throw_out_of_range();\n    __n1 = _VSTD::min(__n1, __sz - __pos);\n    size_type __cap = capacity();\n    value_type* __p;\n    if (__cap - __sz + __n1 >= __n2)\n    {\n        __p = _VSTD::__to_raw_pointer(__get_pointer());\n        if (__n1 != __n2)\n        {\n            size_type __n_move = __sz - __pos - __n1;\n            if (__n_move != 0)\n                traits_type::move(__p + __pos + __n2, __p + __pos + __n1, __n_move);\n        }\n    }\n    else\n    {\n        __grow_by(__cap, __sz - __n1 + __n2 - __cap, __sz, __pos, __n1, __n2);\n        __p = _VSTD::__to_raw_pointer(__get_long_pointer());\n    }\n    traits_type::assign(__p + __pos, __n2, __c);\n    __sz += __n2 - __n1;\n    __set_size(__sz);\n    __invalidate_iterators_past(__sz);\n    traits_type::assign(__p[__sz], value_type());\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate<class _InputIterator>\ntypename enable_if\n<\n    __is_input_iterator<_InputIterator>::value,\n    basic_string<_CharT, _Traits, _Allocator>&\n>::type\nbasic_string<_CharT, _Traits, _Allocator>::replace(const_iterator __i1, const_iterator __i2,\n                                                   _InputIterator __j1, _InputIterator __j2)\n{\n    const basic_string __temp(__j1, __j2, __alloc());\n    return this->replace(__i1, __i2, __temp);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::replace(size_type __pos1, size_type __n1, const basic_string& __str)\n{\n    return replace(__pos1, __n1, __str.data(), __str.size());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::replace(size_type __pos1, size_type __n1, const basic_string& __str,\n                                                   size_type __pos2, size_type __n2)\n{\n    size_type __str_sz = __str.size();\n    if (__pos2 > __str_sz)\n        this->__throw_out_of_range();\n    return replace(__pos1, __n1, __str.data() + __pos2, _VSTD::min(__n2, __str_sz - __pos2));\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate <class _Tp>\ntypename enable_if\n<\n\t__can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,\n\tbasic_string<_CharT, _Traits, _Allocator>&\n>::type\nbasic_string<_CharT, _Traits, _Allocator>::replace(size_type __pos1, size_type __n1, const _Tp& __t,\n                                                   size_type __pos2, size_type __n2)\n{\n    __self_view __sv = __t;\n    size_type __str_sz = __sv.size();\n    if (__pos2 > __str_sz)\n        this->__throw_out_of_range();\n    return replace(__pos1, __n1, __sv.data() + __pos2, _VSTD::min(__n2, __str_sz - __pos2));\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::replace(size_type __pos, size_type __n1, const value_type* __s)\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"string::replace received nullptr\");\n    return replace(__pos, __n1, __s, traits_type::length(__s));\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::replace(const_iterator __i1, const_iterator __i2, const basic_string& __str)\n{\n    return replace(static_cast<size_type>(__i1 - begin()), static_cast<size_type>(__i2 - __i1),\n                   __str.data(), __str.size());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::replace(const_iterator __i1, const_iterator __i2, const value_type* __s, size_type __n)\n{\n    return replace(static_cast<size_type>(__i1 - begin()), static_cast<size_type>(__i2 - __i1), __s, __n);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::replace(const_iterator __i1, const_iterator __i2, const value_type* __s)\n{\n    return replace(static_cast<size_type>(__i1 - begin()), static_cast<size_type>(__i2 - __i1), __s);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::replace(const_iterator __i1, const_iterator __i2, size_type __n, value_type __c)\n{\n    return replace(static_cast<size_type>(__i1 - begin()), static_cast<size_type>(__i2 - __i1), __n, __c);\n}\n\n// erase\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::erase(size_type __pos, size_type __n)\n{\n    size_type __sz = size();\n    if (__pos > __sz)\n        this->__throw_out_of_range();\n    if (__n)\n    {\n        value_type* __p = _VSTD::__to_raw_pointer(__get_pointer());\n        __n = _VSTD::min(__n, __sz - __pos);\n        size_type __n_move = __sz - __pos - __n;\n        if (__n_move != 0)\n            traits_type::move(__p + __pos, __p + __pos + __n, __n_move);\n        __sz -= __n;\n        __set_size(__sz);\n        __invalidate_iterators_past(__sz);\n        traits_type::assign(__p[__sz], value_type());\n    }\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::iterator\nbasic_string<_CharT, _Traits, _Allocator>::erase(const_iterator __pos)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__pos) == this,\n        \"string::erase(iterator) called with an iterator not\"\n        \" referring to this string\");\n#endif\n    _LIBCPP_ASSERT(__pos != end(),\n        \"string::erase(iterator) called with a non-dereferenceable iterator\");\n    iterator __b = begin();\n    size_type __r = static_cast<size_type>(__pos - __b);\n    erase(__r, 1);\n    return __b + static_cast<difference_type>(__r);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::iterator\nbasic_string<_CharT, _Traits, _Allocator>::erase(const_iterator __first, const_iterator __last)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__first) == this,\n        \"string::erase(iterator,  iterator) called with an iterator not\"\n        \" referring to this string\");\n#endif\n    _LIBCPP_ASSERT(__first <= __last, \"string::erase(first, last) called with invalid range\");\n    iterator __b = begin();\n    size_type __r = static_cast<size_type>(__first - __b);\n    erase(__r, static_cast<size_type>(__last - __first));\n    return __b + static_cast<difference_type>(__r);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::pop_back()\n{\n    _LIBCPP_ASSERT(!empty(), \"string::pop_back(): string is already empty\");\n    size_type __sz;\n    if (__is_long())\n    {\n        __sz = __get_long_size() - 1;\n        __set_long_size(__sz);\n        traits_type::assign(*(__get_long_pointer() + __sz), value_type());\n    }\n    else\n    {\n        __sz = __get_short_size() - 1;\n        __set_short_size(__sz);\n        traits_type::assign(*(__get_short_pointer() + __sz), value_type());\n    }\n    __invalidate_iterators_past(__sz);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::clear() _NOEXCEPT\n{\n    __invalidate_all_iterators();\n    if (__is_long())\n    {\n        traits_type::assign(*__get_long_pointer(), value_type());\n        __set_long_size(0);\n    }\n    else\n    {\n        traits_type::assign(*__get_short_pointer(), value_type());\n        __set_short_size(0);\n    }\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::__erase_to_end(size_type __pos)\n{\n    if (__is_long())\n    {\n        traits_type::assign(*(__get_long_pointer() + __pos), value_type());\n        __set_long_size(__pos);\n    }\n    else\n    {\n        traits_type::assign(*(__get_short_pointer() + __pos), value_type());\n        __set_short_size(__pos);\n    }\n    __invalidate_iterators_past(__pos);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::resize(size_type __n, value_type __c)\n{\n    size_type __sz = size();\n    if (__n > __sz)\n        append(__n - __sz, __c);\n    else\n        __erase_to_end(__n);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::max_size() const _NOEXCEPT\n{\n    size_type __m = __alloc_traits::max_size(__alloc());\n#if _LIBCPP_BIG_ENDIAN\n    return (__m <= ~__long_mask ? __m : __m/2) - __alignment;\n#else\n    return __m - __alignment;\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::reserve(size_type __res_arg)\n{\n    if (__res_arg > max_size())\n        this->__throw_length_error();\n    size_type __cap = capacity();\n    size_type __sz = size();\n    __res_arg = _VSTD::max(__res_arg, __sz);\n    __res_arg = __recommend(__res_arg);\n    if (__res_arg != __cap)\n    {\n        pointer __new_data, __p;\n        bool __was_long, __now_long;\n        if (__res_arg == __min_cap - 1)\n        {\n            __was_long = true;\n            __now_long = false;\n            __new_data = __get_short_pointer();\n            __p = __get_long_pointer();\n        }\n        else\n        {\n            if (__res_arg > __cap)\n                __new_data = __alloc_traits::allocate(__alloc(), __res_arg+1);\n            else\n            {\n            #ifndef _LIBCPP_NO_EXCEPTIONS\n                try\n                {\n            #endif  // _LIBCPP_NO_EXCEPTIONS\n                    __new_data = __alloc_traits::allocate(__alloc(), __res_arg+1);\n            #ifndef _LIBCPP_NO_EXCEPTIONS\n                }\n                catch (...)\n                {\n                    return;\n                }\n            #else  // _LIBCPP_NO_EXCEPTIONS\n                if (__new_data == nullptr)\n                    return;\n            #endif  // _LIBCPP_NO_EXCEPTIONS\n            }\n            __now_long = true;\n            __was_long = __is_long();\n            __p = __get_pointer();\n        }\n        traits_type::copy(_VSTD::__to_raw_pointer(__new_data),\n                          _VSTD::__to_raw_pointer(__p), size()+1);\n        if (__was_long)\n            __alloc_traits::deallocate(__alloc(), __p, __cap+1);\n        if (__now_long)\n        {\n            __set_long_cap(__res_arg+1);\n            __set_long_size(__sz);\n            __set_long_pointer(__new_data);\n        }\n        else\n            __set_short_size(__sz);\n        __invalidate_all_iterators();\n    }\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::const_reference\nbasic_string<_CharT, _Traits, _Allocator>::operator[](size_type __pos) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__pos <= size(), \"string index out of bounds\");\n    return *(data() + __pos);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::reference\nbasic_string<_CharT, _Traits, _Allocator>::operator[](size_type __pos) _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__pos <= size(), \"string index out of bounds\");\n    return *(__get_pointer() + __pos);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::const_reference\nbasic_string<_CharT, _Traits, _Allocator>::at(size_type __n) const\n{\n    if (__n >= size())\n        this->__throw_out_of_range();\n    return (*this)[__n];\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::reference\nbasic_string<_CharT, _Traits, _Allocator>::at(size_type __n)\n{\n    if (__n >= size())\n        this->__throw_out_of_range();\n    return (*this)[__n];\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::reference\nbasic_string<_CharT, _Traits, _Allocator>::front()\n{\n    _LIBCPP_ASSERT(!empty(), \"string::front(): string is empty\");\n    return *__get_pointer();\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::const_reference\nbasic_string<_CharT, _Traits, _Allocator>::front() const\n{\n    _LIBCPP_ASSERT(!empty(), \"string::front(): string is empty\");\n    return *data();\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::reference\nbasic_string<_CharT, _Traits, _Allocator>::back()\n{\n    _LIBCPP_ASSERT(!empty(), \"string::back(): string is empty\");\n    return *(__get_pointer() + size() - 1);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::const_reference\nbasic_string<_CharT, _Traits, _Allocator>::back() const\n{\n    _LIBCPP_ASSERT(!empty(), \"string::back(): string is empty\");\n    return *(data() + size() - 1);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::copy(value_type* __s, size_type __n, size_type __pos) const\n{\n    size_type __sz = size();\n    if (__pos > __sz)\n        this->__throw_out_of_range();\n    size_type __rlen = _VSTD::min(__n, __sz - __pos);\n    traits_type::copy(__s, data() + __pos, __rlen);\n    return __rlen;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>::substr(size_type __pos, size_type __n) const\n{\n    return basic_string(*this, __pos, __n, __alloc());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::swap(basic_string& __str)\n#if _LIBCPP_STD_VER >= 14\n        _NOEXCEPT_DEBUG\n#else\n        _NOEXCEPT_DEBUG_(!__alloc_traits::propagate_on_container_swap::value ||\n                    __is_nothrow_swappable<allocator_type>::value)\n#endif\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    if (!__is_long())\n        __get_db()->__invalidate_all(this);\n    if (!__str.__is_long())\n        __get_db()->__invalidate_all(&__str);\n    __get_db()->swap(this, &__str);\n#endif\n    _LIBCPP_ASSERT(\n        __alloc_traits::propagate_on_container_swap::value ||\n        __alloc_traits::is_always_equal::value ||\n        __alloc() == __str.__alloc(), \"swapping non-equal allocators\");\n    _VSTD::swap(__r_.first(), __str.__r_.first());\n    __swap_allocator(__alloc(), __str.__alloc());\n}\n\n// find\n\ntemplate <class _Traits>\nstruct _LIBCPP_HIDDEN __traits_eq\n{\n    typedef typename _Traits::char_type char_type;\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const char_type& __x, const char_type& __y) _NOEXCEPT\n        {return _Traits::eq(__x, __y);}\n};\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find(const value_type* __s,\n                                                size_type __pos,\n                                                size_type __n) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__n == 0 || __s != nullptr, \"string::find(): received nullptr\");\n    return __str_find<value_type, size_type, traits_type, npos>\n        (data(), size(), __s, __pos, __n);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find(const basic_string& __str,\n                                                size_type __pos) const _NOEXCEPT\n{\n    return __str_find<value_type, size_type, traits_type, npos>\n        (data(), size(), __str.data(), __pos, __str.size());\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find(__self_view __sv,\n                                                size_type __pos) const _NOEXCEPT\n{\n    return __str_find<value_type, size_type, traits_type, npos>\n        (data(), size(), __sv.data(), __pos, __sv.size());\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find(const value_type* __s,\n                                                size_type __pos) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"string::find(): received nullptr\");\n    return __str_find<value_type, size_type, traits_type, npos>\n        (data(), size(), __s, __pos, traits_type::length(__s));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find(value_type __c,\n                                                size_type __pos) const _NOEXCEPT\n{\n    return __str_find<value_type, size_type, traits_type, npos>\n        (data(), size(), __c, __pos);\n}\n\n// rfind\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::rfind(const value_type* __s,\n                                                 size_type __pos,\n                                                 size_type __n) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__n == 0 || __s != nullptr, \"string::rfind(): received nullptr\");\n    return __str_rfind<value_type, size_type, traits_type, npos>\n        (data(), size(), __s, __pos, __n);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::rfind(const basic_string& __str,\n                                                 size_type __pos) const _NOEXCEPT\n{\n    return __str_rfind<value_type, size_type, traits_type, npos>\n        (data(), size(), __str.data(), __pos, __str.size());\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::rfind(__self_view __sv,\n                                                size_type __pos) const _NOEXCEPT\n{\n    return __str_rfind<value_type, size_type, traits_type, npos>\n        (data(), size(), __sv.data(), __pos, __sv.size());\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::rfind(const value_type* __s,\n                                                 size_type __pos) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"string::rfind(): received nullptr\");\n    return __str_rfind<value_type, size_type, traits_type, npos>\n        (data(), size(), __s, __pos, traits_type::length(__s));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::rfind(value_type __c,\n                                                 size_type __pos) const _NOEXCEPT\n{\n    return __str_rfind<value_type, size_type, traits_type, npos>\n        (data(), size(), __c, __pos);\n}\n\n// find_first_of\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_first_of(const value_type* __s,\n                                                         size_type __pos,\n                                                         size_type __n) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__n == 0 || __s != nullptr, \"string::find_first_of(): received nullptr\");\n    return __str_find_first_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __s, __pos, __n);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_first_of(const basic_string& __str,\n                                                         size_type __pos) const _NOEXCEPT\n{\n    return __str_find_first_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __str.data(), __pos, __str.size());\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_first_of(__self_view __sv,\n                                                size_type __pos) const _NOEXCEPT\n{\n    return __str_find_first_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __sv.data(), __pos, __sv.size());\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_first_of(const value_type* __s,\n                                                         size_type __pos) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"string::find_first_of(): received nullptr\");\n    return __str_find_first_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __s, __pos, traits_type::length(__s));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_first_of(value_type __c,\n                                                         size_type __pos) const _NOEXCEPT\n{\n    return find(__c, __pos);\n}\n\n// find_last_of\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_last_of(const value_type* __s,\n                                                        size_type __pos,\n                                                        size_type __n) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__n == 0 || __s != nullptr, \"string::find_last_of(): received nullptr\");\n    return __str_find_last_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __s, __pos, __n);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_last_of(const basic_string& __str,\n                                                        size_type __pos) const _NOEXCEPT\n{\n    return __str_find_last_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __str.data(), __pos, __str.size());\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_last_of(__self_view __sv,\n                                                size_type __pos) const _NOEXCEPT\n{\n    return __str_find_last_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __sv.data(), __pos, __sv.size());\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_last_of(const value_type* __s,\n                                                        size_type __pos) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"string::find_last_of(): received nullptr\");\n    return __str_find_last_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __s, __pos, traits_type::length(__s));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_last_of(value_type __c,\n                                                        size_type __pos) const _NOEXCEPT\n{\n    return rfind(__c, __pos);\n}\n\n// find_first_not_of\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_first_not_of(const value_type* __s,\n                                                             size_type __pos,\n                                                             size_type __n) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__n == 0 || __s != nullptr, \"string::find_first_not_of(): received nullptr\");\n    return __str_find_first_not_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __s, __pos, __n);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_first_not_of(const basic_string& __str,\n                                                             size_type __pos) const _NOEXCEPT\n{\n    return __str_find_first_not_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __str.data(), __pos, __str.size());\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_first_not_of(__self_view __sv,\n                                                size_type __pos) const _NOEXCEPT\n{\n    return __str_find_first_not_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __sv.data(), __pos, __sv.size());\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_first_not_of(const value_type* __s,\n                                                             size_type __pos) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"string::find_first_not_of(): received nullptr\");\n    return __str_find_first_not_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __s, __pos, traits_type::length(__s));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_first_not_of(value_type __c,\n                                                             size_type __pos) const _NOEXCEPT\n{\n    return __str_find_first_not_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __c, __pos);\n}\n\n// find_last_not_of\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_last_not_of(const value_type* __s,\n                                                            size_type __pos,\n                                                            size_type __n) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__n == 0 || __s != nullptr, \"string::find_last_not_of(): received nullptr\");\n    return __str_find_last_not_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __s, __pos, __n);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_last_not_of(const basic_string& __str,\n                                                            size_type __pos) const _NOEXCEPT\n{\n    return __str_find_last_not_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __str.data(), __pos, __str.size());\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_last_not_of(__self_view __sv,\n                                                size_type __pos) const _NOEXCEPT\n{\n    return __str_find_last_not_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __sv.data(), __pos, __sv.size());\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_last_not_of(const value_type* __s,\n                                                            size_type __pos) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"string::find_last_not_of(): received nullptr\");\n    return __str_find_last_not_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __s, __pos, traits_type::length(__s));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_last_not_of(value_type __c,\n                                                            size_type __pos) const _NOEXCEPT\n{\n    return __str_find_last_not_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __c, __pos);\n}\n\n// compare\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nint\nbasic_string<_CharT, _Traits, _Allocator>::compare(__self_view __sv) const _NOEXCEPT\n{\n    size_t __lhs_sz = size();\n    size_t __rhs_sz = __sv.size();\n    int __result = traits_type::compare(data(), __sv.data(),\n                                        _VSTD::min(__lhs_sz, __rhs_sz));\n    if (__result != 0)\n        return __result;\n    if (__lhs_sz < __rhs_sz)\n        return -1;\n    if (__lhs_sz > __rhs_sz)\n        return 1;\n    return 0;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nint\nbasic_string<_CharT, _Traits, _Allocator>::compare(const basic_string& __str) const _NOEXCEPT\n{\n    return compare(__self_view(__str));\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nint\nbasic_string<_CharT, _Traits, _Allocator>::compare(size_type __pos1,\n                                                   size_type __n1,\n                                                   const value_type* __s,\n                                                   size_type __n2) const\n{\n    _LIBCPP_ASSERT(__n2 == 0 || __s != nullptr, \"string::compare(): received nullptr\");\n    size_type __sz = size();\n    if (__pos1 > __sz || __n2 == npos)\n        this->__throw_out_of_range();\n    size_type __rlen = _VSTD::min(__n1, __sz - __pos1);\n    int __r = traits_type::compare(data() + __pos1, __s, _VSTD::min(__rlen, __n2));\n    if (__r == 0)\n    {\n        if (__rlen < __n2)\n            __r = -1;\n        else if (__rlen > __n2)\n            __r = 1;\n    }\n    return __r;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nint\nbasic_string<_CharT, _Traits, _Allocator>::compare(size_type __pos1,\n                                                   size_type __n1,\n                                                   __self_view __sv) const\n{\n    return compare(__pos1, __n1, __sv.data(), __sv.size());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nint\nbasic_string<_CharT, _Traits, _Allocator>::compare(size_type __pos1,\n                                                   size_type __n1,\n                                                   const basic_string& __str) const\n{\n    return compare(__pos1, __n1, __str.data(), __str.size());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate <class _Tp>\ntypename enable_if\n<\n\t__can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,\n\tint\n>::type\nbasic_string<_CharT, _Traits, _Allocator>::compare(size_type __pos1,\n                                                   size_type __n1,\n                                                   const _Tp& __t,\n                                                   size_type __pos2,\n                                                   size_type __n2) const\n{\n    __self_view __sv = __t;\n    return __self_view(*this).substr(__pos1, __n1).compare(__sv.substr(__pos2, __n2));\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nint\nbasic_string<_CharT, _Traits, _Allocator>::compare(size_type __pos1,\n                                                   size_type __n1,\n                                                   const basic_string& __str,\n                                                   size_type __pos2,\n                                                   size_type __n2) const\n{\n        return compare(__pos1, __n1, __self_view(__str), __pos2, __n2);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nint\nbasic_string<_CharT, _Traits, _Allocator>::compare(const value_type* __s) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"string::compare(): received nullptr\");\n    return compare(0, npos, __s, traits_type::length(__s));\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nint\nbasic_string<_CharT, _Traits, _Allocator>::compare(size_type __pos1,\n                                                   size_type __n1,\n                                                   const value_type* __s) const\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"string::compare(): received nullptr\");\n    return compare(__pos1, __n1, __s, traits_type::length(__s));\n}\n\n// __invariants\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nbasic_string<_CharT, _Traits, _Allocator>::__invariants() const\n{\n    if (size() > capacity())\n        return false;\n    if (capacity() < __min_cap - 1)\n        return false;\n    if (data() == 0)\n        return false;\n    if (data()[size()] != value_type(0))\n        return false;\n    return true;\n}\n\n// operator==\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const basic_string<_CharT, _Traits, _Allocator>& __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    size_t __lhs_sz = __lhs.size();\n    return __lhs_sz == __rhs.size() && _Traits::compare(__lhs.data(),\n                                                        __rhs.data(),\n                                                        __lhs_sz) == 0;\n}\n\ntemplate<class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const basic_string<char, char_traits<char>, _Allocator>& __lhs,\n           const basic_string<char, char_traits<char>, _Allocator>& __rhs) _NOEXCEPT\n{\n    size_t __lhs_sz = __lhs.size();\n    if (__lhs_sz != __rhs.size())\n        return false;\n    const char* __lp = __lhs.data();\n    const char* __rp = __rhs.data();\n    if (__lhs.__is_long())\n        return char_traits<char>::compare(__lp, __rp, __lhs_sz) == 0;\n    for (; __lhs_sz != 0; --__lhs_sz, ++__lp, ++__rp)\n        if (*__lp != *__rp)\n            return false;\n    return true;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const _CharT* __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    typedef basic_string<_CharT, _Traits, _Allocator> _String;\n    _LIBCPP_ASSERT(__lhs != nullptr, \"operator==(char*, basic_string): received nullptr\");\n    size_t __lhs_len = _Traits::length(__lhs);\n    if (__lhs_len != __rhs.size()) return false;\n    return __rhs.compare(0, _String::npos, __lhs, __lhs_len) == 0;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const basic_string<_CharT,_Traits,_Allocator>& __lhs,\n           const _CharT* __rhs) _NOEXCEPT\n{\n    typedef basic_string<_CharT, _Traits, _Allocator> _String;\n    _LIBCPP_ASSERT(__rhs != nullptr, \"operator==(basic_string, char*): received nullptr\");\n    size_t __rhs_len = _Traits::length(__rhs);\n    if (__rhs_len != __lhs.size()) return false;\n    return __lhs.compare(0, _String::npos, __rhs, __rhs_len) == 0;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const basic_string<_CharT,_Traits,_Allocator>& __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    return !(__lhs == __rhs);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const _CharT* __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    return !(__lhs == __rhs);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const basic_string<_CharT, _Traits, _Allocator>& __lhs,\n           const _CharT* __rhs) _NOEXCEPT\n{\n    return !(__lhs == __rhs);\n}\n\n// operator<\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator< (const basic_string<_CharT, _Traits, _Allocator>& __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    return __lhs.compare(__rhs) < 0;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator< (const basic_string<_CharT, _Traits, _Allocator>& __lhs,\n           const _CharT* __rhs) _NOEXCEPT\n{\n    return __lhs.compare(__rhs) < 0;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator< (const _CharT* __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    return __rhs.compare(__lhs) > 0;\n}\n\n// operator>\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator> (const basic_string<_CharT, _Traits, _Allocator>& __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    return __rhs < __lhs;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator> (const basic_string<_CharT, _Traits, _Allocator>& __lhs,\n           const _CharT* __rhs) _NOEXCEPT\n{\n    return __rhs < __lhs;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator> (const _CharT* __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    return __rhs < __lhs;\n}\n\n// operator<=\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const basic_string<_CharT, _Traits, _Allocator>& __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    return !(__rhs < __lhs);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const basic_string<_CharT, _Traits, _Allocator>& __lhs,\n           const _CharT* __rhs) _NOEXCEPT\n{\n    return !(__rhs < __lhs);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const _CharT* __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    return !(__rhs < __lhs);\n}\n\n// operator>=\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const basic_string<_CharT, _Traits, _Allocator>& __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    return !(__lhs < __rhs);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const basic_string<_CharT, _Traits, _Allocator>& __lhs,\n           const _CharT* __rhs) _NOEXCEPT\n{\n    return !(__lhs < __rhs);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const _CharT* __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    return !(__lhs < __rhs);\n}\n\n// operator +\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(const basic_string<_CharT, _Traits, _Allocator>& __lhs,\n          const basic_string<_CharT, _Traits, _Allocator>& __rhs)\n{\n    basic_string<_CharT, _Traits, _Allocator> __r(__lhs.get_allocator());\n    typename basic_string<_CharT, _Traits, _Allocator>::size_type __lhs_sz = __lhs.size();\n    typename basic_string<_CharT, _Traits, _Allocator>::size_type __rhs_sz = __rhs.size();\n    __r.__init(__lhs.data(), __lhs_sz, __lhs_sz + __rhs_sz);\n    __r.append(__rhs.data(), __rhs_sz);\n    return __r;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(const _CharT* __lhs , const basic_string<_CharT,_Traits,_Allocator>& __rhs)\n{\n    basic_string<_CharT, _Traits, _Allocator> __r(__rhs.get_allocator());\n    typename basic_string<_CharT, _Traits, _Allocator>::size_type __lhs_sz = _Traits::length(__lhs);\n    typename basic_string<_CharT, _Traits, _Allocator>::size_type __rhs_sz = __rhs.size();\n    __r.__init(__lhs, __lhs_sz, __lhs_sz + __rhs_sz);\n    __r.append(__rhs.data(), __rhs_sz);\n    return __r;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(_CharT __lhs, const basic_string<_CharT,_Traits,_Allocator>& __rhs)\n{\n    basic_string<_CharT, _Traits, _Allocator> __r(__rhs.get_allocator());\n    typename basic_string<_CharT, _Traits, _Allocator>::size_type __rhs_sz = __rhs.size();\n    __r.__init(&__lhs, 1, 1 + __rhs_sz);\n    __r.append(__rhs.data(), __rhs_sz);\n    return __r;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(const basic_string<_CharT, _Traits, _Allocator>& __lhs, const _CharT* __rhs)\n{\n    basic_string<_CharT, _Traits, _Allocator> __r(__lhs.get_allocator());\n    typename basic_string<_CharT, _Traits, _Allocator>::size_type __lhs_sz = __lhs.size();\n    typename basic_string<_CharT, _Traits, _Allocator>::size_type __rhs_sz = _Traits::length(__rhs);\n    __r.__init(__lhs.data(), __lhs_sz, __lhs_sz + __rhs_sz);\n    __r.append(__rhs, __rhs_sz);\n    return __r;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(const basic_string<_CharT, _Traits, _Allocator>& __lhs, _CharT __rhs)\n{\n    basic_string<_CharT, _Traits, _Allocator> __r(__lhs.get_allocator());\n    typename basic_string<_CharT, _Traits, _Allocator>::size_type __lhs_sz = __lhs.size();\n    __r.__init(__lhs.data(), __lhs_sz, __lhs_sz + 1);\n    __r.push_back(__rhs);\n    return __r;\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(basic_string<_CharT, _Traits, _Allocator>&& __lhs, const basic_string<_CharT, _Traits, _Allocator>& __rhs)\n{\n    return _VSTD::move(__lhs.append(__rhs));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(const basic_string<_CharT, _Traits, _Allocator>& __lhs, basic_string<_CharT, _Traits, _Allocator>&& __rhs)\n{\n    return _VSTD::move(__rhs.insert(0, __lhs));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(basic_string<_CharT, _Traits, _Allocator>&& __lhs, basic_string<_CharT, _Traits, _Allocator>&& __rhs)\n{\n    return _VSTD::move(__lhs.append(__rhs));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(const _CharT* __lhs , basic_string<_CharT,_Traits,_Allocator>&& __rhs)\n{\n    return _VSTD::move(__rhs.insert(0, __lhs));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(_CharT __lhs, basic_string<_CharT,_Traits,_Allocator>&& __rhs)\n{\n    __rhs.insert(__rhs.begin(), __lhs);\n    return _VSTD::move(__rhs);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(basic_string<_CharT, _Traits, _Allocator>&& __lhs, const _CharT* __rhs)\n{\n    return _VSTD::move(__lhs.append(__rhs));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(basic_string<_CharT, _Traits, _Allocator>&& __lhs, _CharT __rhs)\n{\n    __lhs.push_back(__rhs);\n    return _VSTD::move(__lhs);\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n// swap\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(basic_string<_CharT, _Traits, _Allocator>& __lhs,\n     basic_string<_CharT, _Traits, _Allocator>& __rhs)\n     _NOEXCEPT_(_NOEXCEPT_(__lhs.swap(__rhs)))\n{\n    __lhs.swap(__rhs);\n}\n\n#ifndef _LIBCPP_HAS_NO_UNICODE_CHARS\n\ntypedef basic_string<char16_t> u16string;\ntypedef basic_string<char32_t> u32string;\n\n#endif  // _LIBCPP_HAS_NO_UNICODE_CHARS\n\n_LIBCPP_FUNC_VIS int                stoi  (const string& __str, size_t* __idx = 0, int __base = 10);\n_LIBCPP_FUNC_VIS long               stol  (const string& __str, size_t* __idx = 0, int __base = 10);\n_LIBCPP_FUNC_VIS unsigned long      stoul (const string& __str, size_t* __idx = 0, int __base = 10);\n_LIBCPP_FUNC_VIS long long          stoll (const string& __str, size_t* __idx = 0, int __base = 10);\n_LIBCPP_FUNC_VIS unsigned long long stoull(const string& __str, size_t* __idx = 0, int __base = 10);\n\n_LIBCPP_FUNC_VIS float       stof (const string& __str, size_t* __idx = 0);\n_LIBCPP_FUNC_VIS double      stod (const string& __str, size_t* __idx = 0);\n_LIBCPP_FUNC_VIS long double stold(const string& __str, size_t* __idx = 0);\n\n_LIBCPP_FUNC_VIS string to_string(int __val);\n_LIBCPP_FUNC_VIS string to_string(unsigned __val);\n_LIBCPP_FUNC_VIS string to_string(long __val);\n_LIBCPP_FUNC_VIS string to_string(unsigned long __val);\n_LIBCPP_FUNC_VIS string to_string(long long __val);\n_LIBCPP_FUNC_VIS string to_string(unsigned long long __val);\n_LIBCPP_FUNC_VIS string to_string(float __val);\n_LIBCPP_FUNC_VIS string to_string(double __val);\n_LIBCPP_FUNC_VIS string to_string(long double __val);\n\n_LIBCPP_FUNC_VIS int                stoi  (const wstring& __str, size_t* __idx = 0, int __base = 10);\n_LIBCPP_FUNC_VIS long               stol  (const wstring& __str, size_t* __idx = 0, int __base = 10);\n_LIBCPP_FUNC_VIS unsigned long      stoul (const wstring& __str, size_t* __idx = 0, int __base = 10);\n_LIBCPP_FUNC_VIS long long          stoll (const wstring& __str, size_t* __idx = 0, int __base = 10);\n_LIBCPP_FUNC_VIS unsigned long long stoull(const wstring& __str, size_t* __idx = 0, int __base = 10);\n\n_LIBCPP_FUNC_VIS float       stof (const wstring& __str, size_t* __idx = 0);\n_LIBCPP_FUNC_VIS double      stod (const wstring& __str, size_t* __idx = 0);\n_LIBCPP_FUNC_VIS long double stold(const wstring& __str, size_t* __idx = 0);\n\n_LIBCPP_FUNC_VIS wstring to_wstring(int __val);\n_LIBCPP_FUNC_VIS wstring to_wstring(unsigned __val);\n_LIBCPP_FUNC_VIS wstring to_wstring(long __val);\n_LIBCPP_FUNC_VIS wstring to_wstring(unsigned long __val);\n_LIBCPP_FUNC_VIS wstring to_wstring(long long __val);\n_LIBCPP_FUNC_VIS wstring to_wstring(unsigned long long __val);\n_LIBCPP_FUNC_VIS wstring to_wstring(float __val);\n_LIBCPP_FUNC_VIS wstring to_wstring(double __val);\n_LIBCPP_FUNC_VIS wstring to_wstring(long double __val);\n\ntemplate<class _CharT, class _Traits, class _Allocator>\n    const typename basic_string<_CharT, _Traits, _Allocator>::size_type\n                   basic_string<_CharT, _Traits, _Allocator>::npos;\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nstruct _LIBCPP_TEMPLATE_VIS hash<basic_string<_CharT, _Traits, _Allocator> >\n    : public unary_function<basic_string<_CharT, _Traits, _Allocator>, size_t>\n{\n    size_t\n        operator()(const basic_string<_CharT, _Traits, _Allocator>& __val) const _NOEXCEPT;\n};\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nsize_t\nhash<basic_string<_CharT, _Traits, _Allocator> >::operator()(\n        const basic_string<_CharT, _Traits, _Allocator>& __val) const _NOEXCEPT\n{\n    return __do_string_hash(__val.data(), __val.data() + __val.size());\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_ostream<_CharT, _Traits>&\noperator<<(basic_ostream<_CharT, _Traits>& __os,\n           const basic_string<_CharT, _Traits, _Allocator>& __str);\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_istream<_CharT, _Traits>&\noperator>>(basic_istream<_CharT, _Traits>& __is,\n           basic_string<_CharT, _Traits, _Allocator>& __str);\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_istream<_CharT, _Traits>&\ngetline(basic_istream<_CharT, _Traits>& __is,\n        basic_string<_CharT, _Traits, _Allocator>& __str, _CharT __dlm);\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_istream<_CharT, _Traits>&\ngetline(basic_istream<_CharT, _Traits>& __is,\n        basic_string<_CharT, _Traits, _Allocator>& __str);\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_istream<_CharT, _Traits>&\ngetline(basic_istream<_CharT, _Traits>&& __is,\n        basic_string<_CharT, _Traits, _Allocator>& __str, _CharT __dlm);\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_istream<_CharT, _Traits>&\ngetline(basic_istream<_CharT, _Traits>&& __is,\n        basic_string<_CharT, _Traits, _Allocator>& __str);\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n#if _LIBCPP_DEBUG_LEVEL >= 2\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbool\nbasic_string<_CharT, _Traits, _Allocator>::__dereferenceable(const const_iterator* __i) const\n{\n    return this->data() <= _VSTD::__to_raw_pointer(__i->base()) &&\n           _VSTD::__to_raw_pointer(__i->base()) < this->data() + this->size();\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbool\nbasic_string<_CharT, _Traits, _Allocator>::__decrementable(const const_iterator* __i) const\n{\n    return this->data() < _VSTD::__to_raw_pointer(__i->base()) &&\n           _VSTD::__to_raw_pointer(__i->base()) <= this->data() + this->size();\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbool\nbasic_string<_CharT, _Traits, _Allocator>::__addable(const const_iterator* __i, ptrdiff_t __n) const\n{\n    const value_type* __p = _VSTD::__to_raw_pointer(__i->base()) + __n;\n    return this->data() <= __p && __p <= this->data() + this->size();\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbool\nbasic_string<_CharT, _Traits, _Allocator>::__subscriptable(const const_iterator* __i, ptrdiff_t __n) const\n{\n    const value_type* __p = _VSTD::__to_raw_pointer(__i->base()) + __n;\n    return this->data() <= __p && __p < this->data() + this->size();\n}\n\n#endif  // _LIBCPP_DEBUG_LEVEL >= 2\n\n#if _LIBCPP_STD_VER > 11 \n// Literal suffixes for basic_string [basic.string.literals]\ninline namespace literals\n{\n  inline namespace string_literals\n  {\n    inline _LIBCPP_INLINE_VISIBILITY\n    basic_string<char> operator \"\" s( const char *__str, size_t __len )\n    {\n        return basic_string<char> (__str, __len);\n    }\n\n    inline _LIBCPP_INLINE_VISIBILITY\n    basic_string<wchar_t> operator \"\" s( const wchar_t *__str, size_t __len )\n    {\n        return basic_string<wchar_t> (__str, __len);\n    }\n\n    inline _LIBCPP_INLINE_VISIBILITY\n    basic_string<char16_t> operator \"\" s( const char16_t *__str, size_t __len )\n    {\n        return basic_string<char16_t> (__str, __len);\n    }\n\n    inline _LIBCPP_INLINE_VISIBILITY\n    basic_string<char32_t> operator \"\" s( const char32_t *__str, size_t __len )\n    {\n        return basic_string<char32_t> (__str, __len);\n    }\n  }\n}\n#endif\n\n_LIBCPP_EXTERN_TEMPLATE(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS basic_string<char>)\n_LIBCPP_EXTERN_TEMPLATE(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS basic_string<wchar_t>)\n_LIBCPP_EXTERN_TEMPLATE(string operator+<char, char_traits<char>, allocator<char> >(char const*, string const&))\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_STRING\n","//\n//  gradients.cpp\n//  ARToolKit5\n//\n//  This file is part of ARToolKit.\n//\n//  ARToolKit is free software: you can redistribute it and/or modify\n//  it under the terms of the GNU Lesser General Public License as published by\n//  the Free Software Foundation, either version 3 of the License, or\n//  (at your option) any later version.\n//\n//  ARToolKit is distributed in the hope that it will be useful,\n//  but WITHOUT ANY WARRANTY; without even the implied warranty of\n//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n//  GNU Lesser General Public License for more details.\n//\n//  You should have received a copy of the GNU Lesser General Public License\n//  along with ARToolKit.  If not, see <http://www.gnu.org/licenses/>.\n//\n//  As a special exception, the copyright holders of this library give you\n//  permission to link this library with independent modules to produce an\n//  executable, regardless of the license terms of these independent modules, and to\n//  copy and distribute the resulting executable under terms of your choice,\n//  provided that you also meet, for each linked independent module, the terms and\n//  conditions of the license of that module. An independent module is a module\n//  which is neither derived from nor based on this library. If you modify this\n//  library, you may extend this exception to your version of the library, but you\n//  are not obligated to do so. If you do not wish to do so, delete this exception\n//  statement from your version.\n//\n//  Copyright 2013-2015 Daqri, LLC.\n//\n//  Author(s): Chris Broaddus\n//\n\n#include \"gradients.h\"\n#include <math/math_utils.h>\n#include <cmath>\n\nusing namespace vision;\n\nnamespace vision {\n\n    void ComputePolarGradients(float* gradient,\n                               const float* im,\n                               size_t width,\n                               size_t height) {\n        \n#define SET_GRADIENT(dx, dy)                \\\n*(gradient++) = std::atan2(dy, dx)+PI;      \\\n*(gradient++) = std::sqrt(dx*dx+dy*dy);     \\\np_ptr++; pm1_ptr++; pp1_ptr++;              \\\n\n        size_t width_minus_1;\n        size_t height_minus_1;\n        \n        float dx, dy;\n        const float* p_ptr;\n        const float* pm1_ptr;\n        const float* pp1_ptr;\n        \n        width_minus_1 = width-1;\n        height_minus_1 = height-1;\n        \n        // Top row\n        pm1_ptr = im;\n        p_ptr   = im;\n        pp1_ptr = p_ptr+width;\n        \n        dx = p_ptr[1] - p_ptr[0];\n        dy = pp1_ptr[0] - pm1_ptr[0];\n        SET_GRADIENT(dx, dy)\n        \n        for(int col = 1; col < width_minus_1; col++) {\n            dx = p_ptr[1] - p_ptr[-1];\n            dy = pp1_ptr[0] - pm1_ptr[0];\n            SET_GRADIENT(dx, dy)\n        }\n        \n        dx = p_ptr[0] - p_ptr[-1];\n        dy = pp1_ptr[0] - pm1_ptr[0];\n        SET_GRADIENT(dx, dy)\n        \n        // Non-border pixels\n        pm1_ptr = im;\n        p_ptr   = pm1_ptr+width;\n        pp1_ptr = p_ptr+width;\n        \n        for(int row = 1; row < height_minus_1; row++) {\n            dx = p_ptr[1] - p_ptr[0];\n            dy = pp1_ptr[0] - pm1_ptr[0];\n            SET_GRADIENT(dx, dy)\n            \n            for(int col = 1; col < width_minus_1; col++) {\n                dx = p_ptr[1] - p_ptr[-1];\n                dy = pp1_ptr[0] - pm1_ptr[0];\n                SET_GRADIENT(dx, dy)\n            }\n            \n            dx = p_ptr[0] - p_ptr[-1];\n            dy = pp1_ptr[0] - pm1_ptr[0];\n            SET_GRADIENT(dx, dy)\n        }\n        \n        // Lower row\n        p_ptr   = &im[height_minus_1*width];\n        pm1_ptr = p_ptr-width;\n        pp1_ptr = p_ptr;\n        \n        dx = p_ptr[1] - p_ptr[0];\n        dy = pp1_ptr[0] - pm1_ptr[0];\n        SET_GRADIENT(dx, dy)\n        \n        for(int col = 1; col < width_minus_1; col++) {\n            dx = p_ptr[1] - p_ptr[-1];\n            dy = pp1_ptr[0] - pm1_ptr[0];\n            SET_GRADIENT(dx, dy)\n        }\n        \n        dx = p_ptr[0]   - p_ptr[-1];\n        dy = pp1_ptr[0] - pm1_ptr[0];\n        SET_GRADIENT(dx, dy)\n        \n#undef SET_GRADIENT\n    }\n    \n    void ComputeGradients(float* gradient,\n                          const float* im,\n                          size_t width,\n                          size_t height) {\n#define SET_GRADIENT(dx, dy)                \\\n*(gradient++) = dx;                         \\\n*(gradient++) = dy;                         \\\np_ptr++; pm1_ptr++; pp1_ptr++;              \\\n\n        size_t width_minus_1;\n        size_t height_minus_1;\n        \n        float dx, dy;\n        const float* p_ptr;\n        const float* pm1_ptr;\n        const float* pp1_ptr;\n        \n        width_minus_1 = width-1;\n        height_minus_1 = height-1;\n        \n        // Top row\n        pm1_ptr = im;\n        p_ptr   = im;\n        pp1_ptr = p_ptr+width;\n        \n        dx = p_ptr[1] - p_ptr[0];\n        dy = pp1_ptr[0] - pm1_ptr[0];\n        SET_GRADIENT(dx, dy)\n        \n        for(int col = 1; col < width_minus_1; col++) {\n            dx = p_ptr[1] - p_ptr[-1];\n            dy = pp1_ptr[0] - pm1_ptr[0];\n            SET_GRADIENT(dx, dy)\n        }\n        \n        dx = p_ptr[0] - p_ptr[-1];\n        dy = pp1_ptr[0] - pm1_ptr[0];\n        SET_GRADIENT(dx, dy)\n        \n        // Non-border pixels\n        pm1_ptr = im;\n        p_ptr   = pm1_ptr+width;\n        pp1_ptr = p_ptr+width;\n        \n        for(int row = 1; row < height_minus_1; row++) {\n            dx = p_ptr[1] - p_ptr[0];\n            dy = pp1_ptr[0] - pm1_ptr[0];\n            SET_GRADIENT(dx, dy)\n            \n            for(int col = 1; col < width_minus_1; col++) {\n                dx = p_ptr[1] - p_ptr[-1];\n                dy = pp1_ptr[0] - pm1_ptr[0];\n                SET_GRADIENT(dx, dy)\n            }\n            \n            dx = p_ptr[0] - p_ptr[-1];\n            dy = pp1_ptr[0] - pm1_ptr[0];\n            SET_GRADIENT(dx, dy)\n        }\n        \n        // Lower row\n        p_ptr   = &im[height_minus_1*width];\n        pm1_ptr = p_ptr-width;\n        pp1_ptr = p_ptr;\n        \n        dx = p_ptr[1] - p_ptr[0];\n        dy = pp1_ptr[0] - pm1_ptr[0];\n        SET_GRADIENT(dx, dy)\n        \n        for(int col = 1; col < width_minus_1; col++) {\n            dx = p_ptr[1] - p_ptr[-1];\n            dy = pp1_ptr[0] - pm1_ptr[0];\n            SET_GRADIENT(dx, dy)\n        }\n        \n        dx = p_ptr[0]   - p_ptr[-1];\n        dy = pp1_ptr[0] - pm1_ptr[0];\n        SET_GRADIENT(dx, dy)\n        \n#undef SET_GRADIENT\n    }\n    \n} // vision","/*\n *  arImageProc.c\n *  ARToolKit5\n *\n *  This file is part of ARToolKit.\n *\n *  ARToolKit is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation, either version 3 of the License, or\n *  (at your option) any later version.\n *\n *  ARToolKit is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public License\n *  along with ARToolKit.  If not, see <http://www.gnu.org/licenses/>.\n *\n *  As a special exception, the copyright holders of this library give you\n *  permission to link this library with independent modules to produce an\n *  executable, regardless of the license terms of these independent modules, and to\n *  copy and distribute the resulting executable under terms of your choice,\n *  provided that you also meet, for each linked independent module, the terms and\n *  conditions of the license of that module. An independent module is a module\n *  which is neither derived from nor based on this library. If you modify this\n *  library, you may extend this exception to your version of the library, but you\n *  are not obligated to do so. If you do not wish to do so, delete this exception\n *  statement from your version.\n *\n *  Copyright 2015 Daqri, LLC.\n *  Copyright 2010-2015 ARToolworks, Inc.\n *\n *  Author(s): Philip Lamb\n *\n */\n\n#include <string.h> // memset(), memcpy()\n#include <AR/arImageProc.h>\n#if AR_IMAGEPROC_USE_VIMAGE\n#  include <Accelerate/Accelerate.h>\n#endif\n\n#ifdef HAVE_ARM_NEON\n#  include <arm_neon.h>\n#  ifdef ANDROID\n#    include \"cpu-features.h\"\n#  endif\n#endif\n\n#ifdef HAVE_ARM_NEON\nstatic void arImageProcBGRAtoL_ARM_neon_asm(uint8_t * __restrict dest, uint8_t * __restrict src, int numPixels);\nstatic void arImageProcRGBAtoL_ARM_neon_asm(uint8_t * __restrict dest, uint8_t * __restrict src, int numPixels);\nstatic void arImageProcABGRtoL_ARM_neon_asm(uint8_t * __restrict dest, uint8_t * __restrict src, int numPixels);\nstatic void arImageProcARGBtoL_ARM_neon_asm(uint8_t * __restrict dest, uint8_t * __restrict src, int numPixels);\n#endif\n\nARImageProcInfo *arImageProcInit(const int xsize, const int ysize, const AR_PIXEL_FORMAT pixFormat, int alwaysCopy)\n{\n    ARImageProcInfo *ipi = (ARImageProcInfo *)malloc(sizeof(ARImageProcInfo));\n    if (ipi) {\n        ipi->pixFormat = pixFormat;\n        if (alwaysCopy || (pixFormat != AR_PIXEL_FORMAT_MONO && pixFormat != AR_PIXEL_FORMAT_420v && pixFormat != AR_PIXEL_FORMAT_420f && pixFormat != AR_PIXEL_FORMAT_NV21)) {\n            ipi->image = (unsigned char *)malloc(xsize * ysize * sizeof(unsigned char));\n            if (!ipi->image) goto bail;\n            ipi->imageWasAllocated = TRUE;\n        } else {\n            ipi->imageWasAllocated = FALSE;\n        }\n        ipi->alwaysCopy = alwaysCopy;\n        ipi->image2 = NULL;\n        ipi->imageX = xsize;\n        ipi->imageY = ysize;\n#if AR_IMAGEPROC_USE_VIMAGE\n        ipi->tempBuffer = NULL;\n#endif\n#ifdef HAVE_ARM_NEON\n        ipi->fastPath = (ipi->imageX * ipi->imageY % 8 == 0\n                         && (pixFormat == AR_PIXEL_FORMAT_RGBA\n                             || pixFormat == AR_PIXEL_FORMAT_BGRA\n                             || pixFormat == AR_PIXEL_FORMAT_ABGR\n                             ||pixFormat == AR_PIXEL_FORMAT_ARGB\n                             )\n                         );\n#  ifdef ANDROID\n        // Not all Android devices with ARMv7 are guaranteed to have NEON, so check.\n        uint64_t features = android_getCpuFeatures();\n        ipi->fastPath = ipi->fastPath && (features & ANDROID_CPU_ARM_FEATURE_ARMv7) && (features & ANDROID_CPU_ARM_FEATURE_NEON);\n#  endif\n        if (ipi->fastPath) ARLOGd(\"arImageProc will use ARM NEON acceleration.\\n\");\n#endif\n    }\n    return (ipi);\n    \nbail:\n    free(ipi);\n    return (NULL);\n}\n\nvoid arImageProcFinal(ARImageProcInfo *ipi)\n{\n    if (!ipi) return;\n    if (ipi->imageWasAllocated) free (ipi->image);\n    if (ipi->image2) free (ipi->image2);\n#if AR_IMAGEPROC_USE_VIMAGE\n    if (ipi->tempBuffer) free (ipi->tempBuffer);\n#endif\n    free (ipi);\n}\n\nint arImageProcLuma(ARImageProcInfo *ipi, const ARUint8 *__restrict dataPtr)\n{\n    unsigned int p, q;\n\n    AR_PIXEL_FORMAT pixFormat = ipi->pixFormat;\n#ifdef HAVE_ARM_NEON\n    if (ipi->fastPath) {\n        if (pixFormat == AR_PIXEL_FORMAT_BGRA) {\n            arImageProcBGRAtoL_ARM_neon_asm(ipi->image, (unsigned char *__restrict)dataPtr, ipi->imageX*ipi->imageY);\n        } else if (pixFormat == AR_PIXEL_FORMAT_RGBA) {\n            arImageProcRGBAtoL_ARM_neon_asm(ipi->image, (unsigned char *__restrict)dataPtr, ipi->imageX*ipi->imageY);\n        } else if (pixFormat == AR_PIXEL_FORMAT_ABGR) {\n            arImageProcABGRtoL_ARM_neon_asm(ipi->image, (unsigned char *__restrict)dataPtr, ipi->imageX*ipi->imageY);\n        } else /*(pixFormat == AR_PIXEL_FORMAT_ARGB)*/ {\n            arImageProcARGBtoL_ARM_neon_asm(ipi->image, (unsigned char *__restrict)dataPtr, ipi->imageX*ipi->imageY);\n        }\n        return (0);\n    }\n#endif\n    if (pixFormat == AR_PIXEL_FORMAT_MONO || pixFormat == AR_PIXEL_FORMAT_420v || pixFormat == AR_PIXEL_FORMAT_420f || pixFormat == AR_PIXEL_FORMAT_NV21) {\n        if (!ipi->alwaysCopy) {\n            ipi->image = (unsigned char *__restrict)dataPtr;\n        } else {\n            memcpy(ipi->image, dataPtr, ipi->imageX * ipi->imageY);\n        }\n    } else {\n        q = 0;\n        if (pixFormat == AR_PIXEL_FORMAT_RGBA || pixFormat == AR_PIXEL_FORMAT_BGRA) {\n            for (p = 0; p < ipi->imageX * ipi->imageY; p++) {\n                ipi->image[p] = (dataPtr[q + 0] + dataPtr[q + 1] + dataPtr[q + 2]) / 3;\n                q += 4;\n            }\n        } else if (pixFormat == AR_PIXEL_FORMAT_ABGR || pixFormat == AR_PIXEL_FORMAT_ARGB) {\n            for (p = 0; p < ipi->imageX * ipi->imageY; p++) {\n                ipi->image[p] = (dataPtr[q + 1] + dataPtr[q + 2] + dataPtr[q + 3]) / 3;\n                q += 4;\n            }\n        } else if (pixFormat == AR_PIXEL_FORMAT_RGB || pixFormat == AR_PIXEL_FORMAT_BGR) {\n            for (p = 0; p < ipi->imageX * ipi->imageY; p++) {\n                ipi->image[p] = (dataPtr[q + 0] + dataPtr[q + 1] + dataPtr[q + 2]) / 3;\n                q += 3;\n            }\n        } else if (pixFormat == AR_PIXEL_FORMAT_yuvs) {\n            for (p = 0; p < ipi->imageX * ipi->imageY; p++) {\n                ipi->image[p] = dataPtr[q + 0];\n                q += 2;\n            }\n        } else if (pixFormat == AR_PIXEL_FORMAT_2vuy) {\n            for (p = 0; p < ipi->imageX * ipi->imageY; p++) {\n                ipi->image[p] = dataPtr[q + 1];\n                q += 2;\n            }\n        } else if (pixFormat == AR_PIXEL_FORMAT_RGB_565) {\n            for (p = 0; p < ipi->imageX * ipi->imageY; p++) {\n                ipi->image[p] = ((dataPtr[q + 0] & 0xf8) + ((dataPtr[q + 0] & 0x07) << 5) + ((dataPtr[q + 1] & 0xe0) >> 3) + ((dataPtr[q + 1] & 0x1f) << 3) + 10) / 3;\n                q += 2;\n            }\n        } else if (pixFormat == AR_PIXEL_FORMAT_RGBA_5551) {\n            for (p = 0; p < ipi->imageX * ipi->imageY; p++) {\n                ipi->image[p] = ((dataPtr[q + 0] & 0xf8) + ((dataPtr[q + 0] & 0x07) << 5) + ((dataPtr[q + 1] & 0xc0) >> 3) + ((dataPtr[q + 1] & 0x3e) << 2) + 12) / 3;\n                q += 2;\n            }\n        } else if (pixFormat == AR_PIXEL_FORMAT_RGBA_4444) {\n            for (p = 0; p < ipi->imageX * ipi->imageY; p++) {\n                ipi->image[p] = ((dataPtr[q + 0] & 0xf0) + ((dataPtr[q + 0] & 0x0f) << 4) + (dataPtr[q + 1] & 0xf0) + 24) / 3;\n                q += 2;\n            }\n        } else {\n            ARLOGe(\"Error: Unsupported pixel format passed to arImageProcHist().\\n\");\n            return (-1);\n        }\n    }\n    return (0);\n}\n\nint arImageProcLumaHist(ARImageProcInfo *ipi, const ARUint8 *__restrict dataPtr)\n{\n\tif (!ipi || !dataPtr) return (-1);\n\n    if (arImageProcLuma(ipi, dataPtr) < 0) {\n        return (-1);\n    }\n    \n#ifdef AR_IMAGEPROC_USE_VIMAGE\n    vImage_Error err;\n    vImage_Buffer buf = {(void *)ipi->image, ipi->imageY, ipi->imageX, ipi->imageX};\n    if ((err = vImageHistogramCalculation_Planar8(&buf, ipi->histBins, 0)) != kvImageNoError) {\n        ARLOGe(\"arImageProcLumaHist(): vImageHistogramCalculation_Planar8 error %ld.\\n\", err);\n        return (-1);\n    }\n#else\n    unsigned char *p;\n    memset(ipi->histBins, 0, sizeof(ipi->histBins));\n    for (p = ipi->image; p < ipi->image + ipi->imageX*ipi->imageY; p++) ipi->histBins[*p]++;\n#endif // AR_IMAGEPROC_USE_VIMAGE\n    \n    return (0);\n}\n\n// Returns a pointer to a buffer containing a 256x256 8-bit grayscale texture.\n// The texture can be uploaded to an OpenGL texture with the calls:\n//     buf = arImageProcGetHistImage(ipi);\n//     if (buf) {\n//         glTexImage2D(GL_TEXTURE_2D, 0, GL_LUMINANCE, 256, 256, 0, GL_LUMINANCE, GL_UNSIGNED_BYTE, buf);\n//         free(buf);\n//     }\n// After uploading, the texture can be drawn as with any other OpenGL texture.\nunsigned char *arImageProcGetHistImage(ARImageProcInfo *ipi)\n{\n    int i, j, y;\n    unsigned long peak = 0;\n    float scalef;\n    \n    if (!ipi) return (NULL);\n    \n    unsigned char *buf = (unsigned char *)calloc(1, 256*256*sizeof(unsigned char));\n    if (buf) {\n        for (i = 0; i < 256; i++) if (ipi->histBins[i] > peak) peak = ipi->histBins[i]; // Find value of mode.\n        scalef = 256.0f / (float)peak;\n        for (i = 0; i < 256; i++) {\n            y = (int)((float)ipi->histBins[i] * scalef);\n            if (y > 256) y = 256; // Safety in case of FP rounding errors etc.\n            for (j = 0; j < y; j++) buf[256*j + i] = 0xff;\n        }\n    }\n    return (buf);\n}\n\nint arImageProcLumaHistAndCDF(ARImageProcInfo *ipi, const ARUint8 *__restrict dataPtr)\n{\n    unsigned long cdfCurrent;\n\tunsigned char i;\n\n\tint ret = arImageProcLumaHist(ipi, dataPtr);\n    if (ret < 0) return (ret);\n\n    cdfCurrent = 0;\n    i = 0;\n    do {\n        ipi->cdfBins[i] = cdfCurrent + ipi->histBins[i];\n        cdfCurrent = ipi->cdfBins[i];\n        i++;\n    } while (i != 0);\n    return (0);\n}\n\nint arImageProcLumaHistAndCDFAndPercentile(ARImageProcInfo *ipi, const ARUint8 *__restrict dataPtr, const float percentile, unsigned char *value_p)\n{\n\tint ret;\n\tunsigned int requiredCD;\n\tunsigned char i, j;\n\n    if (percentile < 0.0f || percentile > 1.0f) return (-1);\n    \n    ret = arImageProcLumaHistAndCDF(ipi, dataPtr);\n    if (ret < 0) return (ret);\n    \n    requiredCD = (unsigned int)(ipi->imageX * ipi->imageY * percentile);\n    i = 0;\n    while (ipi->cdfBins[i] < requiredCD) i++; // cdfBins[i] >= requiredCD\n    j = i;\n    while (ipi->cdfBins[j] == requiredCD) j++; // cdfBins[j] > requiredCD    \n    *value_p = (unsigned char)((i + j) / 2);\n    return (0);\n}\n\nint arImageProcLumaHistAndCDFAndMedian(ARImageProcInfo *ipi, const ARUint8 *__restrict dataPtr, unsigned char *value_p)\n{\n    return (arImageProcLumaHistAndCDFAndPercentile(ipi, dataPtr, 0.5f, value_p));\n}\n\n// Implementation of Otsu's Method of binarization threshold determination.\n// See http://en.wikipedia.org/wiki/Otsu's_method fore more information.\nint arImageProcLumaHistAndOtsu(ARImageProcInfo *ipi, const ARUint8 *__restrict dataPtr, unsigned char *value_p)\n{\n    int ret;\n    unsigned char i;\n    \n    ret = arImageProcLumaHist(ipi, dataPtr);\n    if (ret < 0) return (ret);\n    \n    float sum = 0.0f;\n    i = 1;\n    do {\n        sum += ipi->histBins[i] * i;\n        i++;\n    } while (i != 0);\n    \n    float count = (float)(ipi->imageX * ipi->imageY);\n    float sumB = 0.0f;\n    float wB = 0.0f;\n    float wF = 0.0f;\n    float varMax = 0.0f;\n    unsigned char threshold = 0;\n    i = 0;\n    do {\n        wB += ipi->histBins[i];          // Weight background.\n        if (wB != 0.0f) {\n            wF = count - wB;                 // Weight foreground.\n            if (wF == 0.0f) break;\n            \n            sumB += (float)(i * ipi->histBins[i]);\n            \n            float mB = sumB / wB;            // Mean background.\n            float mF = (sum - sumB) / wF;    // Mean foreground.\n            \n            // Calculate between-class variance.\n            float varBetween = wB * wF * (mB - mF) * (mB - mF);\n            \n            // Check if new maximum found.\n            if (varBetween > varMax) {\n                varMax = varBetween;\n                threshold = i;\n            }\n        }\n        i++;\n    } while (i != 0);\n    \n    *value_p = threshold;\n    return (0);\n}\n\n#if !AR_DISABLE_THRESH_MODE_AUTO_ADAPTIVE\nint arImageProcLumaHistAndBoxFilterWithBias(ARImageProcInfo *ipi, const ARUint8 *__restrict dataPtr, const int boxSize, const int bias)\n{\n    int ret, i;\n#if !AR_IMAGEPROC_USE_VIMAGE\n    int j, kernelSizeHalf;\n#endif\n    \n    ret = arImageProcLumaHist(ipi, dataPtr);\n    if (ret < 0) return (ret);\n    \n    if (!ipi->image2) {\n        ipi->image2 = (unsigned char *)malloc(ipi->imageX * ipi->imageY * sizeof(unsigned char));\n        if (!ipi->image2) return (-1);\n    }\n#if AR_IMAGEPROC_USE_VIMAGE\n    vImage_Error err;\n    vImage_Buffer src = {ipi->image, ipi->imageY, ipi->imageX, ipi->imageX};\n    vImage_Buffer dest = {ipi->image2, ipi->imageY, ipi->imageX, ipi->imageX};\n    if (!ipi->tempBuffer) {\n        // Request size of buffer, and allocate.\n        if ((err = vImageBoxConvolve_Planar8(&src, &dest, NULL, 0, 0, boxSize, boxSize, '\\0', kvImageTruncateKernel | kvImageGetTempBufferSize)) < 0) return (-1);\n        if (!(ipi->tempBuffer = malloc(err))) return (-1);\n    }\n    err = vImageBoxConvolve_Planar8(&src, &dest, ipi->tempBuffer, 0, 0, boxSize, boxSize, '\\0', kvImageTruncateKernel);\n    if (err != kvImageNoError) {\n        ARLOGe(\"Error %ld in vImageBoxConvolve_Planar8().\\n\", err);\n        return (-1);\n    }\n#else\n    kernelSizeHalf = boxSize >> 1;\n    for (j = 0; j < ipi->imageY; j++) {\n        for (i = 0; i < ipi->imageX; i++) {\n            int val, count, kernel_i, kernel_j, ii, jj;\n            val = count = 0;\n            for (kernel_j = -kernelSizeHalf; kernel_j <= kernelSizeHalf; kernel_j++) {\n                jj = j + kernel_j;\n                if (jj < 0 || jj >= ipi->imageY) continue;\n                for (kernel_i = -kernelSizeHalf; kernel_i <= kernelSizeHalf; kernel_i++) {\n                    ii = i + kernel_i;\n                    if (ii < 0 || ii >= ipi->imageX) continue;\n                    val += ipi->image[ii + jj*(ipi->imageX)];\n                    count++;\n                }\n            }\n            ipi->image2[i + j*(ipi->imageX)] = val / count;\n        }\n    }\n#endif\n    if (bias) for (i = 0; i < ipi->imageX*ipi->imageY; i++) ipi->image2[i] += bias;\n    return (0);\n}\n#endif // !AR_DISABLE_THRESH_MODE_AUTO_ADAPTIVE\n\nint arImageProcLumaHistAndCDFAndLevels(ARImageProcInfo *ipi, const ARUint8 *__restrict dataPtr)\n{\n\tunsigned char l;\n\tunsigned int maxCD;\n\n    int ret = arImageProcLumaHistAndCDF(ipi, dataPtr);\n    if (ret < 0) return (ret);\n\n    // Find min and max values.\n    l = 0;\n    while (ipi->cdfBins[l] == 0) l++;\n    ipi->min = l;\n    maxCD = ipi->imageX*ipi->imageY;\n    while (ipi->cdfBins[l] < maxCD) l++;\n    ipi->max = l;\n    \n    return (0);\n}\n\n//\n// Methods from http://computer-vision-talks.com/2011/02/a-very-fast-bgra-to-grayscale-conversion-on-iphone/\n//\n#ifdef HAVE_ARM_NEON\n#if 0\nstatic void arImageProcBGRAtoL_ARM_neon(uint8_t * __restrict dest, uint8_t * __restrict src, int numPixels)\n{\n\tint i;\n\tuint8x8_t rfac = vdup_n_u8 (77); // CCIR 601 recommended values. See http://www.poynton.com/notes/colour_and_gamma/ColorFAQ.html#RTFToC11.\n\tuint8x8_t gfac = vdup_n_u8 (150);\n\tuint8x8_t bfac = vdup_n_u8 (29);\n\tint n = numPixels / 8;\n    \n\t// Convert per eight pixels.\n\tfor (i = 0; i < n; i++) {\n\t\tuint16x8_t  temp;\n\t\tuint8x8x4_t rgb  = vld4_u8 (src);\n\t\tuint8x8_t result;\n        \n\t\ttemp = vmull_u8 (rgb.val[0],      bfac);\n\t\ttemp = vmlal_u8 (temp,rgb.val[1], gfac);\n\t\ttemp = vmlal_u8 (temp,rgb.val[2], rfac);\n        \n\t\tresult = vshrn_n_u16 (temp, 8);\n\t\tvst1_u8 (dest, result);\n\t\tsrc  += 8*4;\n\t\tdest += 8;\n\t}\n}\n#endif\n\n\nstatic void arImageProcBGRAtoL_ARM_neon_asm(uint8_t * __restrict dest, uint8_t * __restrict src, int numPixels)\n{\n\t__asm__ volatile(\"lsr          %2, %2, #3      \\n\" // Divide arg 2 (numPixels) by 8.\n\t\t\t\t\t \"# build the three constants: \\n\"\n\t\t\t\t\t \"mov         r4, #29          \\n\" // Blue channel multiplier.\n\t\t\t\t\t \"mov         r5, #150         \\n\" // Green channel multiplier.\n\t\t\t\t\t \"mov         r6, #77          \\n\" // Red channel multiplier.\n\t\t\t\t\t \"vdup.8      d4, r4           \\n\"\n\t\t\t\t\t \"vdup.8      d5, r5           \\n\"\n\t\t\t\t\t \"vdup.8      d6, r6           \\n\"\n\t\t\t\t\t \"0:\t\t\t\t\t\t   \\n\"\n\t\t\t\t\t \"# load 8 pixels:             \\n\"\n\t\t\t\t\t \"vld4.8      {d0-d3}, [%1]!   \\n\" // B into d0, G into d1, R into d2, A into d3.\n\t\t\t\t\t \"# do the weight average:     \\n\"\n\t\t\t\t\t \"vmull.u8    q7, d0, d4       \\n\"\n\t\t\t\t\t \"vmlal.u8    q7, d1, d5       \\n\"\n\t\t\t\t\t \"vmlal.u8    q7, d2, d6       \\n\"\n\t\t\t\t\t \"# shift and store:           \\n\"\n\t\t\t\t\t \"vshrn.u16   d7, q7, #8       \\n\" // Divide q3 by 256 and store in the d7.\n\t\t\t\t\t \"vst1.8      {d7}, [%0]!      \\n\"\n\t\t\t\t\t \"subs        %2, %2, #1       \\n\" // Decrement iteration count.\n\t\t\t\t\t \"bne         0b            \\n\" // Repeat unil iteration count is not zero.\n\t\t\t\t\t :\n\t\t\t\t\t : \"r\"(dest), \"r\"(src), \"r\"(numPixels)\n\t\t\t\t\t : \"cc\", \"r4\", \"r5\", \"r6\"\n\t\t\t\t\t );\n}\n\nstatic void arImageProcRGBAtoL_ARM_neon_asm(uint8_t * __restrict dest, uint8_t * __restrict src, int numPixels)\n{\n\t__asm__ volatile(\"lsr          %2, %2, #3      \\n\" // Divide arg 2 (numPixels) by 8.\n\t\t\t\t\t \"# build the three constants: \\n\"\n\t\t\t\t\t \"mov         r4, #77          \\n\" // Red channel multiplier.\n\t\t\t\t\t \"mov         r5, #150         \\n\" // Green channel multiplier.\n\t\t\t\t\t \"mov         r6, #29          \\n\" // Blue channel multiplier.\n\t\t\t\t\t \"vdup.8      d4, r4           \\n\"\n\t\t\t\t\t \"vdup.8      d5, r5           \\n\"\n\t\t\t\t\t \"vdup.8      d6, r6           \\n\"\n\t\t\t\t\t \"0:\t\t\t\t\t\t   \\n\"\n\t\t\t\t\t \"# load 8 pixels:             \\n\"\n\t\t\t\t\t \"vld4.8      {d0-d3}, [%1]!   \\n\" // R into d0, G into d1, B into d2, A into d3.\n\t\t\t\t\t \"# do the weight average:     \\n\"\n\t\t\t\t\t \"vmull.u8    q7, d0, d4       \\n\"\n\t\t\t\t\t \"vmlal.u8    q7, d1, d5       \\n\"\n\t\t\t\t\t \"vmlal.u8    q7, d2, d6       \\n\"\n\t\t\t\t\t \"# shift and store:           \\n\"\n\t\t\t\t\t \"vshrn.u16   d7, q7, #8       \\n\" // Divide q3 by 256 and store in the d7.\n\t\t\t\t\t \"vst1.8      {d7}, [%0]!      \\n\"\n\t\t\t\t\t \"subs        %2, %2, #1       \\n\" // Decrement iteration count.\n\t\t\t\t\t \"bne         0b            \\n\" // Repeat unil iteration count is not zero.\n\t\t\t\t\t :\n\t\t\t\t\t : \"r\"(dest), \"r\"(src), \"r\"(numPixels)\n\t\t\t\t\t : \"cc\", \"r4\", \"r5\", \"r6\"\n\t\t\t\t\t );\n}\n\nstatic void arImageProcABGRtoL_ARM_neon_asm(uint8_t * __restrict dest, uint8_t * __restrict src, int numPixels)\n{\n\t__asm__ volatile(\"lsr          %2, %2, #3      \\n\" // Divide arg 2 (numPixels) by 8.\n\t\t\t\t\t \"# build the three constants: \\n\"\n\t\t\t\t\t \"mov         r4, #29          \\n\" // Blue channel multiplier.\n\t\t\t\t\t \"mov         r5, #150         \\n\" // Green channel multiplier.\n\t\t\t\t\t \"mov         r6, #77          \\n\" // Red channel multiplier.\n\t\t\t\t\t \"vdup.8      d4, r4           \\n\"\n\t\t\t\t\t \"vdup.8      d5, r5           \\n\"\n\t\t\t\t\t \"vdup.8      d6, r6           \\n\"\n\t\t\t\t\t \"0:\t\t\t\t\t\t   \\n\"\n\t\t\t\t\t \"# load 8 pixels:             \\n\"\n\t\t\t\t\t \"vld4.8      {d0-d3}, [%1]!   \\n\" // A into d0, B into d1, G into d2, R into d3.\n\t\t\t\t\t \"# do the weight average:     \\n\"\n\t\t\t\t\t \"vmull.u8    q7, d1, d4       \\n\"\n\t\t\t\t\t \"vmlal.u8    q7, d2, d5       \\n\"\n\t\t\t\t\t \"vmlal.u8    q7, d3, d6       \\n\"\n\t\t\t\t\t \"# shift and store:           \\n\"\n\t\t\t\t\t \"vshrn.u16   d7, q7, #8       \\n\" // Divide q3 by 256 and store in the d7.\n\t\t\t\t\t \"vst1.8      {d7}, [%0]!      \\n\"\n\t\t\t\t\t \"subs        %2, %2, #1       \\n\" // Decrement iteration count.\n\t\t\t\t\t \"bne         0b            \\n\" // Repeat unil iteration count is not zero.\n\t\t\t\t\t :\n\t\t\t\t\t : \"r\"(dest), \"r\"(src), \"r\"(numPixels)\n\t\t\t\t\t : \"cc\", \"r4\", \"r5\", \"r6\"\n\t\t\t\t\t );\n}\n\nstatic void arImageProcARGBtoL_ARM_neon_asm(uint8_t * __restrict dest, uint8_t * __restrict src, int numPixels)\n{\n\t__asm__ volatile(\"lsr          %2, %2, #3      \\n\" // Divide arg 2 (numPixels) by 8.\n\t\t\t\t\t \"# build the three constants: \\n\"\n\t\t\t\t\t \"mov         r4, #77          \\n\" // Red channel multiplier.\n\t\t\t\t\t \"mov         r5, #150         \\n\" // Green channel multiplier.\n\t\t\t\t\t \"mov         r6, #29          \\n\" // Blue channel multiplier.\n\t\t\t\t\t \"vdup.8      d4, r4           \\n\"\n\t\t\t\t\t \"vdup.8      d5, r5           \\n\"\n\t\t\t\t\t \"vdup.8      d6, r6           \\n\"\n\t\t\t\t\t \"0:\t\t\t\t\t\t   \\n\"\n\t\t\t\t\t \"# load 8 pixels:             \\n\"\n\t\t\t\t\t \"vld4.8      {d0-d3}, [%1]!   \\n\" // A into d0, R into d1, G into d2, B into d3.\n\t\t\t\t\t \"# do the weight average:     \\n\"\n\t\t\t\t\t \"vmull.u8    q7, d1, d4       \\n\"\n\t\t\t\t\t \"vmlal.u8    q7, d2, d5       \\n\"\n\t\t\t\t\t \"vmlal.u8    q7, d3, d6       \\n\"\n\t\t\t\t\t \"# shift and store:           \\n\"\n\t\t\t\t\t \"vshrn.u16   d7, q7, #8       \\n\" // Divide q3 by 256 and store in the d7.\n\t\t\t\t\t \"vst1.8      {d7}, [%0]!      \\n\"\n\t\t\t\t\t \"subs        %2, %2, #1       \\n\" // Decrement iteration count.\n\t\t\t\t\t \"bne         0b            \\n\" // Repeat unil iteration count is not zero.\n\t\t\t\t\t :\n\t\t\t\t\t : \"r\"(dest), \"r\"(src), \"r\"(numPixels)\n\t\t\t\t\t : \"cc\", \"r4\", \"r5\", \"r6\"\n\t\t\t\t\t );\n}\n#endif // HAVE_ARM_NEON\n\n","/*\n *  arLabeling.c\n *  ARToolKit5\n *\n *  This file is part of ARToolKit.\n *\n *  ARToolKit is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation, either version 3 of the License, or\n *  (at your option) any later version.\n *\n *  ARToolKit is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public License\n *  along with ARToolKit.  If not, see <http://www.gnu.org/licenses/>.\n *\n *  As a special exception, the copyright holders of this library give you\n *  permission to link this library with independent modules to produce an\n *  executable, regardless of the license terms of these independent modules, and to\n *  copy and distribute the resulting executable under terms of your choice,\n *  provided that you also meet, for each linked independent module, the terms and\n *  conditions of the license of that module. An independent module is a module\n *  which is neither derived from nor based on this library. If you modify this\n *  library, you may extend this exception to your version of the library, but you\n *  are not obligated to do so. If you do not wish to do so, delete this exception\n *  statement from your version.\n *\n *  Copyright 2015 Daqri, LLC.\n *  Copyright 2003-2015 ARToolworks, Inc.\n *\n *  Author(s): Hirokazu Kato, Philip Lamb\n *\n */\n/*******************************************************\n *\n * Author: Hirokazu Kato\n *\n *         kato@sys.im.hiroshima-cu.ac.jp\n *\n * Revision: 4.0\n * Date: 03/08/13\n *\n *******************************************************/\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <AR/ar.h>\n#include <AR/config.h>\n#include \"arLabelingSub/arLabelingPrivate.h\"\n\nint arLabeling( ARUint8 *image, int xsize, int ysize, int pixFormat,\n                int debugMode, int labelingMode, int labelingThresh, int imageProcMode,\n                ARLabelInfo *labelInfo, ARUint8 *image_thresh )\n{\n#if !AR_DISABLE_LABELING_DEBUG_MODE\n    if( debugMode == AR_DEBUG_DISABLE ) {\n#endif\n        if( labelingMode == AR_LABELING_BLACK_REGION ) {\n#if !AR_DISABLE_THRESH_MODE_AUTO_ADAPTIVE\n            if (image_thresh) return arLabelingSubDBZ(image, xsize, ysize, image_thresh, labelInfo);\n#endif\n            if( imageProcMode == AR_IMAGE_PROC_FRAME_IMAGE ) {\n                if( pixFormat == AR_PIXEL_FORMAT_RGB || pixFormat == AR_PIXEL_FORMAT_BGR )\n                    return arLabelingSubDBR3C(image, xsize, ysize, labelingThresh, labelInfo);\n                else if( pixFormat == AR_PIXEL_FORMAT_RGBA || pixFormat == AR_PIXEL_FORMAT_BGRA )\n                    return arLabelingSubDBR3CA(image, xsize, ysize, labelingThresh, labelInfo);\n                else if( pixFormat == AR_PIXEL_FORMAT_ABGR || pixFormat == AR_PIXEL_FORMAT_ARGB )\n                    return arLabelingSubDBRA3C(image, xsize, ysize, labelingThresh, labelInfo);\n                else if( pixFormat == AR_PIXEL_FORMAT_MONO || pixFormat == AR_PIXEL_FORMAT_420v || pixFormat == AR_PIXEL_FORMAT_420f || pixFormat == AR_PIXEL_FORMAT_NV21 )\n                    return arLabelingSubDBRC(image, xsize, ysize, labelingThresh, labelInfo);\n                else if( pixFormat == AR_PIXEL_FORMAT_yuvs )\n                     return arLabelingSubDBRYC(image, xsize, ysize, labelingThresh, labelInfo);\n                else if( pixFormat == AR_PIXEL_FORMAT_2vuy )\n                     return arLabelingSubDBRCY(image, xsize, ysize, labelingThresh, labelInfo);\n                else if( pixFormat == AR_PIXEL_FORMAT_RGB_565 )\n                    return arLabelingSubDBR3C565(image, xsize, ysize, labelingThresh, labelInfo);\n                else if( pixFormat == AR_PIXEL_FORMAT_RGBA_5551 )\n                    return arLabelingSubDBR3CA5551(image, xsize, ysize, labelingThresh, labelInfo);\n                else if( pixFormat == AR_PIXEL_FORMAT_RGBA_4444 )\n                    return arLabelingSubDBR3CA4444(image, xsize, ysize, labelingThresh, labelInfo);\n                else exit(0);\n            }\n            else if( imageProcMode == AR_IMAGE_PROC_FIELD_IMAGE ) {\n                if( pixFormat == AR_PIXEL_FORMAT_RGB || pixFormat == AR_PIXEL_FORMAT_BGR )\n                    return arLabelingSubDBI3C(image, xsize, ysize, labelingThresh, labelInfo);\n                else if( pixFormat == AR_PIXEL_FORMAT_RGBA || pixFormat == AR_PIXEL_FORMAT_BGRA )\n                    return arLabelingSubDBI3CA(image, xsize, ysize, labelingThresh, labelInfo);\n                else if( pixFormat == AR_PIXEL_FORMAT_ABGR || pixFormat == AR_PIXEL_FORMAT_ARGB )\n                    return arLabelingSubDBIA3C(image, xsize, ysize, labelingThresh, labelInfo);\n                else if( pixFormat == AR_PIXEL_FORMAT_MONO || pixFormat == AR_PIXEL_FORMAT_420v || pixFormat == AR_PIXEL_FORMAT_420f || pixFormat == AR_PIXEL_FORMAT_NV21 )\n                    return arLabelingSubDBIC(image, xsize, ysize, labelingThresh, labelInfo);\n                else if( pixFormat == AR_PIXEL_FORMAT_yuvs )\n                    return arLabelingSubDBIYC(image, xsize, ysize, labelingThresh, labelInfo);\n                else if( pixFormat == AR_PIXEL_FORMAT_2vuy )\n                    return arLabelingSubDBICY(image, xsize, ysize, labelingThresh, labelInfo);\n                else if( pixFormat == AR_PIXEL_FORMAT_RGB_565 )\n                    return arLabelingSubDBI3C565(image, xsize, ysize, labelingThresh, labelInfo);\n                else if( pixFormat == AR_PIXEL_FORMAT_RGBA_5551 )\n                    return arLabelingSubDBI3CA5551(image, xsize, ysize, labelingThresh, labelInfo);\n                else if( pixFormat == AR_PIXEL_FORMAT_RGBA_4444 )\n                    return arLabelingSubDBI3CA4444(image, xsize, ysize, labelingThresh, labelInfo);\n                else exit(0);\n            }\n            else exit(0);\n        }\n        else if( labelingMode == AR_LABELING_WHITE_REGION ) {\n#if !AR_DISABLE_THRESH_MODE_AUTO_ADAPTIVE\n            if (image_thresh) return arLabelingSubDWZ(image, xsize, ysize, image_thresh, labelInfo);\n#endif\n            if( imageProcMode == AR_IMAGE_PROC_FRAME_IMAGE ) {\n                if( pixFormat == AR_PIXEL_FORMAT_RGB || pixFormat == AR_PIXEL_FORMAT_BGR )\n                    return arLabelingSubDWR3C(image, xsize, ysize, labelingThresh, labelInfo);\n                else if( pixFormat == AR_PIXEL_FORMAT_RGBA || pixFormat == AR_PIXEL_FORMAT_BGRA )\n                    return arLabelingSubDWR3CA(image, xsize, ysize, labelingThresh, labelInfo);\n                else if( pixFormat == AR_PIXEL_FORMAT_ABGR || pixFormat == AR_PIXEL_FORMAT_ARGB )\n                    return arLabelingSubDWRA3C(image, xsize, ysize, labelingThresh, labelInfo);\n                else if( pixFormat == AR_PIXEL_FORMAT_MONO || pixFormat == AR_PIXEL_FORMAT_420v || pixFormat == AR_PIXEL_FORMAT_420f || pixFormat == AR_PIXEL_FORMAT_NV21 )\n                    return arLabelingSubDWRC(image, xsize, ysize, labelingThresh, labelInfo);\n                else if( pixFormat == AR_PIXEL_FORMAT_yuvs )\n                    return arLabelingSubDWRYC(image, xsize, ysize, labelingThresh, labelInfo);\n                else if( pixFormat == AR_PIXEL_FORMAT_2vuy )\n                    return arLabelingSubDWRCY(image, xsize, ysize, labelingThresh, labelInfo);\n                else if( pixFormat == AR_PIXEL_FORMAT_RGB_565 )\n                    return arLabelingSubDWR3C565(image, xsize, ysize, labelingThresh, labelInfo);\n                else if( pixFormat == AR_PIXEL_FORMAT_RGBA_5551 )\n                    return arLabelingSubDWR3CA5551(image, xsize, ysize, labelingThresh, labelInfo);\n                else if( pixFormat == AR_PIXEL_FORMAT_RGBA_4444 )\n                    return arLabelingSubDWR3CA4444(image, xsize, ysize, labelingThresh, labelInfo);\n                else exit(0);\n            }\n            else if( imageProcMode == AR_IMAGE_PROC_FIELD_IMAGE ) {\n                if( pixFormat == AR_PIXEL_FORMAT_RGB || pixFormat == AR_PIXEL_FORMAT_BGR )\n                    return arLabelingSubDWI3C(image, xsize, ysize, labelingThresh, labelInfo);\n                else if( pixFormat == AR_PIXEL_FORMAT_RGBA || pixFormat == AR_PIXEL_FORMAT_BGRA )\n                    return arLabelingSubDWI3CA(image, xsize, ysize, labelingThresh, labelInfo);\n                else if( pixFormat == AR_PIXEL_FORMAT_ABGR || pixFormat == AR_PIXEL_FORMAT_ARGB )\n                    return arLabelingSubDWIA3C(image, xsize, ysize, labelingThresh, labelInfo);\n                else if( pixFormat == AR_PIXEL_FORMAT_MONO || pixFormat == AR_PIXEL_FORMAT_420v || pixFormat == AR_PIXEL_FORMAT_420f || pixFormat == AR_PIXEL_FORMAT_NV21 )\n                    return arLabelingSubDWIC(image, xsize, ysize, labelingThresh, labelInfo);\n                else if( pixFormat == AR_PIXEL_FORMAT_yuvs )\n                    return arLabelingSubDWIYC(image, xsize, ysize, labelingThresh, labelInfo);\n                else if( pixFormat == AR_PIXEL_FORMAT_2vuy )\n                    return arLabelingSubDWICY(image, xsize, ysize, labelingThresh, labelInfo);\n                else if( pixFormat == AR_PIXEL_FORMAT_RGB_565 )\n                    return arLabelingSubDWI3C565(image, xsize, ysize, labelingThresh, labelInfo);\n                else if( pixFormat == AR_PIXEL_FORMAT_RGBA_5551 )\n                    return arLabelingSubDWI3CA5551(image, xsize, ysize, labelingThresh, labelInfo);\n                else if( pixFormat == AR_PIXEL_FORMAT_RGBA_4444 )\n                    return arLabelingSubDWI3CA4444(image, xsize, ysize, labelingThresh, labelInfo);\n                else exit(0);\n            }\n            else exit(0);\n        }\n        else exit(0);\n#if !AR_DISABLE_LABELING_DEBUG_MODE\n    }\n    else if( debugMode == AR_DEBUG_ENABLE ) {\n        if( labelingMode == AR_LABELING_BLACK_REGION ) {\n#if !AR_DISABLE_THRESH_MODE_AUTO_ADAPTIVE\n            if (image_thresh) return arLabelingSubEBZ(image, xsize, ysize, image_thresh, labelInfo);\n#endif\n            if( imageProcMode == AR_IMAGE_PROC_FRAME_IMAGE ) {\n                if( pixFormat == AR_PIXEL_FORMAT_RGB || pixFormat == AR_PIXEL_FORMAT_BGR )\n                    return arLabelingSubEBR3C(image, xsize, ysize, labelingThresh, labelInfo);\n                else if( pixFormat == AR_PIXEL_FORMAT_RGBA || pixFormat == AR_PIXEL_FORMAT_BGRA )\n                    return arLabelingSubEBR3CA(image, xsize, ysize, labelingThresh, labelInfo);\n                else if( pixFormat == AR_PIXEL_FORMAT_ABGR || pixFormat == AR_PIXEL_FORMAT_ARGB )\n                    return arLabelingSubEBRA3C(image, xsize, ysize, labelingThresh, labelInfo);\n                else if( pixFormat == AR_PIXEL_FORMAT_MONO || pixFormat == AR_PIXEL_FORMAT_420v || pixFormat == AR_PIXEL_FORMAT_420f || pixFormat == AR_PIXEL_FORMAT_NV21 )\n                    return arLabelingSubEBRC(image, xsize, ysize, labelingThresh, labelInfo);\n                else if( pixFormat == AR_PIXEL_FORMAT_yuvs )\n                    return arLabelingSubEBRYC(image, xsize, ysize, labelingThresh, labelInfo);\n                else if( pixFormat == AR_PIXEL_FORMAT_2vuy )\n                    return arLabelingSubEBRCY(image, xsize, ysize, labelingThresh, labelInfo);\n                else if( pixFormat == AR_PIXEL_FORMAT_RGB_565 )\n                    return arLabelingSubEBR3C565(image, xsize, ysize, labelingThresh, labelInfo);\n                else if( pixFormat == AR_PIXEL_FORMAT_RGBA_5551 )\n                    return arLabelingSubEBR3CA5551(image, xsize, ysize, labelingThresh, labelInfo);\n                else if( pixFormat == AR_PIXEL_FORMAT_RGBA_4444 )\n                    return arLabelingSubEBR3CA4444(image, xsize, ysize, labelingThresh, labelInfo);\n                else exit(0);\n            }\n            else if( imageProcMode == AR_IMAGE_PROC_FIELD_IMAGE ) {\n                if( pixFormat == AR_PIXEL_FORMAT_RGB || pixFormat == AR_PIXEL_FORMAT_BGR )\n                    return arLabelingSubEBI3C(image, xsize, ysize, labelingThresh, labelInfo);\n                else if( pixFormat == AR_PIXEL_FORMAT_RGBA || pixFormat == AR_PIXEL_FORMAT_BGRA )\n                    return arLabelingSubEBI3CA(image, xsize, ysize, labelingThresh, labelInfo);\n                else if( pixFormat == AR_PIXEL_FORMAT_ABGR || pixFormat == AR_PIXEL_FORMAT_ARGB )\n                    return arLabelingSubEBIA3C(image, xsize, ysize, labelingThresh, labelInfo);\n                else if( pixFormat == AR_PIXEL_FORMAT_MONO || pixFormat == AR_PIXEL_FORMAT_420v || pixFormat == AR_PIXEL_FORMAT_420f || pixFormat == AR_PIXEL_FORMAT_NV21 )\n                    return arLabelingSubEBIC(image, xsize, ysize, labelingThresh, labelInfo);\n                else if( pixFormat == AR_PIXEL_FORMAT_yuvs )\n                    return arLabelingSubEBIYC(image, xsize, ysize, labelingThresh, labelInfo);\n                else if( pixFormat == AR_PIXEL_FORMAT_2vuy )\n                    return arLabelingSubEBICY(image, xsize, ysize, labelingThresh, labelInfo);\n                else if( pixFormat == AR_PIXEL_FORMAT_RGB_565 )\n                    return arLabelingSubEBI3C565(image, xsize, ysize, labelingThresh, labelInfo);\n                else if( pixFormat == AR_PIXEL_FORMAT_RGBA_5551 )\n                    return arLabelingSubEBI3CA5551(image, xsize, ysize, labelingThresh, labelInfo);\n                else if( pixFormat == AR_PIXEL_FORMAT_RGBA_4444 )\n                    return arLabelingSubEBI3CA4444(image, xsize, ysize, labelingThresh, labelInfo);\n                else exit(0);\n            }\n            else exit(0);\n        }\n        else if( labelingMode == AR_LABELING_WHITE_REGION ) {\n#if !AR_DISABLE_THRESH_MODE_AUTO_ADAPTIVE\n            if (image_thresh) return arLabelingSubEWZ(image, xsize, ysize, image_thresh, labelInfo);\n#endif\n            if( imageProcMode == AR_IMAGE_PROC_FRAME_IMAGE ) {\n                if( pixFormat == AR_PIXEL_FORMAT_RGB || pixFormat == AR_PIXEL_FORMAT_BGR )\n                    return arLabelingSubEWR3C(image, xsize, ysize, labelingThresh, labelInfo);\n                else if( pixFormat == AR_PIXEL_FORMAT_RGBA || pixFormat == AR_PIXEL_FORMAT_BGRA )\n                    return arLabelingSubEWR3CA(image, xsize, ysize, labelingThresh, labelInfo);\n                else if( pixFormat == AR_PIXEL_FORMAT_ABGR || pixFormat == AR_PIXEL_FORMAT_ARGB )\n                    return arLabelingSubEWRA3C(image, xsize, ysize, labelingThresh, labelInfo);\n                else if( pixFormat == AR_PIXEL_FORMAT_MONO || pixFormat == AR_PIXEL_FORMAT_420v || pixFormat == AR_PIXEL_FORMAT_420f || pixFormat == AR_PIXEL_FORMAT_NV21 )\n                    return arLabelingSubEWRC(image, xsize, ysize, labelingThresh, labelInfo);\n                else if( pixFormat == AR_PIXEL_FORMAT_yuvs )\n                    return arLabelingSubEWRYC(image, xsize, ysize, labelingThresh, labelInfo);\n                else if( pixFormat == AR_PIXEL_FORMAT_2vuy )\n                    return arLabelingSubEWRCY(image, xsize, ysize, labelingThresh, labelInfo);\n                else if( pixFormat == AR_PIXEL_FORMAT_RGB_565 )\n                    return arLabelingSubEWR3C565(image, xsize, ysize, labelingThresh, labelInfo);\n                else if( pixFormat == AR_PIXEL_FORMAT_RGBA_5551 )\n                    return arLabelingSubEWR3CA5551(image, xsize, ysize, labelingThresh, labelInfo);\n                else if( pixFormat == AR_PIXEL_FORMAT_RGBA_4444 )\n                    return arLabelingSubEWR3CA4444(image, xsize, ysize, labelingThresh, labelInfo);\n                else exit(0);\n            }\n            else if( imageProcMode == AR_IMAGE_PROC_FIELD_IMAGE ) {\n                if( pixFormat == AR_PIXEL_FORMAT_RGB || pixFormat == AR_PIXEL_FORMAT_BGR )\n                    return arLabelingSubEWI3C(image, xsize, ysize, labelingThresh, labelInfo);\n                else if( pixFormat == AR_PIXEL_FORMAT_RGBA || pixFormat == AR_PIXEL_FORMAT_BGRA )\n                    return arLabelingSubEWI3CA(image, xsize, ysize, labelingThresh, labelInfo);\n                else if( pixFormat == AR_PIXEL_FORMAT_ABGR || pixFormat == AR_PIXEL_FORMAT_ARGB )\n                    return arLabelingSubEWIA3C(image, xsize, ysize, labelingThresh, labelInfo);\n                else if( pixFormat == AR_PIXEL_FORMAT_MONO || pixFormat == AR_PIXEL_FORMAT_420v || pixFormat == AR_PIXEL_FORMAT_420f || pixFormat == AR_PIXEL_FORMAT_NV21 )\n                    return arLabelingSubEWIC(image, xsize, ysize, labelingThresh, labelInfo);\n                else if( pixFormat == AR_PIXEL_FORMAT_yuvs )\n                    return arLabelingSubEWIYC(image, xsize, ysize, labelingThresh, labelInfo);\n                else if( pixFormat == AR_PIXEL_FORMAT_2vuy )\n                    return arLabelingSubEWICY(image, xsize, ysize, labelingThresh, labelInfo);\n                else if( pixFormat == AR_PIXEL_FORMAT_RGB_565 )\n                    return arLabelingSubEWI3C565(image, xsize, ysize, labelingThresh, labelInfo);\n                else if( pixFormat == AR_PIXEL_FORMAT_RGBA_5551 )\n                    return arLabelingSubEWI3CA5551(image, xsize, ysize, labelingThresh, labelInfo);\n                else if( pixFormat == AR_PIXEL_FORMAT_RGBA_4444 )\n                    return arLabelingSubEWI3CA4444(image, xsize, ysize, labelingThresh, labelInfo);\n                else exit(0);\n            }\n            else exit(0);\n        }\n        else exit(0);\n    }\n    else exit(0);\n#endif\n}\n","/*\n *  AR2/marker.c\n *  ARToolKit5\n *\n *  This file is part of ARToolKit.\n *\n *  ARToolKit is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation, either version 3 of the License, or\n *  (at your option) any later version.\n *\n *  ARToolKit is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public License\n *  along with ARToolKit.  If not, see <http://www.gnu.org/licenses/>.\n *\n *  As a special exception, the copyright holders of this library give you\n *  permission to link this library with independent modules to produce an\n *  executable, regardless of the license terms of these independent modules, and to\n *  copy and distribute the resulting executable under terms of your choice,\n *  provided that you also meet, for each linked independent module, the terms and\n *  conditions of the license of that module. An independent module is a module\n *  which is neither derived from nor based on this library. If you modify this\n *  library, you may extend this exception to your version of the library, but you\n *  are not obligated to do so. If you do not wish to do so, delete this exception\n *  statement from your version.\n *\n *  Copyright 2015 Daqri, LLC.\n *  Copyright 2006-2015 ARToolworks, Inc.\n *\n *  Author(s): Hirokazu Kato, Philip Lamb\n *\n */\n\n#include <AR/ar.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <AR2/marker.h>\n#include <AR2/util.h>\n\nstatic char *get_buff( char *buf, int n, FILE *fp );\n\nint ar2FreeMarkerSet( AR2MarkerSetT **markerSet )\n{\n    if( *markerSet == NULL ) return -1;\n\n    free( (*markerSet)->marker );\n    free( *markerSet );\n    *markerSet = NULL;\n\n    return 0;\n}\n\nAR2MarkerSetT *ar2ReadMarkerSet( char *filename, char *ext, ARPattHandle  *pattHandle )\n{\n    //COVHI10394\n    FILE          *fp = NULL;\n    AR2MarkerSetT *markerSet = NULL;\n    char          buf[256], buf1[256]/*, buf2[256]*/;\n    int           i, j;\n\n    char namebuf[512];\n    sprintf(namebuf, \"%s.%s\", filename, ext);\n    if( (fp=fopen(namebuf, \"r\")) == NULL ) return NULL;\n\n    arMalloc( markerSet, AR2MarkerSetT, 1 );\n\n    if( get_buff(buf, 256, fp) == NULL ) {\n        free( markerSet );\n        markerSet = NULL;\n        goto done;\n    }\n    if( sscanf(buf, \"%d\", &(markerSet->num)) != 1 ) {\n        free( markerSet );\n        markerSet = NULL;\n        goto done;\n    }\n    if( markerSet->num <= 0 ) {\n        free(markerSet);\n        markerSet = NULL;\n        goto done;\n    }\n\n    arMalloc( markerSet->marker, AR2MarkerT, markerSet->num );\n\n    for( i = 0; i < markerSet->num; i++ ) {\n        if( get_buff(buf, 256, fp) == NULL ) {\n            free( markerSet->marker );\n            free( markerSet );\n            markerSet = NULL;\n            goto done;\n        }\n        if( sscanf(buf, \"%s\", buf1) != 1 ) {\n            free( markerSet->marker );\n            free( markerSet );\n            markerSet = NULL;\n            goto done;\n        }\n        //ar2UtilDivideExt(buf1, buf, buf2);\n        if( (markerSet->marker[i].pattId = arPattLoad(pattHandle, buf1)) < 0 ) {\n            free( markerSet->marker );\n            free( markerSet );\n            markerSet = NULL;\n            goto done;\n        }\n\n        if( get_buff(buf, 256, fp) == NULL ) {\n            free( markerSet->marker );\n            free( markerSet );\n            markerSet = NULL;\n            goto done;\n        }\n        if( sscanf(buf, \"%f\", &(markerSet->marker[i].width)) != 1 ) {\n            free( markerSet->marker );\n            free( markerSet );\n            markerSet = NULL;\n            goto done;\n        }\n\n        for( j = 0; j < 3; j++ ) {\n            if( get_buff(buf, 256, fp) == NULL ) {\n                free( markerSet->marker );\n                free( markerSet );\n                markerSet = NULL;\n                goto done;\n            }\n            if( sscanf(buf, \"%f %f %f %f\",\n                            &(markerSet->marker[i].transI2M[j][0]),\n                            &(markerSet->marker[i].transI2M[j][1]),\n                            &(markerSet->marker[i].transI2M[j][2]),\n                            &(markerSet->marker[i].transI2M[j][3])) != 4 ) {\n                free( markerSet->marker );\n                free( markerSet );\n                markerSet = NULL;\n                goto done;\n            }\n        }\n    }\n\ndone:\n    fclose(fp);\n    return markerSet;\n}\n\nstatic char *get_buff( char *buf, int n, FILE *fp )\n{\n    char *ret;\n\n    for(;;) {\n        ret = fgets( buf, n, fp );\n        if( ret == NULL ) return(NULL);\n        if( buf[0] != '\\n' && buf[0] != '#' ) return(ret);\n    }\n}\n\n","/*\n *  AR2/featureSet.c\n *  ARToolKit5\n *\n *  This file is part of ARToolKit.\n *\n *  ARToolKit is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation, either version 3 of the License, or\n *  (at your option) any later version.\n *\n *  ARToolKit is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public License\n *  along with ARToolKit.  If not, see <http://www.gnu.org/licenses/>.\n *\n *  As a special exception, the copyright holders of this library give you\n *  permission to link this library with independent modules to produce an\n *  executable, regardless of the license terms of these independent modules, and to\n *  copy and distribute the resulting executable under terms of your choice,\n *  provided that you also meet, for each linked independent module, the terms and\n *  conditions of the license of that module. An independent module is a module\n *  which is neither derived from nor based on this library. If you modify this\n *  library, you may extend this exception to your version of the library, but you\n *  are not obligated to do so. If you do not wish to do so, delete this exception\n *  statement from your version.\n *\n *  Copyright 2015 Daqri, LLC.\n *  Copyright 2006-2015 ARToolworks, Inc.\n *\n *  Author(s): Hirokazu Kato, Philip Lamb\n *\n */\n\n#include <AR/ar.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <AR2/featureSet.h>\n\nAR2FeatureSetT *ar2ReadFeatureSet( char *filename, char *ext )\n{\n    AR2FeatureSetT *featureSet = NULL;\n    FILE           *fp = NULL;\n    int            i, j, l3;\n\n    char buf[512];\n    sprintf(buf, \"%s.%s\", filename, ext);\n    if( (fp=fopen(buf, \"rb\")) == NULL ) {\n        ARLOGe(\"File open error. %s\\n\", filename);\n        return NULL;\n    }\n\n    arMalloc( featureSet, AR2FeatureSetT, 1 );\n\n    //COVHI10403\n    if( fread(&(featureSet->num), sizeof(featureSet->num), 1, fp) != 1 ) {\n        ARLOGe(\"Read error!!\\n\");\n        goto bail0;\n    }\n\n    arMalloc( featureSet->list, AR2FeaturePointsT, featureSet->num );\n    for( i = 0; i < featureSet->num; i++ ) {\n        if( fread(&(featureSet->list[i].scale), sizeof(featureSet->list[i].scale), 1, fp) != 1 ) {\n            ARLOGe(\"Read error!!\\n\");\n            goto bail1;\n        }\n        if( fread(&(featureSet->list[i].maxdpi), sizeof(featureSet->list[i].maxdpi), 1, fp) != 1 ) {\n            ARLOGe(\"Read error!!\\n\");\n            goto bail1;\n        }\n        if( fread(&(featureSet->list[i].mindpi), sizeof(featureSet->list[i].mindpi), 1, fp) != 1 ) {\n            ARLOGe(\"Read error!!\\n\");\n            goto bail1;\n        }\n        if( fread(&(featureSet->list[i].num), sizeof(featureSet->list[i].num), 1, fp) != 1 ) {\n            ARLOGe(\"Read error!!\\n\");\n            goto bail1;\n        }\n\n        arMalloc( featureSet->list[i].coord, AR2FeatureCoordT, featureSet->list[i].num );\n        for( j = 0; j < featureSet->list[i].num; j++ ) {\n            if( fread(&(featureSet->list[i].coord[j].x), sizeof(featureSet->list[i].coord[j].x), 1, fp) != 1 ) {\n                ARLOGe(\"Read error!!\\n\");\n                goto bail1;\n            }\n            if( fread(&(featureSet->list[i].coord[j].y), sizeof(featureSet->list[i].coord[j].y), 1, fp) != 1 ) {\n                ARLOGe(\"Read error!!\\n\");\n                goto bail1;\n            }\n            if( fread(&(featureSet->list[i].coord[j].mx), sizeof(featureSet->list[i].coord[j].mx), 1, fp) != 1 ) {\n                ARLOGe(\"Read error!!\\n\");\n                goto bail1;\n            }\n            if( fread(&(featureSet->list[i].coord[j].my), sizeof(featureSet->list[i].coord[j].my), 1, fp) != 1 ) {\n                ARLOGe(\"Read error!!\\n\");\n                goto bail1;\n            }\n            if( fread(&(featureSet->list[i].coord[j].maxSim), sizeof(featureSet->list[i].coord[j].maxSim), 1, fp) != 1 ) {\n                ARLOGe(\"Read error!!\\n\");\n                goto bail1;\n            }\n        }\n    }\n\n    goto done;\n    \nbail1:\n    for(l3=0;l3<i;l3++) {\n        free( featureSet->list[l3].coord );\n    }\n    free( featureSet->list );\nbail0:\n    free( featureSet );\n    featureSet = NULL;\n\ndone:\n    fclose(fp);\n    return featureSet;\n}\n\nint ar2SaveFeatureSet( char *filename, char *ext, AR2FeatureSetT *featureSet )\n{\n    FILE    *fp;\n    int     i, j;\n\n    char buf[512];\n    sprintf(buf, \"%s.%s\", filename, ext);\n    if( (fp=fopen(buf, \"wb\")) == NULL ) {\n        ARLOGe(\"File open error. %s\\n\", filename);\n        return -1;\n    }\n\n    if( fwrite(&(featureSet->num), sizeof(featureSet->num), 1, fp) != 1 ) goto bailBadWrite;\n\n    for( i = 0; i < featureSet->num; i++ ) {\n        if( fwrite(&(featureSet->list[i].scale), sizeof(featureSet->list[i].scale), 1, fp) != 1 ) goto bailBadWrite;\n        if( fwrite(&(featureSet->list[i].maxdpi), sizeof(featureSet->list[i].maxdpi), 1, fp) != 1 ) goto bailBadWrite;\n        if( fwrite(&(featureSet->list[i].mindpi), sizeof(featureSet->list[i].mindpi), 1, fp) != 1 ) goto bailBadWrite;\n        if( fwrite(&(featureSet->list[i].num), sizeof(featureSet->list[i].num), 1, fp) != 1 ) goto bailBadWrite;\n\n        for( j = 0; j < featureSet->list[i].num; j++ ) {\n            if( fwrite(&(featureSet->list[i].coord[j].x), sizeof(featureSet->list[i].coord[j].x), 1, fp) != 1 ) goto bailBadWrite;\n            if( fwrite(&(featureSet->list[i].coord[j].y), sizeof(featureSet->list[i].coord[j].y), 1, fp) != 1 ) goto bailBadWrite;\n            if( fwrite(&(featureSet->list[i].coord[j].mx), sizeof(featureSet->list[i].coord[j].mx), 1, fp) != 1 ) goto bailBadWrite;\n            if( fwrite(&(featureSet->list[i].coord[j].my), sizeof(featureSet->list[i].coord[j].my), 1, fp) != 1 ) goto bailBadWrite;\n            if( fwrite(&(featureSet->list[i].coord[j].maxSim), sizeof(featureSet->list[i].coord[j].maxSim), 1, fp) != 1 ) goto bailBadWrite;\n        }\n    }\n\n    fclose(fp);\n    return 0;\n    \nbailBadWrite:\n    ARLOGe(\"Error saving feature set: error writing data.\\n\");\n    fclose(fp);\n    return (-1);\n}\n\nint ar2FreeFeatureSet( AR2FeatureSetT **featureSet )\n{\n    int     i;\n\n    if( *featureSet == NULL ) return -1;\n\n    for( i = 0; i < (*featureSet)->num; i++ ) {\n        free( (*featureSet)->list[i].coord );\n    }\n    free( (*featureSet)->list );\n    free( *featureSet );\n    *featureSet = NULL;\n\n    return 0;\n}\n","/*\n *  gsub_lite.c\n *  ARToolKit5\n *\n *\tGraphics Subroutines (Lite) for ARToolKit.\n *\n *  This file is part of ARToolKit.\n *\n *  ARToolKit is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation, either version 3 of the License, or\n *  (at your option) any later version.\n *\n *  ARToolKit is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public License\n *  along with ARToolKit.  If not, see <http://www.gnu.org/licenses/>.\n *\n *  As a special exception, the copyright holders of this library give you\n *  permission to link this library with independent modules to produce an\n *  executable, regardless of the license terms of these independent modules, and to\n *  copy and distribute the resulting executable under terms of your choice,\n *  provided that you also meet, for each linked independent module, the terms and\n *  conditions of the license of that module. An independent module is a module\n *  which is neither derived from nor based on this library. If you modify this\n *  library, you may extend this exception to your version of the library, but you\n *  are not obligated to do so. If you do not wish to do so, delete this exception\n *  statement from your version.\n *\n *  Copyright 2015 Daqri, LLC.\n *  Copyright 2003-2015 ARToolworks, Inc.\n *\n *  Author(s): Philip Lamb\n *\n */\n\n// ============================================================================\n//\tPrivate includes.\n// ============================================================================\n\n#include <AR/gsub_lite.h>\n\n#include <stdio.h>\t\t// fprintf(), stderr\n#include <string.h>\t\t// strchr(), strstr(), strlen()\n#ifndef __APPLE__\n#  include <GL/glu.h>\n#  ifdef _WIN32\n#    include \"GL/glext.h\"\n#    include \"GL/wglext.h\"\n#  else\n#    ifdef GL_VERSION_1_2\n#      include <GL/glext.h>\n#    endif\n#  endif\n#else\n#  include <OpenGL/glu.h>\n#  include <OpenGL/glext.h>\n#endif\n\n\n// ============================================================================\n//\tPrivate types and defines.\n// ============================================================================\n#ifdef _MSC_VER\n#  pragma warning (disable:4068)\t// Disable MSVC warnings about unknown pragmas.\n#endif\n\n#if AR_ENABLE_MINIMIZE_MEMORY_FOOTPRINT\n#  define ARGL_SUPPORT_DEBUG_MODE 0\n#else\n#  define ARGL_SUPPORT_DEBUG_MODE 1 // Edit as required.\n#endif\n\n// Make sure that required OpenGL constant definitions are available at compile-time.\n// N.B. These should not be used unless the renderer indicates (at run-time) that it supports them.\n\n// Define constants for extensions which became core in OpenGL 1.2\n#ifndef GL_VERSION_1_2\n#  if GL_EXT_bgra\n#    define GL_BGR\t\t\t\t\t\t\tGL_BGR_EXT\n#    define GL_BGRA\t\t\t\t\t\t\tGL_BGRA_EXT\n#  else\n#    define GL_BGR\t\t\t\t\t\t\t0x80E0\n#    define GL_BGRA\t\t\t\t\t\t\t0x80E1\n#  endif\n#  ifndef GL_APPLE_packed_pixels\n#    define GL_UNSIGNED_SHORT_4_4_4_4       0x8033\n#    define GL_UNSIGNED_SHORT_5_5_5_1       0x8034\n#    define GL_UNSIGNED_INT_8_8_8_8         0x8035\n#    define GL_UNSIGNED_SHORT_5_6_5         0x8363\n#    define GL_UNSIGNED_SHORT_5_6_5_REV     0x8364\n#    define GL_UNSIGNED_SHORT_4_4_4_4_REV   0x8365\n#    define GL_UNSIGNED_SHORT_1_5_5_5_REV   0x8366\n#    define GL_UNSIGNED_INT_8_8_8_8_REV     0x8367\n#  endif\n#  if GL_SGIS_texture_edge_clamp\n#    define GL_CLAMP_TO_EDGE\t\t\t\tGL_CLAMP_TO_EDGE_SGIS\n#  else\n#    define GL_CLAMP_TO_EDGE\t\t\t\t0x812F\n#  endif\n#endif\n\n// Define constants for extensions which became core in OpenGL 3.1\n#ifndef GL_VERSION_3_1\n#  if GL_NV_texture_rectangle\n#    define GL_TEXTURE_RECTANGLE            GL_TEXTURE_RECTANGLE_NV\n#    define GL_PROXY_TEXTURE_RECTANGLE\t\tGL_PROXY_TEXTURE_RECTANGLE_NV\n#    define GL_MAX_RECTANGLE_TEXTURE_SIZE   GL_MAX_RECTANGLE_TEXTURE_SIZE_NV\n#  elif GL_EXT_texture_rectangle\n#    define GL_TEXTURE_RECTANGLE            GL_TEXTURE_RECTANGLE_EXT\n#    define GL_PROXY_TEXTURE_RECTANGLE      GL_PROXY_TEXTURE_RECTANGLE_EXT\n#    define GL_MAX_RECTANGLE_TEXTURE_SIZE   GL_MAX_RECTANGLE_TEXTURE_SIZE_EXT\n#  else\n#    define GL_TEXTURE_RECTANGLE            0x84F5\n#    define GL_PROXY_TEXTURE_RECTANGLE      0x84F7\n#    define GL_MAX_RECTANGLE_TEXTURE_SIZE   0x84F8\n#  endif\n#endif\n\n// Define constants for extensions (not yet core).\n#ifndef GL_APPLE_ycbcr_422\n#  define GL_YCBCR_422_APPLE\t\t\t\t0x85B9\n#  define GL_UNSIGNED_SHORT_8_8_APPLE\t\t0x85BA\n#  define GL_UNSIGNED_SHORT_8_8_REV_APPLE\t0x85BB\n#endif\n#ifndef GL_EXT_abgr\n#  define GL_ABGR_EXT\t\t\t\t\t\t0x8000\n#endif\n#ifndef GL_MESA_ycbcr_texture\n#  define GL_YCBCR_MESA\t\t\t\t\t\t0x8757\n#  define GL_UNSIGNED_SHORT_8_8_MESA\t\t0x85BA\n#  define GL_UNSIGNED_SHORT_8_8_REV_MESA\t0x85BB\n#endif\n\n// On Windows, all OpenGL v1.5 and later API must be dynamically resolved against the actual driver.\n#ifdef _WIN32\nPFNGLGENBUFFERSPROC glGenBuffers = NULL; // (PFNGLGENBUFFERSPROC)wglGetProcAddress(\"glGenBuffersARB\");\nPFNGLDELETEBUFFERSPROC glDeleteBuffers = NULL;\nPFNGLBINDBUFFERPROC glBindBuffer = NULL;\nPFNGLBUFFERDATAPROC glBufferData = NULL;\nPFNGLACTIVETEXTUREPROC glActiveTexture = NULL;\nPFNGLCLIENTACTIVETEXTUREPROC glClientActiveTexture = NULL;\n#endif\n\n//#define ARGL_DEBUG\n\nstruct _ARGL_CONTEXT_SETTINGS {\n    ARParam arParam;\n    ARHandle *arhandle; // Not used except for debug mode.\n    GLuint  texture;\n    float   *t2;\n    float   *v2;\n    GLuint  t2bo;     // Vertex buffer object for t2 data.\n    GLuint  v2bo;     // Vertex buffer object for v2 data.\n    float   zoom;\n    GLint   textureSizeMax;\n    GLsizei textureSizeX;\n    GLsizei textureSizeY;\n    GLenum  pixIntFormat;\n    GLenum  pixFormat;\n    GLenum  pixType;\n    GLenum  pixSize;\n    AR_PIXEL_FORMAT format;\n    int     disableDistortionCompensation;\n    int     textureGeometryHasBeenSetup;\n    int     textureObjectsHaveBeenSetup;\n    int     rotate90;\n    int     flipH;\n    int     flipV;\n    GLsizei bufSizeX;\n    GLsizei bufSizeY;\n    int     bufSizeIsTextureSize;\n    int     textureDataReady;\n    int\t    arglTexmapMode;\n};\ntypedef struct _ARGL_CONTEXT_SETTINGS ARGL_CONTEXT_SETTINGS;\n\n\n// ============================================================================\n//\tPrivate globals.\n// ============================================================================\n\n\n#pragma mark -\n// ============================================================================\n//\tPrivate functions.\n// ============================================================================\n\n#if !ARGL_DISABLE_DISP_IMAGE && !EMSCRIPTEN\n// Sets texture, t2, v2, textureGeometryHasBeenSetup.\nstatic char arglSetupTextureGeometry(ARGL_CONTEXT_SETTINGS_REF contextSettings)\n{\n    float    ty_prev, tx, ty;\n    float    y_prev, x, y;\n    ARdouble x1, x2, y1, y2;\n    float    xx1, xx2, yy1, yy2;\n    int      i, j;\n    int      vertexCount, t2count, v2count;\n    float    imageSizeX, imageSizeY;\n    float    zoom;\n    \n    // Delete previous geometry, unless this is our first time here.\n    if (contextSettings->textureGeometryHasBeenSetup) {\n        free(contextSettings->t2);\n        free(contextSettings->v2);\n        glDeleteBuffers(1, &contextSettings->t2bo);\n        glDeleteBuffers(1, &contextSettings->v2bo);\n        contextSettings->textureGeometryHasBeenSetup = FALSE;\n    }\n    \n    // Set up the geometry for the surface which we will texture upon.\n    imageSizeX = (float)contextSettings->arParam.xsize;\n    imageSizeY = (float)contextSettings->arParam.ysize;\n    zoom = contextSettings->zoom;\n    if (contextSettings->disableDistortionCompensation) vertexCount = 4;\n    else vertexCount = 840; // 20 rows of 2 x 21 vertices.\n    contextSettings->t2 = (float *)malloc(sizeof(float) * 2 * vertexCount);\n    contextSettings->v2 = (float *)malloc(sizeof(float) * 2 * vertexCount);\n    t2count = v2count = 0;\n    if (contextSettings->disableDistortionCompensation) {\n        contextSettings->t2[t2count++] = 0.0f; // Top-left.\n        contextSettings->t2[t2count++] = 0.0f;\n        contextSettings->v2[v2count++] = 0.0f;\n        contextSettings->v2[v2count++] = imageSizeY * zoom;\n        contextSettings->t2[t2count++] = 0.0f; // Bottom-left.\n        contextSettings->t2[t2count++] = imageSizeY/(float)contextSettings->textureSizeY;\n        contextSettings->v2[v2count++] = 0.0f;\n        contextSettings->v2[v2count++] = 0.0f;\n        contextSettings->t2[t2count++] = imageSizeX/(float)contextSettings->textureSizeX; // Top-right.\n        contextSettings->t2[t2count++] = 0.0f;\n        contextSettings->v2[v2count++] = imageSizeX * zoom;\n        contextSettings->v2[v2count++] = imageSizeY * zoom;\n        contextSettings->t2[t2count++] = imageSizeX/(float)contextSettings->textureSizeX; // Bottom-right.\n        contextSettings->t2[t2count++] = imageSizeY/(float)contextSettings->textureSizeY;\n        contextSettings->v2[v2count++] = imageSizeX * zoom;\n        contextSettings->v2[v2count++] = 0.0f;\n    } else {\n        y = 0.0f;\n        ty = 0.0f;\n        for (j = 1; j <= 20; j++) {    // Do 20 rows of triangle strips.\n            y_prev = y;\n            ty_prev = ty;\n            y = imageSizeY * (float)j / 20.0f;\n            ty = y / (float)contextSettings->textureSizeY;\n            \n            \n            for (i = 0; i <= 20; i++) { // 21 columns of triangle strip vertices, 2 vertices per column.\n                x = imageSizeX * (float)i / 20.0f;\n                tx = x / (float)contextSettings->textureSizeX;\n                \n                arParamObserv2Ideal(contextSettings->arParam.dist_factor, (ARdouble)x, (ARdouble)y_prev, &x1, &y1, contextSettings->arParam.dist_function_version);\n                arParamObserv2Ideal(contextSettings->arParam.dist_factor, (ARdouble)x, (ARdouble)y,      &x2, &y2, contextSettings->arParam.dist_function_version);\n                \n                xx1 = (float)x1 * zoom;\n                yy1 = (imageSizeY - (float)y1) * zoom;\n                xx2 = (float)x2 * zoom;\n                yy2 = (imageSizeY - (float)y2) * zoom;\n                \n                contextSettings->t2[t2count++] = tx; // Top.\n                contextSettings->t2[t2count++] = ty_prev;\n                contextSettings->v2[v2count++] = xx1;\n                contextSettings->v2[v2count++] = yy1;\n                contextSettings->t2[t2count++] = tx; // Bottom.\n                contextSettings->t2[t2count++] = ty;\n                contextSettings->v2[v2count++] = xx2;\n                contextSettings->v2[v2count++] = yy2;\n            } // columns.\n        } // rows.\n    }\n    \n    // Now setup VBOs.\n    glGenBuffers(1, &contextSettings->t2bo);\n    glGenBuffers(1, &contextSettings->v2bo);\n    glBindBuffer(GL_ARRAY_BUFFER, contextSettings->t2bo);\n    glBufferData(GL_ARRAY_BUFFER, sizeof(float) * 2 * vertexCount, contextSettings->t2, GL_STATIC_DRAW);\n    glBindBuffer(GL_ARRAY_BUFFER, contextSettings->v2bo);\n    glBufferData(GL_ARRAY_BUFFER, sizeof(float) * 2 * vertexCount, contextSettings->v2, GL_STATIC_DRAW);\n    glBindBuffer(GL_ARRAY_BUFFER, 0);\n    \n    contextSettings->textureGeometryHasBeenSetup = TRUE;\n    return (TRUE);\n}\n\n\n// Set up the texture objects.\nstatic char arglSetupTextureObjects(ARGL_CONTEXT_SETTINGS_REF contextSettings)\n{\n    GLint textureWrapMode;\n    \n    // Delete previous textures, unless this is our first time here.\n    if (contextSettings->textureObjectsHaveBeenSetup) {\n        glActiveTexture(GL_TEXTURE0);\n        glBindTexture(GL_TEXTURE_2D, 0);\n        glDeleteTextures(1, &(contextSettings->texture));\n        contextSettings->textureObjectsHaveBeenSetup = FALSE;\n    }\n    \n    glGenTextures(1, &(contextSettings->texture));\n    glActiveTexture(GL_TEXTURE0);\n    glBindTexture(GL_TEXTURE_2D, contextSettings->texture);\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);\n    // Decide whether we can use GL_CLAMP_TO_EDGE.\n    if (arglGLCapabilityCheck(0x0120, (unsigned char *)\"GL_SGIS_texture_edge_clamp\")) {\n        textureWrapMode = GL_CLAMP_TO_EDGE;\n    } else {\n        textureWrapMode = GL_REPEAT;\n    }\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, textureWrapMode);\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, textureWrapMode);\n    \n    contextSettings->textureObjectsHaveBeenSetup = TRUE;\n    return (TRUE);\n}\n\n#endif // !ARGL_DISABLE_DISP_IMAGE\n\n#pragma mark -\n// ============================================================================\n//\tPublic functions.\n// ============================================================================\n\n//\n// Convert a camera parameter structure into an OpenGL projection matrix.\n//\nvoid arglCameraFrustum(const ARParam *cparam, const ARdouble focalmin, const ARdouble focalmax, ARdouble m_projection[16])\n{\n\tARdouble    icpara[3][4];\n    ARdouble    trans[3][4];\n    ARdouble    p[3][3], q[4][4];\n\tint         width, height;\n    int         i, j;\n\t\n    width  = cparam->xsize;\n    height = cparam->ysize;\n\n    if (arParamDecompMat(cparam->mat, icpara, trans) < 0) {\n        ARLOGe(\"arglCameraFrustum(): arParamDecompMat() indicated parameter error.\\n\");\n        return;\n    }\n\tfor (i = 0; i < 4; i++) {\n        icpara[1][i] = (height - 1)*(icpara[2][i]) - icpara[1][i];\n    }\n\t\t\n    for(i = 0; i < 3; i++) {\n        for(j = 0; j < 3; j++) {\n            p[i][j] = icpara[i][j] / icpara[2][2];\n        }\n    }\n    q[0][0] = (2.0 * p[0][0] / (width - 1));\n    q[0][1] = (2.0 * p[0][1] / (width - 1));\n    q[0][2] = ((2.0 * p[0][2] / (width - 1))  - 1.0);\n    q[0][3] = 0.0;\n\t\n    q[1][0] = 0.0;\n    q[1][1] = (2.0 * p[1][1] / (height - 1));\n    q[1][2] = ((2.0 * p[1][2] / (height - 1)) - 1.0);\n    q[1][3] = 0.0;\n\t\n    q[2][0] = 0.0;\n    q[2][1] = 0.0;\n    q[2][2] = (focalmax + focalmin)/(focalmax - focalmin);\n    q[2][3] = -2.0 * focalmax * focalmin / (focalmax - focalmin);\n\t\n    q[3][0] = 0.0;\n    q[3][1] = 0.0;\n    q[3][2] = 1.0;\n    q[3][3] = 0.0;\n\t\n    for (i = 0; i < 4; i++) { // Row.\n\t\t// First 3 columns of the current row.\n        for (j = 0; j < 3; j++) { // Column.\n            m_projection[i + j*4] = q[i][0] * trans[0][j] +\n\t\t\t\t\t\t\t\t\tq[i][1] * trans[1][j] +\n\t\t\t\t\t\t\t\t\tq[i][2] * trans[2][j];\n        }\n\t\t// Fourth column of the current row.\n        m_projection[i + 3*4] = q[i][0] * trans[0][3] +\n\t\t\t\t\t\t\t\tq[i][1] * trans[1][3] +\n\t\t\t\t\t\t\t\tq[i][2] * trans[2][3] +\n\t\t\t\t\t\t\t\tq[i][3];\n    }\t\n}\n\nvoid arglCameraFrustumRH(const ARParam *cparam, const ARdouble focalmin, const ARdouble focalmax, ARdouble m_projection[16])\n{\n\tARdouble    icpara[3][4];\n    ARdouble    trans[3][4];\n    ARdouble    p[3][3], q[4][4];\n\tint         width, height;\n    int         i, j;\n\t\n    width  = cparam->xsize;\n    height = cparam->ysize;\n\t\n    if (arParamDecompMat(cparam->mat, icpara, trans) < 0) {\n        ARLOGe(\"arglCameraFrustum(): arParamDecompMat() indicated parameter error.\\n\");\n        return;\n    }\n\tfor (i = 0; i < 4; i++) {\n        icpara[1][i] = (height - 1)*(icpara[2][i]) - icpara[1][i];\n    }\n\t\n    for(i = 0; i < 3; i++) {\n        for(j = 0; j < 3; j++) {\n            p[i][j] = icpara[i][j] / icpara[2][2];\n        }\n    }\n    q[0][0] = (2.0 * p[0][0] / (width - 1));\n    q[0][1] = (2.0 * p[0][1] / (width - 1));\n    q[0][2] = -((2.0 * p[0][2] / (width - 1))  - 1.0);\n    q[0][3] = 0.0;\n\t\n    q[1][0] = 0.0;\n    q[1][1] = -(2.0 * p[1][1] / (height - 1));\n    q[1][2] = -((2.0 * p[1][2] / (height - 1)) - 1.0);\n    q[1][3] = 0.0;\n\t\n    q[2][0] = 0.0;\n    q[2][1] = 0.0;\n    q[2][2] = (focalmax + focalmin)/(focalmin - focalmax);\n    q[2][3] = 2.0 * focalmax * focalmin / (focalmin - focalmax);\n\t\n    q[3][0] = 0.0;\n    q[3][1] = 0.0;\n    q[3][2] = -1.0;\n    q[3][3] = 0.0;\n\t\n    for (i = 0; i < 4; i++) { // Row.\n\t\t// First 3 columns of the current row.\n        for (j = 0; j < 3; j++) { // Column.\n            m_projection[i + j*4] = q[i][0] * trans[0][j] +\n\t\t\t\t\t\t\t\t\tq[i][1] * trans[1][j] +\n\t\t\t\t\t\t\t\t\tq[i][2] * trans[2][j];\n        }\n\t\t// Fourth column of the current row.\n        m_projection[i + 3*4] = q[i][0] * trans[0][3] +\n\t\t\t\t\t\t\t\tq[i][1] * trans[1][3] +\n\t\t\t\t\t\t\t\tq[i][2] * trans[2][3] +\n\t\t\t\t\t\t\t\tq[i][3];\n    }\t\n}\n\n// para's type is also equivalent to (double(*)[4]).\nvoid arglCameraView(const ARdouble para[3][4], ARdouble m_modelview[16], const ARdouble scale)\n{\n\tm_modelview[0 + 0*4] = para[0][0]; // R1C1\n\tm_modelview[0 + 1*4] = para[0][1]; // R1C2\n\tm_modelview[0 + 2*4] = para[0][2];\n\tm_modelview[0 + 3*4] = para[0][3];\n\tm_modelview[1 + 0*4] = para[1][0]; // R2\n\tm_modelview[1 + 1*4] = para[1][1];\n\tm_modelview[1 + 2*4] = para[1][2];\n\tm_modelview[1 + 3*4] = para[1][3];\n\tm_modelview[2 + 0*4] = para[2][0]; // R3\n\tm_modelview[2 + 1*4] = para[2][1];\n\tm_modelview[2 + 2*4] = para[2][2];\n\tm_modelview[2 + 3*4] = para[2][3];\n\tm_modelview[3 + 0*4] = 0.0;\n\tm_modelview[3 + 1*4] = 0.0;\n\tm_modelview[3 + 2*4] = 0.0;\n\tm_modelview[3 + 3*4] = 1.0;\n\tif (scale != 0.0) {\n\t\tm_modelview[12] *= scale;\n\t\tm_modelview[13] *= scale;\n\t\tm_modelview[14] *= scale;\n\t}\n}\n\n// para's type is also equivalent to (double(*)[4]).\nvoid arglCameraViewRH(const ARdouble para[3][4], ARdouble m_modelview[16], const ARdouble scale)\n{\n\tm_modelview[0 + 0*4] = para[0][0]; // R1C1\n\tm_modelview[0 + 1*4] = para[0][1]; // R1C2\n\tm_modelview[0 + 2*4] = para[0][2];\n\tm_modelview[0 + 3*4] = para[0][3];\n\tm_modelview[1 + 0*4] = -para[1][0]; // R2\n\tm_modelview[1 + 1*4] = -para[1][1];\n\tm_modelview[1 + 2*4] = -para[1][2];\n\tm_modelview[1 + 3*4] = -para[1][3];\n\tm_modelview[2 + 0*4] = -para[2][0]; // R3\n\tm_modelview[2 + 1*4] = -para[2][1];\n\tm_modelview[2 + 2*4] = -para[2][2];\n\tm_modelview[2 + 3*4] = -para[2][3];\n\tm_modelview[3 + 0*4] = 0.0;\n\tm_modelview[3 + 1*4] = 0.0;\n\tm_modelview[3 + 2*4] = 0.0;\n\tm_modelview[3 + 3*4] = 1.0;\n\tif (scale != 0.0) {\n\t\tm_modelview[12] *= scale;\n\t\tm_modelview[13] *= scale;\n\t\tm_modelview[14] *= scale;\n\t}\n}\n\n#if !ARGL_DISABLE_DISP_IMAGE && !EMSCRIPTEN\n\nARGL_CONTEXT_SETTINGS_REF arglSetupForCurrentContext(ARParam *cparam, AR_PIXEL_FORMAT pixelFormat)\n{\n    ARGL_CONTEXT_SETTINGS_REF contextSettings;\n    \n\t// OpenGL 1.5 required.\n\tif (!arglGLCapabilityCheck(0x0150, NULL)) {\n\t\tARLOGe(\"Error: OpenGL v1.5 or later is required, but not found. Renderer reported '%s'\\n\", glGetString(GL_VERSION));\n\t\treturn (NULL);\n\t}\n#ifdef _WIN32\n\tif (!glGenBuffers) glGenBuffers = (PFNGLGENBUFFERSPROC)wglGetProcAddress(\"glGenBuffers\");\n\tif (!glDeleteBuffers) glDeleteBuffers = (PFNGLDELETEBUFFERSPROC)wglGetProcAddress(\"glDeleteBuffers\");\n\tif (!glBindBuffer) glBindBuffer = (PFNGLBINDBUFFERPROC)wglGetProcAddress(\"glBindBuffer\");\n\tif (!glBufferData) glBufferData = (PFNGLBUFFERDATAPROC)wglGetProcAddress(\"glBufferData\");\n\tif (!glActiveTexture) glActiveTexture = (PFNGLACTIVETEXTUREPROC)wglGetProcAddress(\"glActiveTexture\");\n\tif (!glClientActiveTexture) glClientActiveTexture = (PFNGLCLIENTACTIVETEXTUREPROC)wglGetProcAddress(\"glClientActiveTexture\");\n\tif (!glGenBuffers || !glDeleteBuffers || !glBindBuffer || !glBufferData || !glActiveTexture || !glClientActiveTexture) {\n\t\tARLOGe(\"Error: a required OpenGL function counld not be bound.\\n\");\n\t\treturn (NULL);\n\t}\n#endif\n\n    contextSettings = (ARGL_CONTEXT_SETTINGS_REF)calloc(1, sizeof(ARGL_CONTEXT_SETTINGS));\n    contextSettings->arParam = *cparam; // Copy it.\n    contextSettings->arhandle = NULL;\n    contextSettings->zoom = 1.0f;\n    // Because of calloc used above, these are redundant.\n    //contextSettings->rotate90 = contextSettings->flipH = contextSettings->flipV = FALSE;\n    //contextSettings->disableDistortionCompensation = FALSE;\n    //contextSettings->textureGeometryHasBeenSetup = FALSE;\n    //contextSettings->textureObjectsHaveBeenSetup = FALSE;\n    //contextSettings->textureDataReady = FALSE;\n    \n    // This sets pixIntFormat, pixFormat, pixType, pixSize, and resets textureDataReady.\n    arglPixelFormatSet(contextSettings, pixelFormat);\n    \n    // Set pixel buffer sizes to incoming image size, by default.\n    if (!arglPixelBufferSizeSet(contextSettings, cparam->xsize, cparam->ysize)) {\n        ARLOGe(\"ARGL: Error setting pixel buffer size.\\n\");\n        free (contextSettings);\n        return (NULL);\n    }\n    \n    return (contextSettings);\n}\n\nint arglSetupDebugMode(ARGL_CONTEXT_SETTINGS_REF contextSettings, ARHandle *arHandle)\n{\n    contextSettings->arhandle = arHandle;\n    return (TRUE);\n}\n\nvoid arglCleanup(ARGL_CONTEXT_SETTINGS_REF contextSettings)\n{\n    if (!contextSettings) return; // Sanity check.\n    \n    if (contextSettings->textureObjectsHaveBeenSetup) {\n        glActiveTexture(GL_TEXTURE0);\n        glBindTexture(GL_TEXTURE_2D, 0);\n        glDeleteTextures(1, &(contextSettings->texture));\n    }\n    \n    if (contextSettings->textureGeometryHasBeenSetup) {\n        free(contextSettings->t2);\n        free(contextSettings->v2);\n        glDeleteBuffers(1, &contextSettings->t2bo);\n        glDeleteBuffers(1, &contextSettings->v2bo);\n    }\n    \n    free(contextSettings);\n}\n\nvoid arglDispImage(ARGL_CONTEXT_SETTINGS_REF contextSettings)\n{\n    GLdouble left, right, bottom, top;\n    GLboolean lightingSave;\n    GLboolean depthTestSave;\n    \n    if (!contextSettings) return;\n    \n    // Prepare an orthographic projection, set camera position for 2D drawing, and save GL state.\n    glMatrixMode(GL_PROJECTION);\n    glPushMatrix();\n    glLoadIdentity();\n    if (contextSettings->rotate90) glRotatef(90.0f, 0.0f, 0.0f, -1.0f);\n    \n    if (contextSettings->flipV) {\n        bottom = (GLdouble)contextSettings->arParam.ysize;\n        top = 0.0;\n    } else {\n        bottom = 0.0;\n        top = (GLdouble)contextSettings->arParam.ysize;\n    }\n    if (contextSettings->flipH) {\n        left = (GLdouble)contextSettings->arParam.xsize;\n        right = 0.0;\n    } else {\n        left = 0.0;\n        right = (GLdouble)contextSettings->arParam.xsize;\n    }\n    glOrtho(left, right, bottom, top, -1.0, 1.0);\n    glMatrixMode(GL_MODELVIEW);\n    glPushMatrix();\n    glLoadIdentity();\n    \n    lightingSave = glIsEnabled(GL_LIGHTING);\t\t\t// Save enabled state of lighting.\n    if (lightingSave == GL_TRUE) glDisable(GL_LIGHTING);\n    depthTestSave = glIsEnabled(GL_DEPTH_TEST);\t\t// Save enabled state of depth test.\n    if (depthTestSave == GL_TRUE) glDisable(GL_DEPTH_TEST);\n    \n    arglDispImageStateful(contextSettings);\n    \n    if (depthTestSave == GL_TRUE) glEnable(GL_DEPTH_TEST);\t\t\t// Restore enabled state of depth test.\n    if (lightingSave == GL_TRUE) glEnable(GL_LIGHTING);\t\t\t// Restore enabled state of lighting.\n   \n    // Restore previous projection & camera position.\n    glMatrixMode(GL_PROJECTION);\n    glPopMatrix();\n    glMatrixMode(GL_MODELVIEW);\n    glPopMatrix();\n    \n#ifdef ARGL_DEBUG\n    // Report any errors we generated.\n    GLenum err;\n    while ((err = glGetError()) != GL_NO_ERROR) {\n        ARLOGe(\"ARGL: GL error 0x%04X\\n\", (int)err);\n    }\n#endif // ARGL_DEBUG\n    \n}\n\nvoid arglDispImageStateful(ARGL_CONTEXT_SETTINGS_REF contextSettings)\n{\n    GLint texEnvModeSave;\n    int        i;\n    \n    if (!contextSettings) return;\n    if (!contextSettings->textureObjectsHaveBeenSetup) return;\n    if (!contextSettings->textureGeometryHasBeenSetup) return;\n    if (!contextSettings->textureDataReady) return;\n    \n    glActiveTexture(GL_TEXTURE0);\n    \n    glMatrixMode(GL_TEXTURE);\n    glLoadIdentity();\n    glMatrixMode(GL_MODELVIEW);\n    \n    glBindTexture(GL_TEXTURE_2D, contextSettings->texture);\n    glGetTexEnviv(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, &texEnvModeSave); // Save GL texture environment mode.\n    if (texEnvModeSave != GL_REPLACE) glTexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_REPLACE);\n    glEnable(GL_TEXTURE_2D);\n    \n    glClientActiveTexture(GL_TEXTURE0);\n    glBindBuffer(GL_ARRAY_BUFFER, contextSettings->t2bo);\n    glTexCoordPointer(2, GL_FLOAT, 0, NULL);\n    glEnableClientState(GL_TEXTURE_COORD_ARRAY);\n    \n    glBindBuffer(GL_ARRAY_BUFFER, contextSettings->v2bo);\n    glVertexPointer(2, GL_FLOAT, 0, NULL);\n    glEnableClientState(GL_VERTEX_ARRAY);\n    glDisableClientState(GL_NORMAL_ARRAY);\n    \n    if (contextSettings->disableDistortionCompensation) {\n        glDrawArrays(GL_TRIANGLE_STRIP, 0, 4);\n    } else {\n        for (i = 0; i < 20; i++) {\n            glDrawArrays(GL_TRIANGLE_STRIP, i * 42, 42);\n        }\n    }\n    \n    glBindBuffer(GL_ARRAY_BUFFER, 0);\n    glDisableClientState(GL_VERTEX_ARRAY);\n    glDisableClientState(GL_TEXTURE_COORD_ARRAY);\n    \n    glDisable(GL_TEXTURE_2D);\n    if (texEnvModeSave != GL_REPLACE) glTexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, texEnvModeSave); // Restore GL texture environment mode.\n}\n\nint arglDistortionCompensationSet(ARGL_CONTEXT_SETTINGS_REF contextSettings, int enable)\n{\n    if (!contextSettings) return (FALSE);\n    contextSettings->disableDistortionCompensation = !enable;\n    return (arglSetupTextureGeometry(contextSettings));\n}\n\nint arglDistortionCompensationGet(ARGL_CONTEXT_SETTINGS_REF contextSettings, int *enable)\n{\n    if (!contextSettings || !enable) return (FALSE);\n    *enable = !contextSettings->disableDistortionCompensation;\n    return (TRUE);\n}\n\nint arglSetPixelZoom(ARGL_CONTEXT_SETTINGS_REF contextSettings, float zoom)\n{\n    if (!contextSettings) return (FALSE);\n    contextSettings->zoom = zoom;\n    \n    // Changing the zoom invalidates the geometry, so set it up.\n    return (arglSetupTextureGeometry(contextSettings));\n}\n\nint arglGetPixelZoom(ARGL_CONTEXT_SETTINGS_REF contextSettings, float *zoom)\n{\n    if (!contextSettings) return (FALSE);\n    *zoom = contextSettings->zoom;\n    return (TRUE);\n}\n\nint arglPixelFormatSet(ARGL_CONTEXT_SETTINGS_REF contextSettings, AR_PIXEL_FORMAT format)\n{\n\tif (!contextSettings) return (FALSE);\n\tswitch (format) {\n\t\tcase AR_PIXEL_FORMAT_RGBA:\n\t\t\tcontextSettings->pixIntFormat = GL_RGBA;\n\t\t\tcontextSettings->pixFormat = GL_RGBA;\n\t\t\tcontextSettings->pixType = GL_UNSIGNED_BYTE;\n\t\t\tcontextSettings->pixSize = 4;\n\t\t\tbreak;\n\t\tcase AR_PIXEL_FORMAT_ABGR:\t// SGI.\n\t\t\tif (arglGLCapabilityCheck(0, (unsigned char *)\"GL_EXT_abgr\")) {\n\t\t\t\tcontextSettings->pixIntFormat = GL_RGBA;\n\t\t\t\tcontextSettings->pixFormat = GL_ABGR_EXT;\n\t\t\t\tcontextSettings->pixType = GL_UNSIGNED_BYTE;\n\t\t\t\tcontextSettings->pixSize = 4;\n\t\t\t} else {\n\t\t\t\treturn (FALSE);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AR_PIXEL_FORMAT_BGRA:\t// Windows.\n\t\t\tif (arglGLCapabilityCheck(0x0120, (unsigned char *)\"GL_EXT_bgra\")) {\n\t\t\t\tcontextSettings->pixIntFormat = GL_RGBA;\n\t\t\t\tcontextSettings->pixFormat = GL_BGRA;\n\t\t\t\tcontextSettings->pixType = GL_UNSIGNED_BYTE;\n\t\t\t\tcontextSettings->pixSize = 4;\n\t\t\t} else {\n\t\t\t\treturn (FALSE);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AR_PIXEL_FORMAT_ARGB:\t// Mac.\n\t\t\tif (arglGLCapabilityCheck(0x0120, (unsigned char *)\"GL_EXT_bgra\")\n\t\t\t\t&& (arglGLCapabilityCheck(0x0120, (unsigned char *)\"GL_EXT_packed_pixels\") || arglGLCapabilityCheck(0x0120, (unsigned char *)\"GL_APPLE_packed_pixels\"))) {\n\t\t\t\tcontextSettings->pixIntFormat = GL_RGBA;\n\t\t\t\tcontextSettings->pixFormat = GL_BGRA;\n#ifdef AR_BIG_ENDIAN\n\t\t\t\tcontextSettings->pixType = GL_UNSIGNED_INT_8_8_8_8_REV;\n#else\n\t\t\t\tcontextSettings->pixType = GL_UNSIGNED_INT_8_8_8_8;\n#endif\n\t\t\t\tcontextSettings->pixSize = 4;\n\t\t\t} else {\n\t\t\t\treturn (FALSE);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AR_PIXEL_FORMAT_RGB:\n\t\t\tcontextSettings->pixIntFormat = GL_RGB;\n\t\t\tcontextSettings->pixFormat = GL_RGB;\n\t\t\tcontextSettings->pixType = GL_UNSIGNED_BYTE;\n\t\t\tcontextSettings->pixSize = 3;\n\t\t\tbreak;\n\t\tcase AR_PIXEL_FORMAT_BGR:\n\t\t\tif (arglGLCapabilityCheck(0x0120, (unsigned char *)\"GL_EXT_bgra\")) {\n\t\t\t\tcontextSettings->pixIntFormat = GL_RGB;\n\t\t\t\tcontextSettings->pixFormat = GL_BGR;\n\t\t\t\tcontextSettings->pixType = GL_UNSIGNED_BYTE;\n\t\t\t\tcontextSettings->pixSize = 3;\n\t\t\t} else {\n\t\t\t\treturn (FALSE);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AR_PIXEL_FORMAT_MONO:\n\t\t\tcontextSettings->pixIntFormat = GL_LUMINANCE;\n\t\t\tcontextSettings->pixFormat = GL_LUMINANCE;\n\t\t\tcontextSettings->pixType = GL_UNSIGNED_BYTE;\n\t\t\tcontextSettings->pixSize = 1;\n\t\t\tbreak;\n\t\tcase AR_PIXEL_FORMAT_2vuy:\n\t\t\tif (arglGLCapabilityCheck(0, (unsigned char *)\"GL_APPLE_ycbcr_422\")) {\n\t\t\t\tcontextSettings->pixIntFormat = GL_RGB;\n\t\t\t\tcontextSettings->pixFormat = GL_YCBCR_422_APPLE;\n#ifdef AR_BIG_ENDIAN\n\t\t\t\tcontextSettings->pixType = GL_UNSIGNED_SHORT_8_8_REV_APPLE;\n#else\n\t\t\t\tcontextSettings->pixType = GL_UNSIGNED_SHORT_8_8_APPLE;\n#endif\n\t\t\t} else if (arglGLCapabilityCheck(0, (unsigned char *)\"GL_MESA_ycbcr_texture\")) {\n\t\t\t\tcontextSettings->pixIntFormat = GL_YCBCR_MESA;\n\t\t\t\tcontextSettings->pixFormat = GL_YCBCR_MESA;\n#ifdef AR_BIG_ENDIAN\n\t\t\t\tcontextSettings->pixType = GL_UNSIGNED_SHORT_8_8_REV_MESA;\n#else\n\t\t\t\tcontextSettings->pixType = GL_UNSIGNED_SHORT_8_8_MESA;\n#endif\n\t\t\t} else {\n\t\t\t\treturn (FALSE);\n\t\t\t}\n\t\t\tcontextSettings->pixSize = 2;\n\t\t\tbreak;\n\t\tcase AR_PIXEL_FORMAT_yuvs:\n\t\t\tif (arglGLCapabilityCheck(0, (unsigned char *)\"GL_APPLE_ycbcr_422\")) {\n\t\t\t\tcontextSettings->pixIntFormat = GL_RGB;\n\t\t\t\tcontextSettings->pixFormat = GL_YCBCR_422_APPLE;\n#ifdef AR_BIG_ENDIAN\n\t\t\t\tcontextSettings->pixType = GL_UNSIGNED_SHORT_8_8_APPLE;\n#else\n\t\t\t\tcontextSettings->pixType = GL_UNSIGNED_SHORT_8_8_REV_APPLE;\n#endif\n\t\t\t} else if (arglGLCapabilityCheck(0, (unsigned char *)\"GL_MESA_ycbcr_texture\")) {\n\t\t\t\tcontextSettings->pixIntFormat = GL_YCBCR_MESA;\n\t\t\t\tcontextSettings->pixFormat = GL_YCBCR_MESA;\n#ifdef AR_BIG_ENDIAN\n\t\t\t\tcontextSettings->pixType = GL_UNSIGNED_SHORT_8_8_MESA;\n#else\n\t\t\t\tcontextSettings->pixType = GL_UNSIGNED_SHORT_8_8_REV_MESA;\n#endif\n\t\t\t} else {\n\t\t\t\treturn (FALSE);\n\t\t\t}\n\t\t\tcontextSettings->pixSize = 2;\n\t\t\tbreak;\n        case AR_PIXEL_FORMAT_RGB_565:\n            if (arglGLCapabilityCheck(0x0120, (unsigned char *)\"GL_EXT_packed_pixels\") || arglGLCapabilityCheck(0x0120, (unsigned char *)\"GL_APPLE_packed_pixels\")) {\n                contextSettings->pixIntFormat = GL_RGB;\n                contextSettings->pixFormat = GL_RGB;\n                contextSettings->pixType = GL_UNSIGNED_SHORT_5_6_5;\n                contextSettings->pixSize = 2;\n            } else {\n                return (FALSE);\n            }\n            break;\n        case AR_PIXEL_FORMAT_RGBA_5551:\n            if (arglGLCapabilityCheck(0x0120, (unsigned char *)\"GL_EXT_packed_pixels\") || arglGLCapabilityCheck(0x0120, (unsigned char *)\"GL_APPLE_packed_pixels\")) {\n                contextSettings->pixIntFormat = GL_RGBA;\n                contextSettings->pixFormat = GL_RGBA;\n                contextSettings->pixType = GL_UNSIGNED_SHORT_5_5_5_1;\n                contextSettings->pixSize = 2;\n            } else {\n                return (FALSE);\n            }\n            break;\n        case AR_PIXEL_FORMAT_RGBA_4444:\n            if (arglGLCapabilityCheck(0x0120, (unsigned char *)\"GL_EXT_packed_pixels\") || arglGLCapabilityCheck(0x0120, (unsigned char *)\"GL_APPLE_packed_pixels\")) {\n                contextSettings->pixIntFormat = GL_RGBA;\n                contextSettings->pixFormat = GL_RGBA;\n                contextSettings->pixType = GL_UNSIGNED_SHORT_4_4_4_4;\n                contextSettings->pixSize = 2;\n            } else {\n                return (FALSE);\n            }\n            break;\n        // Do mono-only rendering as a better alternative to doing nothing.\n        case AR_PIXEL_FORMAT_420v:\n        case AR_PIXEL_FORMAT_420f:\n        case AR_PIXEL_FORMAT_NV21:\n            contextSettings->pixIntFormat = GL_LUMINANCE;\n            contextSettings->pixFormat = GL_LUMINANCE;\n            contextSettings->pixType = GL_UNSIGNED_BYTE;\n            contextSettings->pixSize = 1;\n            break;\n\t\tdefault:\n\t\t\treturn (FALSE);\n\t\t\tbreak;\n\t}\n    contextSettings->format = format;\n    ARLOGd(\"ARGL: set pixel format %s.\\n\", arUtilGetPixelFormatName(format));\n    contextSettings->textureDataReady = FALSE;\n    \n    if (!arglSetupTextureObjects(contextSettings)) return (FALSE);\n    \n    return (TRUE);\n}\n\nint arglPixelFormatGet(ARGL_CONTEXT_SETTINGS_REF contextSettings, AR_PIXEL_FORMAT *format, int *size)\n{\n    if (!contextSettings) return (FALSE);\n    \n    if (format) *format = contextSettings->format;\n    if (size) *size = contextSettings->pixSize;\n    \n    return (TRUE);\n}\n\nvoid arglSetRotate90(ARGL_CONTEXT_SETTINGS_REF contextSettings, int rotate90)\n{\n    if (!contextSettings) return;\n    contextSettings->rotate90 = rotate90;\n}\n\nint arglGetRotate90(ARGL_CONTEXT_SETTINGS_REF contextSettings)\n{\n    if (!contextSettings) return (-1);\n    return (contextSettings->rotate90);\n}\n\nvoid arglSetFlipH(ARGL_CONTEXT_SETTINGS_REF contextSettings, int flipH)\n{\n    if (!contextSettings) return;\n    contextSettings->flipH = flipH;\n}\n\nint arglGetFlipH(ARGL_CONTEXT_SETTINGS_REF contextSettings)\n{\n    if (!contextSettings) return (-1);\n    return (contextSettings->flipH);\n}\n\nvoid arglSetFlipV(ARGL_CONTEXT_SETTINGS_REF contextSettings, int flipV)\n{\n    if (!contextSettings) return;\n    contextSettings->flipV = flipV;\n}\n\nint arglGetFlipV(ARGL_CONTEXT_SETTINGS_REF contextSettings)\n{\n    if (!contextSettings) return (-1);\n    return (contextSettings->flipV);\n}\n\nchar arglPixelBufferSizeSet(ARGL_CONTEXT_SETTINGS_REF contextSettings, int bufWidth, int bufHeight)\n{\n    if (!contextSettings) return (FALSE);\n    \n    // Check texturing capabilities (sets textureSizeX, textureSizeY, textureSizeMax).\n    glGetIntegerv(GL_MAX_TEXTURE_SIZE, &(contextSettings->textureSizeMax));\n    if (bufWidth > contextSettings->textureSizeMax || bufHeight > contextSettings->textureSizeMax) {\n        ARLOGe(\"Error: ARGL: Your OpenGL implementation and/or hardware's texturing capabilities are insufficient.\\n\");\n        return (FALSE);\n    }\n    \n    if (arglGLCapabilityCheck(0x200u, (const unsigned char *)\"GL_ARB_texture_non_power_of_two\")) {\n        contextSettings->textureSizeX = bufWidth;\n        contextSettings->textureSizeY = bufHeight;\n        contextSettings->bufSizeIsTextureSize = TRUE;\n    } else {\n        // Work out how big power-of-two textures needs to be.\n        contextSettings->textureSizeX = contextSettings->textureSizeY = 1;\n        while (contextSettings->textureSizeX < bufWidth) contextSettings->textureSizeX <<= 1;\n        while (contextSettings->textureSizeY < bufHeight) contextSettings->textureSizeY <<= 1;\n        contextSettings->bufSizeIsTextureSize = FALSE;\n        contextSettings->bufSizeX = bufWidth;\n        contextSettings->bufSizeY = bufHeight;\n    }\n    \n    // Changing the size of the data we'll be receiving invalidates the geometry, so set it up.\n    return (arglSetupTextureGeometry(contextSettings));\n}\n\nchar arglPixelBufferSizeGet(ARGL_CONTEXT_SETTINGS_REF contextSettings, int *bufWidth, int *bufHeight)\n{\n    if (!contextSettings) return (FALSE);\n    if (!contextSettings->textureGeometryHasBeenSetup) return (FALSE);\n    \n    if (contextSettings->bufSizeIsTextureSize) {\n        if (bufWidth) *bufWidth = contextSettings->textureSizeX;\n        if (bufHeight) *bufHeight = contextSettings->textureSizeY;\n    } else {\n        if (bufWidth) *bufWidth = contextSettings->bufSizeX;\n        if (bufHeight) *bufHeight = contextSettings->bufSizeY;\n    }\n    return (TRUE);\n}\n\nint arglPixelBufferDataUpload(ARGL_CONTEXT_SETTINGS_REF contextSettings, ARUint8 *bufDataPtr)\n{\n    int arDebugMode = AR_DEBUG_DISABLE, arImageProcMode;\n    \n    if (!contextSettings) return (FALSE);\n    if (!contextSettings->textureObjectsHaveBeenSetup || !contextSettings->textureGeometryHasBeenSetup || !contextSettings->pixSize) return (FALSE);\n    \n    glActiveTexture(GL_TEXTURE0);\n    glBindTexture(GL_TEXTURE_2D, contextSettings->texture);\n    \n    glPixelTransferi(GL_UNPACK_ALIGNMENT, (((contextSettings->bufSizeX * contextSettings->pixSize) & 0x3) == 0 ? 4 : 1));\n    \n    if (contextSettings->arhandle) {\n        arGetDebugMode(contextSettings->arhandle, &arDebugMode);\n    }\n    if (arDebugMode == AR_DEBUG_DISABLE) {\n        if (contextSettings->bufSizeIsTextureSize) {\n            glTexImage2D(GL_TEXTURE_2D, 0, contextSettings->pixIntFormat, contextSettings->textureSizeX, contextSettings->textureSizeY, 0, contextSettings->pixFormat, contextSettings->pixType, bufDataPtr);\n        } else {\n            // Request OpenGL allocate memory internally for a power-of-two texture of the appropriate size.\n            // Then send the NPOT-data as a subimage.\n            glTexImage2D(GL_TEXTURE_2D, 0, contextSettings->pixIntFormat, contextSettings->textureSizeX, contextSettings->textureSizeY, 0, contextSettings->pixFormat, contextSettings->pixType, NULL);\n            glTexSubImage2D(GL_TEXTURE_2D, 0, 0, 0, contextSettings->bufSizeX, contextSettings->bufSizeY, contextSettings->pixFormat, contextSettings->pixType, bufDataPtr);\n        }\n    } else {\n        if (contextSettings->arhandle->labelInfo.bwImage) {\n            arGetImageProcMode(contextSettings->arhandle, &arImageProcMode);\n            if (arImageProcMode == AR_IMAGE_PROC_FIELD_IMAGE) {\n                if (contextSettings->bufSizeIsTextureSize) {\n                    glTexImage2D(GL_TEXTURE_2D, 0, GL_LUMINANCE, contextSettings->textureSizeX >> 1, contextSettings->textureSizeY >> 1, 0, GL_LUMINANCE, GL_UNSIGNED_BYTE, contextSettings->arhandle->labelInfo.bwImage);\n                } else {\n                    // Request OpenGL allocate memory internally for a power-of-two texture of the appropriate size.\n                    // Then send the NPOT-data as a subimage.\n                    glTexImage2D(GL_TEXTURE_2D, 0, GL_LUMINANCE, contextSettings->textureSizeX >> 1, contextSettings->textureSizeY >> 1, 0, GL_LUMINANCE, GL_UNSIGNED_BYTE, NULL);\n                    glTexSubImage2D(GL_TEXTURE_2D, 0, 0, 0, contextSettings->bufSizeX >> 1, contextSettings->bufSizeY >> 1, GL_LUMINANCE, GL_UNSIGNED_BYTE, contextSettings->arhandle->labelInfo.bwImage);\n                }\n            } else {\n                if (contextSettings->bufSizeIsTextureSize) {\n                    glTexImage2D(GL_TEXTURE_2D, 0, GL_LUMINANCE, contextSettings->textureSizeX, contextSettings->textureSizeY, 0, GL_LUMINANCE, GL_UNSIGNED_BYTE, contextSettings->arhandle->labelInfo.bwImage);\n                } else {\n                    // Request OpenGL allocate memory internally for a power-of-two texture of the appropriate size.\n                    // Then send the NPOT-data as a subimage.\n                    glTexImage2D(GL_TEXTURE_2D, 0, GL_LUMINANCE, contextSettings->textureSizeX, contextSettings->textureSizeY, 0, GL_LUMINANCE, GL_UNSIGNED_BYTE, NULL);\n                    glTexSubImage2D(GL_TEXTURE_2D, 0, 0, 0, contextSettings->bufSizeX, contextSettings->bufSizeY, GL_LUMINANCE, GL_UNSIGNED_BYTE, contextSettings->arhandle->labelInfo.bwImage);\n                }\n            }\n        }\n    }\n    \n    contextSettings->textureDataReady = TRUE;\n    \n    return (TRUE);\n}\n\n#endif // !ARGL_DISABLE_DISP_IMAGE\n\nGLboolean arglGluCheckExtension(const GLubyte* extName, const GLubyte *extString)\n{\n\tconst GLubyte *start;\n\tGLubyte *where, *terminator;\n\t\n\t// Extension names should not have spaces.\n\twhere = (GLubyte *)strchr((const char *)extName, ' ');\n\tif (where || *extName == '\\0')\n\t\treturn GL_FALSE;\n\t// It takes a bit of care to be fool-proof about parsing the\n\t//\tOpenGL extensions string. Don't be fooled by sub-strings, etc.\n\tstart = extString;\n\tfor (;;) {\n\t\twhere = (GLubyte *) strstr((const char *)start, (const char *)extName);\n\t\tif (!where)\n\t\t\tbreak;\n\t\tterminator = where + strlen((const char *)extName);\n\t\tif (where == start || *(where - 1) == ' ')\n\t\t\tif (*terminator == ' ' || *terminator == '\\0')\n\t\t\t\treturn GL_TRUE;\n\t\tstart = terminator;\n\t}\n\treturn GL_FALSE;\n}\n\nint arglGLCapabilityCheck(const unsigned short minVersion, const unsigned char *extension)\n{\n    const GLubyte *strVersion;\n    const GLubyte *strExtensions;\n    short j, shiftVal;\n    unsigned short version = 0; // binary-coded decimal gl version (ie. 1.4 is 0x0140).\n    \n    if (minVersion > 0) {\n        strVersion = glGetString(GL_VERSION);\n#ifdef EDEN_OPENGLES\n        j = 13; // Of the form \"OpenGL ES-XX 1.1\", where XX=CM for common, CL for common lite.\n#else\n        j = 0;\n#endif\n        shiftVal = 8;\n        // Construct BCD version.\n        while (((strVersion[j] <= '9') && (strVersion[j] >= '0')) || (strVersion[j] == '.')) { // Get only basic version info (until first non-digit or non-.)\n            if ((strVersion[j] <= '9') && (strVersion[j] >= '0')) {\n                version += (strVersion[j] - '0') << shiftVal;\n                shiftVal -= 4;\n            }\n            j++;\n        }\n        if (version >= minVersion) return (TRUE);\n    }\n    \n    if (extension) {\n        strExtensions = glGetString(GL_EXTENSIONS);\n        if (arglGluCheckExtension(extension, strExtensions)) return (TRUE);\n    }\n    \n    return (FALSE);\n}\n","/*\n *  AR2/imageSet.c\n *  ARToolKit5\n *\n *  This file is part of ARToolKit.\n *\n *  ARToolKit is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation, either version 3 of the License, or\n *  (at your option) any later version.\n *\n *  ARToolKit is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public License\n *  along with ARToolKit.  If not, see <http://www.gnu.org/licenses/>.\n *\n *  As a special exception, the copyright holders of this library give you\n *  permission to link this library with independent modules to produce an\n *  executable, regardless of the license terms of these independent modules, and to\n *  copy and distribute the resulting executable under terms of your choice,\n *  provided that you also meet, for each linked independent module, the terms and\n *  conditions of the license of that module. An independent module is a module\n *  which is neither derived from nor based on this library. If you modify this\n *  library, you may extend this exception to your version of the library, but you\n *  are not obligated to do so. If you do not wish to do so, delete this exception\n *  statement from your version.\n *\n *  Copyright 2015 Daqri, LLC.\n *  Copyright 2006-2015 ARToolworks, Inc.\n *\n *  Author(s): Hirokazu Kato, Philip Lamb\n *\n */\n\n#include <AR/ar.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n#ifdef _WIN32\n#  define lroundf(x) ((x)>=0.0f?(long)((x)+0.5f):(long)((x)-0.5f))\n#endif\n#include <AR2/imageFormat.h>\n#include <AR2/imageSet.h>\n\nstatic AR2ImageT *ar2GenImageLayer1 ( ARUint8 *image, int xsize, int ysize, int nc, float srcdpi, float dstdpi );\nstatic AR2ImageT *ar2GenImageLayer2 ( AR2ImageT *src, float dstdpi );\n#if AR2_CAPABLE_ADAPTIVE_TEMPLATE\nstatic void       defocus_image     ( ARUint8 *img, int xsize, int ysize, int n );\n#endif\nstatic AR2ImageSetT *ar2ReadImageSetOld( FILE *fp );\n\nAR2ImageSetT *ar2GenImageSet( ARUint8 *image, int xsize, int ysize, int nc, float dpi, float dpi_list[], int dpi_num )\n{\n    AR2ImageSetT   *imageSet;\n    int             i;\n\n    if( nc != 1 && nc != 3 )    return NULL;\n    if( dpi_num <= 0 )          return NULL;\n    if( dpi_list[0] > dpi )     return NULL;\n    for( i = 1; i < dpi_num; i++ ) {\n        if( dpi_list[i] > dpi_list[0] ) return NULL;\n    }\n\n    arMalloc( imageSet, AR2ImageSetT, 1 );\n    imageSet->num = dpi_num;\n    arMalloc( imageSet->scale,  AR2ImageT*,  imageSet->num );\n\n    imageSet->scale[0] = ar2GenImageLayer1( image, xsize, ysize, nc, dpi, dpi_list[0] );\n    for( i = 1; i < dpi_num; i++ ) {\n        imageSet->scale[i] = ar2GenImageLayer2( imageSet->scale[0], dpi_list[i] );\n    }\n\n    return imageSet;\n}\n\nAR2ImageSetT *ar2ReadImageSet( char *filename )\n{\n    FILE          *fp;\n    AR2JpegImageT *jpgImage;\n    AR2ImageSetT  *imageSet;\n    float          dpi;\n    int            i, k1;\n#if AR2_CAPABLE_ADAPTIVE_TEMPLATE\n    int            j, k2;\n    ARUint        *p1, *p2;\n#endif\n    size_t         len;\n    const char     ext[] = \".iset\";\n    char          *buf;\n    \n    len = strlen(filename) + strlen(ext) + 1; // +1 for nul terminator.\n    arMalloc(buf, char, len);\n    sprintf(buf, \"%s%s\", filename, ext);\n    fp = fopen(buf, \"rb\");\n    free(buf);\n    if (!fp) {\n        ARLOGe(\"Error: unable to open file '%s%s' for reading.\\n\", filename, ext);\n        return (NULL);\n    }\n\n    arMalloc( imageSet, AR2ImageSetT, 1 );\n\n    if( fread(&(imageSet->num), sizeof(imageSet->num), 1, fp) != 1 || imageSet->num <= 0) {\n        ARLOGe(\"Error reading imageSet.\\n\");\n        goto bail;\n    }\n    ARLOGi(\"Imageset contains %d images.\\n\", imageSet->num);\n    arMalloc( imageSet->scale, AR2ImageT*, imageSet->num );\n\n    arMalloc( imageSet->scale[0], AR2ImageT, 1 );\n    jpgImage = ar2ReadJpegImage2(fp); // Caller must free result.\n    if( jpgImage == NULL || jpgImage->nc != 1 ) {\n        ARLOGw(\"Falling back to reading '%s%s' in ARToolKit v4.x format.\\n\", filename, ext);\n        free(imageSet->scale[0]);\n        free(imageSet->scale);\n        free(imageSet);\n        \n        if( jpgImage == NULL ) {\n            rewind(fp);\n            return ar2ReadImageSetOld(fp);\n        }\n        free(jpgImage); //COVHI10396\n        fclose(fp);\n        return NULL;\n    }\n    imageSet->scale[0]->xsize = jpgImage->xsize;\n    imageSet->scale[0]->ysize = jpgImage->ysize;\n    imageSet->scale[0]->dpi   = jpgImage->dpi; // The dpi value is not read correctly by jpeglib embedded in OpenCV 2.2.x.\n#if AR2_CAPABLE_ADAPTIVE_TEMPLATE\n    imageSet->scale[0]->imgBWBlur[0] = jpgImage->image;\n    // Create the blurred images.\n    for( j = 1; j < AR2_BLUR_IMAGE_MAX; j++ ) {\n        arMalloc( imageSet->scale[0]->imgBWBlur[j], ARUint8, imageSet->scale[0]->xsize * imageSet->scale[0]->ysize);\n        p1 = dst->imgBWBlur[0];\n        p2 = dst->imgBWBlur[i];\n        for( k1 = 0; k1 < imageSet->scale[0]->xsize * imageSet->scale[0]->ysize; k1++ ) *(p2++) = *(p1++);\n        defocus_image( imageSet->scale[0]->imgBWBlur[j], imageSet->scale[0]->xsize, imageSet->scale[0]->ysize, 3 );\n    }\n#else\n    imageSet->scale[0]->imgBW = jpgImage->image;\n#endif\n    free(jpgImage);\n\n    // Minify for the other scales.\n    // First, find the list of scales we wrote into the file.\n    fseek(fp, (long)(-(int)sizeof(dpi)*(imageSet->num - 1)), SEEK_END);\n    for( i = 1; i < imageSet->num; i++ ) {\n        \n        if( fread(&dpi, sizeof(dpi), 1, fp) != 1 ) {\n            for( k1 = 0; k1 < i; k1++ ) {\n#if AR2_CAPABLE_ADAPTIVE_TEMPLATE\n                for( k2 = 0; k2 < AR2_BLUR_IMAGE_MAX; k2++ ) free(imageSet->scale[k1]->imgBWBlur[k2]);\n#else\n                free(imageSet->scale[k1]->imgBW);\n#endif\n                free(imageSet->scale[k1]);\n            }\n            goto bail1;\n        }\n        \n        imageSet->scale[i] = ar2GenImageLayer2( imageSet->scale[0], dpi );\n        if( imageSet->scale[i] == NULL ) {\n            for( k1 = 0; k1 < i; k1++ ) {\n#if AR2_CAPABLE_ADAPTIVE_TEMPLATE\n                for( k2 = 0; k2 < AR2_BLUR_IMAGE_MAX; k2++ ) free(imageSet->scale[k1]->imgBWBlur[k2]);\n#else\n                free(imageSet->scale[k1]->imgBW);\n#endif\n                free(imageSet->scale[k1]);\n            }\n            goto bail1;\n        }\n    }\n\n    fclose(fp);\n\n    return imageSet;\n    \n    \nbail1:\n    free(imageSet->scale);\nbail:\n    free(imageSet);\n    fclose(fp);\n    return NULL;\n}\n\nint ar2WriteImageSet( char *filename, AR2ImageSetT *imageSet )\n{\n    FILE          *fp;\n    AR2JpegImageT  jpegImage;\n    int            i;\n    size_t         len;\n    const char     ext[] = \".iset\";\n    char          *buf;\n    \n    len = strlen(filename) + strlen(ext) + 1; // +1 for nul terminator.\n    arMalloc(buf, char, len);\n    sprintf(buf, \"%s%s\", filename, ext);\n    if( (fp=fopen(buf, \"wb\")) == NULL ) {\n        ARLOGe(\"Error: unable to open file '%s' for writing.\\n\", buf);\n        free(buf);\n        return (-1);\n    }\n    free(buf);\n\n    if( fwrite(&(imageSet->num), sizeof(imageSet->num), 1, fp) != 1 ) goto bailBadWrite;\n\n    jpegImage.xsize = imageSet->scale[0]->xsize;\n    jpegImage.ysize = imageSet->scale[0]->ysize;\n    jpegImage.dpi   = imageSet->scale[0]->dpi;\n    jpegImage.nc    = 1;\n#if AR2_CAPABLE_ADAPTIVE_TEMPLATE\n    jpegImage.image = imageSet->scale[0]->imgBWBlur[0];\n#else\n    jpegImage.image = imageSet->scale[0]->imgBW;\n#endif\n\n    if( ar2WriteJpegImage2(fp, &jpegImage, AR2_DEFAULT_JPEG_IMAGE_QUALITY) < 0 ) goto bailBadWrite;\n\n    for( i = 1; i < imageSet->num; i++ ) {\n        if( fwrite(&(imageSet->scale[i]->dpi), sizeof(imageSet->scale[i]->dpi), 1, fp) != 1 ) goto bailBadWrite;\n    }\n\n    fclose(fp);\n    return 0;\n    \nbailBadWrite:\n    ARLOGe(\"Error saving image set: error writing data.\\n\");\n    fclose(fp);\n    return (-1);\n}\n\nint ar2FreeImageSet( AR2ImageSetT **imageSet )\n{\n    int    i;\n\n    if(  imageSet == NULL ) return -1;\n    if( *imageSet == NULL ) return -1;\n\n    for( i = 0; i < (*imageSet)->num; i++ ) {\n#if AR2_CAPABLE_ADAPTIVE_TEMPLATE\n        for( int j = 0; j < AR2_BLUR_IMAGE_MAX; j++ ) {\n            free( (*imageSet)->scale[i]->imgBWBlur[j] );\n        }\n#else\n        free( (*imageSet)->scale[i]->imgBW  );\n#endif\n        free( (*imageSet)->scale[i] );\n    }\n    free( (*imageSet)->scale );\n    free( *imageSet );\n    *imageSet = NULL;\n\n    return 0;\n}\n\nstatic AR2ImageT *ar2GenImageLayer1( ARUint8 *image, int xsize, int ysize, int nc, float srcdpi, float dstdpi )\n{\n    AR2ImageT   *dst;\n    ARUint8     *p1, *p2;\n    int          wx, wy;\n    int          sx, sy, ex, ey;\n    int          ii, jj, iii, jjj;\n    int          co, value;\n\n    wx = (int)lroundf(xsize * dstdpi / srcdpi);\n    wy = (int)lroundf(ysize * dstdpi / srcdpi);\n\n    arMalloc( dst, AR2ImageT, 1 );\n    dst->xsize = wx;\n    dst->ysize = wy;\n    dst->dpi   = dstdpi;\n#if AR2_CAPABLE_ADAPTIVE_TEMPLATE\n    for( int i = 0; i < AR2_BLUR_IMAGE_MAX; i++ ) {\n        arMalloc( dst->imgWBlur[i], ARUint8, wx*wy );\n    }\n    p2 = dst->imgBWBlur[0];\n#else\n    arMalloc( dst->imgBW, ARUint8, wx*wy );\n    p2 = dst->imgBW;\n#endif\n\n    // Scale down, nearest neighbour.\n    for( jj = 0; jj < wy; jj++ ) {\n        sy = (int)lroundf( jj    * srcdpi / dstdpi);\n        ey = (int)lroundf((jj+1) * srcdpi / dstdpi) - 1;\n        if( ey >= ysize ) ey = ysize - 1;\n        for( ii = 0; ii < wx; ii++ ) {\n            sx = (int)lroundf( ii    * srcdpi / dstdpi);\n            ex = (int)lroundf((ii+1) * srcdpi / dstdpi) - 1;\n            if( ex >= xsize ) ex = xsize - 1;\n\n            co = value = 0;\n            if( nc == 1 ) {\n                for( jjj = sy; jjj <= ey; jjj++ ) {\n                    p1 = &(image[(jjj*xsize+sx)*nc]);\n                    for( iii = sx; iii <= ex; iii++ ) {\n                        value += *(p1++);\n                        co++;\n                    }\n                }\n            }\n            else {\n                for( jjj = sy; jjj <= ey; jjj++ ) {\n                    p1 = &(image[(jjj*xsize+sx)*nc]);\n                    for( iii = sx; iii <= ex; iii++ ) {\n                        value += *(p1++);\n                        value += *(p1++);\n                        value += *(p1++);\n                        co+=3;\n                    }\n                }\n            }\n            *(p2++) = value / co;\n        }\n    }\n\n#if AR2_CAPABLE_ADAPTIVE_TEMPLATE\n    for( int i = 1; i < AR2_BLUR_IMAGE_MAX; i++ ) {\n        p1 = dst->imgBWBlue[0];\n        p2 = dst->imgBWBlue[i];\n        for( int j = 0; j < wx*wy; j++ ) *(p2++) = *(p1++);\n        defocus_image( dst->imgBWBlur[i], wx, wy, 2 );\n    }\n#else\n    //defocus_image( dst->imgBW, wx, wy, 3 );\n#endif\n\n    return dst;\n}\n\nstatic AR2ImageT *ar2GenImageLayer2( AR2ImageT *src, float dpi )\n{\n    AR2ImageT   *dst;\n    ARUint8     *p1, *p2;\n    int          wx, wy;\n    int          sx, sy, ex, ey;\n    int          ii, jj, iii, jjj;\n    int          co, value;\n\n    wx = (int)lroundf(src->xsize * dpi / src->dpi);\n    wy = (int)lroundf(src->ysize * dpi / src->dpi);\n\n    arMalloc( dst, AR2ImageT, 1 );\n    dst->xsize = wx;\n    dst->ysize = wy;\n    dst->dpi   = dpi;\n#if AR2_CAPABLE_ADAPTIVE_TEMPLATE\n    for( int i = 0; i < AR2_BLUR_IMAGE_MAX; i++ ) {\n        arMalloc( dst->imgBWBlur[i], ARUint8, wx*wy );\n    }\n    p2 = dst->imgBWBlue[0];\n#else\n    arMalloc( dst->imgBW, ARUint8, wx*wy );\n    p2 = dst->imgBW;\n#endif\n\n    for( jj = 0; jj < wy; jj++ ) {\n        sy = (int)lroundf( jj    * src->dpi / dpi);\n        ey = (int)lroundf((jj+1) * src->dpi / dpi) - 1;\n        if( ey >= src->ysize ) ey = src->ysize - 1;\n        for( ii = 0; ii < wx; ii++ ) {\n            sx = (int)lroundf( ii    * src->dpi / dpi);\n            ex = (int)lroundf((ii+1) * src->dpi / dpi) - 1;\n            if( ex >= src->xsize ) ex = src->xsize - 1;\n\n            co = value = 0;\n            for( jjj = sy; jjj <= ey; jjj++ ) {\n#if AR2_CAPABLE_ADAPTIVE_TEMPLATE\n                p1 = &(src->imgBWBlur[0][jjj*src->xsize+sx]);\n#else\n                p1 = &(src->imgBW[jjj*src->xsize+sx]);\n#endif\n                for( iii = sx; iii <= ex; iii++ ) {\n                    value += *(p1++);\n                    co++;\n                }\n            }\n            *(p2++) = value / co;\n        }\n    }\n\n#if AR2_CAPABLE_ADAPTIVE_TEMPLATE\n    defocus_image( dst->imageBWBlur[0], wx, wy, 3 );\n    for( int i = 1; i < AR2_BLUR_IMAGE_MAX; i++ ) {\n        p1 = dst->imgBWBlue[0];\n        p2 = dst->imgBWBlue[i];\n        for( int j = 0; j < wx*wy; j++ ) *(p2++) = *(p1++);\n        defocus_image( dst->imgBWBlur[i], wx, wy, 2 );\n    }\n#else\n    //defocus_image( dst->imgBW, wx, wy, 3 );\n#endif\n\n    return dst;\n}\n\n#if AR2_CAPABLE_ADAPTIVE_TEMPLATE\nstatic void defocus_image( ARUint8 *img, int xsize, int ysize, int n )\n{\n    ARUint8        *wimg;\n    int             isize;\n    ARUint8         *p1, *p2;\n    int             i, j, k, w;\n\n    isize = xsize * ysize;\n    arMalloc( wimg, ARUint8, xsize*ysize );\n\n    for( k = 0; k < n; k++ ) {\n        if( k%2 == 0 ) {\n            p1 = img;\n            p2 = wimg;\n        }\n        else {\n            p1 = wimg;\n            p2 = img;\n        }\n        for( j = 0; j < ysize; j++ ) {\n            for( i = 0; i < xsize; i++ ) {\n                if( i == 0 || j == 0 || i == xsize-1 || j == ysize-1 ) {\n                    *(p2++) = *(p1++);\n                    continue;\n                }\n\n                w = *(p1-xsize-1) + *(p1-xsize) + *(p1-xsize+1)\n                 +  *(p1-1)       + *(p1)       + *(p1+1)\n                 +  *(p1+xsize-1) + *(p1+xsize) + *(p1+xsize+1);\n                *(p2++) = w / 9;\n                p1++;\n            }\n        }\n    }\n\n    if( n%2 == 1 ) {\n        p1 = wimg;\n        p2 = img;\n        for( i = 0; i < xsize*ysize; i++ ) *(p2++) = *(p1++);\n    }\n\n    free(wimg);\n\n    return;\n}\n#endif\n\nstatic AR2ImageSetT *ar2ReadImageSetOld( FILE *fp )\n{\n    AR2ImageSetT  *imageSet;\n    int            i, k;\n#if AR2_CAPABLE_ADAPTIVE_TEMPLATE\n    int            j, l;\n#endif\n\n    arMalloc( imageSet, AR2ImageSetT, 1 );\n    \n    if( fread(&(imageSet->num), sizeof(imageSet->num), 1, fp) != 1 || imageSet->num <= 0) {\n        ARLOGe(\"Error reading imageSet.\\n\");\n        goto bail;\n    }\n\n    arMalloc( imageSet->scale, AR2ImageT*, imageSet->num );\n    for( i = 0; i < imageSet->num; i++ ) {\n        arMalloc( imageSet->scale[i], AR2ImageT, 1 );\n    }\n    \n    for( i = 0; i < imageSet->num; i++ ) {\n        if( fread(&(imageSet->scale[i]->xsize), sizeof(imageSet->scale[i]->xsize), 1, fp) != 1 ) {\n            for( k = 0; k < i; k++ ) {\n#if AR2_CAPABLE_ADAPTIVE_TEMPLATE\n                for( l = 0; l < AR2_BLUR_IMAGE_MAX; l++) free(imageSet->scale[k]->imgBWBlur[l]);\n#else\n                free(imageSet->scale[k]->imgBW);\n#endif\n            }\n            for( k = 0; k < imageSet->num; k++ ) free(imageSet->scale[k]);\n            goto bail1;\n        }\n        if( fread(&(imageSet->scale[i]->ysize), sizeof(imageSet->scale[i]->ysize), 1, fp) != 1 ) {\n            for( k = 0; k < i; k++ ) {\n#if AR2_CAPABLE_ADAPTIVE_TEMPLATE\n                for( l = 0; l < AR2_BLUR_IMAGE_MAX; l++) free(imageSet->scale[k]->imgBWBlur[l]);\n#else\n                free(imageSet->scale[k]->imgBW);\n#endif\n            }\n            for( k = 0; k < imageSet->num; k++ ) free(imageSet->scale[k]);\n            goto bail1;\n        }\n        if( fread(&(imageSet->scale[i]->dpi), sizeof(imageSet->scale[i]->dpi), 1, fp) != 1 ) {\n            for( k = 0; k < i; k++ ) {\n#if AR2_CAPABLE_ADAPTIVE_TEMPLATE\n                for( l = 0; l < AR2_BLUR_IMAGE_MAX; l++) free(imageSet->scale[k]->imgBWBlur[l]);\n#else\n                free(imageSet->scale[k]->imgBW);\n#endif\n            }\n            for( k = 0; k < imageSet->num; k++ ) free(imageSet->scale[k]);\n            goto bail1;\n        }\n        \n#if AR2_CAPABLE_ADAPTIVE_TEMPLATE\n        for( j = 0; j < AR2_BLUR_IMAGE_MAX; j++ ) {\n            arMalloc( imageSet->scale[i]->imgBWBlur[j], ARUint8, imageSet->scale[i]->xsize * imageSet->scale[i]->ysize);\n        }\n#else\n        arMalloc( imageSet->scale[i]->imgBW,  ARUint8, imageSet->scale[i]->xsize * imageSet->scale[i]->ysize);\n#endif\n        \n#if AR2_CAPABLE_ADAPTIVE_TEMPLATE\n        for( j = 0; j < AR2_BLUR_IMAGE_MAX; j++ ) {\n            if( fread(imageSet->scale[i]->imgBWBlur[j], sizeof(ARUint8), imageSet->scale[i]->xsize * imageSet->scale[i]->ysize, fp)\n               != imageSet->scale[i]->xsize * imageSet->scale[i]->ysize ) {\n                for( k = 0; k <= i; k++ ) {\n                    for( l = 0; l < AR2_BLUR_IMAGE_MAX; l++) free(imageSet->scale[k]->imgBWBlur[l]);\n                }\n                for( k = 0; k < imageSet->num; k++ ) free(imageSet->scale[k]);\n                goto bail1;\n            }\n        }\n#else\n        if( fread(imageSet->scale[i]->imgBW, sizeof(ARUint8), imageSet->scale[i]->xsize * imageSet->scale[i]->ysize, fp)\n           != imageSet->scale[i]->xsize * imageSet->scale[i]->ysize ) {\n            for( k = 0; k <= i; k++ ) {\n                free(imageSet->scale[k]->imgBW);\n            }\n            for( k = 0; k < imageSet->num; k++ ) free(imageSet->scale[k]);\n            goto bail1;\n        }\n#endif\n    }\n    \n    fclose(fp);\n    return imageSet;\n    \nbail1:\n    free(imageSet->scale);\nbail:\n    free(imageSet);\n    fclose(fp);\n    return NULL;\n}\n\n","/*\n *  AR2/jpeg.c\n *  ARToolKit5\n *\n *  This file is part of ARToolKit.\n *\n *  ARToolKit is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation, either version 3 of the License, or\n *  (at your option) any later version.\n *\n *  ARToolKit is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public License\n *  along with ARToolKit.  If not, see <http://www.gnu.org/licenses/>.\n *\n *  As a special exception, the copyright holders of this library give you\n *  permission to link this library with independent modules to produce an\n *  executable, regardless of the license terms of these independent modules, and to\n *  copy and distribute the resulting executable under terms of your choice,\n *  provided that you also meet, for each linked independent module, the terms and\n *  conditions of the license of that module. An independent module is a module\n *  which is neither derived from nor based on this library. If you modify this\n *  library, you may extend this exception to your version of the library, but you\n *  are not obligated to do so. If you do not wish to do so, delete this exception\n *  statement from your version.\n *\n *  Copyright 2015 Daqri, LLC.\n *  Copyright 2006-2015 ARToolworks, Inc.\n *\n *  Author(s): Hirokazu Kato, Philip Lamb\n *\n */\n\n#include <AR/ar.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include \"jpeglib.h\"\n#include <setjmp.h>\n#include <AR2/imageFormat.h>\n\nstruct my_error_mgr {\n    struct jpeg_error_mgr pub;\t/* \"public\" fields */    \n    jmp_buf setjmp_buffer;\t/* for return to caller */\n};\ntypedef struct my_error_mgr * my_error_ptr;\n\nstatic unsigned char *jpgread  (FILE *fp, int *w, int *h, int *nc, float *dpi);\nstatic int            jpgwrite (FILE *fp, unsigned char *image, int w, int h, int nc, float dpi, int quality);\n\nint ar2WriteJpegImage( const char *filename, const char *ext, AR2JpegImageT *jpegImage, int quality )\n{\n    FILE           *fp;\n    int             ret;\n    size_t          len;\n    char           *buf1;\n\n    len = strlen(filename) + strlen(ext) + 1;\n    arMalloc(buf1, char, len + 1); // +1 for nul terminator.\n    sprintf(buf1, \"%s.%s\", filename, ext);\n    fp = fopen(buf1, \"wb\");\n    if( fp == NULL ) {\n        ARLOGe(\"Error: Unable to open file '%s' for writing.\\n\", buf1);\n        free(buf1);\n        return -1;\n    }\n    free(buf1);\n\n    ret = ar2WriteJpegImage2( fp, jpegImage, quality );\n\n    fclose(fp);\n    return ret;\n}\n\nint ar2WriteJpegImage2( FILE *fp, AR2JpegImageT *jpegImage, int quality )\n{\n    return jpgwrite(fp, jpegImage->image, jpegImage->xsize, jpegImage->ysize, jpegImage->nc, jpegImage->dpi, quality);\n}\n\nAR2JpegImageT *ar2ReadJpegImage( const char *filename, const char *ext )\n{\n    FILE           *fp;\n    AR2JpegImageT  *jpegImage;\n    size_t          len;\n    char           *buf1;\n    \n    \n    len = strlen(filename) + strlen(ext) + 1;\n    arMalloc(buf1, char, len + 1); // +1 for nul terminator.\n    sprintf(buf1, \"%s.%s\", filename, ext);\n    fp = fopen(buf1, \"rb\");\n    if( fp == NULL ) {\n        ARLOGe(\"Error: Unable to open file '%s' for reading.\\n\", buf1);\n        free(buf1);\n        return (NULL);\n    }\n    free(buf1);\n\n    jpegImage = ar2ReadJpegImage2(fp);\n\n    fclose(fp);\n    return jpegImage;\n}\n\nAR2JpegImageT *ar2ReadJpegImage2( FILE *fp )\n{\n    AR2JpegImageT  *jpegImage;\n    \n    arMalloc( jpegImage, AR2JpegImageT, 1 );\n    jpegImage->image = jpgread(fp, &(jpegImage->xsize), &(jpegImage->ysize), &(jpegImage->nc), &(jpegImage->dpi));\n\n    if( jpegImage->image == NULL ) {\n        free( jpegImage );\n        return NULL;\n    }\n\n    return jpegImage;\n}\n\nint ar2FreeJpegImage( AR2JpegImageT **jpegImage )\n{\n    if( jpegImage == NULL ) return -1;\n    if( *jpegImage == NULL ) return -1;\n\n    free( (*jpegImage)->image );\n    free( (*jpegImage) );\n\n    *jpegImage = NULL;\n\n    return 0;\n}\n\n#define BUFFER_HEIGHT 5\n\nstatic void my_error_exit (j_common_ptr cinfo)\n{\n    /* cinfo->err really points to a my_error_mgr struct, so coerce pointer */\n    my_error_ptr myerr = (my_error_ptr) cinfo->err;\n    \n    /* Always display the message. */\n    /* We could postpone this until after returning, if we chose. */\n    //(*cinfo->err->output_message) (cinfo);\n    \n    /* Return control to the setjmp point */\n    longjmp(myerr->setjmp_buffer, 1);\n}\n\nstatic unsigned char *jpgread (FILE *fp, int *w, int *h, int *nc, float *dpi)\n{\n    struct jpeg_decompress_struct    cinfo;\n    struct my_error_mgr              jerr;\n    unsigned char                    *pixels;\n    unsigned char                    *buffer[BUFFER_HEIGHT];\n    int                              bytes_per_line;\n    int                              row;\n    int                              i;\n    int                              ret;\n\n    /* Initialize the JPEG decompression object with default error handling. */\n    memset(&cinfo, 0, sizeof(cinfo));\n\n    /* We set up the normal JPEG error routines, then override error_exit. */\n    cinfo.err = jpeg_std_error(&jerr.pub);\n    jerr.pub.error_exit = my_error_exit;\n    /* Establish the setjmp return context for my_error_exit to use. */\n    if (setjmp(jerr.setjmp_buffer)) {\n        /* If we get here, the JPEG code has signaled an error.\n         * We need to clean up the JPEG object, close the input file, and return.\n         */\n        jpeg_destroy_decompress(&cinfo);\n        ARLOGe(\"Error reading JPEG file.\\n\");\n        return NULL;\n    }\n\n    jpeg_create_decompress(&cinfo);\n\n    /* Specify data source for decompression */\n    jpeg_stdio_src(&cinfo, fp);\n\n    /* Read file header, set default decompression parameters */\n    ret = jpeg_read_header(&cinfo, TRUE);\n    if( ret != 1 ) {\n        ARLOGe(\"Error reading JPEG file header.\\n\");\n        jpeg_destroy_decompress(&cinfo);\n        return NULL;\n    }\n\n    /* Start decompressor */\n    (void) jpeg_start_decompress(&cinfo);\n\n    /* Allocate image buffer */\n    bytes_per_line = cinfo.num_components * cinfo.image_width;\n    pixels = (unsigned char *)malloc(bytes_per_line  * cinfo.image_height);\n    if (!pixels) {\n        ARLOGe(\"Out of memory!!\\n\");\n        jpeg_destroy_decompress(&cinfo);\n        return NULL;\n    }\n\n    row = 0;\n\n    /* Process data */\n    while (cinfo.output_scanline < cinfo.output_height) {\n        for (i=0; i<BUFFER_HEIGHT; ++i) {\n            /* read in \"upside down\" because opengl says the\n             * texture origin is lower left \n             */\n            //int rrow = cinfo.output_height - row - 1;\n            //buffer[i] = &pixels[bytes_per_line * (rrow - i)];\n            buffer[i] = &pixels[bytes_per_line * (row + i)];\n        }\n        row += jpeg_read_scanlines(&cinfo, buffer, BUFFER_HEIGHT);\n    }\n\n    (void) jpeg_finish_decompress(&cinfo);\n    jpeg_destroy_decompress(&cinfo);\n\n    if (w) *w = cinfo.image_width;\n    if (h) *h = cinfo.image_height;\n    if (nc) *nc = cinfo.num_components;\n    if (dpi) {\n        if( cinfo.density_unit == 1 && cinfo.X_density == cinfo.Y_density ) {\n            *dpi = (float)cinfo.X_density;\n        } else if( cinfo.density_unit == 2 && cinfo.X_density == cinfo.Y_density ) {\n            *dpi = (float)cinfo.X_density * 2.54f;\n        } else if (cinfo.density_unit > 2 && cinfo.X_density == 0 && cinfo.Y_density == 0) { // Handle the case with some libjpeg versions where density in DPI is returned in the density_unit field.\n            *dpi = (float)(cinfo.density_unit);\n        } else {\n            *dpi = 0.0f;\n        }\n    }\n    \n    return pixels;\n}\n\nstatic int jpgwrite (FILE *fp, unsigned char *image, int w, int h, int nc, float dpi, int quality)\n{\n    struct jpeg_compress_struct    cinfo;\n    struct jpeg_error_mgr          jerr;\n    unsigned char  *p;\n    int i, j;\n    JSAMPARRAY img;\n\n    cinfo.err = jpeg_std_error(&jerr);\n    jpeg_create_compress(&cinfo);\n\n    jpeg_stdio_dest(&cinfo, fp);\n    cinfo.image_width    = w;\n    cinfo.image_height   = h;\n    if( nc == 1 ) {\n        cinfo.input_components = 1;\n        cinfo.in_color_space = JCS_GRAYSCALE;\n    }\n    else if( nc == 3 ) {\n        cinfo.input_components = 3;\n        cinfo.in_color_space = JCS_RGB;\n    }\n    else return -1;\n    jpeg_set_defaults(&cinfo);\n    cinfo.density_unit   = 1;\n    cinfo.X_density      = (UINT16)dpi;\n    cinfo.Y_density      = (UINT16)dpi;\n    cinfo.write_JFIF_header = 1;\n\n    if( quality <   0 ) quality = 0;\n    if( quality > 100 ) quality = 100;\n    jpeg_set_quality(&cinfo, quality, TRUE);\n\n    jpeg_start_compress(&cinfo, TRUE);\n\n    p = image;\n    img = (JSAMPARRAY) malloc(sizeof(JSAMPROW) * h);\n    for (i = 0; i < h; i++) {\n        img[i] = (JSAMPROW) malloc(sizeof(JSAMPLE) * nc * w);\n        if( nc == 1 ) {\n            for (j = 0; j < w; j++) {\n                img[i][j] = *(p++);\n            }\n        }\n        else if( nc == 3 ) {\n            for (j = 0; j < w; j++) {\n                img[i][j*3+0] = *(p++);\n                img[i][j*3+1] = *(p++);\n                img[i][j*3+2] = *(p++);\n            }\n        }\n    }\n    jpeg_write_scanlines(&cinfo, img, h);\n\n    jpeg_finish_compress(&cinfo);\n    jpeg_destroy_compress(&cinfo);\n\n    for (i = 0; i < h; i++) free(img[i]);\n    free(img);\n\n    return 0;\n}\n","/*\n *  paramDecomp.c\n *  ARToolKit5\n *\n *  This file is part of ARToolKit.\n *\n *  ARToolKit is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation, either version 3 of the License, or\n *  (at your option) any later version.\n *\n *  ARToolKit is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public License\n *  along with ARToolKit.  If not, see <http://www.gnu.org/licenses/>.\n *\n *  As a special exception, the copyright holders of this library give you\n *  permission to link this library with independent modules to produce an\n *  executable, regardless of the license terms of these independent modules, and to\n *  copy and distribute the resulting executable under terms of your choice,\n *  provided that you also meet, for each linked independent module, the terms and\n *  conditions of the license of that module. An independent module is a module\n *  which is neither derived from nor based on this library. If you modify this\n *  library, you may extend this exception to your version of the library, but you\n *  are not obligated to do so. If you do not wish to do so, delete this exception\n *  statement from your version.\n *\n *  Copyright 2015 Daqri, LLC.\n *  Copyright 2002-2015 ARToolworks, Inc.\n *\n *  Author(s): Takeshi Mita, Shinsaku Hiura, Hirokazu Kato, Philip Lamb\n *\n */\n/*******************************************************\n *\n * Author: Takeshi Mita, Shinsaku Hiura, Hirokazu Kato\n *\n *         tmita@inolab.sys.es.osaka-u.ac.jp\n *         shinsaku@sys.es.osaka-u.ac.jp\n *         kato@sys.im.hiroshima-cu.ac.jp\n *\n * Revision: 4.1\n * Date: 01/12/07\n *\n *******************************************************/\n\n#include <stdio.h>\n#include <math.h>\n#include <AR/ar.h>\n\nstatic ARdouble norm( const ARdouble a, const ARdouble b, const ARdouble c );\nstatic ARdouble dot( const ARdouble a1, const ARdouble a2, const ARdouble a3,\n                   const ARdouble b1, const ARdouble b2, const ARdouble b3 );\n#ifndef ARDOUBLE_IS_FLOAT\nstatic float normf( const float a, const float b, const float c );\nstatic float dotf( const float a1, const float a2, const float a3,\n                   const float b1, const float b2, const float b3 );\n#endif\n\nint  arParamDecomp( const ARParam *source, ARParam *icpara, ARdouble trans[3][4] )\n{\n\tint i;\n\t\n\tif (source->dist_function_version < 1 || source->dist_function_version > AR_DIST_FUNCTION_VERSION_MAX) return (-1);\n\t\n\ticpara->dist_function_version = source->dist_function_version;\n    icpara->xsize          = source->xsize;\n    icpara->ysize          = source->ysize;\n\tfor (i = 0; i < arParamVersionInfo[source->dist_function_version - 1].dist_factor_num; i++) icpara->dist_factor[i] = source->dist_factor[i];\n    return arParamDecompMat( source->mat, icpara->mat, trans );\n}\n\nint  arParamDecompMat( const ARdouble source[3][4], ARdouble cpara[3][4], ARdouble trans[3][4] )\n{\n    int       r, c;\n    ARdouble    Cpara[3][4];\n    ARdouble    rem1, rem2, rem3;\n\n    if( source[2][3] >= 0 ) {\n        for( r = 0; r < 3; r++ ){\n            for( c = 0; c < 4; c++ ){\n                Cpara[r][c] = source[r][c];\n            }\n        }\n    }\n    else {\n        for( r = 0; r < 3; r++ ){\n            for( c = 0; c < 4; c++ ){\n                    Cpara[r][c] = -(source[r][c]);\n                }\n        }\n    }\n\n    for( r = 0; r < 3; r++ ){\n        for( c = 0; c < 4; c++ ){\n                cpara[r][c] = 0.0;\n        }\n    }\n    cpara[2][2] = norm( Cpara[2][0], Cpara[2][1], Cpara[2][2] );\n    trans[2][0] = Cpara[2][0] / cpara[2][2];\n    trans[2][1] = Cpara[2][1] / cpara[2][2];\n    trans[2][2] = Cpara[2][2] / cpara[2][2];\n    trans[2][3] = Cpara[2][3] / cpara[2][2];\n\t\n    cpara[1][2] = dot( trans[2][0], trans[2][1], trans[2][2],\n                       Cpara[1][0], Cpara[1][1], Cpara[1][2] );\n    rem1 = Cpara[1][0] - cpara[1][2] * trans[2][0];\n    rem2 = Cpara[1][1] - cpara[1][2] * trans[2][1];\n    rem3 = Cpara[1][2] - cpara[1][2] * trans[2][2];\n    cpara[1][1] = norm( rem1, rem2, rem3 );\n    trans[1][0] = rem1 / cpara[1][1];\n    trans[1][1] = rem2 / cpara[1][1];\n    trans[1][2] = rem3 / cpara[1][1];\n\n    cpara[0][2] = dot( trans[2][0], trans[2][1], trans[2][2],\n                       Cpara[0][0], Cpara[0][1], Cpara[0][2] );\n    cpara[0][1] = dot( trans[1][0], trans[1][1], trans[1][2],\n                       Cpara[0][0], Cpara[0][1], Cpara[0][2] );\n    rem1 = Cpara[0][0] - cpara[0][1]*trans[1][0] - cpara[0][2]*trans[2][0];\n    rem2 = Cpara[0][1] - cpara[0][1]*trans[1][1] - cpara[0][2]*trans[2][1];\n    rem3 = Cpara[0][2] - cpara[0][1]*trans[1][2] - cpara[0][2]*trans[2][2];\n    cpara[0][0] = norm( rem1, rem2, rem3 );\n    trans[0][0] = rem1 / cpara[0][0];\n    trans[0][1] = rem2 / cpara[0][0];\n    trans[0][2] = rem3 / cpara[0][0];\n\n    trans[1][3] = (Cpara[1][3] - cpara[1][2]*trans[2][3]) / cpara[1][1];\n    trans[0][3] = (Cpara[0][3] - cpara[0][1]*trans[1][3]\n                               - cpara[0][2]*trans[2][3]) / cpara[0][0];\n\n    for( r = 0; r < 3; r++ ){\n        for( c = 0; c < 3; c++ ){\n                cpara[r][c] /= cpara[2][2];\n        }\n    }\n\n    return 0;\n}\n\n#ifndef ARDOUBLE_IS_FLOAT\nint  arParamDecompMatf( const ARdouble source[3][4], float cpara[3][4], float trans[3][4] )\n{\n    int       r, c;\n    float     Cpara[3][4];\n    float     rem1, rem2, rem3;\n    \n    if( source[2][3] >= 0.0 ) {\n        for( r = 0; r < 3; r++ ){\n            for( c = 0; c < 4; c++ ){\n                Cpara[r][c] = (float)source[r][c];\n            }\n        }\n    }\n    else {\n        for( r = 0; r < 3; r++ ){\n            for( c = 0; c < 4; c++ ){\n                Cpara[r][c] = -(float)(source[r][c]);\n            }\n        }\n    }\n    \n    for( r = 0; r < 3; r++ ){\n        for( c = 0; c < 4; c++ ){\n            cpara[r][c] = 0.0f;\n        }\n    }\n    cpara[2][2] = normf( Cpara[2][0], Cpara[2][1], Cpara[2][2] );\n    trans[2][0] = Cpara[2][0] / cpara[2][2];\n    trans[2][1] = Cpara[2][1] / cpara[2][2];\n    trans[2][2] = Cpara[2][2] / cpara[2][2];\n    trans[2][3] = Cpara[2][3] / cpara[2][2];\n\t\n    cpara[1][2] = dotf( trans[2][0], trans[2][1], trans[2][2],\n                      Cpara[1][0], Cpara[1][1], Cpara[1][2] );\n    rem1 = Cpara[1][0] - cpara[1][2] * trans[2][0];\n    rem2 = Cpara[1][1] - cpara[1][2] * trans[2][1];\n    rem3 = Cpara[1][2] - cpara[1][2] * trans[2][2];\n    cpara[1][1] = normf( rem1, rem2, rem3 );\n    trans[1][0] = rem1 / cpara[1][1];\n    trans[1][1] = rem2 / cpara[1][1];\n    trans[1][2] = rem3 / cpara[1][1];\n    \n    cpara[0][2] = dotf( trans[2][0], trans[2][1], trans[2][2],\n                      Cpara[0][0], Cpara[0][1], Cpara[0][2] );\n    cpara[0][1] = dotf( trans[1][0], trans[1][1], trans[1][2],\n                      Cpara[0][0], Cpara[0][1], Cpara[0][2] );\n    rem1 = Cpara[0][0] - cpara[0][1]*trans[1][0] - cpara[0][2]*trans[2][0];\n    rem2 = Cpara[0][1] - cpara[0][1]*trans[1][1] - cpara[0][2]*trans[2][1];\n    rem3 = Cpara[0][2] - cpara[0][1]*trans[1][2] - cpara[0][2]*trans[2][2];\n    cpara[0][0] = normf( rem1, rem2, rem3 );\n    trans[0][0] = rem1 / cpara[0][0];\n    trans[0][1] = rem2 / cpara[0][0];\n    trans[0][2] = rem3 / cpara[0][0];\n    \n    trans[1][3] = (Cpara[1][3] - cpara[1][2]*trans[2][3]) / cpara[1][1];\n    trans[0][3] = (Cpara[0][3] - cpara[0][1]*trans[1][3]\n                   - cpara[0][2]*trans[2][3]) / cpara[0][0];\n    \n    for( r = 0; r < 3; r++ ){\n        for( c = 0; c < 3; c++ ){\n            cpara[r][c] /= cpara[2][2];\n        }\n    }\n    \n    return 0;\n}\n#endif\n\nstatic ARdouble norm( const ARdouble a, const ARdouble b, const ARdouble c )\n{\n    return( sqrt( a*a + b*b + c*c ) );\n}\n\nstatic ARdouble dot( const ARdouble a1, const ARdouble a2, const ARdouble a3,\n\t\t   const ARdouble b1, const ARdouble b2, const ARdouble b3 )\n{\n    return( a1 * b1 + a2 * b2 + a3 * b3 );\n}\n\n#ifndef ARDOUBLE_IS_FLOAT\nstatic float normf( const float a, const float b, const float c )\n{\n    return( sqrtf( a*a + b*b + c*c ) );\n}\n\nstatic float dotf( const float a1, const float a2, const float a3,\n                  const float b1, const float b2, const float b3 )\n{\n    return( a1 * b1 + a2 * b2 + a3 * b3 );\n}\n#endif","/*\n *  paramDistortion.c\n *  ARToolKit5\n *\n *  This file is part of ARToolKit.\n *\n *  ARToolKit is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation, either version 3 of the License, or\n *  (at your option) any later version.\n *\n *  ARToolKit is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public License\n *  along with ARToolKit.  If not, see <http://www.gnu.org/licenses/>.\n *\n *  As a special exception, the copyright holders of this library give you\n *  permission to link this library with independent modules to produce an\n *  executable, regardless of the license terms of these independent modules, and to\n *  copy and distribute the resulting executable under terms of your choice,\n *  provided that you also meet, for each linked independent module, the terms and\n *  conditions of the license of that module. An independent module is a module\n *  which is neither derived from nor based on this library. If you modify this\n *  library, you may extend this exception to your version of the library, but you\n *  are not obligated to do so. If you do not wish to do so, delete this exception\n *  statement from your version.\n *\n *  Copyright 2015 Daqri, LLC.\n *  Copyright 2002-2015 ARToolworks, Inc.\n *\n *  Author(s): Hirokazu Kato, Philip Lamb\n *\n */\n/*******************************************************\n *\n * Author: Hirokazu Kato\n *\n *         kato@sys.im.hiroshima-cu.ac.jp\n *\n * Revision: 2.1\n * Date: 99/07/16\n *\n *******************************************************/\n\n#include <stdio.h>\n#include <math.h>\n#include <AR/ar.h>\n\n#define  PD_LOOP   3\n#define  PD_LOOP2  4\n\n#ifdef ARDOUBLE_IS_FLOAT\n#  define SQRT sqrtf\n#else\n#  define SQRT sqrt\n#endif\n\nint arParamObserv2Ideal( const ARdouble dist_factor[AR_DIST_FACTOR_NUM_MAX], const ARdouble ox, const ARdouble oy,\n                         ARdouble *ix, ARdouble *iy, const int dist_function_version )\n{\n\t// ----------------------------------------\n\tif (dist_function_version == 4) {\n\n    // OpenCV distortion model, with addition of a scale factor so that\n    // entire image fits onscreen.\n    ARdouble k1, k2, p1, p2, fx, fy, x0, y0, s;\n    ARdouble px, py, x02, y02;\n    int    i;\n\n    k1 = dist_factor[0];\n    k2 = dist_factor[1];\n    p1 = dist_factor[2];\n    p2 = dist_factor[3];\n    fx = dist_factor[4];\n    fy = dist_factor[5];\n    x0 = dist_factor[6];\n    y0 = dist_factor[7];\n    s  = dist_factor[8];\n\n    px = (ox - x0)/fx;\n    py = (oy - y0)/fy;\n\n    x02 = px*px;\n    y02 = py*py;\n  \n    for( i = 1; ; i++ ) {\n        if( x02 != 0.0 || y02 != 0.0 ) {\n            px = px - ((1.0 + k1*(x02+y02) + k2*(x02+y02)*(x02+y02))*px + 2.0*p1*px*py + p2*(x02 + y02 + 2.0*x02)-((ox - x0)/fx))/(1.0+k1*(3.0*x02+y02)+k2*(5.0*x02*x02+3.0*x02*y02+y02*y02)+2.0*p1*py+6.0*p2*px);\n            //px = px - ((1.0 + k1*(x02+y02) + k2*(x02+y02)*(x02+y02))*px + 2.0*p1*px*py + p2*(x02 + y02 + 2.0*x02)-((ox - x0)/fx))/(1.0+k1*(3.0*x02+y02)+k2*(5.0*x02*x02+6.0*x02*y02+y02*y02)+2.0*p1*py+6.0*p2*px);\n\n            py = py - ((1.0 + k1*(x02+y02) + k2*(x02+y02)*(x02+y02))*py + p1*(x02 + y02 + 2.0*y02) + 2.0*p2*px*py-((oy - y0)/fy))/(1.0+k1*(x02+3.0*y02)+k2*(x02*x02+3.0*x02*y02+5.0*y02*y02)+6.0*p1*py+2.0*p2*px);\n            //py = py - ((1.0 + k1*(x02+y02) + k2*(x02+y02)*(x02+y02))*py + p1*(x02 + y02 + 2.0*y02) + 2.0*p2*px*py-((oy - y0)/fy))/(1.0+k1*(x02+3.0*y02)+k2*(x02*x02+6.0*x02*y02+5.0*y02*y02)+6.0*p1*py+2.0*p2*px);\n        }\n        else {\n          px = 0.0;\n          py = 0.0;\n          break;\n        }\n        if( i == PD_LOOP2 ) break;\n    \n        x02 = px*px;\n        y02 = py*py;\n    }\n  \n    *ix = px*fx/s + x0;\n    *iy = py*fy/s + y0;\n\n    return 0;\n\n\t// ----------------------------------------\n\t} else if (dist_function_version == 3) {\n\n    ARdouble  z02, z0, p1, p2, q, z, px, py, ar;\n    int     i;\n\n    ar = dist_factor[3];\n    px = (ox - dist_factor[0]) / ar;\n    py =  oy - dist_factor[1];\n    p1 = dist_factor[4]/100000000.0;\n    p2 = dist_factor[5]/100000000.0/100000.0;\n    z02 = px*px+ py*py;\n    q = z0 = SQRT(px*px+ py*py);\n\n    for( i = 1; ; i++ ) {\n        if( z0 != 0.0 ) {\n            z = z0 - ((1.0 - p1*z02 - p2*z02*z02)*z0 - q) / (1.0 - 3.0*p1*z02 - 5.0*p2*z02*z02);\n            px = px * z / z0;\n            py = py * z / z0;\n        }\n        else {\n            px = 0.0;\n            py = 0.0;\n            break;\n        }\n        if( i == PD_LOOP ) break;\n\n        z02 = px*px+ py*py;\n        z0 = SQRT(px*px+ py*py);\n    }\n\n    *ix = px / dist_factor[2] + dist_factor[0];\n    *iy = py / dist_factor[2] + dist_factor[1];\n\n    return 0;\n\n\t// ----------------------------------------\n\t} else if (dist_function_version == 2) {\n\n    ARdouble  z02, z0, p1, p2, q, z, px, py;\n    int     i;\n\n    px = ox - dist_factor[0];\n    py = oy - dist_factor[1];\n    p1 = dist_factor[3]/100000000.0;\n    p2 = dist_factor[4]/100000000.0/100000.0;\n    z02 = px*px+ py*py;\n    q = z0 = SQRT(px*px+ py*py);\n\n    for( i = 1; ; i++ ) {\n        if( z0 != 0.0 ) {\n            z = z0 - ((1.0 - p1*z02 - p2*z02*z02)*z0 - q) / (1.0 - 3.0*p1*z02 - 5.0*p2*z02*z02);\n            px = px * z / z0;\n            py = py * z / z0;\n        }\n        else {\n            px = 0.0;\n            py = 0.0;\n            break;\n        }\n        if( i == PD_LOOP ) break;\n\n        z02 = px*px+ py*py;\n        z0 = SQRT(px*px+ py*py);\n    }\n\n    *ix = px / dist_factor[2] + dist_factor[0];\n    *iy = py / dist_factor[2] + dist_factor[1];\n\n    return 0;\n\n\t// ----------------------------------------\n\t} else if (dist_function_version == 1) {\n\t\t\n    ARdouble  z02, z0, p, q, z, px, py;\n    int     i;\n\n    px = ox - dist_factor[0];\n    py = oy - dist_factor[1];\n    p = dist_factor[3]/100000000.0;\n    z02 = px*px+ py*py;\n    q = z0 = SQRT(px*px+ py*py);\n\n    for( i = 1; ; i++ ) {\n        if( z0 != 0.0 ) {\n            z = z0 - ((1.0 - p*z02)*z0 - q) / (1.0 - 3.0*p*z02);\n            px = px * z / z0;\n            py = py * z / z0;\n        }\n        else {\n            px = 0.0;\n            py = 0.0;\n            break;\n        }\n        if( i == PD_LOOP ) break;\n\n        z02 = px*px+ py*py;\n        z0 = SQRT(px*px+ py*py);\n    }\n\n    *ix = px / dist_factor[2] + dist_factor[0];\n    *iy = py / dist_factor[2] + dist_factor[1];\n\n    return 0;\n\n\t// ----------------------------------------\n\t} else {\n\t\t\n    return -1;\n\t\n\t}\n}\n\nint arParamIdeal2Observ( const ARdouble dist_factor[AR_DIST_FACTOR_NUM_MAX], const ARdouble ix, const ARdouble iy,\n                         ARdouble *ox, ARdouble *oy, const int dist_function_version )\n{\n\t// ----------------------------------------\n\tif (dist_function_version == 4) {\n\n    ARdouble k1, k2, p1, p2, fx, fy, x0, y0, s;\n    ARdouble l, x, y;\n\n    k1 = dist_factor[0];\n    k2 = dist_factor[1];\n    p1 = dist_factor[2];\n    p2 = dist_factor[3];\n    fx = dist_factor[4];\n    fy = dist_factor[5];\n    x0 = dist_factor[6];\n    y0 = dist_factor[7];\n    s  = dist_factor[8];\n  \n    x = (ix - x0)*s/fx;\n    y = (iy - y0)*s/fy;\n    l = x*x + y*y;\n    *ox = (x*(1.0+k1*l+k2*l*l)+2.0*p1*x*y+p2*(l+2.0*x*x))*fx+x0;\n    *oy = (y*(1.0+k1*l+k2*l*l)+p1*(l+2.0*y*y)+2.0*p2*x*y)*fy+y0;\n\n    return 0;\n\n\t// ----------------------------------------\n\t} else if (dist_function_version == 3) {\n\n\tARdouble    x, y, l, d, ar;\n\n    ar = dist_factor[3];\n    x = (ix - dist_factor[0]) * dist_factor[2];\n    y = (iy - dist_factor[1]) * dist_factor[2];\n    if( x == 0.0 && y == 0.0 ) {\n        *ox = dist_factor[0];\n        *oy = dist_factor[1];\n    }\n    else {\n        l = x*x + y*y;\n        d = 1.0 - dist_factor[4]/100000000.0 * l - dist_factor[5]/100000000.0/100000.0 * l * l;\n        *ox = x * d * ar + dist_factor[0];\n        *oy = y * d      + dist_factor[1];\n    }\n\n    return 0;\n\t\n\t// ----------------------------------------\n\t} else if (dist_function_version == 2) {\n\t\n    ARdouble    x, y, l, d;\n\n    x = (ix - dist_factor[0]) * dist_factor[2];\n    y = (iy - dist_factor[1]) * dist_factor[2];\n    if( x == 0.0 && y == 0.0 ) {\n        *ox = dist_factor[0];\n        *oy = dist_factor[1];\n    }\n    else {\n        l = x*x + y*y;\n        d = 1.0 - dist_factor[3]/100000000.0 * l - dist_factor[4]/100000000.0/100000.0 * l * l;\n        *ox = x * d + dist_factor[0];\n        *oy = y * d + dist_factor[1];\n    }\n\n    return 0;\n\t\n\t// ----------------------------------------\n\t} else if (dist_function_version == 1) {\n\t\t\n\tARdouble    x, y, d;\n\n    x = (ix - dist_factor[0]) * dist_factor[2];\n    y = (iy - dist_factor[1]) * dist_factor[2];\n    if( x == 0.0 && y == 0.0 ) {\n        *ox = dist_factor[0];\n        *oy = dist_factor[1];\n    }\n    else {\n        d = 1.0 - dist_factor[3]/100000000.0 * (x*x+y*y);\n        *ox = x * d + dist_factor[0];\n        *oy = y * d + dist_factor[1];\n    }\n\n    return 0;\n\t// ----------------------------------------\n\t} else {\n\t\n\treturn -1;\n\t\n\t}\n}\n","/*\n *  mTrans.c\n *  ARToolKit5\n *\n *  This file is part of ARToolKit.\n *\n *  ARToolKit is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation, either version 3 of the License, or\n *  (at your option) any later version.\n *\n *  ARToolKit is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public License\n *  along with ARToolKit.  If not, see <http://www.gnu.org/licenses/>.\n *\n *  As a special exception, the copyright holders of this library give you\n *  permission to link this library with independent modules to produce an\n *  executable, regardless of the license terms of these independent modules, and to\n *  copy and distribute the resulting executable under terms of your choice,\n *  provided that you also meet, for each linked independent module, the terms and\n *  conditions of the license of that module. An independent module is a module\n *  which is neither derived from nor based on this library. If you modify this\n *  library, you may extend this exception to your version of the library, but you\n *  are not obligated to do so. If you do not wish to do so, delete this exception\n *  statement from your version.\n *\n *  Copyright 2015 Daqri, LLC.\n *  Copyright 2002-2015 ARToolworks, Inc.\n *\n *  Author(s): Shinsaku Hiura, Hirokazu Kato, Philip Lamb\n *\n */\n/*******************************************************\n *\n * Author: Shinsaku Hiura, Hirokazu Kato\n *\n *         shinsaku@sys.es.osaka-u.ac.jp\n *         kato@sys.im.hiroshima-cu.ac.jp\n *\n * Revision: 2.1\n * Date: 99/07/16\n *\n *******************************************************/\n\n#include <stdio.h>\n#include <math.h>\n#include <AR/ar.h>\n\nint arMatrixTrans(ARMat *dest, ARMat *source)\n{\n#if 0\n\tint r, c;\n\n\tif(dest->row != source->clm || dest->clm != source->row) return -1;\n\n\tfor(r = 0; r < dest->row; r++) {\n\t\tfor(c = 0; c < dest->clm; c++) {\n\t\t\tARELEM0(dest, r, c) = ARELEM0(source, c, r);\n\t\t}\n\t}\n#else\n    int      r, c;\n    ARdouble   *p1, *p2;\n    \n    if(dest->row != source->clm || dest->clm != source->row) return -1;\n    \n    p2 = dest->m;\n    for(r = 0; r < dest->row; r++) {\n        p1 = &source->m[r];\n        for(c = 0; c < dest->clm; c++) {\n            *(p2++) = *p1;\n            p1 += dest->row;\n        }\n    }\n#endif\n\n\treturn 0;\n}\n\n#ifndef ARDOUBLE_IS_FLOAT\nint arMatrixTransf(ARMatf *dest, ARMatf *source)\n{\n#if 0\n\tint r, c;\n    \n\tif(dest->row != source->clm || dest->clm != source->row) return -1;\n    \n\tfor(r = 0; r < dest->row; r++) {\n\t\tfor(c = 0; c < dest->clm; c++) {\n\t\t\tARELEM0(dest, r, c) = ARELEM0(source, c, r);\n\t\t}\n\t}\n#else\n    int      r, c;\n    float   *p1, *p2;\n    \n    if(dest->row != source->clm || dest->clm != source->row) return -1;\n    \n    p2 = dest->m;\n    for(r = 0; r < dest->row; r++) {\n        p1 = &source->m[r];\n        for(c = 0; c < dest->clm; c++) {\n            *(p2++) = *p1;\n            p1 += dest->row;\n        }\n    }\n#endif\n    \n\treturn 0;\n}\n#endif","/*\n *  paramChangeSize.c\n *  ARToolKit5\n *\n *  This file is part of ARToolKit.\n *\n *  ARToolKit is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation, either version 3 of the License, or\n *  (at your option) any later version.\n *\n *  ARToolKit is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public License\n *  along with ARToolKit.  If not, see <http://www.gnu.org/licenses/>.\n *\n *  As a special exception, the copyright holders of this library give you\n *  permission to link this library with independent modules to produce an\n *  executable, regardless of the license terms of these independent modules, and to\n *  copy and distribute the resulting executable under terms of your choice,\n *  provided that you also meet, for each linked independent module, the terms and\n *  conditions of the license of that module. An independent module is a module\n *  which is neither derived from nor based on this library. If you modify this\n *  library, you may extend this exception to your version of the library, but you\n *  are not obligated to do so. If you do not wish to do so, delete this exception\n *  statement from your version.\n *\n *  Copyright 2015 Daqri, LLC.\n *  Copyright 2002-2015 ARToolworks, Inc.\n *\n *  Author(s): Takeshi Mita, Shinsaku Hiura, Hirokazu Kato, Philip Lamb\n *\n */\n/*******************************************************\n *\n * Author: Takeshi Mita, Shinsaku Hiura, Hirokazu Kato\n *\n *         tmita@inolab.sys.es.osaka-u.ac.jp\n *         shinsaku@sys.es.osaka-u.ac.jp\n *         kato@sys.im.hiroshima-cu.ac.jp\n *\n * Revision: 4.1\n * Date: 01/12/07\n *\n *******************************************************/\n\n#include <stdio.h>\n#include <math.h>\n#include <AR/ar.h>\n\n\nint arParamChangeSize( ARParam *source, int xsize, int ysize, ARParam *newparam )\n{\n    ARdouble  x_scale, y_scale;\n    int     i;\n\n    x_scale = (ARdouble)xsize / (ARdouble)(source->xsize);\n    y_scale = (ARdouble)ysize / (ARdouble)(source->ysize);\n\n    newparam->xsize = xsize;\n    newparam->ysize = ysize;\n    for( i = 0; i < 4; i++ ) {\n        newparam->mat[0][i] = source->mat[0][i] * x_scale;\n        newparam->mat[1][i] = source->mat[1][i] * y_scale;\n        newparam->mat[2][i] = source->mat[2][i];\n    }\n\n\tif (source->dist_function_version == 4) {\n\t\tnewparam->dist_factor[0] = source->dist_factor[0];             /*  k1  */\n\t\tnewparam->dist_factor[1] = source->dist_factor[1];             /*  k2  */\n\t\tnewparam->dist_factor[2] = source->dist_factor[2];             /*  p1  */\n\t\tnewparam->dist_factor[3] = source->dist_factor[3];             /*  p2  */\n\t\tnewparam->dist_factor[4] = source->dist_factor[4] * x_scale;   /*  fx  */\n\t\tnewparam->dist_factor[5] = source->dist_factor[5] * y_scale;   /*  fy  */\n\t\tnewparam->dist_factor[6] = source->dist_factor[6] * x_scale;   /*  x0  */\n\t\tnewparam->dist_factor[7] = source->dist_factor[7] * y_scale;   /*  y0  */\n\t\tnewparam->dist_factor[8] = source->dist_factor[8];             /*  Size adjust */\n\t} else if (source->dist_function_version == 3) {\n\t\tnewparam->dist_factor[0] = source->dist_factor[0] * x_scale;\n\t\tnewparam->dist_factor[1] = source->dist_factor[1] * y_scale;\n\t\tnewparam->dist_factor[2] = source->dist_factor[2];\n\t\tnewparam->dist_factor[3] = source->dist_factor[3];\n\t\tnewparam->dist_factor[4] = source->dist_factor[4] / (x_scale*y_scale);\n\t    newparam->dist_factor[5] = source->dist_factor[5] / (x_scale*x_scale*y_scale*y_scale);\n\t} else if (source->dist_function_version == 2) {\n\t\tnewparam->dist_factor[0] = source->dist_factor[0] * x_scale;\n\t\tnewparam->dist_factor[1] = source->dist_factor[1] * y_scale;\n\t\tnewparam->dist_factor[2] = source->dist_factor[2];\n\t\tnewparam->dist_factor[3] = source->dist_factor[3] / (x_scale*y_scale);\n\t\tnewparam->dist_factor[4] = source->dist_factor[4] / (x_scale*x_scale*y_scale*y_scale);\n\t} else if (source->dist_function_version == 1) {\n\t\tnewparam->dist_factor[0] = source->dist_factor[0] * x_scale;\n\t\tnewparam->dist_factor[1] = source->dist_factor[1] * y_scale;\n\t\tnewparam->dist_factor[2] = source->dist_factor[2];\n\t\tnewparam->dist_factor[3] = source->dist_factor[3] / (x_scale*y_scale);\n\t} else {\n\t\t// Unknown distortion function version.\n\t\treturn -1;\n\t}\n\tnewparam->dist_function_version = source->dist_function_version;\n    return 0;\n}\n","/*\n *  AR2/surface.c\n *  ARToolKit5\n *\n *  This file is part of ARToolKit.\n *\n *  ARToolKit is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation, either version 3 of the License, or\n *  (at your option) any later version.\n *\n *  ARToolKit is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public License\n *  along with ARToolKit.  If not, see <http://www.gnu.org/licenses/>.\n *\n *  As a special exception, the copyright holders of this library give you\n *  permission to link this library with independent modules to produce an\n *  executable, regardless of the license terms of these independent modules, and to\n *  copy and distribute the resulting executable under terms of your choice,\n *  provided that you also meet, for each linked independent module, the terms and\n *  conditions of the license of that module. An independent module is a module\n *  which is neither derived from nor based on this library. If you modify this\n *  library, you may extend this exception to your version of the library, but you\n *  are not obligated to do so. If you do not wish to do so, delete this exception\n *  statement from your version.\n *\n *  Copyright 2015 Daqri, LLC.\n *  Copyright 2006-2015 ARToolworks, Inc.\n *\n *  Author(s): Hirokazu Kato, Philip Lamb\n *\n */\n\n#include <AR/ar.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <AR2/coord.h>\n#include <AR2/featureSet.h>\n#include <AR2/template.h>\n#include <AR2/tracking.h>\n#include <AR2/util.h>\n\nstatic char *get_buff( char *buf, int n, FILE *fp );\n\nAR2SurfaceSetT *ar2ReadSurfaceSet( const char *filename, const char *ext, ARPattHandle *pattHandle )\n{\n    AR2SurfaceSetT  *surfaceSet;\n    FILE            *fp = NULL;\n    int              readMode;\n    char             buf[256], name[256];\n    int              i, j, k;\n\n    if( ext == NULL || *ext == '\\0' || strcmp(ext,\"fset\") == 0 ) {\n        strncpy(name, filename, sizeof(name) - 1);\n        name[sizeof(name) - 1] = '\\0';\n        readMode = 0;\n    }\n    else {\n        char namebuf[512];\n        sprintf(namebuf, \"%s.%s\", filename, ext);\n        if ((fp = fopen(namebuf,\"r\")) == NULL) {\n            ARLOGe(\"Error opening file '%s': \", filename);\n            ARLOGperror(NULL);\n            return (NULL);\n        }\n        readMode = 1;\n    }\n    arMalloc(surfaceSet, AR2SurfaceSetT, 1);\n\n    if( readMode ) {\n        if( get_buff(buf, 256, fp) == NULL ) {\n            fclose(fp);\n            free(surfaceSet);\n            return (NULL);\n        }\n        if( sscanf(buf, \"%d\", &i) != 1 ) {\n            fclose(fp);\n            free(surfaceSet);\n            return (NULL);\n        }\n        if( i < 1 ) {\n            fclose(fp);\n            free(surfaceSet);\n            return (NULL);\n        }\n        surfaceSet->num     = i;\n        surfaceSet->contNum = 0;\n    }\n    else {\n        surfaceSet->num     = 1;\n        surfaceSet->contNum = 0;\n    }\n    arMalloc(surfaceSet->surface, AR2SurfaceT, surfaceSet->num);\n\n    for( i = 0; i < surfaceSet->num; i++ ) {\n        ARLOGi(\"\\n### Surface No.%d ###\\n\", i+1);\n        if( readMode ) {\n            if( get_buff(buf, 256, fp) == NULL ) break;\n            if( sscanf(buf, \"%s\", name) != 1 ) break;\n            ar2UtilRemoveExt( name );\n        }\n        ARLOGi(\"  Read ImageSet.\\n\");\n        surfaceSet->surface[i].imageSet = ar2ReadImageSet( name );\n        if( surfaceSet->surface[i].imageSet == NULL ) {\n            ARLOGe(\"Error opening file '%s.iset'.\\n\", name);\n            free(surfaceSet->surface);\n            free(surfaceSet);\n\t\t\tif (fp) fclose(fp); //COVHI10426\n            return (NULL);\n        }\n        ARLOGi(\"    end.\\n\");\n\n        ARLOGi(\"  Read FeatureSet.\\n\");\n        surfaceSet->surface[i].featureSet = ar2ReadFeatureSet( name, \"fset\" );\n        if( surfaceSet->surface[i].featureSet == NULL ) {\n            ARLOGe(\"Error opening file '%s.fset'.\\n\", name);\n            ar2FreeImageSet(&surfaceSet->surface[i].imageSet);\n            free(surfaceSet->surface);\n            free(surfaceSet);\n\t\t\tif (fp) fclose(fp); //COVHI10426\n            return (NULL);\n        }\n        ARLOGi(\"    end.\\n\");\n\n        if (pattHandle) {\n            ARLOGi(\"  Read MarkerSet.\\n\");\n            ar2UtilRemoveExt( name );\n            surfaceSet->surface[i].markerSet = ar2ReadMarkerSet( name, \"mrk\", pattHandle );\n            if( surfaceSet->surface[i].markerSet == NULL ) {\n                ARLOGe(\"Error opening file '%s.mrk'.\\n\", name);\n                ar2FreeFeatureSet(&surfaceSet->surface[i].featureSet);\n                ar2FreeImageSet(&surfaceSet->surface[i].imageSet);\n                free(surfaceSet->surface);\n                free(surfaceSet);\n                if (fp) fclose(fp); //COVHI10426\n                return (NULL);\n            }\n            ARLOGi(\"    end.\\n\");\n        } else {\n            surfaceSet->surface[i].markerSet = NULL;\n        }\n\n        if (readMode) {\n            if( get_buff(buf, 256, fp) == NULL ) break;\n            if( sscanf(buf, \"%f %f %f %f\",\n                       &(surfaceSet->surface[i].trans[0][0]),\n                       &(surfaceSet->surface[i].trans[0][1]),\n                       &(surfaceSet->surface[i].trans[0][2]),\n                       &(surfaceSet->surface[i].trans[0][3])) != 4 ) {\n                ARLOGe(\"Transformation matrix read error!!\\n\");\n                fclose(fp);\n                exit(0);\n            }\n            if( get_buff(buf, 256, fp) == NULL ) break;\n            if( sscanf(buf, \"%f %f %f %f\",\n                       &(surfaceSet->surface[i].trans[1][0]),\n                       &(surfaceSet->surface[i].trans[1][1]),\n                       &(surfaceSet->surface[i].trans[1][2]),\n                       &(surfaceSet->surface[i].trans[1][3])) != 4 ) {\n                ARLOGe(\"Transformation matrix read error!!\\n\");\n                fclose(fp);\n                exit(0);\n            }\n            if( get_buff(buf, 256, fp) == NULL ) break;\n            if( sscanf(buf, \"%f %f %f %f\",\n                       &(surfaceSet->surface[i].trans[2][0]),\n                       &(surfaceSet->surface[i].trans[2][1]),\n                       &(surfaceSet->surface[i].trans[2][2]),\n                       &(surfaceSet->surface[i].trans[2][3])) != 4 ) {\n                ARLOGe(\"Transformation matrix read error!!\\n\");\n                fclose(fp);\n                exit(0);\n            }\n        } else {\n            for( j = 0; j < 3; j++ ) {\n                for( k = 0; k < 4; k++ ) {\n                    surfaceSet->surface[i].trans[j][k] = (j == k)? 1.0f: 0.0f;\n                }\n            }\n        }\n        arUtilMatInvf( (const float (*)[4])surfaceSet->surface[i].trans, surfaceSet->surface[i].itrans );\n\n        ar2UtilReplaceExt( name, 256, \"jpg\");\n        arMalloc( surfaceSet->surface[i].jpegName, char, 256);\n        strncpy( surfaceSet->surface[i].jpegName, name, 256 );\n    }\n\n    if (fp) fclose(fp); //COVHI10459\n\n    if (i < surfaceSet->num) exit(0);\n\n    return surfaceSet;\n}\n\nstatic char *get_buff( char *buf, int n, FILE *fp )\n{\n    char *ret;\n\n    for(;;) {\n        ret = fgets( buf, n, fp );\n        if( ret == NULL ) return(NULL);\n        if( buf[0] != '\\n' && buf[0] != '#' ) return(ret);\n    }\n}\n\nint ar2FreeSurfaceSet( AR2SurfaceSetT **surfaceSet )\n{\n    int     i;\n\n    if( *surfaceSet == NULL ) return -1;\n\n    for( i = 0; i < (*surfaceSet)->num; i++ ) {\n        ar2FreeImageSet( &((*surfaceSet)->surface[i].imageSet) );\n        ar2FreeFeatureSet( &((*surfaceSet)->surface[i].featureSet) );\n        if( (*surfaceSet)->surface[i].markerSet != NULL ) {\n            ar2FreeMarkerSet( &((*surfaceSet)->surface[i].markerSet) );\n        }\n        free( (*surfaceSet)->surface[i].jpegName );\n    }\n    free( (*surfaceSet)->surface );\n    free( *surfaceSet );\n    *surfaceSet = NULL;\n\n    return 0;\n}\n\n\nint ar2SetInitTrans( AR2SurfaceSetT *surfaceSet, float  trans[3][4] )\n{\n    int    i, j;\n\n    if( surfaceSet == NULL ) return -1;\n    surfaceSet->contNum = 1;\n    for( j = 0; j < 3; j++ ) {\n        for( i = 0; i < 4; i++ ) surfaceSet->trans1[j][i] = trans[j][i];\n    }\n    surfaceSet->prevFeature[0].flag = -1;\n\n    return 0;\n}\n","/*\n *  paramFile.c\n *  ARToolKit5\n *\n *  This file is part of ARToolKit.\n *\n *  ARToolKit is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation, either version 3 of the License, or\n *  (at your option) any later version.\n *\n *  ARToolKit is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public License\n *  along with ARToolKit.  If not, see <http://www.gnu.org/licenses/>.\n *\n *  As a special exception, the copyright holders of this library give you\n *  permission to link this library with independent modules to produce an\n *  executable, regardless of the license terms of these independent modules, and to\n *  copy and distribute the resulting executable under terms of your choice,\n *  provided that you also meet, for each linked independent module, the terms and\n *  conditions of the license of that module. An independent module is a module\n *  which is neither derived from nor based on this library. If you modify this\n *  library, you may extend this exception to your version of the library, but you\n *  are not obligated to do so. If you do not wish to do so, delete this exception\n *  statement from your version.\n *\n *  Copyright 2015 Daqri, LLC.\n *  Copyright 2002-2015 ARToolworks, Inc.\n *\n *  Author(s): Takeshi Mita, Shinsaku Hiura, Hirokazu Kato, Philip Lamb, Julian Looser\n *\n */\n/*******************************************************\n *\n * Author: Takeshi Mita, Shinsaku Hiura, Hirokazu Kato\n *\n *         tmita@inolab.sys.es.osaka-u.ac.jp\n *         shinsaku@sys.es.osaka-u.ac.jp\n *         kato@sys.im.hiroshima-cu.ac.jp\n *\n * Revision: 4.1\n * Date: 01/12/07\n *\n *******************************************************/\n\n#include <stdio.h>\n#include <stdarg.h>\n#include <string.h>\n#include <AR/ar.h>\n#include <errno.h>\n\ntypedef struct {\n    int      xsize, ysize;\n    double   mat[3][4];                             // Forced to double instead of ARdouble.\n    double   dist_factor[AR_DIST_FACTOR_NUM_MAX];   // Forced to double instead of ARdouble.\n\tint      dist_function_version; // Must be last field in structure (as will not be written to disk).\n} ARParamd;\n\nconst arParamVersionInfo_t arParamVersionInfo[AR_DIST_FUNCTION_VERSION_MAX] = {\n\t{4, 136}, \n\t{5, 144}, \n\t{6, 152}, \n\t{9, 176}, \n};\n\n#ifdef AR_LITTLE_ENDIAN\ntypedef union {\n\tint  x;\n\tunsigned char y[4];\n} SwapIntT;\n\ntypedef union {\n\tfloat  x;\n\tunsigned char y[4];\n} SwapFloatT;\n\ntypedef union {\n\tdouble   x;\n\tunsigned char y[8];\n} SwapDoubleT;\n\nstatic void byteSwapInt( const int *from, int *to )\n{\n    SwapIntT   *w1, *w2;\n    int        i;\n\n    w1 = (SwapIntT *)from;\n    w2 = (SwapIntT *)to;\n    for( i = 0; i < 4; i++ ) {\n        w2->y[i] = w1->y[3-i];\n    }\n\n    return;\n}\n\n/*static void byteSwapFloat( const float *from, float *to )\n{\n    SwapFloatT   *w1, *w2;\n    int           i;\n    \n    w1 = (SwapFloatT *)from;\n    w2 = (SwapFloatT *)to;\n    for( i = 0; i < 4; i++ ) {\n        w2->y[i] = w1->y[3-i];\n    }\n    \n    return;\n}*/\n\nstatic void byteSwapDouble( const double *from, double *to )\n{\n    SwapDoubleT   *w1, *w2;\n    int           i;\n\n    w1 = (SwapDoubleT *)from;\n    w2 = (SwapDoubleT *)to;\n    for( i = 0; i < 8; i++ ) {\n        w2->y[i] = w1->y[7-i];\n    }\n\n    return;\n}\n\nstatic void byteswap( ARParamd *param )\n{\n    ARParamd  wparam;\n    int      i, j;\n\n    byteSwapInt( &(param->xsize), &(wparam.xsize) );\n    byteSwapInt( &(param->ysize), &(wparam.ysize) );\n\n    for( j = 0; j < 3; j++ ) {\n        for( i = 0; i < 4; i++ ) {\n            byteSwapDouble( &(param->mat[j][i]), &(wparam.mat[j][i]) );\n        }\n    }\n\n    for( i = 0; i < arParamVersionInfo[param->dist_function_version - 1].dist_factor_num; i++ ) {\n        byteSwapDouble( &(param->dist_factor[i]), &(wparam.dist_factor[i]) );\n    }\n\twparam.dist_function_version = param->dist_function_version;\n\n    *param = wparam;\n}\n#endif\n\n#ifdef ARDOUBLE_IS_FLOAT\n// If ARdouble has been defined to float, these functions are needed\n// to convert ARParams for writing out to and reading from disk,\n// where floating point values are always stored as doubles.\nstatic ARParamd paramftod(const ARParam *param)\n{\n    int i, j;\n    ARParamd paramd;\n    \n    paramd.xsize = param->xsize;\n    paramd.ysize = param->ysize;\n    for (j = 0; j < 3; j++) {\n        for (i = 0; i < 4; i++) {\n            paramd.mat[j][i] = (double)(param->mat[j][i]);\n        }\n    }\n    for( i = 0; i < arParamVersionInfo[param->dist_function_version - 1].dist_factor_num; i++ ) {\n        paramd.dist_factor[i] = (double)(param->dist_factor[i]);\n    }\n    paramd.dist_function_version = param->dist_function_version;\n    return (paramd);\n}\n\nstatic ARParam paramdtof(const ARParamd *paramd)\n{\n    int i, j;\n    ARParam param;\n    \n    param.xsize = paramd->xsize;\n    param.ysize = paramd->ysize;\n    for (j = 0; j < 3; j++) {\n        for (i = 0; i < 4; i++) {\n            param.mat[j][i] = (float)(paramd->mat[j][i]);\n        }\n    }\n    for( i = 0; i < arParamVersionInfo[paramd->dist_function_version - 1].dist_factor_num; i++ ) {\n        param.dist_factor[i] = (float)(paramd->dist_factor[i]);\n    }\n    param.dist_function_version = paramd->dist_function_version;\n    return (param);\n}\n\n#endif\n\nint    arParamSave( const char *filename, const int num, const ARParam *param, ...)\n{\n    FILE        *fp;\n    va_list     ap;\n    ARParam     *param1;\n    int         i;\n\tARParamd\tparam_toWrite;\n\tdouble\t\ttemp;\n\n    if( num < 1 || !filename || !param) return -1;\n\n    fp = fopen( filename, \"wb\" );\n    if( fp == NULL ) {\n\t\tARLOGe(\"Error (%d): unable to open camera parameters file \\\"%s\\\" for writing.\\n\", errno, filename);\n\t\tARLOGperror(NULL);\n\t\treturn -1;\n\t}\n\n#ifdef ARDOUBLE_IS_FLOAT\n\tparam_toWrite = paramftod(param);\n#else\n    param_toWrite = *((ARParamd *)param);\n#endif\n\tif (param_toWrite.dist_function_version == 1) { // Ensure that version 1 files are compatible with the structure layout in ARToolKit 2.x.\n\t\ttemp = param_toWrite.dist_factor[2];\n\t\tparam_toWrite.dist_factor[2] = param_toWrite.dist_factor[3];\n\t\tparam_toWrite.dist_factor[3] = temp;\n\t}\t\n#ifdef AR_LITTLE_ENDIAN\n    byteswap(&param_toWrite);\n#endif\n\t\n    if (fwrite((void *)&param_toWrite, arParamVersionInfo[param_toWrite.dist_function_version - 1].ARParam_size, 1, fp) != 1) {\n        fclose(fp);\n        return -1;\n    }\n\n    va_start(ap, param);\n    for( i = 1; i < num; i++ ) {\n        param1 = va_arg(ap, ARParam *);\n\t\t\n#ifdef ARDOUBLE_IS_FLOAT\n\t\tparam_toWrite = paramftod(param1);\n#else\n        param_toWrite = *((ARParamd *)param1);\n#endif\n\t\tif (param_toWrite.dist_function_version == 1) {\n\t\t\ttemp = param_toWrite.dist_factor[2];\n\t\t\tparam_toWrite.dist_factor[2] = param_toWrite.dist_factor[3];\n\t\t\tparam_toWrite.dist_factor[3] = temp;\n\t\t}\n#ifdef AR_LITTLE_ENDIAN\n        byteswap(&param_toWrite);\n#endif\n\n\t\tif (fwrite((void *)&param_toWrite, arParamVersionInfo[param_toWrite.dist_function_version - 1].ARParam_size, 1, fp) != 1) {\n            fclose(fp);\n            return -1;\n        }\n    }\n\n    fclose(fp);\n\n    return 0;\n}\n\nint arParamLoad( const char *filename, int num, ARParam *param, ...)\n{\n    //COVHI10334\n    int      ret = 0;\n    FILE     *fp = NULL;\n    int      i = 0;\n    va_list  ap;\n    ARParam  *param1;\n    int      dist_function_version;\n    long     flen;\n    ARParamd param_wasRead;\n    double   temp;\n\n    if (num < 1 || !filename || !param) {\n        ret = -1;\n        goto done;\n    }\n\n    fp = fopen(filename, \"rb\");\n    if (fp == NULL) {\n\t\tARLOGe(\"Error (%d): unable to open camera parameters file \\\"%s\\\" for reading.\\n\", errno, filename);\n\t\tARLOGperror(NULL);\n        ret = -1;\n        goto done;\n\t}\n\t\n\t// Determine file length.\n\tfseek(fp, 0L, SEEK_END);\n\tif (ferror(fp)) {\n\t\tARLOGe(\"Error (%d): unable to determine file length.\", errno);\n\t\tARLOGperror(NULL);\n        ret = -1;\n        goto done;\n    }\n\tflen = ftell(fp);\n\t//ARLOGd(\"Loading a parameter file of length %ld.\\n\", flen);\n\trewind(fp);\n\t\n\t// Try to determine distortion function version number.\n\t// Infer distortion function version number from file length.\n\t// Assumes all ARParams in file are of same version.\n\tfor (i = 0; i < AR_DIST_FUNCTION_VERSION_MAX; i++) {\n\t\tif (flen % arParamVersionInfo[i].ARParam_size == 0) {\n\t\t\tdist_function_version = i + 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (i == AR_DIST_FUNCTION_VERSION_MAX) {\n\t\tARLOGe(\"Error: supplied file does not appear to be an ARToolKit camera parameter file.\\n\");\n        ret = -1;\n        goto done;\n\t}\n\tARLOGd(\"Reading camera parameters from %s (distortion function version %d).\\n\", filename, dist_function_version);\n    \n    if (fread((void *)&param_wasRead, arParamVersionInfo[dist_function_version - 1].ARParam_size, 1, fp) != 1) {\n\t\tARLOGe(\"Error (%d): unable to read from file.\", errno);\n\t\tARLOGperror(NULL);\n        ret = -1;\n        goto done;\n    }\n    param_wasRead.dist_function_version = dist_function_version;\n#ifdef AR_LITTLE_ENDIAN\n    byteswap( &param_wasRead );\n#endif\n\tif (dist_function_version == 1) { // Ensure that file layout in ARToolKit 2.x.version is modified for ARToolKit 4.x and later.\n\t\ttemp = param_wasRead.dist_factor[2];\n\t\tparam_wasRead.dist_factor[2] = param_wasRead.dist_factor[3];\n\t\tparam_wasRead.dist_factor[3] = temp;\n\t}\t\n#ifdef ARDOUBLE_IS_FLOAT\n\t*param = paramdtof(&param_wasRead);\n#else\n    *((ARParamd *)param) = param_wasRead;\n#endif\n\n    va_start(ap, param);\n    for( i = 1; i < num; i++ ) {\n        param1 = va_arg(ap, ARParam *);\n\t\tparam1->dist_function_version = param->dist_function_version;\n        if (fread((void *)&param_wasRead, arParamVersionInfo[param->dist_function_version - 1].ARParam_size, 1, fp) != 1) {\n            ret = -1;\n            goto done;\n        }\n        param_wasRead.dist_function_version = dist_function_version;\n#ifdef AR_LITTLE_ENDIAN\n        byteswap( &param_wasRead );\n#endif\n        if (dist_function_version == 1) { // Ensure that file layout in ARToolKit 2.x.version is modified for ARToolKit 4.x and later.\n            temp = param_wasRead.dist_factor[2];\n            param_wasRead.dist_factor[2] = param_wasRead.dist_factor[3];\n            param_wasRead.dist_factor[3] = temp;\n        }\t\n#ifdef ARDOUBLE_IS_FLOAT\n        *param1 = paramdtof(&param_wasRead);\n#else\n        *((ARParamd *)param1) = param_wasRead;\n#endif\n    }\n\ndone:\n    if (fp) {\n        fclose(fp);\n    }\n    \n    return ret;\n}\n\nint    arParamLoadFromBuffer( const void *buffer, size_t bufsize, ARParam *param)\n{\n    int         i;\n    int         dist_function_version;\n\tARParamd\tparam_wasRead;\n\tdouble\t\ttemp;\n    \n    if( !buffer || !param) return -1;\n    \n\t// Try to determine distortion function version number.\n\t// Infer distortion function version number from buffer length.\n\t// Assumes all ARParams in file are of same version.\n\tfor (i = 0; i < AR_DIST_FUNCTION_VERSION_MAX; i++) {\n\t\tif (bufsize % arParamVersionInfo[i].ARParam_size == 0) {\n\t\t\tdist_function_version = i + 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (i == AR_DIST_FUNCTION_VERSION_MAX) {\n\t\tARLOGe(\"Error: supplied buffer does not appear to be ARToolKit camera parameters.\\n\");\n\t\t//fclose(fp);  // don't need to close file anymore\n\t\treturn -1;\n\t}\n    \n\tARLOGd(\"Reading camera parameters from buffer (distortion function version %d).\\n\", dist_function_version);\n    \n\tmemcpy((void *)&param_wasRead, buffer, arParamVersionInfo[dist_function_version - 1].ARParam_size);\n    \n\tparam_wasRead.dist_function_version = dist_function_version;\n    \n#ifdef AR_LITTLE_ENDIAN\n    byteswap( &param_wasRead );\n#endif\n\tif (dist_function_version == 1) { // Ensure that file layout in ARToolKit 2.x.version is modified for ARToolKit 4.x and later.\n\t\ttemp = param_wasRead.dist_factor[2];\n\t\tparam_wasRead.dist_factor[2] = param_wasRead.dist_factor[3];\n\t\tparam_wasRead.dist_factor[3] = temp;\n\t}\n#ifdef ARDOUBLE_IS_FLOAT\n\t*param = paramdtof(&param_wasRead);\n#else\n    *((ARParamd *)param) = param_wasRead;\n#endif\n    \n    return 0;\n}\n\nint arParamSaveExt( const char *filename, ARdouble para[3][4] )\n{\n    FILE        *fp;\n    double      para0[3][4];\n#ifdef AR_LITTLE_ENDIAN\n    double      para1[3][4];\n#endif\n    int         i, j;\n\n    if (!filename || !filename[0] || !para) return (-1);\n\n    fp = fopen( filename, \"wb\" );\n    if( fp == NULL ) {\n\t\tARLOGe(\"Error (%d): unable to open external parameters file \\\"%s\\\" for writing.\\n\", errno, filename);\n\t\tARLOGperror(NULL);\n\t\treturn -1;\n\t}\n\n    for( j = 0; j < 3; j++ ) {\n        for( i = 0; i < 4; i++ ) {\n            para0[j][i] = (double)(para[j][i]);\n        }\n    }\n\n#ifdef AR_LITTLE_ENDIAN\n    for( j = 0; j < 3; j++ ) {\n        for( i = 0; i < 4; i++ ) {\n            byteSwapDouble( &(para0[j][i]), &(para1[j][i]) );\n        }\n    }\n\n    if( fwrite( para1, sizeof(double), 12, fp ) != 12 ) {\n        fclose(fp);\n        return -1;\n    }\n#else\n    if( fwrite( para0, sizeof(double), 12, fp ) != 12 ) {\n        fclose(fp);\n        return -1;\n    }\n#endif\n\n    fclose(fp);\n\n    return 0;\n}\n\nint arParamLoadExt( const char *filename, ARdouble para[3][4] )\n{\n    FILE        *fp;\n    double      para0[3][4];\n#ifdef AR_LITTLE_ENDIAN\n    double      para1[3][4];\n#endif\n    int         i, j;\n\n    if (!filename || !filename[0] || !para) return (-1);\n    \n    fp = fopen( filename, \"rb\" );\n    if( fp == NULL ) {\n\t\tARLOGe(\"Error (%d): unable to open external parameters file \\\"%s\\\" for reading.\\n\", errno, filename);\n\t\tARLOGperror(NULL);\n\t\treturn -1;\n\t}\n\n#ifdef AR_LITTLE_ENDIAN\n    if( fread( para1, sizeof(double), 12, fp ) != 12 ) {\n        fclose(fp);\n        return -1;\n    }\n    for( j = 0; j < 3; j++ ) {\n        for( i = 0; i < 4; i++ ) {\n            byteSwapDouble( &(para1[j][i]), &(para0[j][i]) );\n        }\n    }\n#else\n    if( fread( para0, sizeof(double), 12, fp ) != 12 ) {\n        fclose(fp);\n        return -1;\n    }\n#endif\n    \n    for( j = 0; j < 3; j++ ) {\n        for( i = 0; i < 4; i++ ) {\n            para[j][i] = (ARdouble)(para0[j][i]);\n        }\n    }\n\n    fclose(fp);\n\n    return 0;\n}\n\nint arParamLoadExtFromBuffer( const void *buffer, size_t bufsize, ARdouble para[3][4] )\n{\n    double      para0[3][4];\n#ifdef AR_LITTLE_ENDIAN\n    double      para1[3][4];\n#endif\n    int         i, j;\n    \n    if (!buffer || bufsize != 12*sizeof(double) || !para) return (-1);\n    \n#ifdef AR_LITTLE_ENDIAN\n    memcpy(para1, buffer, 12*sizeof(double));\n    for( j = 0; j < 3; j++ ) {\n        for( i = 0; i < 4; i++ ) {\n            byteSwapDouble( &(para1[j][i]), &(para0[j][i]) );\n        }\n    }\n#else\n    memcpy(para0, buffer, 12*sizeof(double));\n#endif\n    \n    for( j = 0; j < 3; j++ ) {\n        for( i = 0; i < 4; i++ ) {\n            para[j][i] = (ARdouble)(para0[j][i]);\n        }\n    }\n    \n    return 0;\n}\n\nint arParamSaveOptical(const char *filename, const ARdouble fovy, const ARdouble aspect, const ARdouble m[16])\n{\n    FILE        *fp;\n    double      fovy0, aspect0, m0[16];\n#ifdef AR_LITTLE_ENDIAN\n\tdouble\t\tfovy1, aspect1, m1[16];\n#endif\n    int         i;\n\t\n    if (!filename || !filename[0] || !m) return (-1);\n\n    fp = fopen(filename, \"wb\");\n    if( fp == NULL ) {\n\t\tARLOGe(\"Error (%d): unable to open optical parameters file \\\"%s\\\" for writing.\\n\", errno, filename);\n\t\tARLOGperror(NULL);\n\t\treturn -1;\n\t}\n\t\n    fovy0 = (double)fovy;\n    aspect0 = (double)aspect;\n    for (i = 0; i < 16; i++) m0[i] = (double)(m[i]);\n    \n#ifdef AR_LITTLE_ENDIAN\n\tbyteSwapDouble(&fovy0, &fovy1);\n    if (fwrite(&fovy1, sizeof(double), 1, fp) != 1) {\n        goto bail;\n    }\n\tbyteSwapDouble(&aspect0, &aspect1);\n    if (fwrite(&aspect1, sizeof(double), 1, fp) != 1) {\n        goto bail;\n    }\n    for (i = 0; i < 16; i++) byteSwapDouble(&(m0[i]), &(m1[i]));\n    if (fwrite(m1, sizeof(double), 16, fp) != 16) {\n        goto bail;\n    }\n#else\n    if (fwrite(&fovy0, sizeof(double), 1, fp) != 1) {\n        goto bail;\n    }\n    if (fwrite(&aspect0, sizeof(double), 1, fp) != 1) {\n        goto bail;\n    }\n    if (fwrite(m0, sizeof(double), 16, fp) != 16) {\n        goto bail;\n    }\n#endif\n\t\n    fclose(fp);\t\n    return 0;\n\t\nbail:\n\tfclose(fp);\n\treturn -1;\n}\n\nint arParamLoadOptical(const char *filename, ARdouble *fovy_p, ARdouble *aspect_p, ARdouble m[16])\n{\n    FILE        *fp;\n\tdouble\t\tfovy0, aspect0, m0[16];\n#ifdef AR_LITTLE_ENDIAN\n\tdouble\t\tfovy1, aspect1, m1[16];\n#endif\n    int         i;\n\t\n    if (!filename || !filename[0] || !fovy_p || !aspect_p || !m) return (-1);\n\n    fp = fopen(filename, \"rb\");\n    if( fp == NULL ) {\n\t\tARLOGe(\"Error (%d): unable to open optical parameters file \\\"%s\\\" for reading.\\n\", errno, filename);\n\t\tARLOGperror(NULL);\n\t\treturn -1;\n\t}\n\t\n#ifdef AR_LITTLE_ENDIAN\n    if (fread(&fovy1, sizeof(double), 1, fp) != 1) {\n        goto bail;\n    }\n\tbyteSwapDouble(&fovy1, &fovy0);\n    if (fread(&aspect1, sizeof(double), 1, fp) != 1) {\n        goto bail;\n    }\n\tbyteSwapDouble(&aspect1, &aspect0);\n    if (fread(m1, sizeof(double), 16, fp) != 16) {\n        goto bail;\n    }\n    for (i = 0; i < 16; i++) byteSwapDouble(&(m1[i]), &(m0[i]));\n#else\n    if (fread(&fovy0, sizeof(double), 1, fp) != 1) {\n        goto bail;\n    }\n    if (fread(&aspect0, sizeof(double), 1, fp) != 1) {\n        goto bail;\n    }\n    if (fread(m0, sizeof(double), 16, fp) != 16) {\n        goto bail;\n    }\n#endif\n    \n    *fovy_p = (ARdouble)fovy0;\n    *aspect_p = (ARdouble)aspect0;\n    for (i = 0; i < 16; i++) m[i] = (ARdouble)(m0[i]);\n\t\n    fclose(fp);\n    return 0;\n\t\nbail:\n\tfclose(fp);\n\treturn -1;\n}\n\nint arParamLoadOpticalFromBuffer(const void *buffer, size_t bufsize, ARdouble *fovy_p, ARdouble *aspect_p, ARdouble m[16])\n{\n \tdouble\t\tfovy0, aspect0, m0[16];\n#ifdef AR_LITTLE_ENDIAN\n\tdouble\t\tfovy1, aspect1, m1[16];\n#endif\n    int         i;\n\t\n    if (!buffer || bufsize != 18*sizeof(double) || !fovy_p || !aspect_p || !m) return (-1);\n    \n#ifdef AR_LITTLE_ENDIAN\n    memcpy(&fovy1, (unsigned char *)buffer, sizeof(double));\n\tbyteSwapDouble(&fovy1, &fovy0);\n    memcpy(&aspect1, (unsigned char *)buffer + sizeof(double), sizeof(double));\n\tbyteSwapDouble(&aspect1, &aspect0);\n    memcpy(m1, (unsigned char *)buffer + 2*sizeof(double), 16*sizeof(double));\n    for (i = 0; i < 16; i++) byteSwapDouble(&(m1[i]), &(m0[i]));\n#else\n    memcpy(&fovy0, (unsigned char *)buffer, sizeof(double));\n    memcpy(&aspect0, (unsigned char *)buffer + sizeof(double), sizeof(double));\n    memcpy(m0, (unsigned char *)buffer + 2*sizeof(double), 16*sizeof(double));\n#endif\n    \n    *fovy_p = (ARdouble)fovy0;\n    *aspect_p = (ARdouble)aspect0;\n    for (i = 0; i < 16; i++) m[i] = (ARdouble)(m0[i]);\n\t\n    return 0;\n}\n\n","/*\n *  paramLT.c\n *  ARToolKit5\n *\n *  This file is part of ARToolKit.\n *\n *  ARToolKit is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation, either version 3 of the License, or\n *  (at your option) any later version.\n *\n *  ARToolKit is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public License\n *  along with ARToolKit.  If not, see <http://www.gnu.org/licenses/>.\n *\n *  As a special exception, the copyright holders of this library give you\n *  permission to link this library with independent modules to produce an\n *  executable, regardless of the license terms of these independent modules, and to\n *  copy and distribute the resulting executable under terms of your choice,\n *  provided that you also meet, for each linked independent module, the terms and\n *  conditions of the license of that module. An independent module is a module\n *  which is neither derived from nor based on this library. If you modify this\n *  library, you may extend this exception to your version of the library, but you\n *  are not obligated to do so. If you do not wish to do so, delete this exception\n *  statement from your version.\n *\n *  Copyright 2015 Daqri, LLC.\n *  Copyright 2013-2015 ARToolworks, Inc.\n *\n *  Author(s): Hirokazu Kato\n *\n */\n\n#include <stdio.h>\n#include <string.h>\n#include <math.h>\n#include <AR/ar.h>\n#include <AR/param.h>\n\n\nint arParamLTSave( char *filename, char *ext, ARParamLT *paramLT )\n{\n    FILE  *fp;\n    char *buf;\n    size_t len;\n\n    len = strlen(filename) + strlen(ext) + 2;\n    arMalloc(buf, char, len);\n    sprintf(buf, \"%s.%s\", filename, ext);\n    if( (fp=fopen(buf, \"wb\")) == NULL ) {\n        ARLOGe(\"Error: Unable to open file '%s' for writing.\\n\", buf);\n        free(buf);\n        return -1;\n    }\n    free(buf);\n\n    if( fwrite( paramLT, sizeof(ARParamLT), 1, fp ) != 1 ) {\n        fclose(fp);\n        return -1;\n    }\n    if( fwrite( paramLT->paramLTf.i2o, sizeof(float), paramLT->paramLTf.xsize*paramLT->paramLTf.ysize*2, fp )\n       != paramLT->paramLTf.xsize*paramLT->paramLTf.ysize*2 ) {\n        fclose(fp);\n        return -1;\n    }\n    if( fwrite( paramLT->paramLTf.o2i, sizeof(float), paramLT->paramLTf.xsize*paramLT->paramLTf.ysize*2, fp )\n       != paramLT->paramLTf.xsize*paramLT->paramLTf.ysize*2 ) {\n        fclose(fp);\n        return -1;\n    }\n    //if( fwrite( paramLT->paramLTi.i2o, sizeof(short), paramLT->paramLTi.xsize*paramLT->paramLTi.ysize*2, fp )\n    //   != paramLT->paramLTi.xsize*paramLT->paramLTi.ysize*2 ) {\n    //    fclose(fp);\n    //    return -1;\n    //}\n    //if( fwrite( paramLT->paramLTi.o2i, sizeof(short), paramLT->paramLTi.xsize*paramLT->paramLTi.ysize*2, fp )\n    //   != paramLT->paramLTi.xsize*paramLT->paramLTi.ysize*2 ) {\n    //    fclose(fp);\n    //    return -1;\n    //}\n\n    fclose(fp);\n    \n    return 0;\n}\n\nARParamLT *arParamLTLoad( char *filename, char *ext )\n{\n    FILE        *fp;\n    ARParamLT   *paramLT;\n    char *buf;\n    size_t len;\n\n    len = strlen(filename) + strlen(ext) + 2;\n    arMalloc(buf, char, len);\n    sprintf(buf, \"%s.%s\", filename, ext);\n    if( (fp=fopen(buf, \"rb\")) == NULL ) {\n        ARLOGe(\"Error: Unable to open file '%s' for reading.\\n\", buf);\n        free(buf);\n        return NULL;\n    }\n    free(buf);\n    \n    arMalloc(paramLT, ARParamLT, 1);\n    \n    if( fread( paramLT, sizeof(ARParamLT), 1, fp ) != 1 ) {\n        fclose(fp);\n        free(paramLT);\n        return NULL;\n    }\n\n    arMalloc(paramLT->paramLTf.i2o, float, paramLT->paramLTf.xsize*paramLT->paramLTf.ysize*2);\n    arMalloc(paramLT->paramLTf.o2i, float, paramLT->paramLTf.xsize*paramLT->paramLTf.ysize*2);\n    //arMalloc(paramLT->paramLTi.i2o, short, paramLT->paramLTi.xsize*paramLT->paramLTi.ysize*2);\n    //arMalloc(paramLT->paramLTi.o2i, short, paramLT->paramLTi.xsize*paramLT->paramLTi.ysize*2);\n\n    if( fread( paramLT->paramLTf.i2o, sizeof(float), paramLT->paramLTf.xsize*paramLT->paramLTf.ysize*2, fp )\n       != paramLT->paramLTf.xsize*paramLT->paramLTf.ysize*2 ) {\n        free(paramLT->paramLTf.i2o);\n        free(paramLT->paramLTf.o2i);\n        //free(paramLT->paramLTi.i2o);\n        //free(paramLT->paramLTi.o2i);\n        free(paramLT);\n        fclose(fp);\n        return NULL;\n    }\n    if( fread( paramLT->paramLTf.o2i, sizeof(float), paramLT->paramLTf.xsize*paramLT->paramLTf.ysize*2, fp )\n       != paramLT->paramLTf.xsize*paramLT->paramLTf.ysize*2 ) {\n        free(paramLT->paramLTf.i2o);\n        free(paramLT->paramLTf.o2i);\n        //free(paramLT->paramLTi.i2o);\n        //free(paramLT->paramLTi.o2i);\n        free(paramLT);\n        fclose(fp);\n        return NULL;\n    }\n    //if( fread( paramLT->paramLTi.i2o, sizeof(short), paramLT->paramLTi.xsize*paramLT->paramLTi.ysize*2, fp )\n    //   != paramLT->paramLTi.xsize*paramLT->paramLTi.ysize*2 ) {\n    //    free(paramLT->paramLTf.i2o);\n    //    free(paramLT->paramLTf.o2i);\n    //    free(paramLT->paramLTi.i2o);\n    //    free(paramLT->paramLTi.o2i);\n    //    free(paramLT);\n    //    fclose(fp);\n    //    return NULL;\n    //}\n    //if( fread( paramLT->paramLTi.o2i, sizeof(short), paramLT->paramLTi.xsize*paramLT->paramLTi.ysize*2, fp )\n    //   != paramLT->paramLTi.xsize*paramLT->paramLTi.ysize*2 ) {\n    //    free(paramLT->paramLTf.i2o);\n    //    free(paramLT->paramLTf.o2i);\n    //    free(paramLT->paramLTi.i2o);\n    //    free(paramLT->paramLTi.o2i);\n    //    free(paramLT);\n    //    fclose(fp);\n    //    return NULL;\n    //}\n    \n    fclose(fp);\n    \n    return paramLT;\n\n}\n\nARParamLT  *arParamLTCreate( ARParam *param, int offset )\n{\n    ARParamLT   *paramLT;\n    ARdouble    *dist_factor;\n    int          dist_function_version;\n    ARdouble     ix, iy;\n    ARdouble     ox, oy;\n    float       *i2of, *o2if;\n    //short       *i2oi, *o2ii;\n    int          i, j;\n    \n    arMalloc(paramLT, ARParamLT, 1);\n    paramLT->param = *param;\n    \n    paramLT->paramLTf.xsize = param->xsize + offset*2;\n    paramLT->paramLTf.ysize = param->ysize + offset*2;\n    paramLT->paramLTf.xOff = offset;\n    paramLT->paramLTf.yOff = offset;\n    arMalloc(paramLT->paramLTf.i2o, float, paramLT->paramLTf.xsize*paramLT->paramLTf.ysize*2);\n    arMalloc(paramLT->paramLTf.o2i, float, paramLT->paramLTf.xsize*paramLT->paramLTf.ysize*2);\n    \n    //paramLT->paramLTi.xsize = param->xsize + offset*2;\n    //paramLT->paramLTi.ysize = param->ysize + offset*2;\n    //paramLT->paramLTi.xOff = offset;\n    //paramLT->paramLTi.yOff = offset;\n    //arMalloc(paramLT->paramLTi.i2o, short, paramLT->paramLTi.xsize*paramLT->paramLTi.ysize*2);\n    //arMalloc(paramLT->paramLTi.o2i, short, paramLT->paramLTi.xsize*paramLT->paramLTi.ysize*2);\n    \n    dist_factor = param->dist_factor;\n    dist_function_version = param->dist_function_version;\n    i2of = paramLT->paramLTf.i2o;\n    o2if = paramLT->paramLTf.o2i;\n    //i2oi = paramLT->paramLTi.i2o;\n    //o2ii = paramLT->paramLTi.o2i;\n    for( j = 0; j < paramLT->paramLTf.ysize; j++ ) {\n        for( i = 0; i < paramLT->paramLTf.xsize; i++ ) {\n            arParamIdeal2Observ( dist_factor, (float)(i-offset), (float)(j-offset), &ox, &oy, dist_function_version);\n            *(i2of++) = (float)ox;\n            //*(i2oi++) = (int)(ox+0.5F);\n            *(i2of++) = (float)oy;\n            //*(i2oi++) = (int)(oy+0.5F);\n            arParamObserv2Ideal( dist_factor, (float)(i-offset), (float)(j-offset), &ix, &iy, dist_function_version);\n            *(o2if++) = (float)ix;\n            //*(o2ii++) = (int)(ix+0.5F);\n            *(o2if++) = (float)iy;\n            //*(o2ii++) = (int)(iy+0.5F);\n        }\n    }\n    \n    return paramLT;\n}\n\nint arParamLTFree( ARParamLT **paramLT_p )\n{\n    if (!paramLT_p || !(*paramLT_p)) return (-1);\n    \n    free((*paramLT_p)->paramLTf.i2o);\n    free((*paramLT_p)->paramLTf.o2i);\n    //free((*paramLT_p)->paramLTi.i2o);\n    //free((*paramLT_p)->paramLTi.o2i);\n    free(*paramLT_p);\n    *paramLT_p = NULL;\n    return 0;\n}\n\n/*\nint arParamIdeal2ObservLTi( const ARParamLTi *paramLTi, const int    ix, const int    iy, int    *ox, int    *oy)\n{\n    int      px, py;\n    short   *lt;\n    \n    px = ix + paramLTi->xOff;\n    py = iy + paramLTi->yOff;\n    if( px < 0 || px >= paramLTi->xsize ||\n        py < 0 || py >= paramLTi->ysize ) return -1;\n    \n    lt = paramLTi->i2o+ (py*paramLTi->xsize + px)*2;\n    *ox = *(lt++);\n    *oy = *lt;\n    return 0;\n}\n*/\n\nint arParamIdeal2ObservLTf( const ARParamLTf *paramLTf, const float  ix, const float  iy, float  *ox, float  *oy)\n{\n    int      px, py;\n    float   *lt;\n    \n    px = (int)(ix+0.5F) + paramLTf->xOff;\n    py = (int)(iy+0.5F) + paramLTf->yOff;\n    if( px < 0 || px >= paramLTf->xsize ||\n        py < 0 || py >= paramLTf->ysize ) return -1;\n    \n    lt = paramLTf->i2o+ (py*paramLTf->xsize + px)*2;\n    *ox = *(lt++);\n    *oy = *lt;\n    return 0;\n}\n\n/*\nint arParamObserv2IdealLTi( const ARParamLTi *paramLTi, const int    ox, const int    oy, int    *ix, int    *iy)\n{\n    int      px, py;\n    short   *lt;\n    \n    px = ox + paramLTi->xOff;\n    py = oy + paramLTi->yOff;\n    if( px < 0 || px >= paramLTi->xsize ||\n        py < 0 || py >= paramLTi->ysize ) return -1;\n\n    lt = paramLTi->o2i+ (py*paramLTi->xsize + px)*2;\n    *ix = *(lt++);\n    *iy = *lt;\n    return 0;\n}\n*/\n\nint arParamObserv2IdealLTf( const ARParamLTf *paramLTf, const float  ox, const float  oy, float  *ix, float  *iy)\n{\n    int      px, py;\n    float   *lt;\n    \n    px = (int)(ox+0.5F) + paramLTf->xOff;\n    py = (int)(oy+0.5F) + paramLTf->yOff;\n    if( px < 0 || px >= paramLTf->xsize ||\n        py < 0 || py >= paramLTf->ysize ) return -1;\n    \n    lt = paramLTf->o2i+ (py*paramLTf->xsize + px)*2;\n    *ix = *(lt++);\n    *iy = *lt;\n    return 0;\n}\n\n","// -*- C++ -*-\n//===-------------------------- locale ------------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_LOCALE\n#define _LIBCPP_LOCALE\n\n/*\n    locale synopsis\n\nnamespace std\n{\n\nclass locale\n{\npublic:\n    // types:\n    class facet;\n    class id;\n\n    typedef int category;\n    static const category // values assigned here are for exposition only\n        none     = 0x000,\n        collate  = 0x010,\n        ctype    = 0x020,\n        monetary = 0x040,\n        numeric  = 0x080,\n        time     = 0x100,\n        messages = 0x200,\n        all = collate | ctype | monetary | numeric | time | messages;\n\n    // construct/copy/destroy:\n    locale() noexcept;\n    locale(const locale& other) noexcept;\n    explicit locale(const char* std_name);\n    explicit locale(const string& std_name);\n    locale(const locale& other, const char* std_name, category);\n    locale(const locale& other, const string& std_name, category);\n    template <class Facet> locale(const locale& other, Facet* f);\n    locale(const locale& other, const locale& one, category);\n\n    ~locale(); // not virtual\n\n    const locale& operator=(const locale& other) noexcept;\n\n    template <class Facet> locale combine(const locale& other) const;\n\n    // locale operations:\n    basic_string<char> name() const;\n    bool operator==(const locale& other) const;\n    bool operator!=(const locale& other) const;\n    template <class charT, class Traits, class Allocator>\n      bool operator()(const basic_string<charT,Traits,Allocator>& s1,\n                      const basic_string<charT,Traits,Allocator>& s2) const;\n\n    // global locale objects:\n    static locale global(const locale&);\n    static const locale& classic();\n};\n\ntemplate <class Facet> const Facet& use_facet(const locale&);\ntemplate <class Facet> bool has_facet(const locale&) noexcept;\n\n// 22.3.3, convenience interfaces:\ntemplate <class charT> bool isspace (charT c, const locale& loc);\ntemplate <class charT> bool isprint (charT c, const locale& loc);\ntemplate <class charT> bool iscntrl (charT c, const locale& loc);\ntemplate <class charT> bool isupper (charT c, const locale& loc);\ntemplate <class charT> bool islower (charT c, const locale& loc);\ntemplate <class charT> bool isalpha (charT c, const locale& loc);\ntemplate <class charT> bool isdigit (charT c, const locale& loc);\ntemplate <class charT> bool ispunct (charT c, const locale& loc);\ntemplate <class charT> bool isxdigit(charT c, const locale& loc);\ntemplate <class charT> bool isalnum (charT c, const locale& loc);\ntemplate <class charT> bool isgraph (charT c, const locale& loc);\ntemplate <class charT> charT toupper(charT c, const locale& loc);\ntemplate <class charT> charT tolower(charT c, const locale& loc);\n\ntemplate<class Codecvt, class Elem = wchar_t,\n         class Wide_alloc = allocator<Elem>,\n         class Byte_alloc = allocator<char>>\nclass wstring_convert\n{\npublic:\n    typedef basic_string<char, char_traits<char>, Byte_alloc> byte_string;\n    typedef basic_string<Elem, char_traits<Elem>, Wide_alloc> wide_string;\n    typedef typename Codecvt::state_type                      state_type;\n    typedef typename wide_string::traits_type::int_type       int_type;\n\n    explicit wstring_convert(Codecvt* pcvt = new Codecvt);          // explicit in C++14\n    wstring_convert(Codecvt* pcvt, state_type state);\n    explicit wstring_convert(const byte_string& byte_err,           // explicit in C++14\n                    const wide_string& wide_err = wide_string());\n    wstring_convert(const wstring_convert&) = delete;               // C++14\n    wstring_convert & operator=(const wstring_convert &) = delete;  // C++14\n    ~wstring_convert();\n\n    wide_string from_bytes(char byte);\n    wide_string from_bytes(const char* ptr);\n    wide_string from_bytes(const byte_string& str);\n    wide_string from_bytes(const char* first, const char* last);\n\n    byte_string to_bytes(Elem wchar);\n    byte_string to_bytes(const Elem* wptr);\n    byte_string to_bytes(const wide_string& wstr);\n    byte_string to_bytes(const Elem* first, const Elem* last);\n\n    size_t converted() const; // noexcept in C++14\n    state_type state() const;\n};\n\ntemplate <class Codecvt, class Elem = wchar_t, class Tr = char_traits<Elem>>\nclass wbuffer_convert\n    : public basic_streambuf<Elem, Tr>\n{\npublic:\n    typedef typename Tr::state_type state_type;\n\n    explicit wbuffer_convert(streambuf* bytebuf = 0, Codecvt* pcvt = new Codecvt,\n                    state_type state = state_type());       // explicit in C++14\n    wbuffer_convert(const wbuffer_convert&) = delete;               // C++14\n    wbuffer_convert & operator=(const wbuffer_convert &) = delete;  // C++14\n    ~wbuffer_convert();                                             // C++14\n    \n    streambuf* rdbuf() const;\n    streambuf* rdbuf(streambuf* bytebuf);\n\n    state_type state() const;\n};\n\n// 22.4.1 and 22.4.1.3, ctype:\nclass ctype_base;\ntemplate <class charT> class ctype;\ntemplate <> class ctype<char>; // specialization\ntemplate <class charT> class ctype_byname;\ntemplate <> class ctype_byname<char>; // specialization\n\nclass codecvt_base;\ntemplate <class internT, class externT, class stateT> class codecvt;\ntemplate <class internT, class externT, class stateT> class codecvt_byname;\n\n// 22.4.2 and 22.4.3, numeric:\ntemplate <class charT, class InputIterator> class num_get;\ntemplate <class charT, class OutputIterator> class num_put;\ntemplate <class charT> class numpunct;\ntemplate <class charT> class numpunct_byname;\n\n// 22.4.4, col lation:\ntemplate <class charT> class collate;\ntemplate <class charT> class collate_byname;\n\n// 22.4.5, date and time:\nclass time_base;\ntemplate <class charT, class InputIterator> class time_get;\ntemplate <class charT, class InputIterator> class time_get_byname;\ntemplate <class charT, class OutputIterator> class time_put;\ntemplate <class charT, class OutputIterator> class time_put_byname;\n\n// 22.4.6, money:\nclass money_base;\ntemplate <class charT, class InputIterator> class money_get;\ntemplate <class charT, class OutputIterator> class money_put;\ntemplate <class charT, bool Intl> class moneypunct;\ntemplate <class charT, bool Intl> class moneypunct_byname;\n\n// 22.4.7, message retrieval:\nclass messages_base;\ntemplate <class charT> class messages;\ntemplate <class charT> class messages_byname;\n\n}  // std\n\n*/\n\n#include <__config>\n#include <__locale>\n#include <__debug>\n#include <algorithm>\n#include <memory>\n#include <ios>\n#include <streambuf>\n#include <iterator>\n#include <limits>\n#ifndef __APPLE__\n#include <cstdarg>\n#endif\n#include <cstdlib>\n#include <ctime>\n#if defined(_LIBCPP_MSVCRT) || defined(__MINGW32__)\n#include <support/win32/locale_win32.h>\n#elif defined(_NEWLIB_VERSION)\n// FIXME: replace all the uses of _NEWLIB_VERSION with __NEWLIB__ preceded by an\n// include of <sys/cdefs.h> once https://sourceware.org/ml/newlib-cvs/2014-q3/msg00038.html\n// has had a chance to bake for a bit\n#include <support/newlib/xlocale.h>\n#endif\n#ifdef _LIBCPP_HAS_CATOPEN\n#include <nl_types.h>\n#endif\n\n#ifdef __APPLE__\n#include <Availability.h>\n#endif\n\n#include <__undef_min_max>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n#ifdef _LIBCPP_LOCALE__L_EXTENSIONS\n#include <__bsd_locale_defaults.h>\n#else\n#include <__bsd_locale_fallbacks.h>\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\n#if defined(__APPLE__) || defined(__FreeBSD__)\n#  define _LIBCPP_GET_C_LOCALE 0\n#elif defined(__CloudABI__) || defined(__NetBSD__)\n#  define _LIBCPP_GET_C_LOCALE LC_C_LOCALE\n#else\n#  define _LIBCPP_GET_C_LOCALE __cloc()\n   // Get the C locale object\n   _LIBCPP_FUNC_VIS locale_t __cloc();\n#define __cloc_defined\n#endif\n\ntypedef _VSTD::remove_pointer<locale_t>::type __locale_struct;\ntypedef _VSTD::unique_ptr<__locale_struct, decltype(&freelocale)> __locale_unique_ptr;\n\n// __scan_keyword\n// Scans [__b, __e) until a match is found in the basic_strings range\n//  [__kb, __ke) or until it can be shown that there is no match in [__kb, __ke).\n//  __b will be incremented (visibly), consuming CharT until a match is found\n//  or proved to not exist.  A keyword may be \"\", in which will match anything.\n//  If one keyword is a prefix of another, and the next CharT in the input\n//  might match another keyword, the algorithm will attempt to find the longest\n//  matching keyword.  If the longer matching keyword ends up not matching, then\n//  no keyword match is found.  If no keyword match is found, __ke is returned\n//  and failbit is set in __err.\n//  Else an iterator pointing to the matching keyword is found.  If more than\n//  one keyword matches, an iterator to the first matching keyword is returned.\n//  If on exit __b == __e, eofbit is set in __err.  If __case_sensitive is false,\n//  __ct is used to force to lower case before comparing characters.\n//  Examples:\n//  Keywords:  \"a\", \"abb\"\n//  If the input is \"a\", the first keyword matches and eofbit is set.\n//  If the input is \"abc\", no match is found and \"ab\" are consumed.\ntemplate <class _InputIterator, class _ForwardIterator, class _Ctype>\n_LIBCPP_HIDDEN\n_ForwardIterator\n__scan_keyword(_InputIterator& __b, _InputIterator __e,\n               _ForwardIterator __kb, _ForwardIterator __ke,\n               const _Ctype& __ct, ios_base::iostate& __err,\n               bool __case_sensitive = true)\n{\n    typedef typename iterator_traits<_InputIterator>::value_type _CharT;\n    size_t __nkw = static_cast<size_t>(_VSTD::distance(__kb, __ke));\n    const unsigned char __doesnt_match = '\\0';\n    const unsigned char __might_match = '\\1';\n    const unsigned char __does_match = '\\2';\n    unsigned char __statbuf[100];\n    unsigned char* __status = __statbuf;\n    unique_ptr<unsigned char, void(*)(void*)> __stat_hold(0, free);\n    if (__nkw > sizeof(__statbuf))\n    {\n        __status = (unsigned char*)malloc(__nkw);\n        if (__status == 0)\n            __throw_bad_alloc();\n        __stat_hold.reset(__status);\n    }\n    size_t __n_might_match = __nkw;  // At this point, any keyword might match\n    size_t __n_does_match = 0;       // but none of them definitely do\n    // Initialize all statuses to __might_match, except for \"\" keywords are __does_match\n    unsigned char* __st = __status;\n    for (_ForwardIterator __ky = __kb; __ky != __ke; ++__ky, (void) ++__st)\n    {\n        if (!__ky->empty())\n            *__st = __might_match;\n        else\n        {\n            *__st = __does_match;\n            --__n_might_match;\n            ++__n_does_match;\n        }\n    }\n    // While there might be a match, test keywords against the next CharT\n    for (size_t __indx = 0; __b != __e && __n_might_match > 0; ++__indx)\n    {\n        // Peek at the next CharT but don't consume it\n        _CharT __c = *__b;\n        if (!__case_sensitive)\n            __c = __ct.toupper(__c);\n        bool __consume = false;\n        // For each keyword which might match, see if the __indx character is __c\n        // If a match if found, consume __c\n        // If a match is found, and that is the last character in the keyword,\n        //    then that keyword matches.\n        // If the keyword doesn't match this character, then change the keyword\n        //    to doesn't match\n        __st = __status;\n        for (_ForwardIterator __ky = __kb; __ky != __ke; ++__ky, (void) ++__st)\n        {\n            if (*__st == __might_match)\n            {\n                _CharT __kc = (*__ky)[__indx];\n                if (!__case_sensitive)\n                    __kc = __ct.toupper(__kc);\n                if (__c == __kc)\n                {\n                    __consume = true;\n                    if (__ky->size() == __indx+1)\n                    {\n                        *__st = __does_match;\n                        --__n_might_match;\n                        ++__n_does_match;\n                    }\n                }\n                else\n                {\n                    *__st = __doesnt_match;\n                    --__n_might_match;\n                }\n            }\n        }\n        // consume if we matched a character\n        if (__consume)\n        {\n            ++__b;\n            // If we consumed a character and there might be a matched keyword that\n            //   was marked matched on a previous iteration, then such keywords\n            //   which are now marked as not matching.\n            if (__n_might_match + __n_does_match > 1)\n            {\n                __st = __status;\n                for (_ForwardIterator __ky = __kb; __ky != __ke; ++__ky, (void) ++__st)\n                {\n                    if (*__st == __does_match && __ky->size() != __indx+1)\n                    {\n                        *__st = __doesnt_match;\n                        --__n_does_match;\n                    }\n                }\n            }\n        }\n    }\n    // We've exited the loop because we hit eof and/or we have no more \"might matches\".\n    if (__b == __e)\n        __err |= ios_base::eofbit;\n    // Return the first matching result\n    for (__st = __status; __kb != __ke; ++__kb, (void) ++__st)\n        if (*__st == __does_match)\n            break;\n    if (__kb == __ke)\n        __err |= ios_base::failbit;\n    return __kb;\n}\n\nstruct _LIBCPP_TYPE_VIS __num_get_base\n{\n    static const int __num_get_buf_sz = 40;\n\n    static int __get_base(ios_base&);\n    static const char __src[33];\n};\n\n_LIBCPP_FUNC_VIS\nvoid __check_grouping(const string& __grouping, unsigned* __g, unsigned* __g_end,\n                      ios_base::iostate& __err);\n\ntemplate <class _CharT>\nstruct __num_get\n    : protected __num_get_base\n{\n    static string __stage2_int_prep(ios_base& __iob, _CharT* __atoms, _CharT& __thousands_sep);\n    static string __stage2_float_prep(ios_base& __iob, _CharT* __atoms, _CharT& __decimal_point,\n                                      _CharT& __thousands_sep);\n    static int __stage2_int_loop(_CharT __ct, int __base, char* __a, char*& __a_end,\n                  unsigned& __dc, _CharT __thousands_sep, const string& __grouping,\n                  unsigned* __g, unsigned*& __g_end, _CharT* __atoms);\n    static int __stage2_float_loop(_CharT __ct, bool& __in_units, char& __exp,\n                                   char* __a, char*& __a_end,\n                                   _CharT __decimal_point, _CharT __thousands_sep,\n                                   const string& __grouping, unsigned* __g,\n                                   unsigned*& __g_end, unsigned& __dc, _CharT* __atoms);\n};\n\ntemplate <class _CharT>\nstring\n__num_get<_CharT>::__stage2_int_prep(ios_base& __iob, _CharT* __atoms, _CharT& __thousands_sep)\n{\n    locale __loc = __iob.getloc();\n    use_facet<ctype<_CharT> >(__loc).widen(__src, __src + 26, __atoms);\n    const numpunct<_CharT>& __np = use_facet<numpunct<_CharT> >(__loc);\n    __thousands_sep = __np.thousands_sep();\n    return __np.grouping();\n}\n\ntemplate <class _CharT>\nstring\n__num_get<_CharT>::__stage2_float_prep(ios_base& __iob, _CharT* __atoms, _CharT& __decimal_point,\n                    _CharT& __thousands_sep)\n{\n    locale __loc = __iob.getloc();\n    use_facet<ctype<_CharT> >(__loc).widen(__src, __src + 32, __atoms);\n    const numpunct<_CharT>& __np = use_facet<numpunct<_CharT> >(__loc);\n    __decimal_point = __np.decimal_point();\n    __thousands_sep = __np.thousands_sep();\n    return __np.grouping();\n}\n\ntemplate <class _CharT>\nint\n__num_get<_CharT>::__stage2_int_loop(_CharT __ct, int __base, char* __a, char*& __a_end,\n                  unsigned& __dc, _CharT __thousands_sep, const string& __grouping,\n                  unsigned* __g, unsigned*& __g_end, _CharT* __atoms)\n{\n    if (__a_end == __a && (__ct == __atoms[24] || __ct == __atoms[25]))\n    {\n        *__a_end++ = __ct == __atoms[24] ? '+' : '-';\n        __dc = 0;\n        return 0;\n    }\n    if (__grouping.size() != 0 && __ct == __thousands_sep)\n    {\n        if (__g_end-__g < __num_get_buf_sz)\n        {\n            *__g_end++ = __dc;\n            __dc = 0;\n        }\n        return 0;\n    }\n    ptrdiff_t __f = find(__atoms, __atoms + 26, __ct) - __atoms;\n    if (__f >= 24)\n        return -1;\n    switch (__base)\n    {\n    case 8:\n    case 10:\n        if (__f >= __base)\n            return -1;\n        break;\n    case 16:\n        if (__f < 22)\n            break;\n        if (__a_end != __a && __a_end - __a <= 2 && __a_end[-1] == '0')\n        {\n            __dc = 0;\n            *__a_end++ = __src[__f];\n            return 0;\n        }\n        return -1;\n    }\n    *__a_end++ = __src[__f];\n    ++__dc;\n    return 0;\n}\n\ntemplate <class _CharT>\nint\n__num_get<_CharT>::__stage2_float_loop(_CharT __ct, bool& __in_units, char& __exp, char* __a, char*& __a_end,\n                    _CharT __decimal_point, _CharT __thousands_sep, const string& __grouping,\n                    unsigned* __g, unsigned*& __g_end, unsigned& __dc, _CharT* __atoms)\n{\n    if (__ct == __decimal_point)\n    {\n        if (!__in_units)\n            return -1;\n        __in_units = false;\n        *__a_end++ = '.';\n        if (__grouping.size() != 0 && __g_end-__g < __num_get_buf_sz)\n            *__g_end++ = __dc;\n        return 0;\n    }\n    if (__ct == __thousands_sep && __grouping.size() != 0)\n    {\n        if (!__in_units)\n            return -1;\n        if (__g_end-__g < __num_get_buf_sz)\n        {\n            *__g_end++ = __dc;\n            __dc = 0;\n        }\n        return 0;\n    }\n    ptrdiff_t __f = find(__atoms, __atoms + 32, __ct) - __atoms;\n    if (__f >= 32)\n        return -1;\n    char __x = __src[__f];\n    if (__x == '-' || __x == '+')\n    {\n        if (__a_end == __a || (__a_end[-1] & 0x5F) == (__exp & 0x7F))\n        {\n            *__a_end++ = __x;\n            return 0;\n        }\n        return -1;\n    }\n    if (__x == 'x' || __x == 'X')\n        __exp = 'P';\n    else if ((__x & 0x5F) == __exp)\n    {\n        __exp |= 0x80;\n        if (__in_units)\n        {\n            __in_units = false;\n            if (__grouping.size() != 0 && __g_end-__g < __num_get_buf_sz)\n                *__g_end++ = __dc;\n        }\n    }\n    *__a_end++ = __x;\n    if (__f >= 22)\n        return 0;\n    ++__dc;\n    return 0;\n}\n\n_LIBCPP_EXTERN_TEMPLATE2(struct _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS __num_get<char>)\n_LIBCPP_EXTERN_TEMPLATE2(struct _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS __num_get<wchar_t>)\n\ntemplate <class _CharT, class _InputIterator = istreambuf_iterator<_CharT> >\nclass _LIBCPP_TEMPLATE_VIS num_get\n    : public locale::facet,\n      private __num_get<_CharT>\n{\npublic:\n    typedef _CharT char_type;\n    typedef _InputIterator iter_type;\n\n    _LIBCPP_ALWAYS_INLINE\n    explicit num_get(size_t __refs = 0)\n        : locale::facet(__refs) {}\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,\n                  ios_base::iostate& __err, bool& __v) const\n    {\n        return do_get(__b, __e, __iob, __err, __v);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,\n                  ios_base::iostate& __err, long& __v) const\n    {\n        return do_get(__b, __e, __iob, __err, __v);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,\n                  ios_base::iostate& __err, long long& __v) const\n    {\n        return do_get(__b, __e, __iob, __err, __v);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,\n                  ios_base::iostate& __err, unsigned short& __v) const\n    {\n        return do_get(__b, __e, __iob, __err, __v);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,\n                  ios_base::iostate& __err, unsigned int& __v) const\n    {\n        return do_get(__b, __e, __iob, __err, __v);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,\n                  ios_base::iostate& __err, unsigned long& __v) const\n    {\n        return do_get(__b, __e, __iob, __err, __v);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,\n                  ios_base::iostate& __err, unsigned long long& __v) const\n    {\n        return do_get(__b, __e, __iob, __err, __v);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,\n                  ios_base::iostate& __err, float& __v) const\n    {\n        return do_get(__b, __e, __iob, __err, __v);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,\n                  ios_base::iostate& __err, double& __v) const\n    {\n        return do_get(__b, __e, __iob, __err, __v);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,\n                  ios_base::iostate& __err, long double& __v) const\n    {\n        return do_get(__b, __e, __iob, __err, __v);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,\n                  ios_base::iostate& __err, void*& __v) const\n    {\n        return do_get(__b, __e, __iob, __err, __v);\n    }\n\n    static locale::id id;\n\nprotected:\n    _LIBCPP_ALWAYS_INLINE\n    ~num_get() {}\n\n    template <class _Fp>\n    iter_type __do_get_floating_point\n                            (iter_type __b, iter_type __e, ios_base& __iob,\n                             ios_base::iostate& __err, _Fp& __v) const;\n\n    template <class _Signed>\n    iter_type __do_get_signed\n                            (iter_type __b, iter_type __e, ios_base& __iob,\n                             ios_base::iostate& __err, _Signed& __v) const;\n\n    template <class _Unsigned>\n    iter_type __do_get_unsigned\n                            (iter_type __b, iter_type __e, ios_base& __iob,\n                             ios_base::iostate& __err, _Unsigned& __v) const;\n\n\n    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,\n                             ios_base::iostate& __err, bool& __v) const;\n\n    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,\n                             ios_base::iostate& __err, long& __v) const\n    { return this->__do_get_signed ( __b, __e, __iob, __err, __v ); }\n\n    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,\n                             ios_base::iostate& __err, long long& __v) const\n    { return this->__do_get_signed ( __b, __e, __iob, __err, __v ); }\n\n    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,\n                             ios_base::iostate& __err, unsigned short& __v) const\n    { return this->__do_get_unsigned ( __b, __e, __iob, __err, __v ); }\n\n    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,\n                             ios_base::iostate& __err, unsigned int& __v) const\n    { return this->__do_get_unsigned ( __b, __e, __iob, __err, __v ); }\n\n    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,\n                             ios_base::iostate& __err, unsigned long& __v) const\n    { return this->__do_get_unsigned ( __b, __e, __iob, __err, __v ); }\n\n    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,\n                             ios_base::iostate& __err, unsigned long long& __v) const\n    { return this->__do_get_unsigned ( __b, __e, __iob, __err, __v ); }\n\n    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,\n                             ios_base::iostate& __err, float& __v) const\n    { return this->__do_get_floating_point ( __b, __e, __iob, __err, __v ); }\n\n    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,\n                             ios_base::iostate& __err, double& __v) const\n    { return this->__do_get_floating_point ( __b, __e, __iob, __err, __v ); }\n\n    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,\n                             ios_base::iostate& __err, long double& __v) const\n    { return this->__do_get_floating_point ( __b, __e, __iob, __err, __v ); }\n\n    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,\n                             ios_base::iostate& __err, void*& __v) const;\n};\n\ntemplate <class _CharT, class _InputIterator>\nlocale::id\nnum_get<_CharT, _InputIterator>::id;\n\ntemplate <class _Tp>\n_Tp\n__num_get_signed_integral(const char* __a, const char* __a_end,\n                          ios_base::iostate& __err, int __base)\n{\n    if (__a != __a_end)\n    {\n        typename remove_reference<decltype(errno)>::type __save_errno = errno;\n        errno = 0;\n        char *__p2;\n        long long __ll = strtoll_l(__a, &__p2, __base, _LIBCPP_GET_C_LOCALE);\n        typename remove_reference<decltype(errno)>::type __current_errno = errno;\n        if (__current_errno == 0)\n            errno = __save_errno;\n        if (__p2 != __a_end)\n        {\n            __err = ios_base::failbit;\n            return 0;\n        }\n        else if (__current_errno == ERANGE         ||\n                 __ll < numeric_limits<_Tp>::min() ||\n                 numeric_limits<_Tp>::max() < __ll)\n        {\n            __err = ios_base::failbit;\n            if (__ll > 0)\n                return numeric_limits<_Tp>::max();\n            else\n                return numeric_limits<_Tp>::min();\n        }\n        return static_cast<_Tp>(__ll);\n    }\n    __err = ios_base::failbit;\n    return 0;\n}\n\ntemplate <class _Tp>\n_Tp\n__num_get_unsigned_integral(const char* __a, const char* __a_end,\n                            ios_base::iostate& __err, int __base)\n{\n    if (__a != __a_end)\n    {\n        if (*__a == '-')\n        {\n            __err = ios_base::failbit;\n            return 0;\n        }\n        typename remove_reference<decltype(errno)>::type __save_errno = errno;\n        errno = 0;\n        char *__p2;\n        unsigned long long __ll = strtoull_l(__a, &__p2, __base, _LIBCPP_GET_C_LOCALE);\n        typename remove_reference<decltype(errno)>::type __current_errno = errno;\n        if (__current_errno == 0)\n            errno = __save_errno;\n        if (__p2 != __a_end)\n        {\n            __err = ios_base::failbit;\n            return 0;\n        }\n        else if (__current_errno == ERANGE ||\n                 numeric_limits<_Tp>::max() < __ll)\n        {\n            __err = ios_base::failbit;\n            return numeric_limits<_Tp>::max();\n        }\n        return static_cast<_Tp>(__ll);\n    }\n    __err = ios_base::failbit;\n    return 0;\n}\n\ntemplate <class _Tp>\n_LIBCPP_INLINE_VISIBILITY\n_Tp __do_strtod(const char* __a, char** __p2);\n\ntemplate <>\ninline _LIBCPP_INLINE_VISIBILITY\nfloat __do_strtod<float>(const char* __a, char** __p2) {\n    return strtof_l(__a, __p2, _LIBCPP_GET_C_LOCALE);\n}\n\ntemplate <>\ninline _LIBCPP_INLINE_VISIBILITY\ndouble __do_strtod<double>(const char* __a, char** __p2) {\n    return strtod_l(__a, __p2, _LIBCPP_GET_C_LOCALE);\n}\n\ntemplate <>\ninline _LIBCPP_INLINE_VISIBILITY\nlong double __do_strtod<long double>(const char* __a, char** __p2) {\n    return strtold_l(__a, __p2, _LIBCPP_GET_C_LOCALE);\n}\n\ntemplate <class _Tp>\n_LIBCPP_HIDDEN\n_Tp\n__num_get_float(const char* __a, const char* __a_end, ios_base::iostate& __err)\n{\n    if (__a != __a_end)\n    {\n        typename remove_reference<decltype(errno)>::type __save_errno = errno;\n        errno = 0;\n        char *__p2;\n        _Tp __ld = __do_strtod<_Tp>(__a, &__p2);\n        typename remove_reference<decltype(errno)>::type __current_errno = errno;\n        if (__current_errno == 0)\n            errno = __save_errno;\n        if (__p2 != __a_end)\n        {\n            __err = ios_base::failbit;\n            return 0;\n        }\n        else if (__current_errno == ERANGE)\n            __err = ios_base::failbit;\n        return __ld;\n    }\n    __err = ios_base::failbit;\n    return 0;\n}\n\ntemplate <class _CharT, class _InputIterator>\n_InputIterator\nnum_get<_CharT, _InputIterator>::do_get(iter_type __b, iter_type __e,\n                                        ios_base& __iob,\n                                        ios_base::iostate& __err,\n                                        bool& __v) const\n{\n    if ((__iob.flags() & ios_base::boolalpha) == 0)\n    {\n        long __lv = -1;\n        __b = do_get(__b, __e, __iob, __err, __lv);\n        switch (__lv)\n        {\n        case 0:\n            __v = false;\n            break;\n        case 1:\n            __v = true;\n            break;\n        default:\n            __v = true;\n            __err = ios_base::failbit;\n            break;\n        }\n        return __b;\n    }\n    const ctype<_CharT>& __ct = use_facet<ctype<_CharT> >(__iob.getloc());\n    const numpunct<_CharT>& __np = use_facet<numpunct<_CharT> >(__iob.getloc());\n    typedef typename numpunct<_CharT>::string_type string_type;\n    const string_type __names[2] = {__np.truename(), __np.falsename()};\n    const string_type* __i = __scan_keyword(__b, __e, __names, __names+2,\n                                            __ct, __err);\n    __v = __i == __names;\n    return __b;\n}\n\n// signed\n\ntemplate <class _CharT, class _InputIterator>\ntemplate <class _Signed>\n_InputIterator\nnum_get<_CharT, _InputIterator>::__do_get_signed(iter_type __b, iter_type __e,\n                                        ios_base& __iob,\n                                        ios_base::iostate& __err,\n                                        _Signed& __v) const\n{\n    // Stage 1\n    int __base = this->__get_base(__iob);\n    // Stage 2\n    char_type __atoms[26];\n    char_type __thousands_sep;\n    string __grouping = this->__stage2_int_prep(__iob, __atoms, __thousands_sep);\n    string __buf;\n    __buf.resize(__buf.capacity());\n    char* __a = &__buf[0];\n    char* __a_end = __a;\n    unsigned __g[__num_get_base::__num_get_buf_sz];\n    unsigned* __g_end = __g;\n    unsigned __dc = 0;\n    for (; __b != __e; ++__b)\n    {\n        if (__a_end == __a + __buf.size())\n        {\n            size_t __tmp = __buf.size();\n            __buf.resize(2*__buf.size());\n            __buf.resize(__buf.capacity());\n            __a = &__buf[0];\n            __a_end = __a + __tmp;\n        }\n        if (this->__stage2_int_loop(*__b, __base, __a, __a_end, __dc,\n                                    __thousands_sep, __grouping, __g, __g_end,\n                                    __atoms))\n            break;\n    }\n    if (__grouping.size() != 0 && __g_end-__g < __num_get_base::__num_get_buf_sz)\n        *__g_end++ = __dc;\n    // Stage 3\n    __v = __num_get_signed_integral<_Signed>(__a, __a_end, __err, __base);\n    // Digit grouping checked\n    __check_grouping(__grouping, __g, __g_end, __err);\n    // EOF checked\n    if (__b == __e)\n        __err |= ios_base::eofbit;\n    return __b;\n}\n\n// unsigned\n\ntemplate <class _CharT, class _InputIterator>\ntemplate <class _Unsigned>\n_InputIterator\nnum_get<_CharT, _InputIterator>::__do_get_unsigned(iter_type __b, iter_type __e,\n                                        ios_base& __iob,\n                                        ios_base::iostate& __err,\n                                        _Unsigned& __v) const\n{\n    // Stage 1\n    int __base = this->__get_base(__iob);\n    // Stage 2\n    char_type __atoms[26];\n    char_type __thousands_sep;\n    string __grouping = this->__stage2_int_prep(__iob, __atoms, __thousands_sep);\n    string __buf;\n    __buf.resize(__buf.capacity());\n    char* __a = &__buf[0];\n    char* __a_end = __a;\n    unsigned __g[__num_get_base::__num_get_buf_sz];\n    unsigned* __g_end = __g;\n    unsigned __dc = 0;\n    for (; __b != __e; ++__b)\n    {\n        if (__a_end == __a + __buf.size())\n        {\n            size_t __tmp = __buf.size();\n            __buf.resize(2*__buf.size());\n            __buf.resize(__buf.capacity());\n            __a = &__buf[0];\n            __a_end = __a + __tmp;\n        }\n        if (this->__stage2_int_loop(*__b, __base, __a, __a_end, __dc,\n                                    __thousands_sep, __grouping, __g, __g_end,\n                                    __atoms))\n            break;\n    }\n    if (__grouping.size() != 0 && __g_end-__g < __num_get_base::__num_get_buf_sz)\n        *__g_end++ = __dc;\n    // Stage 3\n    __v = __num_get_unsigned_integral<_Unsigned>(__a, __a_end, __err, __base);\n    // Digit grouping checked\n    __check_grouping(__grouping, __g, __g_end, __err);\n    // EOF checked\n    if (__b == __e)\n        __err |= ios_base::eofbit;\n    return __b;\n}\n\n// floating point\n\ntemplate <class _CharT, class _InputIterator>\ntemplate <class _Fp>\n_InputIterator\nnum_get<_CharT, _InputIterator>::__do_get_floating_point(iter_type __b, iter_type __e,\n                                        ios_base& __iob,\n                                        ios_base::iostate& __err,\n                                        _Fp& __v) const\n{\n    // Stage 1, nothing to do\n    // Stage 2\n    char_type __atoms[32];\n    char_type __decimal_point;\n    char_type __thousands_sep;\n    string __grouping = this->__stage2_float_prep(__iob, __atoms,\n                                                  __decimal_point,\n                                                  __thousands_sep);\n    string __buf;\n    __buf.resize(__buf.capacity());\n    char* __a = &__buf[0];\n    char* __a_end = __a;\n    unsigned __g[__num_get_base::__num_get_buf_sz];\n    unsigned* __g_end = __g;\n    unsigned __dc = 0;\n    bool __in_units = true;\n    char __exp = 'E';\n    for (; __b != __e; ++__b)\n    {\n        if (__a_end == __a + __buf.size())\n        {\n            size_t __tmp = __buf.size();\n            __buf.resize(2*__buf.size());\n            __buf.resize(__buf.capacity());\n            __a = &__buf[0];\n            __a_end = __a + __tmp;\n        }\n        if (this->__stage2_float_loop(*__b, __in_units, __exp, __a, __a_end,\n                                      __decimal_point, __thousands_sep,\n                                      __grouping, __g, __g_end,\n                                      __dc, __atoms))\n            break;\n    }\n    if (__grouping.size() != 0 && __in_units && __g_end-__g < __num_get_base::__num_get_buf_sz)\n        *__g_end++ = __dc;\n    // Stage 3\n    __v = __num_get_float<_Fp>(__a, __a_end, __err);\n    // Digit grouping checked\n    __check_grouping(__grouping, __g, __g_end, __err);\n    // EOF checked\n    if (__b == __e)\n        __err |= ios_base::eofbit;\n    return __b;\n}\n\ntemplate <class _CharT, class _InputIterator>\n_InputIterator\nnum_get<_CharT, _InputIterator>::do_get(iter_type __b, iter_type __e,\n                                        ios_base& __iob,\n                                        ios_base::iostate& __err,\n                                        void*& __v) const\n{\n    // Stage 1\n    int __base = 16;\n    // Stage 2\n    char_type __atoms[26];\n    char_type __thousands_sep = 0;\n    string __grouping;\n    use_facet<ctype<_CharT> >(__iob.getloc()).widen(__num_get_base::__src,\n                                                    __num_get_base::__src + 26, __atoms);\n    string __buf;\n    __buf.resize(__buf.capacity());\n    char* __a = &__buf[0];\n    char* __a_end = __a;\n    unsigned __g[__num_get_base::__num_get_buf_sz];\n    unsigned* __g_end = __g;\n    unsigned __dc = 0;\n    for (; __b != __e; ++__b)\n    {\n        if (__a_end == __a + __buf.size())\n        {\n            size_t __tmp = __buf.size();\n            __buf.resize(2*__buf.size());\n            __buf.resize(__buf.capacity());\n            __a = &__buf[0];\n            __a_end = __a + __tmp;\n        }\n        if (this->__stage2_int_loop(*__b, __base, __a, __a_end, __dc,\n                                    __thousands_sep, __grouping,\n                                    __g, __g_end, __atoms))\n            break;\n    }\n    // Stage 3\n    __buf.resize(__a_end - __a);\n    if (__libcpp_sscanf_l(__buf.c_str(), _LIBCPP_GET_C_LOCALE, \"%p\", &__v) != 1)\n        __err = ios_base::failbit;\n    // EOF checked\n    if (__b == __e)\n        __err |= ios_base::eofbit;\n    return __b;\n}\n\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS num_get<char>)\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS num_get<wchar_t>)\n\nstruct _LIBCPP_TYPE_VIS __num_put_base\n{\nprotected:\n    static void __format_int(char* __fmt, const char* __len, bool __signd,\n                             ios_base::fmtflags __flags);\n    static bool __format_float(char* __fmt, const char* __len,\n                               ios_base::fmtflags __flags);\n    static char* __identify_padding(char* __nb, char* __ne,\n                                    const ios_base& __iob);\n};\n\ntemplate <class _CharT>\nstruct __num_put\n    : protected __num_put_base\n{\n    static void __widen_and_group_int(char* __nb, char* __np, char* __ne,\n                                      _CharT* __ob, _CharT*& __op, _CharT*& __oe,\n                                      const locale& __loc);\n    static void __widen_and_group_float(char* __nb, char* __np, char* __ne,\n                                        _CharT* __ob, _CharT*& __op, _CharT*& __oe,\n                                        const locale& __loc);\n};\n\ntemplate <class _CharT>\nvoid\n__num_put<_CharT>::__widen_and_group_int(char* __nb, char* __np, char* __ne,\n                                         _CharT* __ob, _CharT*& __op, _CharT*& __oe,\n                                         const locale& __loc)\n{\n    const ctype<_CharT>&    __ct = use_facet<ctype<_CharT> >   (__loc);\n    const numpunct<_CharT>& __npt = use_facet<numpunct<_CharT> >(__loc);\n    string __grouping = __npt.grouping();\n    if (__grouping.empty())\n    {\n        __ct.widen(__nb, __ne, __ob);\n        __oe = __ob + (__ne - __nb);\n    }\n    else\n    {\n        __oe = __ob;\n        char* __nf = __nb;\n        if (*__nf == '-' || *__nf == '+')\n            *__oe++ = __ct.widen(*__nf++);\n        if (__ne - __nf >= 2 && __nf[0] == '0' && (__nf[1] == 'x' ||\n                                                   __nf[1] == 'X'))\n        {\n            *__oe++ = __ct.widen(*__nf++);\n            *__oe++ = __ct.widen(*__nf++);\n        }\n        reverse(__nf, __ne);\n        _CharT __thousands_sep = __npt.thousands_sep();\n        unsigned __dc = 0;\n        unsigned __dg = 0;\n        for (char* __p = __nf; __p < __ne; ++__p)\n        {\n            if (static_cast<unsigned>(__grouping[__dg]) > 0 &&\n                __dc == static_cast<unsigned>(__grouping[__dg]))\n            {\n                *__oe++ = __thousands_sep;\n                __dc = 0;\n                if (__dg < __grouping.size()-1)\n                    ++__dg;\n            }\n            *__oe++ = __ct.widen(*__p);\n            ++__dc;\n        }\n        reverse(__ob + (__nf - __nb), __oe);\n    }\n    if (__np == __ne)\n        __op = __oe;\n    else\n        __op = __ob + (__np - __nb);\n}\n\ntemplate <class _CharT>\nvoid\n__num_put<_CharT>::__widen_and_group_float(char* __nb, char* __np, char* __ne,\n                                           _CharT* __ob, _CharT*& __op, _CharT*& __oe,\n                                           const locale& __loc)\n{\n    const ctype<_CharT>&    __ct = use_facet<ctype<_CharT> >   (__loc);\n    const numpunct<_CharT>& __npt = use_facet<numpunct<_CharT> >(__loc);\n    string __grouping = __npt.grouping();\n    __oe = __ob;\n    char* __nf = __nb;\n    if (*__nf == '-' || *__nf == '+')\n        *__oe++ = __ct.widen(*__nf++);\n    char* __ns;\n    if (__ne - __nf >= 2 && __nf[0] == '0' && (__nf[1] == 'x' ||\n                                               __nf[1] == 'X'))\n    {\n        *__oe++ = __ct.widen(*__nf++);\n        *__oe++ = __ct.widen(*__nf++);\n        for (__ns = __nf; __ns < __ne; ++__ns)\n            if (!isxdigit_l(*__ns, _LIBCPP_GET_C_LOCALE))\n                break;\n    }\n    else\n    {\n        for (__ns = __nf; __ns < __ne; ++__ns)\n            if (!isdigit_l(*__ns, _LIBCPP_GET_C_LOCALE))\n                break;\n    }\n    if (__grouping.empty())\n    {\n        __ct.widen(__nf, __ns, __oe);\n        __oe += __ns - __nf;\n    }\n    else\n    {\n        reverse(__nf, __ns);\n        _CharT __thousands_sep = __npt.thousands_sep();\n        unsigned __dc = 0;\n        unsigned __dg = 0;\n        for (char* __p = __nf; __p < __ns; ++__p)\n        {\n            if (__grouping[__dg] > 0 && __dc == static_cast<unsigned>(__grouping[__dg]))\n            {\n                *__oe++ = __thousands_sep;\n                __dc = 0;\n                if (__dg < __grouping.size()-1)\n                    ++__dg;\n            }\n            *__oe++ = __ct.widen(*__p);\n            ++__dc;\n        }\n        reverse(__ob + (__nf - __nb), __oe);\n    }\n    for (__nf = __ns; __nf < __ne; ++__nf)\n    {\n        if (*__nf == '.')\n        {\n            *__oe++ = __npt.decimal_point();\n            ++__nf;\n            break;\n        }\n        else\n            *__oe++ = __ct.widen(*__nf);\n    }\n    __ct.widen(__nf, __ne, __oe);\n    __oe += __ne - __nf;\n    if (__np == __ne)\n        __op = __oe;\n    else\n        __op = __ob + (__np - __nb);\n}\n\n_LIBCPP_EXTERN_TEMPLATE2(struct _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS __num_put<char>)\n_LIBCPP_EXTERN_TEMPLATE2(struct _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS __num_put<wchar_t>)\n\ntemplate <class _CharT, class _OutputIterator = ostreambuf_iterator<_CharT> >\nclass _LIBCPP_TEMPLATE_VIS num_put\n    : public locale::facet,\n      private __num_put<_CharT>\n{\npublic:\n    typedef _CharT char_type;\n    typedef _OutputIterator iter_type;\n\n    _LIBCPP_ALWAYS_INLINE\n    explicit num_put(size_t __refs = 0)\n        : locale::facet(__refs) {}\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type put(iter_type __s, ios_base& __iob, char_type __fl,\n                  bool __v) const\n    {\n        return do_put(__s, __iob, __fl, __v);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type put(iter_type __s, ios_base& __iob, char_type __fl,\n                  long __v) const\n    {\n        return do_put(__s, __iob, __fl, __v);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type put(iter_type __s, ios_base& __iob, char_type __fl,\n                  long long __v) const\n    {\n        return do_put(__s, __iob, __fl, __v);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type put(iter_type __s, ios_base& __iob, char_type __fl,\n                  unsigned long __v) const\n    {\n        return do_put(__s, __iob, __fl, __v);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type put(iter_type __s, ios_base& __iob, char_type __fl,\n                  unsigned long long __v) const\n    {\n        return do_put(__s, __iob, __fl, __v);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type put(iter_type __s, ios_base& __iob, char_type __fl,\n                  double __v) const\n    {\n        return do_put(__s, __iob, __fl, __v);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type put(iter_type __s, ios_base& __iob, char_type __fl,\n                  long double __v) const\n    {\n        return do_put(__s, __iob, __fl, __v);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type put(iter_type __s, ios_base& __iob, char_type __fl,\n                  const void* __v) const\n    {\n        return do_put(__s, __iob, __fl, __v);\n    }\n\n    static locale::id id;\n\nprotected:\n    _LIBCPP_ALWAYS_INLINE\n    ~num_put() {}\n\n    virtual iter_type do_put(iter_type __s, ios_base& __iob, char_type __fl,\n                             bool __v) const;\n    virtual iter_type do_put(iter_type __s, ios_base& __iob, char_type __fl,\n                             long __v) const;\n    virtual iter_type do_put(iter_type __s, ios_base& __iob, char_type __fl,\n                             long long __v) const;\n    virtual iter_type do_put(iter_type __s, ios_base& __iob, char_type __fl,\n                             unsigned long) const;\n    virtual iter_type do_put(iter_type __s, ios_base& __iob, char_type __fl,\n                             unsigned long long) const;\n    virtual iter_type do_put(iter_type __s, ios_base& __iob, char_type __fl,\n                             double __v) const;\n    virtual iter_type do_put(iter_type __s, ios_base& __iob, char_type __fl,\n                             long double __v) const;\n    virtual iter_type do_put(iter_type __s, ios_base& __iob, char_type __fl,\n                             const void* __v) const;\n};\n\ntemplate <class _CharT, class _OutputIterator>\nlocale::id\nnum_put<_CharT, _OutputIterator>::id;\n\ntemplate <class _CharT, class _OutputIterator>\n_LIBCPP_HIDDEN\n_OutputIterator\n__pad_and_output(_OutputIterator __s,\n                 const _CharT* __ob, const _CharT* __op, const _CharT* __oe,\n                 ios_base& __iob, _CharT __fl)\n{\n    streamsize __sz = __oe - __ob;\n    streamsize __ns = __iob.width();\n    if (__ns > __sz)\n        __ns -= __sz;\n    else\n        __ns = 0;\n    for (;__ob < __op; ++__ob, ++__s)\n        *__s = *__ob;\n    for (; __ns; --__ns, ++__s)\n        *__s = __fl;\n    for (; __ob < __oe; ++__ob, ++__s)\n        *__s = *__ob;\n    __iob.width(0);\n    return __s;\n}\n\n#if !defined(__APPLE__) || \\\n    (defined(__MAC_OS_X_VERSION_MIN_REQUIRED) && __MAC_OS_X_VERSION_MIN_REQUIRED > __MAC_10_8) || \\\n    (defined(__IPHONE_OS_VERSION_MIN_REQUIRED) && __IPHONE_OS_VERSION_MIN_REQUIRED > __IPHONE_6_0)\n\ntemplate <class _CharT, class _Traits>\n_LIBCPP_HIDDEN\nostreambuf_iterator<_CharT, _Traits>\n__pad_and_output(ostreambuf_iterator<_CharT, _Traits> __s,\n                 const _CharT* __ob, const _CharT* __op, const _CharT* __oe,\n                 ios_base& __iob, _CharT __fl)\n{\n    if (__s.__sbuf_ == nullptr)\n        return __s;\n    streamsize __sz = __oe - __ob;\n    streamsize __ns = __iob.width();\n    if (__ns > __sz)\n        __ns -= __sz;\n    else\n        __ns = 0;\n    streamsize __np = __op - __ob;\n    if (__np > 0)\n    {\n        if (__s.__sbuf_->sputn(__ob, __np) != __np)\n        {\n            __s.__sbuf_ = nullptr;\n            return __s;\n        }\n    }\n    if (__ns > 0)\n    {\n        basic_string<_CharT, _Traits> __sp(__ns, __fl);\n        if (__s.__sbuf_->sputn(__sp.data(), __ns) != __ns)\n        {\n            __s.__sbuf_ = nullptr;\n            return __s;\n        }\n    }\n    __np = __oe - __op;\n    if (__np > 0)\n    {\n        if (__s.__sbuf_->sputn(__op, __np) != __np)\n        {\n            __s.__sbuf_ = nullptr;\n            return __s;\n        }\n    }\n    __iob.width(0);\n    return __s;\n}\n\n#endif\n\ntemplate <class _CharT, class _OutputIterator>\n_OutputIterator\nnum_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base& __iob,\n                                         char_type __fl, bool __v) const\n{\n    if ((__iob.flags() & ios_base::boolalpha) == 0)\n        return do_put(__s, __iob, __fl, (unsigned long)__v);\n    const numpunct<char_type>& __np = use_facet<numpunct<char_type> >(__iob.getloc());\n    typedef typename numpunct<char_type>::string_type string_type;\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    string_type __tmp(__v ? __np.truename() : __np.falsename());\n    string_type __nm = _VSTD::move(__tmp);\n#else\n    string_type __nm = __v ? __np.truename() : __np.falsename();\n#endif\n    for (typename string_type::iterator __i = __nm.begin(); __i != __nm.end(); ++__i, ++__s)\n        *__s = *__i;\n    return __s;\n}\n\ntemplate <class _CharT, class _OutputIterator>\n_OutputIterator\nnum_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base& __iob,\n                                         char_type __fl, long __v) const\n{\n    // Stage 1 - Get number in narrow char\n    char __fmt[6] = {'%', 0};\n    const char* __len = \"l\";\n    this->__format_int(__fmt+1, __len, true, __iob.flags());\n    const unsigned __nbuf = (numeric_limits<long>::digits / 3)\n                          + ((numeric_limits<long>::digits % 3) != 0)\n                          + 2;\n    char __nar[__nbuf];\n    int __nc = __libcpp_snprintf_l(__nar, sizeof(__nar), _LIBCPP_GET_C_LOCALE, __fmt, __v);\n    char* __ne = __nar + __nc;\n    char* __np = this->__identify_padding(__nar, __ne, __iob);\n    // Stage 2 - Widen __nar while adding thousands separators\n    char_type __o[2*(__nbuf-1) - 1];\n    char_type* __op;  // pad here\n    char_type* __oe;  // end of output\n    this->__widen_and_group_int(__nar, __np, __ne, __o, __op, __oe, __iob.getloc());\n    // [__o, __oe) contains thousands_sep'd wide number\n    // Stage 3 & 4\n    return __pad_and_output(__s, __o, __op, __oe, __iob, __fl);\n}\n\ntemplate <class _CharT, class _OutputIterator>\n_OutputIterator\nnum_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base& __iob,\n                                         char_type __fl, long long __v) const\n{\n    // Stage 1 - Get number in narrow char\n    char __fmt[8] = {'%', 0};\n    const char* __len = \"ll\";\n    this->__format_int(__fmt+1, __len, true, __iob.flags());\n    const unsigned __nbuf = (numeric_limits<long long>::digits / 3)\n                          + ((numeric_limits<long long>::digits % 3) != 0)\n                          + 2;\n    char __nar[__nbuf];\n    int __nc = __libcpp_snprintf_l(__nar, sizeof(__nar), _LIBCPP_GET_C_LOCALE, __fmt, __v);\n    char* __ne = __nar + __nc;\n    char* __np = this->__identify_padding(__nar, __ne, __iob);\n    // Stage 2 - Widen __nar while adding thousands separators\n    char_type __o[2*(__nbuf-1) - 1];\n    char_type* __op;  // pad here\n    char_type* __oe;  // end of output\n    this->__widen_and_group_int(__nar, __np, __ne, __o, __op, __oe, __iob.getloc());\n    // [__o, __oe) contains thousands_sep'd wide number\n    // Stage 3 & 4\n    return __pad_and_output(__s, __o, __op, __oe, __iob, __fl);\n}\n\ntemplate <class _CharT, class _OutputIterator>\n_OutputIterator\nnum_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base& __iob,\n                                         char_type __fl, unsigned long __v) const\n{\n    // Stage 1 - Get number in narrow char\n    char __fmt[6] = {'%', 0};\n    const char* __len = \"l\";\n    this->__format_int(__fmt+1, __len, false, __iob.flags());\n    const unsigned __nbuf = (numeric_limits<unsigned long>::digits / 3)\n                          + ((numeric_limits<unsigned long>::digits % 3) != 0)\n                          + 1;\n    char __nar[__nbuf];\n    int __nc = __libcpp_snprintf_l(__nar, sizeof(__nar), _LIBCPP_GET_C_LOCALE, __fmt, __v);\n    char* __ne = __nar + __nc;\n    char* __np = this->__identify_padding(__nar, __ne, __iob);\n    // Stage 2 - Widen __nar while adding thousands separators\n    char_type __o[2*(__nbuf-1) - 1];\n    char_type* __op;  // pad here\n    char_type* __oe;  // end of output\n    this->__widen_and_group_int(__nar, __np, __ne, __o, __op, __oe, __iob.getloc());\n    // [__o, __oe) contains thousands_sep'd wide number\n    // Stage 3 & 4\n    return __pad_and_output(__s, __o, __op, __oe, __iob, __fl);\n}\n\ntemplate <class _CharT, class _OutputIterator>\n_OutputIterator\nnum_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base& __iob,\n                                         char_type __fl, unsigned long long __v) const\n{\n    // Stage 1 - Get number in narrow char\n    char __fmt[8] = {'%', 0};\n    const char* __len = \"ll\";\n    this->__format_int(__fmt+1, __len, false, __iob.flags());\n    const unsigned __nbuf = (numeric_limits<unsigned long long>::digits / 3)\n                          + ((numeric_limits<unsigned long long>::digits % 3) != 0)\n                          + 1;\n    char __nar[__nbuf];\n    int __nc = __libcpp_snprintf_l(__nar, sizeof(__nar), _LIBCPP_GET_C_LOCALE, __fmt, __v);\n    char* __ne = __nar + __nc;\n    char* __np = this->__identify_padding(__nar, __ne, __iob);\n    // Stage 2 - Widen __nar while adding thousands separators\n    char_type __o[2*(__nbuf-1) - 1];\n    char_type* __op;  // pad here\n    char_type* __oe;  // end of output\n    this->__widen_and_group_int(__nar, __np, __ne, __o, __op, __oe, __iob.getloc());\n    // [__o, __oe) contains thousands_sep'd wide number\n    // Stage 3 & 4\n    return __pad_and_output(__s, __o, __op, __oe, __iob, __fl);\n}\n\ntemplate <class _CharT, class _OutputIterator>\n_OutputIterator\nnum_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base& __iob,\n                                         char_type __fl, double __v) const\n{\n    // Stage 1 - Get number in narrow char\n    char __fmt[8] = {'%', 0};\n    const char* __len = \"\";\n    bool __specify_precision = this->__format_float(__fmt+1, __len, __iob.flags());\n    const unsigned __nbuf = 30;\n    char __nar[__nbuf];\n    char* __nb = __nar;\n    int __nc;\n    if (__specify_precision)\n        __nc = __libcpp_snprintf_l(__nb, __nbuf, _LIBCPP_GET_C_LOCALE, __fmt,\n                                   (int)__iob.precision(), __v);\n    else\n        __nc = __libcpp_snprintf_l(__nb, __nbuf, _LIBCPP_GET_C_LOCALE, __fmt, __v);\n    unique_ptr<char, void(*)(void*)> __nbh(0, free);\n    if (__nc > static_cast<int>(__nbuf-1))\n    {\n        if (__specify_precision)\n            __nc = __libcpp_asprintf_l(&__nb, _LIBCPP_GET_C_LOCALE, __fmt, (int)__iob.precision(), __v);\n        else\n            __nc = __libcpp_asprintf_l(&__nb, _LIBCPP_GET_C_LOCALE, __fmt, __v);\n        if (__nb == 0)\n            __throw_bad_alloc();\n        __nbh.reset(__nb);\n    }\n    char* __ne = __nb + __nc;\n    char* __np = this->__identify_padding(__nb, __ne, __iob);\n    // Stage 2 - Widen __nar while adding thousands separators\n    char_type __o[2*(__nbuf-1) - 1];\n    char_type* __ob = __o;\n    unique_ptr<char_type, void(*)(void*)> __obh(0, free);\n    if (__nb != __nar)\n    {\n        __ob = (char_type*)malloc(2*static_cast<size_t>(__nc)*sizeof(char_type));\n        if (__ob == 0)\n            __throw_bad_alloc();\n        __obh.reset(__ob);\n    }\n    char_type* __op;  // pad here\n    char_type* __oe;  // end of output\n    this->__widen_and_group_float(__nb, __np, __ne, __ob, __op, __oe, __iob.getloc());\n    // [__o, __oe) contains thousands_sep'd wide number\n    // Stage 3 & 4\n    __s = __pad_and_output(__s, __ob, __op, __oe, __iob, __fl);\n    return __s;\n}\n\ntemplate <class _CharT, class _OutputIterator>\n_OutputIterator\nnum_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base& __iob,\n                                         char_type __fl, long double __v) const\n{\n    // Stage 1 - Get number in narrow char\n    char __fmt[8] = {'%', 0};\n    const char* __len = \"L\";\n    bool __specify_precision = this->__format_float(__fmt+1, __len, __iob.flags());\n    const unsigned __nbuf = 30;\n    char __nar[__nbuf];\n    char* __nb = __nar;\n    int __nc;\n    if (__specify_precision)\n        __nc = __libcpp_snprintf_l(__nb, __nbuf, _LIBCPP_GET_C_LOCALE, __fmt,\n                                   (int)__iob.precision(), __v);\n    else\n        __nc = __libcpp_snprintf_l(__nb, __nbuf, _LIBCPP_GET_C_LOCALE, __fmt, __v);\n    unique_ptr<char, void(*)(void*)> __nbh(0, free);\n    if (__nc > static_cast<int>(__nbuf-1))\n    {\n        if (__specify_precision)\n            __nc = __libcpp_asprintf_l(&__nb, _LIBCPP_GET_C_LOCALE, __fmt, (int)__iob.precision(), __v);\n        else\n            __nc = __libcpp_asprintf_l(&__nb, _LIBCPP_GET_C_LOCALE, __fmt, __v);\n        if (__nb == 0)\n            __throw_bad_alloc();\n        __nbh.reset(__nb);\n    }\n    char* __ne = __nb + __nc;\n    char* __np = this->__identify_padding(__nb, __ne, __iob);\n    // Stage 2 - Widen __nar while adding thousands separators\n    char_type __o[2*(__nbuf-1) - 1];\n    char_type* __ob = __o;\n    unique_ptr<char_type, void(*)(void*)> __obh(0, free);\n    if (__nb != __nar)\n    {\n        __ob = (char_type*)malloc(2*static_cast<size_t>(__nc)*sizeof(char_type));\n        if (__ob == 0)\n            __throw_bad_alloc();\n        __obh.reset(__ob);\n    }\n    char_type* __op;  // pad here\n    char_type* __oe;  // end of output\n    this->__widen_and_group_float(__nb, __np, __ne, __ob, __op, __oe, __iob.getloc());\n    // [__o, __oe) contains thousands_sep'd wide number\n    // Stage 3 & 4\n    __s = __pad_and_output(__s, __ob, __op, __oe, __iob, __fl);\n    return __s;\n}\n\ntemplate <class _CharT, class _OutputIterator>\n_OutputIterator\nnum_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base& __iob,\n                                         char_type __fl, const void* __v) const\n{\n    // Stage 1 - Get pointer in narrow char\n    char __fmt[6] = \"%p\";\n    const unsigned __nbuf = 20;\n    char __nar[__nbuf];\n    int __nc = __libcpp_snprintf_l(__nar, sizeof(__nar), _LIBCPP_GET_C_LOCALE, __fmt, __v);\n    char* __ne = __nar + __nc;\n    char* __np = this->__identify_padding(__nar, __ne, __iob);\n    // Stage 2 - Widen __nar\n    char_type __o[2*(__nbuf-1) - 1];\n    char_type* __op;  // pad here\n    char_type* __oe;  // end of output\n    const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__iob.getloc());\n    __ct.widen(__nar, __ne, __o);\n    __oe = __o + (__ne - __nar);\n    if (__np == __ne)\n        __op = __oe;\n    else\n        __op = __o + (__np - __nar);\n    // [__o, __oe) contains wide number\n    // Stage 3 & 4\n    return __pad_and_output(__s, __o, __op, __oe, __iob, __fl);\n}\n\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS num_put<char>)\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS num_put<wchar_t>)\n\ntemplate <class _CharT, class _InputIterator>\n_LIBCPP_HIDDEN\nint\n__get_up_to_n_digits(_InputIterator& __b, _InputIterator __e,\n                     ios_base::iostate& __err, const ctype<_CharT>& __ct, int __n)\n{\n    // Precondition:  __n >= 1\n    if (__b == __e)\n    {\n        __err |= ios_base::eofbit | ios_base::failbit;\n        return 0;\n    }\n    // get first digit\n    _CharT __c = *__b;\n    if (!__ct.is(ctype_base::digit, __c))\n    {\n        __err |= ios_base::failbit;\n        return 0;\n    }\n    int __r = __ct.narrow(__c, 0) - '0';\n    for (++__b, (void) --__n; __b != __e && __n > 0; ++__b, (void) --__n)\n    {\n        // get next digit\n        __c = *__b;\n        if (!__ct.is(ctype_base::digit, __c))\n            return __r;\n        __r = __r * 10 + __ct.narrow(__c, 0) - '0';\n    }\n    if (__b == __e)\n        __err |= ios_base::eofbit;\n    return __r;\n}\n\nclass _LIBCPP_TYPE_VIS time_base\n{\npublic:\n    enum dateorder {no_order, dmy, mdy, ymd, ydm};\n};\n\ntemplate <class _CharT>\nclass _LIBCPP_TEMPLATE_VIS __time_get_c_storage\n{\nprotected:\n    typedef basic_string<_CharT> string_type;\n\n    virtual const string_type* __weeks() const;\n    virtual const string_type* __months() const;\n    virtual const string_type* __am_pm() const;\n    virtual const string_type& __c() const;\n    virtual const string_type& __r() const;\n    virtual const string_type& __x() const;\n    virtual const string_type& __X() const;\n\n    _LIBCPP_ALWAYS_INLINE\n    ~__time_get_c_storage() {}\n};\n\ntemplate <class _CharT, class _InputIterator = istreambuf_iterator<_CharT> >\nclass _LIBCPP_TEMPLATE_VIS time_get\n    : public locale::facet,\n      public time_base,\n      private __time_get_c_storage<_CharT>\n{\npublic:\n    typedef _CharT                  char_type;\n    typedef _InputIterator          iter_type;\n    typedef time_base::dateorder    dateorder;\n    typedef basic_string<char_type> string_type;\n\n    _LIBCPP_ALWAYS_INLINE\n    explicit time_get(size_t __refs = 0)\n        : locale::facet(__refs) {}\n\n    _LIBCPP_ALWAYS_INLINE\n    dateorder date_order() const\n    {\n        return this->do_date_order();\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type get_time(iter_type __b, iter_type __e, ios_base& __iob,\n                       ios_base::iostate& __err, tm* __tm) const\n    {\n        return do_get_time(__b, __e, __iob, __err, __tm);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type get_date(iter_type __b, iter_type __e, ios_base& __iob,\n                       ios_base::iostate& __err, tm* __tm) const\n    {\n        return do_get_date(__b, __e, __iob, __err, __tm);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type get_weekday(iter_type __b, iter_type __e, ios_base& __iob,\n                          ios_base::iostate& __err, tm* __tm) const\n    {\n        return do_get_weekday(__b, __e, __iob, __err, __tm);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type get_monthname(iter_type __b, iter_type __e, ios_base& __iob,\n                            ios_base::iostate& __err, tm* __tm) const\n    {\n        return do_get_monthname(__b, __e, __iob, __err, __tm);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type get_year(iter_type __b, iter_type __e, ios_base& __iob,\n                       ios_base::iostate& __err, tm* __tm) const\n    {\n        return do_get_year(__b, __e, __iob, __err, __tm);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,\n                  ios_base::iostate& __err, tm *__tm,\n                  char __fmt, char __mod = 0) const\n    {\n        return do_get(__b, __e, __iob, __err, __tm, __fmt, __mod);\n    }\n\n    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,\n                  ios_base::iostate& __err, tm* __tm,\n                  const char_type* __fmtb, const char_type* __fmte) const;\n\n    static locale::id id;\n\nprotected:\n    _LIBCPP_ALWAYS_INLINE\n    ~time_get() {}\n\n    virtual dateorder do_date_order() const;\n    virtual iter_type do_get_time(iter_type __b, iter_type __e, ios_base& __iob,\n                                  ios_base::iostate& __err, tm* __tm) const;\n    virtual iter_type do_get_date(iter_type __b, iter_type __e, ios_base& __iob,\n                                  ios_base::iostate& __err, tm* __tm) const;\n    virtual iter_type do_get_weekday(iter_type __b, iter_type __e, ios_base& __iob,\n                                     ios_base::iostate& __err, tm* __tm) const;\n    virtual iter_type do_get_monthname(iter_type __b, iter_type __e, ios_base& __iob,\n                                       ios_base::iostate& __err, tm* __tm) const;\n    virtual iter_type do_get_year(iter_type __b, iter_type __e, ios_base& __iob,\n                                  ios_base::iostate& __err, tm* __tm) const;\n    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,\n                             ios_base::iostate& __err, tm* __tm,\n                             char __fmt, char __mod) const;\nprivate:\n    void __get_white_space(iter_type& __b, iter_type __e,\n                           ios_base::iostate& __err, const ctype<char_type>& __ct) const;\n    void __get_percent(iter_type& __b, iter_type __e, ios_base::iostate& __err,\n                       const ctype<char_type>& __ct) const;\n\n    void __get_weekdayname(int& __m,\n                           iter_type& __b, iter_type __e,\n                           ios_base::iostate& __err,\n                           const ctype<char_type>& __ct) const;\n    void __get_monthname(int& __m,\n                         iter_type& __b, iter_type __e,\n                         ios_base::iostate& __err,\n                         const ctype<char_type>& __ct) const;\n    void __get_day(int& __d,\n                   iter_type& __b, iter_type __e,\n                   ios_base::iostate& __err,\n                   const ctype<char_type>& __ct) const;\n    void __get_month(int& __m,\n                     iter_type& __b, iter_type __e,\n                     ios_base::iostate& __err,\n                     const ctype<char_type>& __ct) const;\n    void __get_year(int& __y,\n                   iter_type& __b, iter_type __e,\n                   ios_base::iostate& __err,\n                   const ctype<char_type>& __ct) const;\n    void __get_year4(int& __y,\n                    iter_type& __b, iter_type __e,\n                    ios_base::iostate& __err,\n                    const ctype<char_type>& __ct) const;\n    void __get_hour(int& __d,\n                    iter_type& __b, iter_type __e,\n                    ios_base::iostate& __err,\n                    const ctype<char_type>& __ct) const;\n    void __get_12_hour(int& __h,\n                       iter_type& __b, iter_type __e,\n                       ios_base::iostate& __err,\n                       const ctype<char_type>& __ct) const;\n    void __get_am_pm(int& __h,\n                     iter_type& __b, iter_type __e,\n                     ios_base::iostate& __err,\n                     const ctype<char_type>& __ct) const;\n    void __get_minute(int& __m,\n                      iter_type& __b, iter_type __e,\n                      ios_base::iostate& __err,\n                      const ctype<char_type>& __ct) const;\n    void __get_second(int& __s,\n                      iter_type& __b, iter_type __e,\n                      ios_base::iostate& __err,\n                      const ctype<char_type>& __ct) const;\n    void __get_weekday(int& __w,\n                       iter_type& __b, iter_type __e,\n                       ios_base::iostate& __err,\n                       const ctype<char_type>& __ct) const;\n    void __get_day_year_num(int& __w,\n                            iter_type& __b, iter_type __e,\n                            ios_base::iostate& __err,\n                            const ctype<char_type>& __ct) const;\n};\n\ntemplate <class _CharT, class _InputIterator>\nlocale::id\ntime_get<_CharT, _InputIterator>::id;\n\n// time_get primitives\n\ntemplate <class _CharT, class _InputIterator>\nvoid\ntime_get<_CharT, _InputIterator>::__get_weekdayname(int& __w,\n                                                    iter_type& __b, iter_type __e,\n                                                    ios_base::iostate& __err,\n                                                    const ctype<char_type>& __ct) const\n{\n    // Note:  ignoring case comes from the POSIX strptime spec\n    const string_type* __wk = this->__weeks();\n    ptrdiff_t __i = __scan_keyword(__b, __e, __wk, __wk+14, __ct, __err, false) - __wk;\n    if (__i < 14)\n        __w = __i % 7;\n}\n\ntemplate <class _CharT, class _InputIterator>\nvoid\ntime_get<_CharT, _InputIterator>::__get_monthname(int& __m,\n                                                  iter_type& __b, iter_type __e,\n                                                  ios_base::iostate& __err,\n                                                  const ctype<char_type>& __ct) const\n{\n    // Note:  ignoring case comes from the POSIX strptime spec\n    const string_type* __month = this->__months();\n    ptrdiff_t __i = __scan_keyword(__b, __e, __month, __month+24, __ct, __err, false) - __month;\n    if (__i < 24)\n        __m = __i % 12;\n}\n\ntemplate <class _CharT, class _InputIterator>\nvoid\ntime_get<_CharT, _InputIterator>::__get_day(int& __d,\n                                            iter_type& __b, iter_type __e,\n                                            ios_base::iostate& __err,\n                                            const ctype<char_type>& __ct) const\n{\n    int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 2);\n    if (!(__err & ios_base::failbit) && 1 <= __t && __t <= 31)\n        __d = __t;\n    else\n        __err |= ios_base::failbit;\n}\n\ntemplate <class _CharT, class _InputIterator>\nvoid\ntime_get<_CharT, _InputIterator>::__get_month(int& __m,\n                                              iter_type& __b, iter_type __e,\n                                              ios_base::iostate& __err,\n                                              const ctype<char_type>& __ct) const\n{\n    int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 2) - 1;\n    if (!(__err & ios_base::failbit) && __t <= 11)\n        __m = __t;\n    else\n        __err |= ios_base::failbit;\n}\n\ntemplate <class _CharT, class _InputIterator>\nvoid\ntime_get<_CharT, _InputIterator>::__get_year(int& __y,\n                                             iter_type& __b, iter_type __e,\n                                             ios_base::iostate& __err,\n                                             const ctype<char_type>& __ct) const\n{\n    int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 4);\n    if (!(__err & ios_base::failbit))\n    {\n        if (__t < 69)\n            __t += 2000;\n        else if (69 <= __t && __t <= 99)\n            __t += 1900;\n        __y = __t - 1900;\n    }\n}\n\ntemplate <class _CharT, class _InputIterator>\nvoid\ntime_get<_CharT, _InputIterator>::__get_year4(int& __y,\n                                              iter_type& __b, iter_type __e,\n                                              ios_base::iostate& __err,\n                                              const ctype<char_type>& __ct) const\n{\n    int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 4);\n    if (!(__err & ios_base::failbit))\n        __y = __t - 1900;\n}\n\ntemplate <class _CharT, class _InputIterator>\nvoid\ntime_get<_CharT, _InputIterator>::__get_hour(int& __h,\n                                             iter_type& __b, iter_type __e,\n                                             ios_base::iostate& __err,\n                                             const ctype<char_type>& __ct) const\n{\n    int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 2);\n    if (!(__err & ios_base::failbit) && __t <= 23)\n        __h = __t;\n    else\n        __err |= ios_base::failbit;\n}\n\ntemplate <class _CharT, class _InputIterator>\nvoid\ntime_get<_CharT, _InputIterator>::__get_12_hour(int& __h,\n                                                iter_type& __b, iter_type __e,\n                                                ios_base::iostate& __err,\n                                                const ctype<char_type>& __ct) const\n{\n    int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 2);\n    if (!(__err & ios_base::failbit) && 1 <= __t && __t <= 12)\n        __h = __t;\n    else\n        __err |= ios_base::failbit;\n}\n\ntemplate <class _CharT, class _InputIterator>\nvoid\ntime_get<_CharT, _InputIterator>::__get_minute(int& __m,\n                                               iter_type& __b, iter_type __e,\n                                               ios_base::iostate& __err,\n                                               const ctype<char_type>& __ct) const\n{\n    int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 2);\n    if (!(__err & ios_base::failbit) && __t <= 59)\n        __m = __t;\n    else\n        __err |= ios_base::failbit;\n}\n\ntemplate <class _CharT, class _InputIterator>\nvoid\ntime_get<_CharT, _InputIterator>::__get_second(int& __s,\n                                               iter_type& __b, iter_type __e,\n                                               ios_base::iostate& __err,\n                                               const ctype<char_type>& __ct) const\n{\n    int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 2);\n    if (!(__err & ios_base::failbit) && __t <= 60)\n        __s = __t;\n    else\n        __err |= ios_base::failbit;\n}\n\ntemplate <class _CharT, class _InputIterator>\nvoid\ntime_get<_CharT, _InputIterator>::__get_weekday(int& __w,\n                                                iter_type& __b, iter_type __e,\n                                                ios_base::iostate& __err,\n                                                const ctype<char_type>& __ct) const\n{\n    int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 1);\n    if (!(__err & ios_base::failbit) && __t <= 6)\n        __w = __t;\n    else\n        __err |= ios_base::failbit;\n}\n\ntemplate <class _CharT, class _InputIterator>\nvoid\ntime_get<_CharT, _InputIterator>::__get_day_year_num(int& __d,\n                                                     iter_type& __b, iter_type __e,\n                                                     ios_base::iostate& __err,\n                                                     const ctype<char_type>& __ct) const\n{\n    int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 3);\n    if (!(__err & ios_base::failbit) && __t <= 365)\n        __d = __t;\n    else\n        __err |= ios_base::failbit;\n}\n\ntemplate <class _CharT, class _InputIterator>\nvoid\ntime_get<_CharT, _InputIterator>::__get_white_space(iter_type& __b, iter_type __e,\n                                                    ios_base::iostate& __err,\n                                                    const ctype<char_type>& __ct) const\n{\n    for (; __b != __e && __ct.is(ctype_base::space, *__b); ++__b)\n        ;\n    if (__b == __e)\n        __err |= ios_base::eofbit;\n}\n\ntemplate <class _CharT, class _InputIterator>\nvoid\ntime_get<_CharT, _InputIterator>::__get_am_pm(int& __h,\n                                              iter_type& __b, iter_type __e,\n                                              ios_base::iostate& __err,\n                                              const ctype<char_type>& __ct) const\n{\n    const string_type* __ap = this->__am_pm();\n    if (__ap[0].size() + __ap[1].size() == 0)\n    {\n        __err |= ios_base::failbit;\n        return;\n    }\n    ptrdiff_t __i = __scan_keyword(__b, __e, __ap, __ap+2, __ct, __err, false) - __ap;\n    if (__i == 0 && __h == 12)\n        __h = 0;\n    else if (__i == 1 && __h < 12)\n        __h += 12;\n}\n\ntemplate <class _CharT, class _InputIterator>\nvoid\ntime_get<_CharT, _InputIterator>::__get_percent(iter_type& __b, iter_type __e,\n                                                ios_base::iostate& __err,\n                                                const ctype<char_type>& __ct) const\n{\n    if (__b == __e)\n    {\n        __err |= ios_base::eofbit | ios_base::failbit;\n        return;\n    }\n    if (__ct.narrow(*__b, 0) != '%')\n        __err |= ios_base::failbit;\n    else if(++__b == __e)\n        __err |= ios_base::eofbit;\n}\n\n// time_get end primitives\n\ntemplate <class _CharT, class _InputIterator>\n_InputIterator\ntime_get<_CharT, _InputIterator>::get(iter_type __b, iter_type __e,\n                                      ios_base& __iob,\n                                      ios_base::iostate& __err, tm* __tm,\n                                      const char_type* __fmtb, const char_type* __fmte) const\n{\n    const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__iob.getloc());\n    __err = ios_base::goodbit;\n    while (__fmtb != __fmte && __err == ios_base::goodbit)\n    {\n        if (__b == __e)\n        {\n            __err = ios_base::failbit;\n            break;\n        }\n        if (__ct.narrow(*__fmtb, 0) == '%')\n        {\n            if (++__fmtb == __fmte)\n            {\n                __err = ios_base::failbit;\n                break;\n            }\n            char __cmd = __ct.narrow(*__fmtb, 0);\n            char __opt = '\\0';\n            if (__cmd == 'E' || __cmd == '0')\n            {\n                if (++__fmtb == __fmte)\n                {\n                    __err = ios_base::failbit;\n                    break;\n                }\n                __opt = __cmd;\n                __cmd = __ct.narrow(*__fmtb, 0);\n            }\n            __b = do_get(__b, __e, __iob, __err, __tm, __cmd, __opt);\n            ++__fmtb;\n        }\n        else if (__ct.is(ctype_base::space, *__fmtb))\n        {\n            for (++__fmtb; __fmtb != __fmte && __ct.is(ctype_base::space, *__fmtb); ++__fmtb)\n                ;\n            for (        ;    __b != __e    && __ct.is(ctype_base::space, *__b);    ++__b)\n                ;\n        }\n        else if (__ct.toupper(*__b) == __ct.toupper(*__fmtb))\n        {\n            ++__b;\n            ++__fmtb;\n        }\n        else\n            __err = ios_base::failbit;\n    }\n    if (__b == __e)\n        __err |= ios_base::eofbit;\n    return __b;\n}\n\ntemplate <class _CharT, class _InputIterator>\ntypename time_get<_CharT, _InputIterator>::dateorder\ntime_get<_CharT, _InputIterator>::do_date_order() const\n{\n    return mdy;\n}\n\ntemplate <class _CharT, class _InputIterator>\n_InputIterator\ntime_get<_CharT, _InputIterator>::do_get_time(iter_type __b, iter_type __e,\n                                              ios_base& __iob,\n                                              ios_base::iostate& __err,\n                                              tm* __tm) const\n{\n    const char_type __fmt[] = {'%', 'H', ':', '%', 'M', ':', '%', 'S'};\n    return get(__b, __e, __iob, __err, __tm, __fmt, __fmt + sizeof(__fmt)/sizeof(__fmt[0]));\n}\n\ntemplate <class _CharT, class _InputIterator>\n_InputIterator\ntime_get<_CharT, _InputIterator>::do_get_date(iter_type __b, iter_type __e,\n                                              ios_base& __iob,\n                                              ios_base::iostate& __err,\n                                              tm* __tm) const\n{\n    const string_type& __fmt = this->__x();\n    return get(__b, __e, __iob, __err, __tm, __fmt.data(), __fmt.data() + __fmt.size());\n}\n\ntemplate <class _CharT, class _InputIterator>\n_InputIterator\ntime_get<_CharT, _InputIterator>::do_get_weekday(iter_type __b, iter_type __e,\n                                                 ios_base& __iob,\n                                                 ios_base::iostate& __err,\n                                                 tm* __tm) const\n{\n    const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__iob.getloc());\n    __get_weekdayname(__tm->tm_wday, __b, __e, __err, __ct);\n    return __b;\n}\n\ntemplate <class _CharT, class _InputIterator>\n_InputIterator\ntime_get<_CharT, _InputIterator>::do_get_monthname(iter_type __b, iter_type __e,\n                                                   ios_base& __iob,\n                                                   ios_base::iostate& __err,\n                                                   tm* __tm) const\n{\n    const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__iob.getloc());\n    __get_monthname(__tm->tm_mon, __b, __e, __err, __ct);\n    return __b;\n}\n\ntemplate <class _CharT, class _InputIterator>\n_InputIterator\ntime_get<_CharT, _InputIterator>::do_get_year(iter_type __b, iter_type __e,\n                                              ios_base& __iob,\n                                              ios_base::iostate& __err,\n                                              tm* __tm) const\n{\n    const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__iob.getloc());\n    __get_year(__tm->tm_year, __b, __e, __err, __ct);\n    return __b;\n}\n\ntemplate <class _CharT, class _InputIterator>\n_InputIterator\ntime_get<_CharT, _InputIterator>::do_get(iter_type __b, iter_type __e,\n                                         ios_base& __iob,\n                                         ios_base::iostate& __err, tm* __tm,\n                                         char __fmt, char) const\n{\n    __err = ios_base::goodbit;\n    const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__iob.getloc());\n    switch (__fmt)\n    {\n    case 'a':\n    case 'A':\n        __get_weekdayname(__tm->tm_wday, __b, __e, __err, __ct);\n        break;\n    case 'b':\n    case 'B':\n    case 'h':\n        __get_monthname(__tm->tm_mon, __b, __e, __err, __ct);\n        break;\n    case 'c':\n        {\n        const string_type& __fm = this->__c();\n        __b = get(__b, __e, __iob, __err, __tm, __fm.data(), __fm.data() + __fm.size());\n        }\n        break;\n    case 'd':\n    case 'e':\n        __get_day(__tm->tm_mday, __b, __e, __err, __ct);\n        break;\n    case 'D':\n        {\n        const char_type __fm[] = {'%', 'm', '/', '%', 'd', '/', '%', 'y'};\n        __b = get(__b, __e, __iob, __err, __tm, __fm, __fm + sizeof(__fm)/sizeof(__fm[0]));\n        }\n        break;\n    case 'F':\n        {\n        const char_type __fm[] = {'%', 'Y', '-', '%', 'm', '-', '%', 'd'};\n        __b = get(__b, __e, __iob, __err, __tm, __fm, __fm + sizeof(__fm)/sizeof(__fm[0]));\n        }\n        break;\n    case 'H':\n        __get_hour(__tm->tm_hour, __b, __e, __err, __ct);\n        break;\n    case 'I':\n        __get_12_hour(__tm->tm_hour, __b, __e, __err, __ct);\n        break;\n    case 'j':\n        __get_day_year_num(__tm->tm_yday, __b, __e, __err, __ct);\n        break;\n    case 'm':\n        __get_month(__tm->tm_mon, __b, __e, __err, __ct);\n        break;\n    case 'M':\n        __get_minute(__tm->tm_min, __b, __e, __err, __ct);\n        break;\n    case 'n':\n    case 't':\n        __get_white_space(__b, __e, __err, __ct);\n        break;\n    case 'p':\n        __get_am_pm(__tm->tm_hour, __b, __e, __err, __ct);\n        break;\n    case 'r':\n        {\n        const char_type __fm[] = {'%', 'I', ':', '%', 'M', ':', '%', 'S', ' ', '%', 'p'};\n        __b = get(__b, __e, __iob, __err, __tm, __fm, __fm + sizeof(__fm)/sizeof(__fm[0]));\n        }\n        break;\n    case 'R':\n        {\n        const char_type __fm[] = {'%', 'H', ':', '%', 'M'};\n        __b = get(__b, __e, __iob, __err, __tm, __fm, __fm + sizeof(__fm)/sizeof(__fm[0]));\n        }\n        break;\n    case 'S':\n        __get_second(__tm->tm_sec, __b, __e, __err, __ct);\n        break;\n    case 'T':\n        {\n        const char_type __fm[] = {'%', 'H', ':', '%', 'M', ':', '%', 'S'};\n        __b = get(__b, __e, __iob, __err, __tm, __fm, __fm + sizeof(__fm)/sizeof(__fm[0]));\n        }\n        break;\n    case 'w':\n        __get_weekday(__tm->tm_wday, __b, __e, __err, __ct);\n        break;\n    case 'x':\n        return do_get_date(__b, __e, __iob, __err, __tm);\n    case 'X':\n        {\n        const string_type& __fm = this->__X();\n        __b = get(__b, __e, __iob, __err, __tm, __fm.data(), __fm.data() + __fm.size());\n        }\n        break;\n    case 'y':\n        __get_year(__tm->tm_year, __b, __e, __err, __ct);\n        break;\n    case 'Y':\n        __get_year4(__tm->tm_year, __b, __e, __err, __ct);\n        break;\n    case '%':\n        __get_percent(__b, __e, __err, __ct);\n        break;\n    default:\n        __err |= ios_base::failbit;\n    }\n    return __b;\n}\n\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS time_get<char>)\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS time_get<wchar_t>)\n\nclass _LIBCPP_TYPE_VIS __time_get\n{\nprotected:\n    locale_t __loc_;\n\n    __time_get(const char* __nm);\n    __time_get(const string& __nm);\n    ~__time_get();\n};\n\ntemplate <class _CharT>\nclass _LIBCPP_TEMPLATE_VIS __time_get_storage\n    : public __time_get\n{\nprotected:\n    typedef basic_string<_CharT> string_type;\n\n    string_type __weeks_[14];\n    string_type __months_[24];\n    string_type __am_pm_[2];\n    string_type __c_;\n    string_type __r_;\n    string_type __x_;\n    string_type __X_;\n\n    explicit __time_get_storage(const char* __nm);\n    explicit __time_get_storage(const string& __nm);\n\n    _LIBCPP_ALWAYS_INLINE ~__time_get_storage() {}\n\n    time_base::dateorder __do_date_order() const;\n\nprivate:\n    void init(const ctype<_CharT>&);\n    string_type __analyze(char __fmt, const ctype<_CharT>&);\n};\n\ntemplate <class _CharT, class _InputIterator = istreambuf_iterator<_CharT> >\nclass _LIBCPP_TEMPLATE_VIS time_get_byname\n    : public time_get<_CharT, _InputIterator>,\n      private __time_get_storage<_CharT>\n{\npublic:\n    typedef time_base::dateorder    dateorder;\n    typedef _InputIterator          iter_type;\n    typedef _CharT                  char_type;\n    typedef basic_string<char_type> string_type;\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit time_get_byname(const char* __nm, size_t __refs = 0)\n        : time_get<_CharT, _InputIterator>(__refs),\n          __time_get_storage<_CharT>(__nm) {}\n    _LIBCPP_INLINE_VISIBILITY\n    explicit time_get_byname(const string& __nm, size_t __refs = 0)\n        : time_get<_CharT, _InputIterator>(__refs),\n          __time_get_storage<_CharT>(__nm) {}\n\nprotected:\n    _LIBCPP_INLINE_VISIBILITY\n    ~time_get_byname() {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    virtual dateorder do_date_order() const {return this->__do_date_order();}\nprivate:\n    _LIBCPP_INLINE_VISIBILITY\n    virtual const string_type* __weeks() const  {return this->__weeks_;}\n    _LIBCPP_INLINE_VISIBILITY\n    virtual const string_type* __months() const {return this->__months_;}\n    _LIBCPP_INLINE_VISIBILITY\n    virtual const string_type* __am_pm() const  {return this->__am_pm_;}\n    _LIBCPP_INLINE_VISIBILITY\n    virtual const string_type& __c() const      {return this->__c_;}\n    _LIBCPP_INLINE_VISIBILITY\n    virtual const string_type& __r() const      {return this->__r_;}\n    _LIBCPP_INLINE_VISIBILITY\n    virtual const string_type& __x() const      {return this->__x_;}\n    _LIBCPP_INLINE_VISIBILITY\n    virtual const string_type& __X() const      {return this->__X_;}\n};\n\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS time_get_byname<char>)\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS time_get_byname<wchar_t>)\n\nclass _LIBCPP_TYPE_VIS __time_put\n{\n    locale_t __loc_;\nprotected:\n    _LIBCPP_ALWAYS_INLINE __time_put() : __loc_(_LIBCPP_GET_C_LOCALE) {}\n    __time_put(const char* __nm);\n    __time_put(const string& __nm);\n    ~__time_put();\n    void __do_put(char* __nb, char*& __ne, const tm* __tm,\n                  char __fmt, char __mod) const;\n    void __do_put(wchar_t* __wb, wchar_t*& __we, const tm* __tm,\n                  char __fmt, char __mod) const;\n};\n\ntemplate <class _CharT, class _OutputIterator = ostreambuf_iterator<_CharT> >\nclass _LIBCPP_TEMPLATE_VIS time_put\n    : public locale::facet,\n      private __time_put\n{\npublic:\n    typedef _CharT char_type;\n    typedef _OutputIterator iter_type;\n\n    _LIBCPP_ALWAYS_INLINE\n    explicit time_put(size_t __refs = 0)\n        : locale::facet(__refs) {}\n\n    iter_type put(iter_type __s, ios_base& __iob, char_type __fl, const tm* __tm,\n                  const char_type* __pb, const char_type* __pe) const;\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type put(iter_type __s, ios_base& __iob, char_type __fl,\n                  const tm* __tm, char __fmt, char __mod = 0) const\n    {\n        return do_put(__s, __iob, __fl, __tm, __fmt, __mod);\n    }\n\n    static locale::id id;\n\nprotected:\n    _LIBCPP_ALWAYS_INLINE\n    ~time_put() {}\n    virtual iter_type do_put(iter_type __s, ios_base&, char_type, const tm* __tm,\n                             char __fmt, char __mod) const;\n\n    _LIBCPP_ALWAYS_INLINE\n    explicit time_put(const char* __nm, size_t __refs)\n        : locale::facet(__refs),\n          __time_put(__nm) {}\n    _LIBCPP_ALWAYS_INLINE\n    explicit time_put(const string& __nm, size_t __refs)\n        : locale::facet(__refs),\n          __time_put(__nm) {}\n};\n\ntemplate <class _CharT, class _OutputIterator>\nlocale::id\ntime_put<_CharT, _OutputIterator>::id;\n\ntemplate <class _CharT, class _OutputIterator>\n_OutputIterator\ntime_put<_CharT, _OutputIterator>::put(iter_type __s, ios_base& __iob,\n                                       char_type __fl, const tm* __tm,\n                                       const char_type* __pb,\n                                       const char_type* __pe) const\n{\n    const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__iob.getloc());\n    for (; __pb != __pe; ++__pb)\n    {\n        if (__ct.narrow(*__pb, 0) == '%')\n        {\n            if (++__pb == __pe)\n            {\n                *__s++ = __pb[-1];\n                break;\n            }\n            char __mod = 0;\n            char __fmt = __ct.narrow(*__pb, 0);\n            if (__fmt == 'E' || __fmt == 'O')\n            {\n                if (++__pb == __pe)\n                {\n                    *__s++ = __pb[-2];\n                    *__s++ = __pb[-1];\n                    break;\n                }\n                __mod = __fmt;\n                __fmt = __ct.narrow(*__pb, 0);\n            }\n            __s = do_put(__s, __iob, __fl, __tm, __fmt, __mod);\n        }\n        else\n            *__s++ = *__pb;\n    }\n    return __s;\n}\n\ntemplate <class _CharT, class _OutputIterator>\n_OutputIterator\ntime_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base&,\n                                          char_type, const tm* __tm,\n                                          char __fmt, char __mod) const\n{\n    char_type __nar[100];\n    char_type* __nb = __nar;\n    char_type* __ne = __nb + 100;\n    __do_put(__nb, __ne, __tm, __fmt, __mod);\n    return _VSTD::copy(__nb, __ne, __s);\n}\n\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS time_put<char>)\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS time_put<wchar_t>)\n\ntemplate <class _CharT, class _OutputIterator = ostreambuf_iterator<_CharT> >\nclass _LIBCPP_TEMPLATE_VIS time_put_byname\n    : public time_put<_CharT, _OutputIterator>\n{\npublic:\n    _LIBCPP_ALWAYS_INLINE\n    explicit time_put_byname(const char* __nm, size_t __refs = 0)\n        : time_put<_CharT, _OutputIterator>(__nm, __refs) {}\n\n    _LIBCPP_ALWAYS_INLINE\n    explicit time_put_byname(const string& __nm, size_t __refs = 0)\n        : time_put<_CharT, _OutputIterator>(__nm, __refs) {}\n\nprotected:\n    _LIBCPP_ALWAYS_INLINE\n    ~time_put_byname() {}\n};\n\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS time_put_byname<char>)\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS time_put_byname<wchar_t>)\n\n// money_base\n\nclass _LIBCPP_TYPE_VIS money_base\n{\npublic:\n    enum part {none, space, symbol, sign, value};\n    struct pattern {char field[4];};\n\n    _LIBCPP_ALWAYS_INLINE money_base() {}\n};\n\n// moneypunct\n\ntemplate <class _CharT, bool _International = false>\nclass _LIBCPP_TEMPLATE_VIS moneypunct\n    : public locale::facet,\n      public money_base\n{\npublic:\n    typedef _CharT                  char_type;\n    typedef basic_string<char_type> string_type;\n\n    _LIBCPP_ALWAYS_INLINE\n    explicit moneypunct(size_t __refs = 0)\n        : locale::facet(__refs) {}\n\n    _LIBCPP_ALWAYS_INLINE char_type   decimal_point() const {return do_decimal_point();}\n    _LIBCPP_ALWAYS_INLINE char_type   thousands_sep() const {return do_thousands_sep();}\n    _LIBCPP_ALWAYS_INLINE string      grouping()      const {return do_grouping();}\n    _LIBCPP_ALWAYS_INLINE string_type curr_symbol()   const {return do_curr_symbol();}\n    _LIBCPP_ALWAYS_INLINE string_type positive_sign() const {return do_positive_sign();}\n    _LIBCPP_ALWAYS_INLINE string_type negative_sign() const {return do_negative_sign();}\n    _LIBCPP_ALWAYS_INLINE int         frac_digits()   const {return do_frac_digits();}\n    _LIBCPP_ALWAYS_INLINE pattern     pos_format()    const {return do_pos_format();}\n    _LIBCPP_ALWAYS_INLINE pattern     neg_format()    const {return do_neg_format();}\n\n    static locale::id id;\n    static const bool intl = _International;\n\nprotected:\n    _LIBCPP_ALWAYS_INLINE\n    ~moneypunct() {}\n\n    virtual char_type   do_decimal_point() const {return numeric_limits<char_type>::max();}\n    virtual char_type   do_thousands_sep() const {return numeric_limits<char_type>::max();}\n    virtual string      do_grouping()      const {return string();}\n    virtual string_type do_curr_symbol()   const {return string_type();}\n    virtual string_type do_positive_sign() const {return string_type();}\n    virtual string_type do_negative_sign() const {return string_type(1, '-');}\n    virtual int         do_frac_digits()   const {return 0;}\n    virtual pattern     do_pos_format()    const\n        {pattern __p = {{symbol, sign, none, value}}; return __p;}\n    virtual pattern     do_neg_format()    const\n        {pattern __p = {{symbol, sign, none, value}}; return __p;}\n};\n\ntemplate <class _CharT, bool _International>\nlocale::id\nmoneypunct<_CharT, _International>::id;\n\ntemplate <class _CharT, bool _International>\nconst bool\nmoneypunct<_CharT, _International>::intl;\n\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS moneypunct<char, false>)\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS moneypunct<char, true>)\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS moneypunct<wchar_t, false>)\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS moneypunct<wchar_t, true>)\n\n// moneypunct_byname\n\ntemplate <class _CharT, bool _International = false>\nclass _LIBCPP_TEMPLATE_VIS moneypunct_byname\n    : public moneypunct<_CharT, _International>\n{\npublic:\n    typedef money_base::pattern  pattern;\n    typedef _CharT                  char_type;\n    typedef basic_string<char_type> string_type;\n\n    _LIBCPP_ALWAYS_INLINE\n    explicit moneypunct_byname(const char* __nm, size_t __refs = 0)\n        : moneypunct<_CharT, _International>(__refs) {init(__nm);}\n\n    _LIBCPP_ALWAYS_INLINE\n    explicit moneypunct_byname(const string& __nm, size_t __refs = 0)\n        : moneypunct<_CharT, _International>(__refs) {init(__nm.c_str());}\n\nprotected:\n    _LIBCPP_ALWAYS_INLINE\n    ~moneypunct_byname() {}\n\n    virtual char_type   do_decimal_point() const {return __decimal_point_;}\n    virtual char_type   do_thousands_sep() const {return __thousands_sep_;}\n    virtual string      do_grouping()      const {return __grouping_;}\n    virtual string_type do_curr_symbol()   const {return __curr_symbol_;}\n    virtual string_type do_positive_sign() const {return __positive_sign_;}\n    virtual string_type do_negative_sign() const {return __negative_sign_;}\n    virtual int         do_frac_digits()   const {return __frac_digits_;}\n    virtual pattern     do_pos_format()    const {return __pos_format_;}\n    virtual pattern     do_neg_format()    const {return __neg_format_;}\n\nprivate:\n    char_type   __decimal_point_;\n    char_type   __thousands_sep_;\n    string      __grouping_;\n    string_type __curr_symbol_;\n    string_type __positive_sign_;\n    string_type __negative_sign_;\n    int         __frac_digits_;\n    pattern     __pos_format_;\n    pattern     __neg_format_;\n\n    void init(const char*);\n};\n\ntemplate<> void moneypunct_byname<char, false>::init(const char*);\ntemplate<> void moneypunct_byname<char, true>::init(const char*);\ntemplate<> void moneypunct_byname<wchar_t, false>::init(const char*);\ntemplate<> void moneypunct_byname<wchar_t, true>::init(const char*);\n\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS moneypunct_byname<char, false>)\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS moneypunct_byname<char, true>)\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS moneypunct_byname<wchar_t, false>)\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS moneypunct_byname<wchar_t, true>)\n\n// money_get\n\ntemplate <class _CharT>\nclass __money_get\n{\nprotected:\n    typedef _CharT                  char_type;\n    typedef basic_string<char_type> string_type;\n\n    _LIBCPP_ALWAYS_INLINE __money_get() {}\n\n    static void __gather_info(bool __intl, const locale& __loc,\n                              money_base::pattern& __pat, char_type& __dp,\n                              char_type& __ts, string& __grp,\n                              string_type& __sym, string_type& __psn,\n                              string_type& __nsn, int& __fd);\n};\n\ntemplate <class _CharT>\nvoid\n__money_get<_CharT>::__gather_info(bool __intl, const locale& __loc,\n                                   money_base::pattern& __pat, char_type& __dp,\n                                   char_type& __ts, string& __grp,\n                                   string_type& __sym, string_type& __psn,\n                                   string_type& __nsn, int& __fd)\n{\n    if (__intl)\n    {\n        const moneypunct<char_type, true>& __mp =\n            use_facet<moneypunct<char_type, true> >(__loc);\n        __pat = __mp.neg_format();\n        __nsn = __mp.negative_sign();\n        __psn = __mp.positive_sign();\n        __dp = __mp.decimal_point();\n        __ts = __mp.thousands_sep();\n        __grp = __mp.grouping();\n        __sym = __mp.curr_symbol();\n        __fd = __mp.frac_digits();\n    }\n    else\n    {\n        const moneypunct<char_type, false>& __mp =\n            use_facet<moneypunct<char_type, false> >(__loc);\n        __pat = __mp.neg_format();\n        __nsn = __mp.negative_sign();\n        __psn = __mp.positive_sign();\n        __dp = __mp.decimal_point();\n        __ts = __mp.thousands_sep();\n        __grp = __mp.grouping();\n        __sym = __mp.curr_symbol();\n        __fd = __mp.frac_digits();\n    }\n}\n\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS __money_get<char>)\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS __money_get<wchar_t>)\n\ntemplate <class _CharT, class _InputIterator = istreambuf_iterator<_CharT> >\nclass _LIBCPP_TEMPLATE_VIS money_get\n    : public locale::facet,\n      private __money_get<_CharT>\n{\npublic:\n    typedef _CharT                  char_type;\n    typedef _InputIterator          iter_type;\n    typedef basic_string<char_type> string_type;\n\n    _LIBCPP_ALWAYS_INLINE\n    explicit money_get(size_t __refs = 0)\n        : locale::facet(__refs) {}\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type get(iter_type __b, iter_type __e, bool __intl, ios_base& __iob,\n                  ios_base::iostate& __err, long double& __v) const\n    {\n        return do_get(__b, __e, __intl, __iob, __err, __v);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type get(iter_type __b, iter_type __e, bool __intl, ios_base& __iob,\n                  ios_base::iostate& __err, string_type& __v) const\n    {\n        return do_get(__b, __e, __intl, __iob, __err, __v);\n    }\n\n    static locale::id id;\n\nprotected:\n\n    _LIBCPP_ALWAYS_INLINE\n    ~money_get() {}\n\n    virtual iter_type do_get(iter_type __b, iter_type __e, bool __intl,\n                             ios_base& __iob, ios_base::iostate& __err,\n                             long double& __v) const;\n    virtual iter_type do_get(iter_type __b, iter_type __e, bool __intl,\n                             ios_base& __iob, ios_base::iostate& __err,\n                             string_type& __v) const;\n\nprivate:\n    static bool __do_get(iter_type& __b, iter_type __e,\n                         bool __intl, const locale& __loc,\n                         ios_base::fmtflags __flags, ios_base::iostate& __err,\n                         bool& __neg, const ctype<char_type>& __ct,\n                         unique_ptr<char_type, void(*)(void*)>& __wb,\n                         char_type*& __wn, char_type* __we);\n};\n\ntemplate <class _CharT, class _InputIterator>\nlocale::id\nmoney_get<_CharT, _InputIterator>::id;\n\n_LIBCPP_FUNC_VIS void __do_nothing(void*);\n\ntemplate <class _Tp>\n_LIBCPP_HIDDEN\nvoid\n__double_or_nothing(unique_ptr<_Tp, void(*)(void*)>& __b, _Tp*& __n, _Tp*& __e)\n{\n    bool __owns = __b.get_deleter() != __do_nothing;\n    size_t __cur_cap = static_cast<size_t>(__e-__b.get()) * sizeof(_Tp);\n    size_t __new_cap = __cur_cap < numeric_limits<size_t>::max() / 2 ?\n                       2 * __cur_cap : numeric_limits<size_t>::max();\n    if (__new_cap == 0)\n        __new_cap = sizeof(_Tp);\n    size_t __n_off = static_cast<size_t>(__n - __b.get());\n    _Tp* __t = (_Tp*)realloc(__owns ? __b.get() : 0, __new_cap);\n    if (__t == 0)\n        __throw_bad_alloc();\n    if (__owns)\n        __b.release();\n    __b = unique_ptr<_Tp, void(*)(void*)>(__t, free);\n    __new_cap /= sizeof(_Tp);\n    __n = __b.get() + __n_off;\n    __e = __b.get() + __new_cap;\n}\n\n// true == success\ntemplate <class _CharT, class _InputIterator>\nbool\nmoney_get<_CharT, _InputIterator>::__do_get(iter_type& __b, iter_type __e,\n                                            bool __intl, const locale& __loc,\n                                            ios_base::fmtflags __flags,\n                                            ios_base::iostate& __err,\n                                            bool& __neg,\n                                            const ctype<char_type>& __ct,\n                                            unique_ptr<char_type, void(*)(void*)>& __wb,\n                                            char_type*& __wn, char_type* __we)\n{\n    const unsigned __bz = 100;\n    unsigned __gbuf[__bz];\n    unique_ptr<unsigned, void(*)(void*)> __gb(__gbuf, __do_nothing);\n    unsigned* __gn = __gb.get();\n    unsigned* __ge = __gn + __bz;\n    money_base::pattern __pat;\n    char_type __dp;\n    char_type __ts;\n    string __grp;\n    string_type __sym;\n    string_type __psn;\n    string_type __nsn;\n    // Capture the spaces read into money_base::{space,none} so they\n    // can be compared to initial spaces in __sym.\n    string_type __spaces;\n    int __fd;\n    __money_get<_CharT>::__gather_info(__intl, __loc, __pat, __dp, __ts, __grp,\n                                       __sym, __psn, __nsn, __fd);\n    const string_type* __trailing_sign = 0;\n    __wn = __wb.get();\n    for (unsigned __p = 0; __p < 4 && __b != __e; ++__p)\n    {\n        switch (__pat.field[__p])\n        {\n        case money_base::space:\n            if (__p != 3)\n            {\n                if (__ct.is(ctype_base::space, *__b))\n                    __spaces.push_back(*__b++);\n                else\n                {\n                    __err |= ios_base::failbit;\n                    return false;\n                }\n            }\n            // drop through\n        case money_base::none:\n            if (__p != 3)\n            {\n                while (__b != __e && __ct.is(ctype_base::space, *__b))\n                    __spaces.push_back(*__b++);\n            }\n            break;\n        case money_base::sign:\n            if (__psn.size() + __nsn.size() > 0)\n            {\n                if (__psn.size() == 0 || __nsn.size() == 0)\n                {   // sign is optional\n                    if (__psn.size() > 0)\n                    {   // __nsn.size() == 0\n                        if (*__b == __psn[0])\n                        {\n                            ++__b;\n                            if (__psn.size() > 1)\n                                __trailing_sign = &__psn;\n                        }\n                        else\n                            __neg = true;\n                    }\n                    else if (*__b == __nsn[0])  // __nsn.size() > 0 &&  __psn.size() == 0\n                    {\n                        ++__b;\n                        __neg = true;\n                        if (__nsn.size() > 1)\n                            __trailing_sign = &__nsn;\n                    }\n                }\n                else  // sign is required\n                {\n                    if (*__b == __psn[0])\n                    {\n                        ++__b;\n                        if (__psn.size() > 1)\n                            __trailing_sign = &__psn;\n                    }\n                    else if (*__b == __nsn[0])\n                    {\n                        ++__b;\n                        __neg = true;\n                        if (__nsn.size() > 1)\n                            __trailing_sign = &__nsn;\n                    }\n                    else\n                    {\n                        __err |= ios_base::failbit;\n                        return false;\n                    }\n                }\n            }\n            break;\n        case money_base::symbol:\n            {\n            bool __more_needed = __trailing_sign ||\n                                 (__p < 2)       ||\n                                 (__p == 2 && __pat.field[3] != static_cast<char>(money_base::none));\n            bool __sb = (__flags & ios_base::showbase) != 0;\n            if (__sb || __more_needed)\n            {\n                typename string_type::const_iterator __sym_space_end = __sym.begin();\n                if (__p > 0 && (__pat.field[__p - 1] == money_base::none ||\n                                __pat.field[__p - 1] == money_base::space)) {\n                    // Match spaces we've already read against spaces at\n                    // the beginning of __sym.\n                    while (__sym_space_end != __sym.end() &&\n                           __ct.is(ctype_base::space, *__sym_space_end))\n                        ++__sym_space_end;\n                    const size_t __num_spaces = __sym_space_end - __sym.begin();\n                    if (__num_spaces > __spaces.size() ||\n                        !equal(__spaces.end() - __num_spaces, __spaces.end(),\n                               __sym.begin())) {\n                        // No match. Put __sym_space_end back at the\n                        // beginning of __sym, which will prevent a\n                        // match in the next loop.\n                        __sym_space_end = __sym.begin();\n                    }\n                }\n                typename string_type::const_iterator __sym_curr_char = __sym_space_end;\n                while (__sym_curr_char != __sym.end() && __b != __e &&\n                       *__b == *__sym_curr_char) {\n                    ++__b;\n                    ++__sym_curr_char;\n                }\n                if (__sb && __sym_curr_char != __sym.end())\n                {\n                    __err |= ios_base::failbit;\n                    return false;\n                }\n            }\n            }\n            break;\n        case money_base::value:\n            {\n            unsigned __ng = 0;\n            for (; __b != __e; ++__b)\n            {\n                char_type __c = *__b;\n                if (__ct.is(ctype_base::digit, __c))\n                {\n                    if (__wn == __we)\n                        __double_or_nothing(__wb, __wn, __we);\n                    *__wn++ = __c;\n                    ++__ng;\n                }\n                else if (__grp.size() > 0 && __ng > 0 && __c == __ts)\n                {\n                    if (__gn == __ge)\n                        __double_or_nothing(__gb, __gn, __ge);\n                    *__gn++ = __ng;\n                    __ng = 0;\n                }\n                else\n                    break;\n            }\n            if (__gb.get() != __gn && __ng > 0)\n            {\n                if (__gn == __ge)\n                    __double_or_nothing(__gb, __gn, __ge);\n                *__gn++ = __ng;\n            }\n            if (__fd > 0)\n            {\n                if (__b == __e || *__b != __dp)\n                {\n                    __err |= ios_base::failbit;\n                    return false;\n                }\n                for (++__b; __fd > 0; --__fd, ++__b)\n                {\n                    if (__b == __e || !__ct.is(ctype_base::digit, *__b))\n                    {\n                        __err |= ios_base::failbit;\n                        return false;\n                    }\n                    if (__wn == __we)\n                        __double_or_nothing(__wb, __wn, __we);\n                    *__wn++ = *__b;\n                }\n            }\n            if (__wn == __wb.get())\n            {\n                __err |= ios_base::failbit;\n                return false;\n            }\n            }\n            break;\n        }\n    }\n    if (__trailing_sign)\n    {\n        for (unsigned __i = 1; __i < __trailing_sign->size(); ++__i, ++__b)\n        {\n            if (__b == __e || *__b != (*__trailing_sign)[__i])\n            {\n                __err |= ios_base::failbit;\n                return false;\n            }\n        }\n    }\n    if (__gb.get() != __gn)\n    {\n        ios_base::iostate __et = ios_base::goodbit;\n        __check_grouping(__grp, __gb.get(), __gn, __et);\n        if (__et)\n        {\n            __err |= ios_base::failbit;\n            return false;\n        }\n    }\n    return true;\n}\n\ntemplate <class _CharT, class _InputIterator>\n_InputIterator\nmoney_get<_CharT, _InputIterator>::do_get(iter_type __b, iter_type __e,\n                                          bool __intl, ios_base& __iob,\n                                          ios_base::iostate& __err,\n                                          long double& __v) const\n{\n    const int __bz = 100;\n    char_type __wbuf[__bz];\n    unique_ptr<char_type, void(*)(void*)> __wb(__wbuf, __do_nothing);\n    char_type* __wn;\n    char_type* __we = __wbuf + __bz;\n    locale __loc = __iob.getloc();\n    const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__loc);\n    bool __neg = false;\n    if (__do_get(__b, __e, __intl, __loc, __iob.flags(), __err, __neg, __ct,\n                 __wb, __wn, __we))\n    {\n        const char __src[] = \"0123456789\";\n        char_type __atoms[sizeof(__src)-1];\n        __ct.widen(__src, __src + (sizeof(__src)-1), __atoms);\n        char __nbuf[__bz];\n        char* __nc = __nbuf;\n        unique_ptr<char, void(*)(void*)> __h(0, free);\n        if (__wn - __wb.get() > __bz-2)\n        {\n            __h.reset((char*)malloc(static_cast<size_t>(__wn - __wb.get() + 2)));\n            if (__h.get() == 0)\n                __throw_bad_alloc();\n            __nc = __h.get();\n        }\n        if (__neg)\n            *__nc++ = '-';\n        for (const char_type* __w = __wb.get(); __w < __wn; ++__w, ++__nc)\n            *__nc = __src[find(__atoms, _VSTD::end(__atoms), *__w) - __atoms];\n        *__nc = char();\n        if (sscanf(__nbuf, \"%Lf\", &__v) != 1)\n            __throw_runtime_error(\"money_get error\");\n    }\n    if (__b == __e)\n        __err |= ios_base::eofbit;\n    return __b;\n}\n\ntemplate <class _CharT, class _InputIterator>\n_InputIterator\nmoney_get<_CharT, _InputIterator>::do_get(iter_type __b, iter_type __e,\n                                          bool __intl, ios_base& __iob,\n                                          ios_base::iostate& __err,\n                                          string_type& __v) const\n{\n    const int __bz = 100;\n    char_type __wbuf[__bz];\n    unique_ptr<char_type, void(*)(void*)> __wb(__wbuf, __do_nothing);\n    char_type* __wn;\n    char_type* __we = __wbuf + __bz;\n    locale __loc = __iob.getloc();\n    const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__loc);\n    bool __neg = false;\n    if (__do_get(__b, __e, __intl, __loc, __iob.flags(), __err, __neg, __ct,\n                 __wb, __wn, __we))\n    {\n        __v.clear();\n        if (__neg)\n            __v.push_back(__ct.widen('-'));\n        char_type __z = __ct.widen('0');\n        char_type* __w;\n        for (__w = __wb.get(); __w < __wn-1; ++__w)\n            if (*__w != __z)\n                break;\n        __v.append(__w, __wn);\n    }\n    if (__b == __e)\n        __err |= ios_base::eofbit;\n    return __b;\n}\n\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS money_get<char>)\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS money_get<wchar_t>)\n\n// money_put\n\ntemplate <class _CharT>\nclass __money_put\n{\nprotected:\n    typedef _CharT                  char_type;\n    typedef basic_string<char_type> string_type;\n\n    _LIBCPP_ALWAYS_INLINE __money_put() {}\n\n    static void __gather_info(bool __intl, bool __neg, const locale& __loc,\n                              money_base::pattern& __pat, char_type& __dp,\n                              char_type& __ts, string& __grp,\n                              string_type& __sym, string_type& __sn,\n                              int& __fd);\n    static void __format(char_type* __mb, char_type*& __mi, char_type*& __me,\n                         ios_base::fmtflags __flags,\n                         const char_type* __db, const char_type* __de,\n                         const ctype<char_type>& __ct, bool __neg,\n                         const money_base::pattern& __pat, char_type __dp,\n                         char_type __ts, const string& __grp,\n                         const string_type& __sym, const string_type& __sn,\n                         int __fd);\n};\n\ntemplate <class _CharT>\nvoid\n__money_put<_CharT>::__gather_info(bool __intl, bool __neg, const locale& __loc,\n                                   money_base::pattern& __pat, char_type& __dp,\n                                   char_type& __ts, string& __grp,\n                                   string_type& __sym, string_type& __sn,\n                                   int& __fd)\n{\n    if (__intl)\n    {\n        const moneypunct<char_type, true>& __mp =\n            use_facet<moneypunct<char_type, true> >(__loc);\n        if (__neg)\n        {\n            __pat = __mp.neg_format();\n            __sn = __mp.negative_sign();\n        }\n        else\n        {\n            __pat = __mp.pos_format();\n            __sn = __mp.positive_sign();\n        }\n        __dp = __mp.decimal_point();\n        __ts = __mp.thousands_sep();\n        __grp = __mp.grouping();\n        __sym = __mp.curr_symbol();\n        __fd = __mp.frac_digits();\n    }\n    else\n    {\n        const moneypunct<char_type, false>& __mp =\n            use_facet<moneypunct<char_type, false> >(__loc);\n        if (__neg)\n        {\n            __pat = __mp.neg_format();\n            __sn = __mp.negative_sign();\n        }\n        else\n        {\n            __pat = __mp.pos_format();\n            __sn = __mp.positive_sign();\n        }\n        __dp = __mp.decimal_point();\n        __ts = __mp.thousands_sep();\n        __grp = __mp.grouping();\n        __sym = __mp.curr_symbol();\n        __fd = __mp.frac_digits();\n    }\n}\n\ntemplate <class _CharT>\nvoid\n__money_put<_CharT>::__format(char_type* __mb, char_type*& __mi, char_type*& __me,\n                              ios_base::fmtflags __flags,\n                              const char_type* __db, const char_type* __de,\n                              const ctype<char_type>& __ct, bool __neg,\n                              const money_base::pattern& __pat, char_type __dp,\n                              char_type __ts, const string& __grp,\n                              const string_type& __sym, const string_type& __sn,\n                              int __fd)\n{\n    __me = __mb;\n    for (unsigned __p = 0; __p < 4; ++__p)\n    {\n        switch (__pat.field[__p])\n        {\n        case money_base::none:\n            __mi = __me;\n            break;\n        case money_base::space:\n            __mi = __me;\n            *__me++ = __ct.widen(' ');\n            break;\n        case money_base::sign:\n            if (!__sn.empty())\n                *__me++ = __sn[0];\n            break;\n        case money_base::symbol:\n            if (!__sym.empty() && (__flags & ios_base::showbase))\n                __me = _VSTD::copy(__sym.begin(), __sym.end(), __me);\n            break;\n        case money_base::value:\n            {\n            // remember start of value so we can reverse it\n            char_type* __t = __me;\n            // find beginning of digits\n            if (__neg)\n                ++__db;\n            // find end of digits\n            const char_type* __d;\n            for (__d = __db; __d < __de; ++__d)\n                if (!__ct.is(ctype_base::digit, *__d))\n                    break;\n            // print fractional part\n            if (__fd > 0)\n            {\n                int __f;\n                for (__f = __fd; __d > __db && __f > 0; --__f)\n                    *__me++ = *--__d;\n                char_type __z = __f > 0 ? __ct.widen('0') : char_type();\n                for (; __f > 0; --__f)\n                    *__me++ = __z;\n                *__me++ = __dp;\n            }\n            // print units part\n            if (__d == __db)\n            {\n                *__me++ = __ct.widen('0');\n            }\n            else\n            {\n                unsigned __ng = 0;\n                unsigned __ig = 0;\n                unsigned __gl = __grp.empty() ? numeric_limits<unsigned>::max()\n                                              : static_cast<unsigned>(__grp[__ig]);\n                while (__d != __db)\n                {\n                    if (__ng == __gl)\n                    {\n                        *__me++ = __ts;\n                        __ng = 0;\n                        if (++__ig < __grp.size())\n                            __gl = __grp[__ig] == numeric_limits<char>::max() ?\n                                        numeric_limits<unsigned>::max() :\n                                        static_cast<unsigned>(__grp[__ig]);\n                    }\n                    *__me++ = *--__d;\n                    ++__ng;\n                }\n            }\n            // reverse it\n            reverse(__t, __me);\n            }\n            break;\n        }\n    }\n    // print rest of sign, if any\n    if (__sn.size() > 1)\n        __me = _VSTD::copy(__sn.begin()+1, __sn.end(), __me);\n    // set alignment\n    if ((__flags & ios_base::adjustfield) == ios_base::left)\n        __mi = __me;\n    else if ((__flags & ios_base::adjustfield) != ios_base::internal)\n        __mi = __mb;\n}\n\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS __money_put<char>)\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS __money_put<wchar_t>)\n\ntemplate <class _CharT, class _OutputIterator = ostreambuf_iterator<_CharT> >\nclass _LIBCPP_TEMPLATE_VIS money_put\n    : public locale::facet,\n      private __money_put<_CharT>\n{\npublic:\n    typedef _CharT                  char_type;\n    typedef _OutputIterator         iter_type;\n    typedef basic_string<char_type> string_type;\n\n    _LIBCPP_ALWAYS_INLINE\n    explicit money_put(size_t __refs = 0)\n        : locale::facet(__refs) {}\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type put(iter_type __s, bool __intl, ios_base& __iob, char_type __fl,\n                  long double __units) const\n    {\n        return do_put(__s, __intl, __iob, __fl, __units);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type put(iter_type __s, bool __intl, ios_base& __iob, char_type __fl,\n                  const string_type& __digits) const\n    {\n        return do_put(__s, __intl, __iob, __fl, __digits);\n    }\n\n    static locale::id id;\n\nprotected:\n    _LIBCPP_ALWAYS_INLINE\n    ~money_put() {}\n\n    virtual iter_type do_put(iter_type __s, bool __intl, ios_base& __iob,\n                             char_type __fl, long double __units) const;\n    virtual iter_type do_put(iter_type __s, bool __intl, ios_base& __iob,\n                             char_type __fl, const string_type& __digits) const;\n};\n\ntemplate <class _CharT, class _OutputIterator>\nlocale::id\nmoney_put<_CharT, _OutputIterator>::id;\n\ntemplate <class _CharT, class _OutputIterator>\n_OutputIterator\nmoney_put<_CharT, _OutputIterator>::do_put(iter_type __s, bool __intl,\n                                           ios_base& __iob, char_type __fl,\n                                           long double __units) const\n{\n    // convert to char\n    const size_t __bs = 100;\n    char __buf[__bs];\n    char* __bb = __buf;\n    char_type __digits[__bs];\n    char_type* __db = __digits;\n    size_t __n = static_cast<size_t>(snprintf(__bb, __bs, \"%.0Lf\", __units));\n    unique_ptr<char, void(*)(void*)> __hn(0, free);\n    unique_ptr<char_type, void(*)(void*)> __hd(0, free);\n    // secure memory for digit storage\n    if (__n > __bs-1)\n    {\n        __n = static_cast<size_t>(__libcpp_asprintf_l(&__bb, _LIBCPP_GET_C_LOCALE, \"%.0Lf\", __units));\n        if (__bb == 0)\n            __throw_bad_alloc();\n        __hn.reset(__bb);\n        __hd.reset((char_type*)malloc(__n * sizeof(char_type)));\n        if (__hd == nullptr)\n            __throw_bad_alloc();\n        __db = __hd.get();\n    }\n    // gather info\n    locale __loc = __iob.getloc();\n    const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__loc);\n    __ct.widen(__bb, __bb + __n, __db);\n    bool __neg = __n > 0 && __bb[0] == '-';\n    money_base::pattern __pat;\n    char_type __dp;\n    char_type __ts;\n    string __grp;\n    string_type __sym;\n    string_type __sn;\n    int __fd;\n    this->__gather_info(__intl, __neg, __loc, __pat, __dp, __ts, __grp, __sym, __sn, __fd);\n    // secure memory for formatting\n    char_type __mbuf[__bs];\n    char_type* __mb = __mbuf;\n    unique_ptr<char_type, void(*)(void*)> __hw(0, free);\n    size_t __exn = static_cast<int>(__n) > __fd ?\n                   (__n - static_cast<size_t>(__fd)) * 2 + __sn.size() +\n                    __sym.size() + static_cast<size_t>(__fd) + 1\n                 : __sn.size() + __sym.size() + static_cast<size_t>(__fd) + 2;\n    if (__exn > __bs)\n    {\n        __hw.reset((char_type*)malloc(__exn * sizeof(char_type)));\n        __mb = __hw.get();\n        if (__mb == 0)\n            __throw_bad_alloc();\n    }\n    // format\n    char_type* __mi;\n    char_type* __me;\n    this->__format(__mb, __mi, __me, __iob.flags(),\n                   __db, __db + __n, __ct,\n                   __neg, __pat, __dp, __ts, __grp, __sym, __sn, __fd);\n    return __pad_and_output(__s, __mb, __mi, __me, __iob, __fl);\n}\n\ntemplate <class _CharT, class _OutputIterator>\n_OutputIterator\nmoney_put<_CharT, _OutputIterator>::do_put(iter_type __s, bool __intl,\n                                           ios_base& __iob, char_type __fl,\n                                           const string_type& __digits) const\n{\n    // gather info\n    locale __loc = __iob.getloc();\n    const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__loc);\n    bool __neg = __digits.size() > 0 && __digits[0] == __ct.widen('-');\n    money_base::pattern __pat;\n    char_type __dp;\n    char_type __ts;\n    string __grp;\n    string_type __sym;\n    string_type __sn;\n    int __fd;\n    this->__gather_info(__intl, __neg, __loc, __pat, __dp, __ts, __grp, __sym, __sn, __fd);\n    // secure memory for formatting\n    char_type __mbuf[100];\n    char_type* __mb = __mbuf;\n    unique_ptr<char_type, void(*)(void*)> __h(0, free);\n    size_t __exn = static_cast<int>(__digits.size()) > __fd ?\n                   (__digits.size() - static_cast<size_t>(__fd)) * 2 +\n                    __sn.size() + __sym.size() + static_cast<size_t>(__fd) + 1\n                 : __sn.size() + __sym.size() + static_cast<size_t>(__fd) + 2;\n    if (__exn > 100)\n    {\n        __h.reset((char_type*)malloc(__exn * sizeof(char_type)));\n        __mb = __h.get();\n        if (__mb == 0)\n            __throw_bad_alloc();\n    }\n    // format\n    char_type* __mi;\n    char_type* __me;\n    this->__format(__mb, __mi, __me, __iob.flags(),\n                   __digits.data(), __digits.data() + __digits.size(), __ct,\n                   __neg, __pat, __dp, __ts, __grp, __sym, __sn, __fd);\n    return __pad_and_output(__s, __mb, __mi, __me, __iob, __fl);\n}\n\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS money_put<char>)\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS money_put<wchar_t>)\n\n// messages\n\nclass _LIBCPP_TYPE_VIS messages_base\n{\npublic:\n    typedef ptrdiff_t catalog;\n\n    _LIBCPP_ALWAYS_INLINE messages_base() {}\n};\n\ntemplate <class _CharT>\nclass _LIBCPP_TEMPLATE_VIS messages\n    : public locale::facet,\n      public messages_base\n{\npublic:\n    typedef _CharT               char_type;\n    typedef basic_string<_CharT> string_type;\n\n    _LIBCPP_ALWAYS_INLINE\n    explicit messages(size_t __refs = 0)\n        : locale::facet(__refs) {}\n\n    _LIBCPP_ALWAYS_INLINE\n    catalog open(const basic_string<char>& __nm, const locale& __loc) const\n    {\n        return do_open(__nm, __loc);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    string_type get(catalog __c, int __set, int __msgid,\n                    const string_type& __dflt) const\n    {\n        return do_get(__c, __set, __msgid, __dflt);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    void close(catalog __c) const\n    {\n        do_close(__c);\n    }\n\n    static locale::id id;\n\nprotected:\n    _LIBCPP_ALWAYS_INLINE\n    ~messages() {}\n\n    virtual catalog do_open(const basic_string<char>&, const locale&) const;\n    virtual string_type do_get(catalog, int __set, int __msgid,\n                               const string_type& __dflt) const;\n    virtual void do_close(catalog) const;\n};\n\ntemplate <class _CharT>\nlocale::id\nmessages<_CharT>::id;\n\ntemplate <class _CharT>\ntypename messages<_CharT>::catalog\nmessages<_CharT>::do_open(const basic_string<char>& __nm, const locale&) const\n{\n#ifdef _LIBCPP_HAS_CATOPEN\n    catalog __cat = (catalog)catopen(__nm.c_str(), NL_CAT_LOCALE);\n    if (__cat != -1)\n        __cat = static_cast<catalog>((static_cast<size_t>(__cat) >> 1));\n    return __cat;\n#else // !_LIBCPP_HAS_CATOPEN\n    return -1;\n#endif // _LIBCPP_HAS_CATOPEN\n}\n\ntemplate <class _CharT>\ntypename messages<_CharT>::string_type\nmessages<_CharT>::do_get(catalog __c, int __set, int __msgid,\n                         const string_type& __dflt) const\n{\n#ifdef _LIBCPP_HAS_CATOPEN\n    string __ndflt;\n    __narrow_to_utf8<sizeof(char_type)*__CHAR_BIT__>()(back_inserter(__ndflt),\n                                                       __dflt.c_str(),\n                                                       __dflt.c_str() + __dflt.size());\n    if (__c != -1)\n        __c <<= 1;\n    nl_catd __cat = (nl_catd)__c;\n    char* __n = catgets(__cat, __set, __msgid, __ndflt.c_str());\n    string_type __w;\n    __widen_from_utf8<sizeof(char_type)*__CHAR_BIT__>()(back_inserter(__w),\n                                                        __n, __n + strlen(__n));\n    return __w;\n#else // !_LIBCPP_HAS_CATOPEN\n    return __dflt;\n#endif // _LIBCPP_HAS_CATOPEN\n}\n\ntemplate <class _CharT>\nvoid\nmessages<_CharT>::do_close(catalog __c) const\n{\n#ifdef _LIBCPP_HAS_CATOPEN\n    if (__c != -1)\n        __c <<= 1;\n    nl_catd __cat = (nl_catd)__c;\n    catclose(__cat);\n#endif // _LIBCPP_HAS_CATOPEN\n}\n\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS messages<char>)\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS messages<wchar_t>)\n\ntemplate <class _CharT>\nclass _LIBCPP_TEMPLATE_VIS messages_byname\n    : public messages<_CharT>\n{\npublic:\n    typedef messages_base::catalog catalog;\n    typedef basic_string<_CharT> string_type;\n\n    _LIBCPP_ALWAYS_INLINE\n    explicit messages_byname(const char*, size_t __refs = 0)\n        : messages<_CharT>(__refs) {}\n\n    _LIBCPP_ALWAYS_INLINE\n    explicit messages_byname(const string&, size_t __refs = 0)\n        : messages<_CharT>(__refs) {}\n\nprotected:\n    _LIBCPP_ALWAYS_INLINE\n    ~messages_byname() {}\n};\n\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS messages_byname<char>)\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS messages_byname<wchar_t>)\n\ntemplate<class _Codecvt, class _Elem = wchar_t,\n         class _Wide_alloc = allocator<_Elem>,\n         class _Byte_alloc = allocator<char> >\nclass _LIBCPP_TEMPLATE_VIS wstring_convert\n{\npublic:\n    typedef basic_string<char, char_traits<char>, _Byte_alloc>   byte_string;\n    typedef basic_string<_Elem, char_traits<_Elem>, _Wide_alloc> wide_string;\n    typedef typename _Codecvt::state_type                        state_type;\n    typedef typename wide_string::traits_type::int_type          int_type;\n\nprivate:\n    byte_string __byte_err_string_;\n    wide_string __wide_err_string_;\n    _Codecvt* __cvtptr_;\n    state_type __cvtstate_;\n    size_t __cvtcount_;\n\n    wstring_convert(const wstring_convert& __wc);\n    wstring_convert& operator=(const wstring_convert& __wc);\npublic:\n    _LIBCPP_ALWAYS_INLINE\n    _LIBCPP_EXPLICIT_AFTER_CXX11 wstring_convert(_Codecvt* __pcvt = new _Codecvt);\n    _LIBCPP_ALWAYS_INLINE\n    wstring_convert(_Codecvt* __pcvt, state_type __state);\n    _LIBCPP_EXPLICIT_AFTER_CXX11 wstring_convert(const byte_string& __byte_err,\n                    const wide_string& __wide_err = wide_string());\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_ALWAYS_INLINE\n    wstring_convert(wstring_convert&& __wc);\n#endif\n    ~wstring_convert();\n\n    _LIBCPP_ALWAYS_INLINE\n    wide_string from_bytes(char __byte)\n        {return from_bytes(&__byte, &__byte+1);}\n    _LIBCPP_ALWAYS_INLINE\n    wide_string from_bytes(const char* __ptr)\n        {return from_bytes(__ptr, __ptr + char_traits<char>::length(__ptr));}\n    _LIBCPP_ALWAYS_INLINE\n    wide_string from_bytes(const byte_string& __str)\n        {return from_bytes(__str.data(), __str.data() + __str.size());}\n    wide_string from_bytes(const char* __first, const char* __last);\n\n    _LIBCPP_ALWAYS_INLINE\n    byte_string to_bytes(_Elem __wchar)\n        {return to_bytes(&__wchar, &__wchar+1);}\n    _LIBCPP_ALWAYS_INLINE\n    byte_string to_bytes(const _Elem* __wptr)\n        {return to_bytes(__wptr, __wptr + char_traits<_Elem>::length(__wptr));}\n    _LIBCPP_ALWAYS_INLINE\n    byte_string to_bytes(const wide_string& __wstr)\n        {return to_bytes(__wstr.data(), __wstr.data() + __wstr.size());}\n    byte_string to_bytes(const _Elem* __first, const _Elem* __last);\n\n    _LIBCPP_ALWAYS_INLINE\n    size_t converted() const _NOEXCEPT {return __cvtcount_;}\n    _LIBCPP_ALWAYS_INLINE\n    state_type state() const {return __cvtstate_;}\n};\n\ntemplate<class _Codecvt, class _Elem, class _Wide_alloc, class _Byte_alloc>\ninline\nwstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>::\n    wstring_convert(_Codecvt* __pcvt)\n        : __cvtptr_(__pcvt), __cvtstate_(), __cvtcount_(0)\n{\n}\n\ntemplate<class _Codecvt, class _Elem, class _Wide_alloc, class _Byte_alloc>\ninline\nwstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>::\n    wstring_convert(_Codecvt* __pcvt, state_type __state)\n        : __cvtptr_(__pcvt), __cvtstate_(__state), __cvtcount_(0)\n{\n}\n\ntemplate<class _Codecvt, class _Elem, class _Wide_alloc, class _Byte_alloc>\nwstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>::\n    wstring_convert(const byte_string& __byte_err, const wide_string& __wide_err)\n        : __byte_err_string_(__byte_err), __wide_err_string_(__wide_err),\n          __cvtstate_(), __cvtcount_(0)\n{\n    __cvtptr_ = new _Codecvt;\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _Codecvt, class _Elem, class _Wide_alloc, class _Byte_alloc>\ninline\nwstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>::\n    wstring_convert(wstring_convert&& __wc)\n        : __byte_err_string_(_VSTD::move(__wc.__byte_err_string_)),\n          __wide_err_string_(_VSTD::move(__wc.__wide_err_string_)),\n          __cvtptr_(__wc.__cvtptr_),\n          __cvtstate_(__wc.__cvtstate_), __cvtcount_(__wc.__cvtcount_)\n{\n    __wc.__cvtptr_ = nullptr;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _Codecvt, class _Elem, class _Wide_alloc, class _Byte_alloc>\nwstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>::~wstring_convert()\n{\n    delete __cvtptr_;\n}\n\ntemplate<class _Codecvt, class _Elem, class _Wide_alloc, class _Byte_alloc>\ntypename wstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>::wide_string\nwstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>::\n    from_bytes(const char* __frm, const char* __frm_end)\n{\n    __cvtcount_ = 0;\n    if (__cvtptr_ != nullptr)\n    {\n        wide_string __ws(2*(__frm_end - __frm), _Elem());\n        if (__frm != __frm_end)\n            __ws.resize(__ws.capacity());\n        codecvt_base::result __r = codecvt_base::ok;\n        state_type __st = __cvtstate_;\n        if (__frm != __frm_end)\n        {\n            _Elem* __to = &__ws[0];\n            _Elem* __to_end = __to + __ws.size();\n            const char* __frm_nxt;\n            do\n            {\n                _Elem* __to_nxt;\n                __r = __cvtptr_->in(__st, __frm, __frm_end, __frm_nxt,\n                                          __to, __to_end, __to_nxt);\n                __cvtcount_ += __frm_nxt - __frm;\n                if (__frm_nxt == __frm)\n                {\n                    __r = codecvt_base::error;\n                }\n                else if (__r == codecvt_base::noconv)\n                {\n                    __ws.resize(__to - &__ws[0]);\n                    // This only gets executed if _Elem is char\n                    __ws.append((const _Elem*)__frm, (const _Elem*)__frm_end);\n                    __frm = __frm_nxt;\n                    __r = codecvt_base::ok;\n                }\n                else if (__r == codecvt_base::ok)\n                {\n                    __ws.resize(__to_nxt - &__ws[0]);\n                    __frm = __frm_nxt;\n                }\n                else if (__r == codecvt_base::partial)\n                {\n                    ptrdiff_t __s = __to_nxt - &__ws[0];\n                    __ws.resize(2 * __s);\n                    __to = &__ws[0] + __s;\n                    __to_end = &__ws[0] + __ws.size();\n                    __frm = __frm_nxt;\n                }\n            } while (__r == codecvt_base::partial && __frm_nxt < __frm_end);\n        }\n        if (__r == codecvt_base::ok)\n            return __ws;\n    }\n\n    if (__wide_err_string_.empty())\n        __throw_range_error(\"wstring_convert: from_bytes error\");\n\n    return __wide_err_string_;\n}\n\ntemplate<class _Codecvt, class _Elem, class _Wide_alloc, class _Byte_alloc>\ntypename wstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>::byte_string\nwstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>::\n    to_bytes(const _Elem* __frm, const _Elem* __frm_end)\n{\n    __cvtcount_ = 0;\n    if (__cvtptr_ != nullptr)\n    {\n        byte_string __bs(2*(__frm_end - __frm), char());\n        if (__frm != __frm_end)\n            __bs.resize(__bs.capacity());\n        codecvt_base::result __r = codecvt_base::ok;\n        state_type __st = __cvtstate_;\n        if (__frm != __frm_end)\n        {\n            char* __to = &__bs[0];\n            char* __to_end = __to + __bs.size();\n            const _Elem* __frm_nxt;\n            do\n            {\n                char* __to_nxt;\n                __r = __cvtptr_->out(__st, __frm, __frm_end, __frm_nxt,\n                                           __to, __to_end, __to_nxt);\n                __cvtcount_ += __frm_nxt - __frm;\n                if (__frm_nxt == __frm)\n                {\n                    __r = codecvt_base::error;\n                }\n                else if (__r == codecvt_base::noconv)\n                {\n                    __bs.resize(__to - &__bs[0]);\n                    // This only gets executed if _Elem is char\n                    __bs.append((const char*)__frm, (const char*)__frm_end);\n                    __frm = __frm_nxt;\n                    __r = codecvt_base::ok;\n                }\n                else if (__r == codecvt_base::ok)\n                {\n                    __bs.resize(__to_nxt - &__bs[0]);\n                    __frm = __frm_nxt;\n                }\n                else if (__r == codecvt_base::partial)\n                {\n                    ptrdiff_t __s = __to_nxt - &__bs[0];\n                    __bs.resize(2 * __s);\n                    __to = &__bs[0] + __s;\n                    __to_end = &__bs[0] + __bs.size();\n                    __frm = __frm_nxt;\n                }\n            } while (__r == codecvt_base::partial && __frm_nxt < __frm_end);\n        }\n        if (__r == codecvt_base::ok)\n        {\n            size_t __s = __bs.size();\n            __bs.resize(__bs.capacity());\n            char* __to = &__bs[0] + __s;\n            char* __to_end = __to + __bs.size();\n            do\n            {\n                char* __to_nxt;\n                __r = __cvtptr_->unshift(__st, __to, __to_end, __to_nxt);\n                if (__r == codecvt_base::noconv)\n                {\n                    __bs.resize(__to - &__bs[0]);\n                    __r = codecvt_base::ok;\n                }\n                else if (__r == codecvt_base::ok)\n                {\n                    __bs.resize(__to_nxt - &__bs[0]);\n                }\n                else if (__r == codecvt_base::partial)\n                {\n                    ptrdiff_t __sp = __to_nxt - &__bs[0];\n                    __bs.resize(2 * __sp);\n                    __to = &__bs[0] + __sp;\n                    __to_end = &__bs[0] + __bs.size();\n                }\n            } while (__r == codecvt_base::partial);\n            if (__r == codecvt_base::ok)\n                return __bs;\n        }\n    }\n\n    if (__byte_err_string_.empty())\n        __throw_range_error(\"wstring_convert: to_bytes error\");\n\n    return __byte_err_string_;\n}\n\ntemplate <class _Codecvt, class _Elem = wchar_t, class _Tr = char_traits<_Elem> >\nclass _LIBCPP_TEMPLATE_VIS wbuffer_convert\n    : public basic_streambuf<_Elem, _Tr>\n{\npublic:\n    // types:\n    typedef _Elem                          char_type;\n    typedef _Tr                            traits_type;\n    typedef typename traits_type::int_type int_type;\n    typedef typename traits_type::pos_type pos_type;\n    typedef typename traits_type::off_type off_type;\n    typedef typename _Codecvt::state_type  state_type;\n\nprivate:\n    char*       __extbuf_;\n    const char* __extbufnext_;\n    const char* __extbufend_;\n    char __extbuf_min_[8];\n    size_t __ebs_;\n    char_type* __intbuf_;\n    size_t __ibs_;\n    streambuf* __bufptr_;\n    _Codecvt* __cv_;\n    state_type __st_;\n    ios_base::openmode __cm_;\n    bool __owns_eb_;\n    bool __owns_ib_;\n    bool __always_noconv_;\n\n    wbuffer_convert(const wbuffer_convert&);\n    wbuffer_convert& operator=(const wbuffer_convert&);\npublic:\n    _LIBCPP_EXPLICIT_AFTER_CXX11 wbuffer_convert(streambuf* __bytebuf = 0, \n            _Codecvt* __pcvt = new _Codecvt, state_type __state = state_type());\n    ~wbuffer_convert();\n\n    _LIBCPP_INLINE_VISIBILITY\n    streambuf* rdbuf() const {return __bufptr_;}\n    _LIBCPP_INLINE_VISIBILITY\n    streambuf* rdbuf(streambuf* __bytebuf)\n    {\n        streambuf* __r = __bufptr_;\n        __bufptr_ = __bytebuf;\n        return __r;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    state_type state() const {return __st_;}\n\nprotected:\n    virtual int_type underflow();\n    virtual int_type pbackfail(int_type __c = traits_type::eof());\n    virtual int_type overflow (int_type __c = traits_type::eof());\n    virtual basic_streambuf<char_type, traits_type>* setbuf(char_type* __s,\n                                                            streamsize __n);\n    virtual pos_type seekoff(off_type __off, ios_base::seekdir __way,\n                             ios_base::openmode __wch = ios_base::in | ios_base::out);\n    virtual pos_type seekpos(pos_type __sp,\n                             ios_base::openmode __wch = ios_base::in | ios_base::out);\n    virtual int sync();\n\nprivate:\n    bool __read_mode();\n    void __write_mode();\n    wbuffer_convert* __close();\n};\n\ntemplate <class _Codecvt, class _Elem, class _Tr>\nwbuffer_convert<_Codecvt, _Elem, _Tr>::\n    wbuffer_convert(streambuf* __bytebuf, _Codecvt* __pcvt, state_type __state)\n    : __extbuf_(0),\n      __extbufnext_(0),\n      __extbufend_(0),\n      __ebs_(0),\n      __intbuf_(0),\n      __ibs_(0),\n      __bufptr_(__bytebuf),\n      __cv_(__pcvt),\n      __st_(__state),\n      __cm_(0),\n      __owns_eb_(false),\n      __owns_ib_(false),\n      __always_noconv_(__cv_ ? __cv_->always_noconv() : false)\n{\n    setbuf(0, 4096);\n}\n\ntemplate <class _Codecvt, class _Elem, class _Tr>\nwbuffer_convert<_Codecvt, _Elem, _Tr>::~wbuffer_convert()\n{\n    __close();\n    delete __cv_;\n    if (__owns_eb_)\n        delete [] __extbuf_;\n    if (__owns_ib_)\n        delete [] __intbuf_;\n}\n\ntemplate <class _Codecvt, class _Elem, class _Tr>\ntypename wbuffer_convert<_Codecvt, _Elem, _Tr>::int_type\nwbuffer_convert<_Codecvt, _Elem, _Tr>::underflow()\n{\n    if (__cv_ == 0 || __bufptr_ == 0)\n        return traits_type::eof();\n    bool __initial = __read_mode();\n    char_type __1buf;\n    if (this->gptr() == 0)\n        this->setg(&__1buf, &__1buf+1, &__1buf+1);\n    const size_t __unget_sz = __initial ? 0 : min<size_t>((this->egptr() - this->eback()) / 2, 4);\n    int_type __c = traits_type::eof();\n    if (this->gptr() == this->egptr())\n    {\n        memmove(this->eback(), this->egptr() - __unget_sz, __unget_sz * sizeof(char_type));\n        if (__always_noconv_)\n        {\n            streamsize __nmemb = static_cast<streamsize>(this->egptr() - this->eback() - __unget_sz);\n            __nmemb = __bufptr_->sgetn((char*)this->eback() + __unget_sz, __nmemb);\n            if (__nmemb != 0)\n            {\n                this->setg(this->eback(),\n                           this->eback() + __unget_sz,\n                           this->eback() + __unget_sz + __nmemb);\n                __c = *this->gptr();\n            }\n        }\n        else\n        {\n             _LIBCPP_ASSERT(!(__extbufnext_ == NULL && (__extbufend_ != __extbufnext_)), \"underflow moving from NULL\" );\n             if (__extbufend_ != __extbufnext_)\n                memmove(__extbuf_, __extbufnext_, __extbufend_ - __extbufnext_);\n            __extbufnext_ = __extbuf_ + (__extbufend_ - __extbufnext_);\n            __extbufend_ = __extbuf_ + (__extbuf_ == __extbuf_min_ ? sizeof(__extbuf_min_) : __ebs_);\n            streamsize __nmemb = _VSTD::min(static_cast<streamsize>(this->egptr() - this->eback() - __unget_sz),\n                                 static_cast<streamsize>(__extbufend_ - __extbufnext_));\n            codecvt_base::result __r;\n            // FIXME: Do we ever need to restore the state here?\n            //state_type __svs = __st_;\n            streamsize __nr = __bufptr_->sgetn(const_cast<char*>(__extbufnext_), __nmemb);\n            if (__nr != 0)\n            {\n                __extbufend_ = __extbufnext_ + __nr;\n                char_type*  __inext;\n                __r = __cv_->in(__st_, __extbuf_, __extbufend_, __extbufnext_,\n                                       this->eback() + __unget_sz,\n                                       this->egptr(), __inext);\n                if (__r == codecvt_base::noconv)\n                {\n                    this->setg((char_type*)__extbuf_, (char_type*)__extbuf_, (char_type*)__extbufend_);\n                    __c = *this->gptr();\n                }\n                else if (__inext != this->eback() + __unget_sz)\n                {\n                    this->setg(this->eback(), this->eback() + __unget_sz, __inext);\n                    __c = *this->gptr();\n                }\n            }\n        }\n    }\n    else\n        __c = *this->gptr();\n    if (this->eback() == &__1buf)\n        this->setg(0, 0, 0);\n    return __c;\n}\n\ntemplate <class _Codecvt, class _Elem, class _Tr>\ntypename wbuffer_convert<_Codecvt, _Elem, _Tr>::int_type\nwbuffer_convert<_Codecvt, _Elem, _Tr>::pbackfail(int_type __c)\n{\n    if (__cv_ != 0 && __bufptr_ != 0 && this->eback() < this->gptr())\n    {\n        if (traits_type::eq_int_type(__c, traits_type::eof()))\n        {\n            this->gbump(-1);\n            return traits_type::not_eof(__c);\n        }\n        if (traits_type::eq(traits_type::to_char_type(__c), this->gptr()[-1]))\n        {\n            this->gbump(-1);\n            *this->gptr() = traits_type::to_char_type(__c);\n            return __c;\n        }\n    }\n    return traits_type::eof();\n}\n\ntemplate <class _Codecvt, class _Elem, class _Tr>\ntypename wbuffer_convert<_Codecvt, _Elem, _Tr>::int_type\nwbuffer_convert<_Codecvt, _Elem, _Tr>::overflow(int_type __c)\n{\n    if (__cv_ == 0 || __bufptr_ == 0)\n        return traits_type::eof();\n    __write_mode();\n    char_type __1buf;\n    char_type* __pb_save = this->pbase();\n    char_type* __epb_save = this->epptr();\n    if (!traits_type::eq_int_type(__c, traits_type::eof()))\n    {\n        if (this->pptr() == 0)\n            this->setp(&__1buf, &__1buf+1);\n        *this->pptr() = traits_type::to_char_type(__c);\n        this->pbump(1);\n    }\n    if (this->pptr() != this->pbase())\n    {\n        if (__always_noconv_)\n        {\n            streamsize __nmemb = static_cast<streamsize>(this->pptr() - this->pbase());\n            if (__bufptr_->sputn((const char*)this->pbase(), __nmemb) != __nmemb)\n                return traits_type::eof();\n        }\n        else\n        {\n            char* __extbe = __extbuf_;\n            codecvt_base::result __r;\n            do\n            {\n                const char_type* __e;\n                __r = __cv_->out(__st_, this->pbase(), this->pptr(), __e,\n                                        __extbuf_, __extbuf_ + __ebs_, __extbe);\n                if (__e == this->pbase())\n                    return traits_type::eof();\n                if (__r == codecvt_base::noconv)\n                {\n                    streamsize __nmemb = static_cast<size_t>(this->pptr() - this->pbase());\n                    if (__bufptr_->sputn((const char*)this->pbase(), __nmemb) != __nmemb)\n                        return traits_type::eof();\n                }\n                else if (__r == codecvt_base::ok || __r == codecvt_base::partial)\n                {\n                    streamsize __nmemb = static_cast<size_t>(__extbe - __extbuf_);\n                    if (__bufptr_->sputn(__extbuf_, __nmemb) != __nmemb)\n                        return traits_type::eof();\n                    if (__r == codecvt_base::partial)\n                    {\n                        this->setp((char_type*)__e, this->pptr());\n                        this->pbump(this->epptr() - this->pbase());\n                    }\n                }\n                else\n                    return traits_type::eof();\n            } while (__r == codecvt_base::partial);\n        }\n        this->setp(__pb_save, __epb_save);\n    }\n    return traits_type::not_eof(__c);\n}\n\ntemplate <class _Codecvt, class _Elem, class _Tr>\nbasic_streambuf<_Elem, _Tr>*\nwbuffer_convert<_Codecvt, _Elem, _Tr>::setbuf(char_type* __s, streamsize __n)\n{\n    this->setg(0, 0, 0);\n    this->setp(0, 0);\n    if (__owns_eb_)\n        delete [] __extbuf_;\n    if (__owns_ib_)\n        delete [] __intbuf_;\n    __ebs_ = __n;\n    if (__ebs_ > sizeof(__extbuf_min_))\n    {\n        if (__always_noconv_ && __s)\n        {\n            __extbuf_ = (char*)__s;\n            __owns_eb_ = false;\n        }\n        else\n        {\n            __extbuf_ = new char[__ebs_];\n            __owns_eb_ = true;\n        }\n    }\n    else\n    {\n        __extbuf_ = __extbuf_min_;\n        __ebs_ = sizeof(__extbuf_min_);\n        __owns_eb_ = false;\n    }\n    if (!__always_noconv_)\n    {\n        __ibs_ = max<streamsize>(__n, sizeof(__extbuf_min_));\n        if (__s && __ibs_ >= sizeof(__extbuf_min_))\n        {\n            __intbuf_ = __s;\n            __owns_ib_ = false;\n        }\n        else\n        {\n            __intbuf_ = new char_type[__ibs_];\n            __owns_ib_ = true;\n        }\n    }\n    else\n    {\n        __ibs_ = 0;\n        __intbuf_ = 0;\n        __owns_ib_ = false;\n    }\n    return this;\n}\n\ntemplate <class _Codecvt, class _Elem, class _Tr>\ntypename wbuffer_convert<_Codecvt, _Elem, _Tr>::pos_type\nwbuffer_convert<_Codecvt, _Elem, _Tr>::seekoff(off_type __off, ios_base::seekdir __way,\n                                        ios_base::openmode __om)\n{\n    int __width = __cv_->encoding();\n    if (__cv_ == 0 || __bufptr_ == 0 || (__width <= 0 && __off != 0) || sync())\n        return pos_type(off_type(-1));\n    // __width > 0 || __off == 0, now check __way\n    if (__way != ios_base::beg && __way != ios_base::cur && __way != ios_base::end)\n        return pos_type(off_type(-1));\n    pos_type __r = __bufptr_->pubseekoff(__width * __off, __way, __om);\n    __r.state(__st_);\n    return __r;\n}\n\ntemplate <class _Codecvt, class _Elem, class _Tr>\ntypename wbuffer_convert<_Codecvt, _Elem, _Tr>::pos_type\nwbuffer_convert<_Codecvt, _Elem, _Tr>::seekpos(pos_type __sp, ios_base::openmode __wch)\n{\n    if (__cv_ == 0 || __bufptr_ == 0 || sync())\n        return pos_type(off_type(-1));\n    if (__bufptr_->pubseekpos(__sp, __wch) == pos_type(off_type(-1)))\n        return pos_type(off_type(-1));\n    return __sp;\n}\n\ntemplate <class _Codecvt, class _Elem, class _Tr>\nint\nwbuffer_convert<_Codecvt, _Elem, _Tr>::sync()\n{\n    if (__cv_ == 0 || __bufptr_ == 0)\n        return 0;\n    if (__cm_ & ios_base::out)\n    {\n        if (this->pptr() != this->pbase())\n            if (overflow() == traits_type::eof())\n                return -1;\n        codecvt_base::result __r;\n        do\n        {\n            char* __extbe;\n            __r = __cv_->unshift(__st_, __extbuf_, __extbuf_ + __ebs_, __extbe);\n            streamsize __nmemb = static_cast<streamsize>(__extbe - __extbuf_);\n            if (__bufptr_->sputn(__extbuf_, __nmemb) != __nmemb)\n                return -1;\n        } while (__r == codecvt_base::partial);\n        if (__r == codecvt_base::error)\n            return -1;\n        if (__bufptr_->pubsync())\n            return -1;\n    }\n    else if (__cm_ & ios_base::in)\n    {\n        off_type __c;\n        if (__always_noconv_)\n            __c = this->egptr() - this->gptr();\n        else\n        {\n            int __width = __cv_->encoding();\n            __c = __extbufend_ - __extbufnext_;\n            if (__width > 0)\n                __c += __width * (this->egptr() - this->gptr());\n            else\n            {\n                if (this->gptr() != this->egptr())\n                {\n                    reverse(this->gptr(), this->egptr());\n                    codecvt_base::result __r;\n                    const char_type* __e = this->gptr();\n                    char* __extbe;\n                    do\n                    {\n                        __r = __cv_->out(__st_, __e, this->egptr(), __e,\n                                         __extbuf_, __extbuf_ + __ebs_, __extbe);\n                        switch (__r)\n                        {\n                        case codecvt_base::noconv:\n                            __c += this->egptr() - this->gptr();\n                            break;\n                        case codecvt_base::ok:\n                        case codecvt_base::partial:\n                            __c += __extbe - __extbuf_;\n                            break;\n                        default:\n                            return -1;\n                        }\n                    } while (__r == codecvt_base::partial);\n                }\n            }\n        }\n        if (__bufptr_->pubseekoff(-__c, ios_base::cur, __cm_) == pos_type(off_type(-1)))\n            return -1;\n        this->setg(0, 0, 0);\n        __cm_ = 0;\n    }\n    return 0;\n}\n\ntemplate <class _Codecvt, class _Elem, class _Tr>\nbool\nwbuffer_convert<_Codecvt, _Elem, _Tr>::__read_mode()\n{\n    if (!(__cm_ & ios_base::in))\n    {\n        this->setp(0, 0);\n        if (__always_noconv_)\n            this->setg((char_type*)__extbuf_,\n                       (char_type*)__extbuf_ + __ebs_,\n                       (char_type*)__extbuf_ + __ebs_);\n        else\n            this->setg(__intbuf_, __intbuf_ + __ibs_, __intbuf_ + __ibs_);\n        __cm_ = ios_base::in;\n        return true;\n    }\n    return false;\n}\n\ntemplate <class _Codecvt, class _Elem, class _Tr>\nvoid\nwbuffer_convert<_Codecvt, _Elem, _Tr>::__write_mode()\n{\n    if (!(__cm_ & ios_base::out))\n    {\n        this->setg(0, 0, 0);\n        if (__ebs_ > sizeof(__extbuf_min_))\n        {\n            if (__always_noconv_)\n                this->setp((char_type*)__extbuf_,\n                           (char_type*)__extbuf_ + (__ebs_ - 1));\n            else\n                this->setp(__intbuf_, __intbuf_ + (__ibs_ - 1));\n        }\n        else\n            this->setp(0, 0);\n        __cm_ = ios_base::out;\n    }\n}\n\ntemplate <class _Codecvt, class _Elem, class _Tr>\nwbuffer_convert<_Codecvt, _Elem, _Tr>*\nwbuffer_convert<_Codecvt, _Elem, _Tr>::__close()\n{\n    wbuffer_convert* __rt = 0;\n    if (__cv_ != 0 && __bufptr_ != 0)\n    {\n        __rt = this;\n        if ((__cm_ & ios_base::out) && sync())\n            __rt = 0;\n    }\n    return __rt;\n}\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_LOCALE\n","// -*- C++ -*-\n//===------------------------- streambuf ----------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_STEAMBUF\n#define _LIBCPP_STEAMBUF\n\n/*\n    streambuf synopsis\n\nnamespace std\n{\n\ntemplate <class charT, class traits = char_traits<charT> >\nclass basic_streambuf\n{\npublic:\n    // types:\n    typedef charT char_type;\n    typedef traits traits_type;\n    typedef typename traits_type::int_type int_type;\n    typedef typename traits_type::pos_type pos_type;\n    typedef typename traits_type::off_type off_type;\n\n    virtual ~basic_streambuf();\n\n    // 27.6.2.2.1 locales:\n    locale pubimbue(const locale& loc);\n    locale getloc() const;\n\n    // 27.6.2.2.2 buffer and positioning:\n    basic_streambuf* pubsetbuf(char_type* s, streamsize n);\n    pos_type pubseekoff(off_type off, ios_base::seekdir way,\n                        ios_base::openmode which = ios_base::in | ios_base::out);\n    pos_type pubseekpos(pos_type sp,\n                        ios_base::openmode which = ios_base::in | ios_base::out);\n    int pubsync();\n\n    // Get and put areas:\n    // 27.6.2.2.3 Get area:\n    streamsize in_avail();\n    int_type snextc();\n    int_type sbumpc();\n    int_type sgetc();\n    streamsize sgetn(char_type* s, streamsize n);\n\n    // 27.6.2.2.4 Putback:\n    int_type sputbackc(char_type c);\n    int_type sungetc();\n\n    // 27.6.2.2.5 Put area:\n    int_type sputc(char_type c);\n    streamsize sputn(const char_type* s, streamsize n);\n\nprotected:\n    basic_streambuf();\n    basic_streambuf(const basic_streambuf& rhs);\n    basic_streambuf& operator=(const basic_streambuf& rhs);\n    void swap(basic_streambuf& rhs);\n\n    // 27.6.2.3.2 Get area:\n    char_type* eback() const;\n    char_type* gptr() const;\n    char_type* egptr() const;\n    void gbump(int n);\n    void setg(char_type* gbeg, char_type* gnext, char_type* gend);\n\n    // 27.6.2.3.3 Put area:\n    char_type* pbase() const;\n    char_type* pptr() const;\n    char_type* epptr() const;\n    void pbump(int n);\n    void setp(char_type* pbeg, char_type* pend);\n\n    // 27.6.2.4 virtual functions:\n    // 27.6.2.4.1 Locales:\n    virtual void imbue(const locale& loc);\n\n    // 27.6.2.4.2 Buffer management and positioning:\n    virtual basic_streambuf* setbuf(char_type* s, streamsize n);\n    virtual pos_type seekoff(off_type off, ios_base::seekdir way,\n                             ios_base::openmode which = ios_base::in | ios_base::out);\n    virtual pos_type seekpos(pos_type sp,\n                             ios_base::openmode which = ios_base::in | ios_base::out);\n    virtual int sync();\n\n    // 27.6.2.4.3 Get area:\n    virtual streamsize showmanyc();\n    virtual streamsize xsgetn(char_type* s, streamsize n);\n    virtual int_type underflow();\n    virtual int_type uflow();\n\n    // 27.6.2.4.4 Putback:\n    virtual int_type pbackfail(int_type c = traits_type::eof());\n\n    // 27.6.2.4.5 Put area:\n    virtual streamsize xsputn(const char_type* s, streamsize n);\n    virtual int_type overflow (int_type c = traits_type::eof());\n};\n\n}  // std\n\n*/\n\n#include <__config>\n#include <iosfwd>\n#include <ios>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\ntemplate <class _CharT, class _Traits>\nclass _LIBCPP_TEMPLATE_VIS basic_streambuf\n{\npublic:\n    // types:\n    typedef _CharT                         char_type;\n    typedef _Traits                        traits_type;\n    typedef typename traits_type::int_type int_type;\n    typedef typename traits_type::pos_type pos_type;\n    typedef typename traits_type::off_type off_type;\n\n    virtual ~basic_streambuf();\n\n    // 27.6.2.2.1 locales:\n    inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY\n    locale pubimbue(const locale& __loc) {\n        imbue(__loc);\n        locale __r = __loc_;\n        __loc_ = __loc;\n        return __r;\n    }\n\n    inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY\n    locale getloc() const { return __loc_; }\n\n    // 27.6.2.2.2 buffer and positioning:\n    inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY\n    basic_streambuf* pubsetbuf(char_type* __s, streamsize __n)\n    { return setbuf(__s, __n); }\n\n    inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY\n    pos_type pubseekoff(off_type __off, ios_base::seekdir __way,\n                        ios_base::openmode __which = ios_base::in | ios_base::out)\n    { return seekoff(__off, __way, __which); }\n\n    inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY\n    pos_type pubseekpos(pos_type __sp,\n                        ios_base::openmode __which = ios_base::in | ios_base::out)\n    { return seekpos(__sp, __which); }\n\n    inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY\n    int pubsync() { return sync(); }\n\n    // Get and put areas:\n    // 27.6.2.2.3 Get area:\n    inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY\n    streamsize in_avail() {\n        if (__ninp_ < __einp_)\n            return static_cast<streamsize>(__einp_ - __ninp_);\n        return showmanyc();\n    }\n\n    inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY\n    int_type snextc() {\n        if (sbumpc() == traits_type::eof())\n            return traits_type::eof();\n        return sgetc();\n    }\n\n    inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY\n    int_type sbumpc() {\n        if (__ninp_ == __einp_)\n            return uflow();\n        return traits_type::to_int_type(*__ninp_++);\n    }\n\n    inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY\n    int_type sgetc() {\n        if (__ninp_ == __einp_)\n            return underflow();\n        return traits_type::to_int_type(*__ninp_);\n    }\n\n    inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY\n    streamsize sgetn(char_type* __s, streamsize __n)\n    { return xsgetn(__s, __n); }\n\n    // 27.6.2.2.4 Putback:\n    inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY\n    int_type sputbackc(char_type __c) {\n        if (__binp_ == __ninp_ || !traits_type::eq(__c, __ninp_[-1]))\n            return pbackfail(traits_type::to_int_type(__c));\n        return traits_type::to_int_type(*--__ninp_);\n    }\n\n    inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY\n    int_type sungetc() {\n        if (__binp_ == __ninp_)\n          return pbackfail();\n        return traits_type::to_int_type(*--__ninp_);\n    }\n\n    // 27.6.2.2.5 Put area:\n    inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY\n    int_type sputc(char_type __c) {\n        if (__nout_ == __eout_)\n            return overflow(traits_type::to_int_type(__c));\n        *__nout_++ = __c;\n        return traits_type::to_int_type(__c);\n    }\n\n    inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY\n    streamsize sputn(const char_type* __s, streamsize __n)\n    { return xsputn(__s, __n); }\n\nprotected:\n    basic_streambuf();\n    basic_streambuf(const basic_streambuf& __rhs);\n    basic_streambuf& operator=(const basic_streambuf& __rhs);\n    void swap(basic_streambuf& __rhs);\n\n    // 27.6.2.3.2 Get area:\n    _LIBCPP_ALWAYS_INLINE char_type* eback() const {return __binp_;}\n    _LIBCPP_ALWAYS_INLINE char_type* gptr()  const {return __ninp_;}\n    _LIBCPP_ALWAYS_INLINE char_type* egptr() const {return __einp_;}\n\n    inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY\n    void gbump(int __n) { __ninp_ += __n; }\n\n    inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY\n    void setg(char_type* __gbeg, char_type* __gnext, char_type* __gend) {\n        __binp_ = __gbeg;\n        __ninp_ = __gnext;\n        __einp_ = __gend;\n    }\n\n    // 27.6.2.3.3 Put area:\n    _LIBCPP_ALWAYS_INLINE char_type* pbase() const {return __bout_;}\n    _LIBCPP_ALWAYS_INLINE char_type* pptr()  const {return __nout_;}\n    _LIBCPP_ALWAYS_INLINE char_type* epptr() const {return __eout_;}\n\n    inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY\n    void pbump(int __n) { __nout_ += __n; }\n\n    inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY\n    void setp(char_type* __pbeg, char_type* __pend) {\n        __bout_ = __nout_ = __pbeg;\n        __eout_ = __pend;\n    }\n\n    // 27.6.2.4 virtual functions:\n    // 27.6.2.4.1 Locales:\n    virtual void imbue(const locale& __loc);\n\n    // 27.6.2.4.2 Buffer management and positioning:\n    virtual basic_streambuf* setbuf(char_type* __s, streamsize __n);\n    virtual pos_type seekoff(off_type __off, ios_base::seekdir __way,\n                             ios_base::openmode __which = ios_base::in | ios_base::out);\n    virtual pos_type seekpos(pos_type __sp,\n                             ios_base::openmode __which = ios_base::in | ios_base::out);\n    virtual int sync();\n\n    // 27.6.2.4.3 Get area:\n    virtual streamsize showmanyc();\n    virtual streamsize xsgetn(char_type* __s, streamsize __n);\n    virtual int_type underflow();\n    virtual int_type uflow();\n\n    // 27.6.2.4.4 Putback:\n    virtual int_type pbackfail(int_type __c = traits_type::eof());\n\n    // 27.6.2.4.5 Put area:\n    virtual streamsize xsputn(const char_type* __s, streamsize __n);\n    virtual int_type overflow(int_type __c = traits_type::eof());\n\nprivate:\n    locale __loc_;\n    char_type* __binp_;\n    char_type* __ninp_;\n    char_type* __einp_;\n    char_type* __bout_;\n    char_type* __nout_;\n    char_type* __eout_;\n};\n\ntemplate <class _CharT, class _Traits>\nbasic_streambuf<_CharT, _Traits>::~basic_streambuf()\n{\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_streambuf<_CharT, _Traits>::basic_streambuf()\n    : __binp_(0),\n      __ninp_(0),\n      __einp_(0),\n      __bout_(0),\n      __nout_(0),\n      __eout_(0)\n{\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_streambuf<_CharT, _Traits>::basic_streambuf(const basic_streambuf& __sb)\n    : __loc_(__sb.__loc_),\n      __binp_(__sb.__binp_),\n      __ninp_(__sb.__ninp_),\n      __einp_(__sb.__einp_),\n      __bout_(__sb.__bout_),\n      __nout_(__sb.__nout_),\n      __eout_(__sb.__eout_)\n{\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_streambuf<_CharT, _Traits>&\nbasic_streambuf<_CharT, _Traits>::operator=(const basic_streambuf& __sb)\n{\n    __loc_ = __sb.__loc_;\n    __binp_ = __sb.__binp_;\n    __ninp_ = __sb.__ninp_;\n    __einp_ = __sb.__einp_;\n    __bout_ = __sb.__bout_;\n    __nout_ = __sb.__nout_;\n    __eout_ = __sb.__eout_;\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nvoid\nbasic_streambuf<_CharT, _Traits>::swap(basic_streambuf& __sb)\n{\n    _VSTD::swap(__loc_, __sb.__loc_);\n    _VSTD::swap(__binp_, __sb.__binp_);\n    _VSTD::swap(__ninp_, __sb.__ninp_);\n    _VSTD::swap(__einp_, __sb.__einp_);\n    _VSTD::swap(__bout_, __sb.__bout_);\n    _VSTD::swap(__nout_, __sb.__nout_);\n    _VSTD::swap(__eout_, __sb.__eout_);\n}\n\ntemplate <class _CharT, class _Traits>\nvoid\nbasic_streambuf<_CharT, _Traits>::imbue(const locale&)\n{\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_streambuf<_CharT, _Traits>*\nbasic_streambuf<_CharT, _Traits>::setbuf(char_type*, streamsize)\n{\n    return this;\n}\n\ntemplate <class _CharT, class _Traits>\ntypename basic_streambuf<_CharT, _Traits>::pos_type\nbasic_streambuf<_CharT, _Traits>::seekoff(off_type, ios_base::seekdir,\n                                          ios_base::openmode)\n{\n    return pos_type(off_type(-1));\n}\n\ntemplate <class _CharT, class _Traits>\ntypename basic_streambuf<_CharT, _Traits>::pos_type\nbasic_streambuf<_CharT, _Traits>::seekpos(pos_type, ios_base::openmode)\n{\n    return pos_type(off_type(-1));\n}\n\ntemplate <class _CharT, class _Traits>\nint\nbasic_streambuf<_CharT, _Traits>::sync()\n{\n    return 0;\n}\n\ntemplate <class _CharT, class _Traits>\nstreamsize\nbasic_streambuf<_CharT, _Traits>::showmanyc()\n{\n    return 0;\n}\n\ntemplate <class _CharT, class _Traits>\nstreamsize\nbasic_streambuf<_CharT, _Traits>::xsgetn(char_type* __s, streamsize __n)\n{\n    const int_type __eof = traits_type::eof();\n    int_type __c;\n    streamsize __i = 0;\n    while(__i < __n)\n    {\n        if (__ninp_ < __einp_)\n        {\n            const streamsize __len = _VSTD::min(__einp_ - __ninp_, __n - __i);\n            traits_type::copy(__s, __ninp_, __len);\n            __s +=  __len;\n            __i +=  __len;\n            this->gbump(__len);\n        }\n        else if ((__c = uflow()) != __eof)\n        {\n            *__s = traits_type::to_char_type(__c);\n            ++__s;\n            ++__i;\n        }\n        else\n            break;\n    }\n    return __i;\n}\n\ntemplate <class _CharT, class _Traits>\ntypename basic_streambuf<_CharT, _Traits>::int_type\nbasic_streambuf<_CharT, _Traits>::underflow()\n{\n    return traits_type::eof();\n}\n\ntemplate <class _CharT, class _Traits>\ntypename basic_streambuf<_CharT, _Traits>::int_type\nbasic_streambuf<_CharT, _Traits>::uflow()\n{\n    if (underflow() == traits_type::eof())\n        return traits_type::eof();\n    return traits_type::to_int_type(*__ninp_++);\n}\n\ntemplate <class _CharT, class _Traits>\ntypename basic_streambuf<_CharT, _Traits>::int_type\nbasic_streambuf<_CharT, _Traits>::pbackfail(int_type)\n{\n    return traits_type::eof();\n}\n\ntemplate <class _CharT, class _Traits>\nstreamsize\nbasic_streambuf<_CharT, _Traits>::xsputn(const char_type* __s, streamsize __n)\n{\n    streamsize __i = 0;\n    int_type __eof = traits_type::eof();\n    while( __i < __n)\n    {\n        if (__nout_ >= __eout_)\n        {\n            if (overflow(traits_type::to_int_type(*__s)) == __eof)\n                break;\n            ++__s;\n            ++__i;\n        }\n        else\n        {\n            streamsize __chunk_size = _VSTD::min(__eout_ - __nout_, __n - __i);\n            traits_type::copy(__nout_, __s, __chunk_size);\n            __nout_ += __chunk_size;\n            __s     += __chunk_size;\n            __i     += __chunk_size;\n        }\n    }\n    return __i;\n}\n\ntemplate <class _CharT, class _Traits>\ntypename basic_streambuf<_CharT, _Traits>::int_type\nbasic_streambuf<_CharT, _Traits>::overflow(int_type)\n{\n    return traits_type::eof();\n}\n\n_LIBCPP_EXTERN_TEMPLATE(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS basic_streambuf<char>)\n_LIBCPP_EXTERN_TEMPLATE(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS basic_streambuf<wchar_t>)\n\n_LIBCPP_EXTERN_TEMPLATE(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS basic_ios<char>)\n_LIBCPP_EXTERN_TEMPLATE(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS basic_ios<wchar_t>)\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_STEAMBUF\n","/*\n *  icpPoint.c\n *  ARToolKit5\n *\n *  This file is part of ARToolKit.\n *\n *  ARToolKit is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation, either version 3 of the License, or\n *  (at your option) any later version.\n *\n *  ARToolKit is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public License\n *  along with ARToolKit.  If not, see <http://www.gnu.org/licenses/>.\n *\n *  As a special exception, the copyright holders of this library give you\n *  permission to link this library with independent modules to produce an\n *  executable, regardless of the license terms of these independent modules, and to\n *  copy and distribute the resulting executable under terms of your choice,\n *  provided that you also meet, for each linked independent module, the terms and\n *  conditions of the license of that module. An independent module is a module\n *  which is neither derived from nor based on this library. If you modify this\n *  library, you may extend this exception to your version of the library, but you\n *  are not obligated to do so. If you do not wish to do so, delete this exception\n *  statement from your version.\n *\n *  Copyright 2015 Daqri, LLC.\n *  Copyright 2007-2015 ARToolworks, Inc.\n *\n *  Author(s): Hirokazu Kato\n *\n */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n#include <AR/ar.h>\n#include <AR/matrix.h>\n#include <AR/icp.h>\n\n\nstatic void   icpGetXw2XcCleanup( char *message, ARdouble *J_U_S, ARdouble *dU );\n\nint icpPoint( ICPHandleT   *handle,\n              ICPDataT     *data,\n              ARdouble        initMatXw2Xc[3][4],\n              ARdouble        matXw2Xc[3][4],\n              ARdouble       *err )\n{\n    ICP2DCoordT   U;\n    ARdouble        *J_U_S;\n    ARdouble        *dU, dx, dy;\n    ARdouble         matXw2U[3][4];\n    ARdouble         dS[6];\n    ARdouble         err0, err1;\n    int           i, j;\n\n    if( data->num < 3 ) return -1;\n\n    if( (J_U_S = (ARdouble *)malloc( sizeof(ARdouble)*12*(data->num) )) == NULL ) {\n        ARLOGe(\"Error: malloc\\n\");\n        return -1;\n    }\n    if( (dU = (ARdouble *)malloc( sizeof(ARdouble)*2*(data->num) )) == NULL ) {\n        ARLOGe(\"Error: malloc\\n\");\n        free(J_U_S);\n        return -1;\n    }\n    for( j = 0; j < 3; j++ ) {\n        for( i = 0; i < 4; i++ ) matXw2Xc[j][i] = initMatXw2Xc[j][i];\n    }\n\n    for( i = 0;; i++ ) {\n#if ICP_DEBUG\n        icpDispMat( \"matXw2Xc\", &(matXw2Xc[0][0]), 3, 4 );\n#endif\n        arUtilMatMul( (const ARdouble (*)[4])handle->matXc2U, (const ARdouble (*)[4])matXw2Xc, matXw2U );\n\n        err1 = 0.0;\n        for( j = 0; j < data->num; j++ ) {\n            if( icpGetU_from_X_by_MatX2U( &U, matXw2U, &(data->worldCoord[j]) ) < 0 ) {\n                icpGetXw2XcCleanup(\"icpGetU_from_X_by_MatX2U\", J_U_S, dU);\n                return -1;\n            }\n            dx = data->screenCoord[j].x - U.x;\n            dy = data->screenCoord[j].y - U.y;\n            err1 += dx*dx + dy*dy;\n            dU[j*2+0] = dx;\n            dU[j*2+1] = dy;\n        }\n        err1 /= data->num;\n#if ICP_DEBUG\n        ARLOG(\"Loop[%d]: err = %15.10f\\n\", i, err1);\n#endif\n        if( err1 < handle->breakLoopErrorThresh ) break;\n        if( i > 0 && err1 < handle->breakLoopErrorThresh2 && err1/err0 > handle->breakLoopErrorRatioThresh ) break;\n        if( i == handle->maxLoop ) break;\n        err0 = err1;\n\n        for( j = 0; j < data->num; j++ ) {\n            if( icpGetJ_U_S( (ARdouble (*)[6])(&J_U_S[12*j]), handle->matXc2U, matXw2Xc, &(data->worldCoord[j]) ) < 0 ) {\n                icpGetXw2XcCleanup(\"icpGetJ_U_S\", J_U_S, dU);\n                return -1;\n            }\n#if ICP_DEBUG\n            icpDispMat( \"J_U_S\", (ARdouble *)(&J_U_S[j*12]), 2, 6 );\n#endif\n        }\n        if( icpGetDeltaS( dS, dU, (ARdouble (*)[6])J_U_S, (data->num)*2 ) < 0 ) {\n            icpGetXw2XcCleanup(\"icpGetDeltaS\", J_U_S, dU);\n            return -1;\n        }\n\n        icpUpdateMat( matXw2Xc, dS );\n    }\n\n#if ICP_DEBUG\n    ARLOG(\"*********** %f\\n\", err1);\n    ARLOG(\"Loop = %d\\n\", i);\n#endif\n\n    *err = err1;\n    free(J_U_S);\n    free(dU);\n\n    return 0;\n}\n\nstatic void icpGetXw2XcCleanup( char *message, ARdouble *J_U_S, ARdouble *dU )\n{\n    ARLOGd(\"Error: %s\\n\", message);\n    free(J_U_S);\n    free(dU);\n}\n","/*\n *  icpPointRobust.c\n *  ARToolKit5\n *\n *  This file is part of ARToolKit.\n *\n *  ARToolKit is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation, either version 3 of the License, or\n *  (at your option) any later version.\n *\n *  ARToolKit is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public License\n *  along with ARToolKit.  If not, see <http://www.gnu.org/licenses/>.\n *\n *  As a special exception, the copyright holders of this library give you\n *  permission to link this library with independent modules to produce an\n *  executable, regardless of the license terms of these independent modules, and to\n *  copy and distribute the resulting executable under terms of your choice,\n *  provided that you also meet, for each linked independent module, the terms and\n *  conditions of the license of that module. An independent module is a module\n *  which is neither derived from nor based on this library. If you modify this\n *  library, you may extend this exception to your version of the library, but you\n *  are not obligated to do so. If you do not wish to do so, delete this exception\n *  statement from your version.\n *\n *  Copyright 2015 Daqri, LLC.\n *  Copyright 2007-2015 ARToolworks, Inc.\n *\n *  Author(s): Hirokazu Kato\n *\n */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n#include <AR/ar.h>\n#include <AR/icp.h>\n\n#ifndef ARDOUBLE_IS_FLOAT\n#define     K2_FACTOR     4.0\n#else\n#define     K2_FACTOR     4.0f\n#endif\n\nstatic void   icpGetXw2XcCleanup( char *message, ARdouble *J_U_S, ARdouble *dU, ARdouble *E, ARdouble *E2 );\nstatic int    compE(const void *a, const void *b );\n\nint icpPointRobust( ICPHandleT   *handle,\n                    ICPDataT     *data,\n                    ARdouble        initMatXw2Xc[3][4],\n                    ARdouble        matXw2Xc[3][4],\n                    ARdouble       *err )\n{\n    ICP2DCoordT   U;\n    ARdouble       *J_U_S;\n    ARdouble       *dU, dx, dy;\n    ARdouble       *E, *E2, K2, W;\n    ARdouble        matXw2U[3][4];\n    ARdouble        dS[6];\n    ARdouble        err0, err1;\n    int           inlierNum;\n    int           i, j, k;\n\n    if( data->num < 4 ) return -1;\n\n    inlierNum = (int)(data->num * handle->inlierProb) - 1;\n    if( inlierNum < 3 ) inlierNum = 3;\n\n    if( (J_U_S = (ARdouble *)malloc( sizeof(ARdouble)*12*(data->num) )) == NULL ) {\n        ARLOGe(\"Error: malloc\\n\");\n        return -1;\n    }\n    if( (dU = (ARdouble *)malloc( sizeof(ARdouble)*2*(data->num) )) == NULL ) {\n        ARLOGe(\"Error: malloc\\n\");\n        free(J_U_S);\n        return -1;\n    }\n    if( (E = (ARdouble *)malloc( sizeof(ARdouble)*(data->num) )) == NULL ) {\n        ARLOGe(\"Error: malloc\\n\");\n        free(J_U_S);\n        free(dU);\n        return -1;\n    }\n    if( (E2 = (ARdouble *)malloc( sizeof(ARdouble)*(data->num) )) == NULL ) {\n        ARLOGe(\"Error: malloc\\n\");\n        free(J_U_S);\n        free(dU);\n        free(E);\n        return -1;\n    }\n    for( j = 0; j < 3; j++ ) {\n        for( i = 0; i < 4; i++ ) matXw2Xc[j][i] = initMatXw2Xc[j][i];\n    }\n\n\n    for( i = 0;; i++ ) {\n#if ICP_DEBUG\n        icpDispMat( \"matXw2Xc\", &(matXw2Xc[0][0]), 3, 4 );\n#endif\n        arUtilMatMul( (const ARdouble (*)[4])handle->matXc2U, (const ARdouble (*)[4])matXw2Xc, matXw2U );\n\n        for( j = 0; j < data->num; j++ ) {\n            if( icpGetU_from_X_by_MatX2U( &U, matXw2U, &(data->worldCoord[j]) ) < 0 ) {\n                icpGetXw2XcCleanup(\"icpGetU_from_X_by_MatX2U\",J_U_S,dU,E,E2);\n                return -1;\n            }\n            dx = data->screenCoord[j].x - U.x;\n            dy = data->screenCoord[j].y - U.y;\n            dU[j*2+0] = dx;\n            dU[j*2+1] = dy;\n            E[j] = E2[j] = dx*dx + dy*dy;\n        }\n        qsort(E2, data->num, sizeof(ARdouble), compE);\n        K2 = E2[inlierNum] * K2_FACTOR;\n        if( K2 < 16.0 ) K2 = 16.0;\n\n        err1 = 0.0;\n        for( j = 0; j < data->num; j++ ) {\n            if( E2[j] > K2 ) err1 += K2/6.0;\n            else err1 += K2/6.0 * (1.0 - (1.0-E2[j]/K2)*(1.0-E2[j]/K2)*(1.0-E2[j]/K2));\n        }\n        err1 /= data->num;\n#if ICP_DEBUG\n        ARLOG(\"Loop[%d]: k^2 = %f, err = %15.10f\\n\", i, K2, err1);\n#endif\n        //ARLOG(\"  %f %f %f %f\\n\", E2[0], E2[1], E2[2], E2[3]);\n        //ARLOG(\"  %f %f %f %f\\n\", E[0], E[1], E[2], E[3]);\n        if( err1 < handle->breakLoopErrorThresh ) break;\n        if( i > 0 && err1 < handle->breakLoopErrorThresh2 && err1/err0 > handle->breakLoopErrorRatioThresh ) break;\n        if( i == handle->maxLoop ) break;\n        err0 = err1;\n\n        k = 0;\n        for( j = 0; j < data->num; j++ ) {\n            if( E[j] <= K2 ) {\n                if( icpGetJ_U_S( (ARdouble (*)[6])(&J_U_S[6*k]), handle->matXc2U, matXw2Xc, &(data->worldCoord[j]) ) < 0 ) {\n                    icpGetXw2XcCleanup(\"icpGetJ_U_S\", J_U_S, dU, E, E2);\n                    return -1;\n                }\n#if ICP_DEBUG\n                icpDispMat( \"J_U_S\", (ARdouble *)(&J_U_S[6*k]), 2, 6 );\n#endif\n                W = (1.0 - E[j]/K2)*(1.0 - E[j]/K2);\n                J_U_S[k*6+0] *= W;\n                J_U_S[k*6+1] *= W;\n                J_U_S[k*6+2] *= W;\n                J_U_S[k*6+3] *= W;\n                J_U_S[k*6+4] *= W;\n                J_U_S[k*6+5] *= W;\n                J_U_S[k*6+6] *= W;\n                J_U_S[k*6+7] *= W;\n                J_U_S[k*6+8] *= W;\n                J_U_S[k*6+9] *= W;\n                J_U_S[k*6+10] *= W;\n                J_U_S[k*6+11] *= W;\n                dU[k+0] = dU[j*2+0] * W;\n                dU[k+1] = dU[j*2+1] * W;\n                k+=2;\n            }\n        }\n\n        if( k < 6 ) {\n            icpGetXw2XcCleanup(\"icpPointRobust: k < 6\",J_U_S,dU,E,E2);\n            return -1;\n        }\n\n        if( icpGetDeltaS( dS, dU, (ARdouble (*)[6])J_U_S, k ) < 0 ) {\n            icpGetXw2XcCleanup(\"icpGetDeltaS\",J_U_S,dU,E,E2);\n            return -1;\n        }\n\n        icpUpdateMat( matXw2Xc, dS );\n    }\n\n#if ICP_DEBUG\n    ARLOG(\"*********** %f\\n\", err1);\n    ARLOG(\"Loop = %d\\n\", i);\n#endif\n\n    *err = err1;\n    free(J_U_S);\n    free(dU);\n    free(E);\n    free(E2);\n\n    return 0;\n}\n\nstatic void icpGetXw2XcCleanup( char *message, ARdouble *J_U_S, ARdouble *dU, ARdouble *E, ARdouble *E2 )\n{\n    ARLOGd(\"Error: %s\\n\", message);\n    free(J_U_S);\n    free(dU);\n    free(E);\n    free(E2);\n}\n\nstatic int compE( const void *a, const void *b )\n{\n    ARdouble  c;\n    c = *(ARdouble *)a - *(ARdouble *)b;\n    if( c < 0.0 ) return -1;\n    if( c > 0.0 ) return  1;\n    return 0;\n}\n","/*\n *  kpmRefDataSet.cpp\n *  ARToolKit5\n *\n *  This file is part of ARToolKit.\n *\n *  ARToolKit is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation, either version 3 of the License, or\n *  (at your option) any later version.\n *\n *  ARToolKit is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public License\n *  along with ARToolKit.  If not, see <http://www.gnu.org/licenses/>.\n *\n *  As a special exception, the copyright holders of this library give you\n *  permission to link this library with independent modules to produce an\n *  executable, regardless of the license terms of these independent modules, and to\n *  copy and distribute the resulting executable under terms of your choice,\n *  provided that you also meet, for each linked independent module, the terms and\n *  conditions of the license of that module. An independent module is a module\n *  which is neither derived from nor based on this library. If you modify this\n *  library, you may extend this exception to your version of the library, but you\n *  are not obligated to do so. If you do not wish to do so, delete this exception\n *  statement from your version.\n *\n *  Copyright 2015 Daqri, LLC. All rights reserved.\n *  Copyright 2006-2015 ARToolworks, Inc. All rights reserved.\n *  Author(s): Hirokazu Kato, Philip Lamb\n *\n */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <AR/ar.h>\n#include <KPM/kpm.h>\n#include <KPM/kpmType.h>\n#include \"kpmPrivate.h\"\n#include \"kpmFopen.h\"\n\n#if BINARY_FEATURE\n#include <facade/visual_database_facade.h>\n#else\n#include <KPM/surfSub.h>\n#endif\n\n\n\nint kpmGenRefDataSet ( ARUint8 *refImage, AR_PIXEL_FORMAT pixFormat, int xsize, int ysize, float dpi, int procMode, int compMode, int maxFeatureNum,\n                       int pageNo, int imageNo, KpmRefDataSet **refDataSetPtr )\n{\n    ARUint8         *refImageBW;\n    KpmRefDataSet   *refDataSet;\n    int              xsize2, ysize2;\n    int              i, j;\n\n    if (!refDataSetPtr || !refImage) {\n        ARLOGe(\"kpmDeleteRefDataSet(): NULL refDataSetPtr/refImage.\\n\");\n        return (-1);\n    }\n    if (!xsize || !ysize || !dpi) {\n        ARLOGe(\"kpmDeleteRefDataSet(): 0 xsize/ysize/dpi.\\n\");\n        return (-1);\n    }\n\n    arMalloc( refDataSet, KpmRefDataSet, 1 );\n\n    refDataSet->pageNum = 1; // I.e. number of pages = 1.\n    arMalloc( refDataSet->pageInfo, KpmPageInfo, 1 );\n    refDataSet->pageInfo[0].pageNo = pageNo;\n    refDataSet->pageInfo[0].imageNum = 1; // I.e. number of images = 1.\n    arMalloc( refDataSet->pageInfo[0].imageInfo, KpmImageInfo, 1 );\n    refDataSet->pageInfo[0].imageInfo[0].imageNo = imageNo;\n    refImageBW = kpmUtilGenBWImage( refImage, pixFormat, xsize, ysize, procMode, &xsize2, &ysize2 );\n    refDataSet->pageInfo[0].imageInfo[0].width   = xsize2;\n    refDataSet->pageInfo[0].imageInfo[0].height  = ysize2;\n\n    if( compMode == KpmCompY ) {\n        ARUint8 *refImageBW2 = refImageBW;\n        refImageBW = (ARUint8 *)malloc(sizeof(ARUint8)*xsize2*(ysize2/2));\n        if( refImageBW == NULL ) exit(0);\n\n        ARUint8 *p1 = refImageBW;\n        ARUint8 *p2 = refImageBW2;\n        for( j = 0; j < ysize2/2; j++ ) {\n            for( i = 0; i < xsize2; i++ ) {\n                *(p1++) = ( (int)*p2 + (int)*(p2+xsize2) ) / 2;\n                p2++;\n            }\n            p2 += xsize2;\n        }\n        free( refImageBW2 );\n    }\n\n#if BINARY_FEATURE\n    vision::VisualDatabaseFacade freakMatcher;\n    std::vector<vision::FeaturePoint> points;\n    std::vector<unsigned char> descriptors;\n    freakMatcher.computeFreakFeaturesAndDescriptors(refImageBW, xsize2, ysize2, points, descriptors);\n    ARLOGi(\"Freak features - %d\",points.size());\n    //freakMatcher.addImage(refImageBW, xsize2, ysize2, imageNo);\n    //const std::vector<vision::FeaturePoint>& points = freakMatcher.getFeaturePoints(imageNo);\n    //const std::vector<unsigned char>& descriptors = freakMatcher.getDescriptors(imageNo);\n    refDataSet->num = (int)points.size();\n#else\n    SurfSubHandleT   *surfHandle;\n    surfHandle = surfSubCreateHandle(xsize2, (compMode == KpmCompY)? ysize2/2: ysize2, AR_PIXEL_FORMAT_MONO);\n    if (!surfHandle) {\n        ARLOGe(\"Error: unable to initialise KPM feature matching.\\n\");\n        exit(-1);\n    }\n    surfSubSetMaxPointNum( surfHandle, maxFeatureNum );\n    surfSubExtractFeaturePoint( surfHandle, refImageBW, NULL, 0 );\n    refDataSet->num = surfSubGetFeaturePointNum( surfHandle );\n#endif\n\n    if( refDataSet->num != 0 ) {\n        arMalloc( refDataSet->refPoint, KpmRefData, refDataSet->num );\n        if( procMode == KpmProcFullSize ) {\n            for( i = 0 ; i < refDataSet->num ; i++ ) {\n#if BINARY_FEATURE\n                float  x = points[i].x, y = points[i].y;\n                if( compMode == KpmCompY ) y *= 2.0f;\n                for( j = 0; j < FREAK_SUB_DIMENSION; j++ ) {\n                    refDataSet->refPoint[i].featureVec.v[j] = descriptors[i*FREAK_SUB_DIMENSION+j];\n                }\n                refDataSet->refPoint[i].featureVec.angle = points[i].angle;\n                refDataSet->refPoint[i].featureVec.scale = points[i].scale;\n                refDataSet->refPoint[i].featureVec.maxima = (int)points[i].maxima;\n#else\n                float  x, y, *desc;\n                desc = surfSubGetFeatureDescPtr( surfHandle, i );\n                surfSubGetFeaturePosition( surfHandle, i, &x, &y );\n                if( compMode == KpmCompY ) y *= 2.0f;\n                for( j = 0; j < SURF_SUB_DIMENSION; j++ ) {\n                    refDataSet->refPoint[i].featureVec.v[j] = desc[j];\n                }\n                refDataSet->refPoint[i].featureVec.l = surfSubGetFeatureSign( surfHandle, i );\n#endif\n\n                refDataSet->refPoint[i].coord2D.x = x;\n                refDataSet->refPoint[i].coord2D.y = y;\n                refDataSet->refPoint[i].coord3D.x = (x + 0.5f) / dpi * 25.4f;               // millimetres.\n                refDataSet->refPoint[i].coord3D.y = ((ysize-0.5f) - y) / dpi * 25.4f;       // millimetres.\n                refDataSet->refPoint[i].pageNo = pageNo;\n                refDataSet->refPoint[i].refImageNo = imageNo;\n            }\n        }\n        else if( procMode == KpmProcTwoThirdSize ) {\n            for( i = 0 ; i < refDataSet->num ; i++ ) {\n#if BINARY_FEATURE\n                float  x = points[i].x, y = points[i].y;\n                if( compMode == KpmCompY ) y *= 2.0f;\n                for( j = 0; j < FREAK_SUB_DIMENSION; j++ ) {\n                    refDataSet->refPoint[i].featureVec.v[j] = descriptors[i*FREAK_SUB_DIMENSION+j];\n                }\n                refDataSet->refPoint[i].featureVec.angle = points[i].angle;\n                refDataSet->refPoint[i].featureVec.scale = points[i].scale;\n                refDataSet->refPoint[i].featureVec.maxima = (int)points[i].maxima;\n#else\n                float  x, y, *desc;\n                desc = surfSubGetFeatureDescPtr( surfHandle, i );\n                surfSubGetFeaturePosition( surfHandle, i, &x, &y );\n                if( compMode == KpmCompY ) y *= 2.0f;\n                for( j = 0; j < SURF_SUB_DIMENSION; j++ ) {\n                    refDataSet->refPoint[i].featureVec.v[j] = desc[j];\n                }\n                refDataSet->refPoint[i].featureVec.l = surfSubGetFeatureSign( surfHandle, i );\n#endif\n\n                refDataSet->refPoint[i].coord2D.x = x;\n                refDataSet->refPoint[i].coord2D.y = y;\n                refDataSet->refPoint[i].coord3D.x = (x*1.5f + 0.75f) / dpi * 25.4f;         // millimetres.\n                refDataSet->refPoint[i].coord3D.y = ((ysize-0.75f) - y*1.5f) / dpi * 25.4f; // millimetres.\n                refDataSet->refPoint[i].pageNo = pageNo;\n                refDataSet->refPoint[i].refImageNo = imageNo;\n            }\n        }\n        else if( procMode == KpmProcHalfSize ) {\n            for( i = 0 ; i < refDataSet->num ; i++ ) {\n#if BINARY_FEATURE\n                float  x = points[i].x, y = points[i].y;\n                if( compMode == KpmCompY ) y *= 2.0f;\n                for( j = 0; j < FREAK_SUB_DIMENSION; j++ ) {\n                    refDataSet->refPoint[i].featureVec.v[j] = descriptors[i*FREAK_SUB_DIMENSION+j];\n                }\n                refDataSet->refPoint[i].featureVec.angle = points[i].angle;\n                refDataSet->refPoint[i].featureVec.scale = points[i].scale;\n                refDataSet->refPoint[i].featureVec.maxima = (int)points[i].maxima;\n#else\n                float  x, y, *desc;\n                desc = surfSubGetFeatureDescPtr( surfHandle, i );\n                surfSubGetFeaturePosition( surfHandle, i, &x, &y );\n                if( compMode == KpmCompY ) y *= 2.0f;\n                for( j = 0; j < SURF_SUB_DIMENSION; j++ ) {\n                    refDataSet->refPoint[i].featureVec.v[j] = desc[j];\n                }\n                refDataSet->refPoint[i].featureVec.l = surfSubGetFeatureSign( surfHandle, i );\n#endif\n\n                refDataSet->refPoint[i].coord2D.x = x;\n                refDataSet->refPoint[i].coord2D.y = y;\n                refDataSet->refPoint[i].coord3D.x = (x*2.0f + 1.0f) / dpi * 25.4f;          // millimetres.\n                refDataSet->refPoint[i].coord3D.y = ((ysize-1.0f) - y*2.0f) / dpi * 25.4f;  // millimetres.\n                refDataSet->refPoint[i].pageNo = pageNo;\n                refDataSet->refPoint[i].refImageNo = imageNo;\n            }\n        }\n        else if( procMode == KpmProcOneThirdSize ) {\n            for( i = 0 ; i < refDataSet->num ; i++ ) {\n#if BINARY_FEATURE\n                float  x = points[i].x, y = points[i].y;\n                if( compMode == KpmCompY ) y *= 2.0f;\n                for( j = 0; j < FREAK_SUB_DIMENSION; j++ ) {\n                    refDataSet->refPoint[i].featureVec.v[j] = descriptors[i*FREAK_SUB_DIMENSION+j];\n                }\n                refDataSet->refPoint[i].featureVec.angle = points[i].angle;\n                refDataSet->refPoint[i].featureVec.scale = points[i].scale;\n                refDataSet->refPoint[i].featureVec.maxima = (int)points[i].maxima;\n#else\n                float  x, y, *desc;\n                desc = surfSubGetFeatureDescPtr( surfHandle, i );\n                surfSubGetFeaturePosition( surfHandle, i, &x, &y );\n                if( compMode == KpmCompY ) y *= 2.0f;\n                for( j = 0; j < SURF_SUB_DIMENSION; j++ ) {\n                    refDataSet->refPoint[i].featureVec.v[j] = desc[j];\n                }\n                refDataSet->refPoint[i].featureVec.l = surfSubGetFeatureSign( surfHandle, i );\n#endif\n                refDataSet->refPoint[i].coord2D.x = x;\n                refDataSet->refPoint[i].coord2D.y = y;\n                refDataSet->refPoint[i].coord3D.x = (x*3.0f + 1.5f) / dpi * 25.4f;          // millimetres.\n                refDataSet->refPoint[i].coord3D.y = ((ysize-1.5f) - y*3.0f) / dpi * 25.4f;  // millimetres.\n                refDataSet->refPoint[i].pageNo = pageNo;\n                refDataSet->refPoint[i].refImageNo = imageNo;\n            }\n        }\n        else {\n            for( i = 0 ; i < refDataSet->num ; i++ ) {\n#if BINARY_FEATURE\n                float  x = points[i].x, y = points[i].y;\n                if( compMode == KpmCompY ) y *= 2.0f;\n                for( j = 0; j < FREAK_SUB_DIMENSION; j++ ) {\n                    refDataSet->refPoint[i].featureVec.v[j] = descriptors[i*FREAK_SUB_DIMENSION+j];\n                }\n                refDataSet->refPoint[i].featureVec.angle = points[i].angle;\n                refDataSet->refPoint[i].featureVec.scale = points[i].scale;\n                refDataSet->refPoint[i].featureVec.maxima = (int)points[i].maxima;\n#else\n                float  x, y, *desc;\n                desc = surfSubGetFeatureDescPtr( surfHandle, i );\n                surfSubGetFeaturePosition( surfHandle, i, &x, &y );\n                if( compMode == KpmCompY ) y *= 2.0f;\n                for( j = 0; j < SURF_SUB_DIMENSION; j++ ) {\n                    refDataSet->refPoint[i].featureVec.v[j] = desc[j];\n                }\n                refDataSet->refPoint[i].featureVec.l = surfSubGetFeatureSign( surfHandle, i );\n#endif\n\n                refDataSet->refPoint[i].coord2D.x = x;\n                refDataSet->refPoint[i].coord2D.y = y;\n                refDataSet->refPoint[i].coord3D.x = (x*4.0f + 2.0f) / dpi * 25.4f;          // millimetres.\n                refDataSet->refPoint[i].coord3D.y = ((ysize-2.0f) - y*4.0f) / dpi * 25.4f;  // millimetres.\n                refDataSet->refPoint[i].pageNo = pageNo;\n                refDataSet->refPoint[i].refImageNo = imageNo;\n            }\n        }\n    }\n    else {\n        refDataSet->refPoint = NULL;\n    }\n    free(refImageBW);\n#if !BINARY_FEATURE\n    surfSubDeleteHandle( &surfHandle );\n#endif\n\n    *refDataSetPtr = refDataSet;\n\n    return 0;\n}\n\nint kpmAddRefDataSet ( ARUint8 *refImage, AR_PIXEL_FORMAT pixFormat, int xsize, int ysize, float  dpi, int procMode, int compMode, int maxFeatureNum,\n                              int pageNo, int imageNo, KpmRefDataSet **refDataSetPtr )\n{\n    KpmRefDataSet  *refDataSetPtr2;\n    int ret;\n\n    ret =  kpmGenRefDataSet(refImage, pixFormat, xsize, ysize, dpi, procMode, compMode, maxFeatureNum, pageNo, imageNo, &refDataSetPtr2);\n    if (ret < 0) {\n        ARLOGe(\"Error while adding reference data set: kpmGenRefDataSet() failed.\\n\");\n        return (ret);\n    }\n\n    ARLOGi(\"========= %d ===========\\n\", refDataSetPtr2->num);\n\n    ret = kpmMergeRefDataSet( refDataSetPtr, &refDataSetPtr2 );\n    if (ret < 0) {\n        ARLOGe(\"Error while adding reference data set: kpmMergeRefDataSet() failed.\\n\");\n    }\n    return (ret);\n}\n\nint kpmMergeRefDataSet ( KpmRefDataSet **refDataSetPtr1, KpmRefDataSet **refDataSetPtr2 )\n{\n    KpmRefData    *refPoint;\n    KpmPageInfo   *pageInfo;\n    int            pageNum;\n    int            imageNum;\n    int            num1, num2, num3;\n    int            i, j, k, l;\n\n    if (!refDataSetPtr1 || !refDataSetPtr2) {\n        ARLOGe(\"kpmDeleteRefDataSet(): NULL refDataSetPtr1/refDataSetPtr2.\\n\");\n        return (-1);\n    }\n\n    if (!*refDataSetPtr1) {\n        arMalloc( *refDataSetPtr1, KpmRefDataSet, 1 );\n        (*refDataSetPtr1)->num          = 0;\n        (*refDataSetPtr1)->refPoint     = NULL;\n        (*refDataSetPtr1)->pageNum      = 0;\n        (*refDataSetPtr1)->pageInfo     = NULL;\n    }\n    if (!*refDataSetPtr2) return 0;\n\n    // Merge KpmRefData.\n    num1 = (*refDataSetPtr1)->num;\n    num2 = (*refDataSetPtr2)->num;\n\n    arMalloc( refPoint, KpmRefData, num1+num2 );\n    for( i = 0; i < num1; i++ ) {\n        refPoint[i] = (*refDataSetPtr1)->refPoint[i];\n    }\n    for( i = 0; i < num2; i++ ) {\n        refPoint[num1+i] = (*refDataSetPtr2)->refPoint[i];\n    }\n    if( (*refDataSetPtr1)->refPoint != NULL ) free((*refDataSetPtr1)->refPoint);\n    (*refDataSetPtr1)->refPoint = refPoint;\n    (*refDataSetPtr1)->num      = num1 + num2;\n\n    // Allocate pageInfo for the combined sets.\n    num1 = (*refDataSetPtr1)->pageNum;\n    num2 = (*refDataSetPtr2)->pageNum;\n    num3 = 0;\n    for( i = 0; i < num2; i++ ) {\n        for( j = 0; j < num1; j++ ) {\n            if( (*refDataSetPtr2)->pageInfo[i].pageNo == (*refDataSetPtr1)->pageInfo[j].pageNo ) {\n                num3++; // count a duplicate.\n                break;\n            }\n        }\n    }\n    pageNum = num1+num2-num3;\n    arMalloc(pageInfo, KpmPageInfo, pageNum);\n\n    for( i = 0; i < num1; i++ ) {\n\n        pageInfo[i].pageNo = (*refDataSetPtr1)->pageInfo[i].pageNo;\n\n        // Count the number of imageInfo records in the combined set for this pageNo.\n        imageNum = (*refDataSetPtr1)->pageInfo[i].imageNum;\n        for( j = 0; j < num2; j++ ) {\n            if( (*refDataSetPtr2)->pageInfo[j].pageNo == (*refDataSetPtr1)->pageInfo[i].pageNo ) {\n                imageNum += (*refDataSetPtr2)->pageInfo[j].imageNum;\n            }\n        }\n        arMalloc(pageInfo[i].imageInfo, KpmImageInfo, imageNum);\n\n        // Copy the imageInfo records into the new set.\n        l = (*refDataSetPtr1)->pageInfo[i].imageNum;\n        for( j = 0; j < l; j++ ) {\n            pageInfo[i].imageInfo[j] = (*refDataSetPtr1)->pageInfo[i].imageInfo[j];\n        }\n        for( j = 0; j < num2; j++ ) {\n            if( (*refDataSetPtr2)->pageInfo[j].pageNo == (*refDataSetPtr1)->pageInfo[i].pageNo ) {\n                for( k = 0; k < (*refDataSetPtr2)->pageInfo[j].imageNum; k++ ) {\n                    pageInfo[i].imageInfo[l+k] = (*refDataSetPtr2)->pageInfo[j].imageInfo[k];\n                }\n                break;\n            }\n        }\n        pageInfo[i].imageNum = imageNum;\n    }\n\n    k = 0;\n    for( i = 0; i < num2; i++ ) {\n        for( j = 0; j < num1; j++ ) {\n            if( (*refDataSetPtr2)->pageInfo[i].pageNo == (*refDataSetPtr1)->pageInfo[j].pageNo ) {\n                k++; // count a duplicate.\n                break;\n            }\n        }\n        if( j < num1 ) continue;\n        // If we get to here, we have a page from refDataSetPtr2 which doesn't\n        // have the same pageNo as any page from refDataSetPtr1.\n        pageInfo[num1+i-k].pageNo = (*refDataSetPtr2)->pageInfo[i].pageNo;\n        imageNum = (*refDataSetPtr2)->pageInfo[i].imageNum;\n        arMalloc(pageInfo[num1+i-k].imageInfo, KpmImageInfo, imageNum);\n        for( j = 0; j < imageNum; j++ ) {\n            pageInfo[num1+i-k].imageInfo[j] = (*refDataSetPtr2)->pageInfo[i].imageInfo[j];\n        }\n        pageInfo[num1+i-k].imageNum = imageNum;\n    }\n\n    if ((*refDataSetPtr1)->pageInfo) {\n        for( i = 0; i < (*refDataSetPtr1)->pageNum; i++ ) {\n            free( (*refDataSetPtr1)->pageInfo[i].imageInfo );\n        }\n        free((*refDataSetPtr1)->pageInfo);\n    }\n    (*refDataSetPtr1)->pageInfo = pageInfo;\n    (*refDataSetPtr1)->pageNum  = pageNum;\n\n    // TODO you should not free ptr2 here\n    // because you call this function only for copying data from 2 to 1\n    //kpmDeleteRefDataSet(refDataSetPtr2);\n\n    return 0;\n}\n\nint kpmDeleteRefDataSet( KpmRefDataSet **refDataSetPtr )\n{\n    if (!refDataSetPtr) {\n        ARLOGe(\"kpmDeleteRefDataSet(): NULL refDataSetPtr.\\n\");\n        return (-1);\n    }\n    if (!*refDataSetPtr) return 0; // OK to call on already deleted handle.\n\n    if ((*refDataSetPtr)->refPoint) free((*refDataSetPtr)->refPoint);\n\n    for(int i = 0; i < (*refDataSetPtr)->pageNum; i++ ) {\n        free( (*refDataSetPtr)->pageInfo[i].imageInfo );\n    }\n    free( (*refDataSetPtr)->pageInfo );\n    free( *refDataSetPtr );\n    *refDataSetPtr = NULL;\n\n    return 0;\n}\n\n\nint kpmSaveRefDataSet( const char *filename, const char *ext, KpmRefDataSet  *refDataSet )\n{\n    FILE   *fp;\n    char    fmode[] = \"wb\";\n    int     i, j;\n\n    if (!filename || !refDataSet) {\n        ARLOGe(\"kpmSaveRefDataSet(): NULL filename/refDataSet.\\n\");\n        return (-1);\n    }\n\n    fp = kpmFopen(filename, ext, fmode);\n    if( fp == NULL ) {\n        ARLOGe(\"Error saving KPM data: unable to open file '%s%s%s' for writing.\\n\", filename, (ext ? \".\" : \"\"), (ext ? ext : \"\"));\n        return -1;\n    }\n\n    if( fwrite(&(refDataSet->num), sizeof(int), 1, fp) != 1 ) goto bailBadWrite;\n\n    for(i = 0; i < refDataSet->num; i++ ) {\n        if( fwrite(  &(refDataSet->refPoint[i].coord2D), sizeof(KpmCoord2D), 1, fp) != 1 ) goto bailBadWrite;\n        if( fwrite(  &(refDataSet->refPoint[i].coord3D), sizeof(KpmCoord2D), 1, fp) != 1 ) goto bailBadWrite;\n#if BINARY_FEATURE\n        if( fwrite(  &(refDataSet->refPoint[i].featureVec), sizeof(FreakFeature), 1, fp) != 1 ) goto bailBadWrite;\n#else\n        if( fwrite(  &(refDataSet->refPoint[i].featureVec), sizeof(SurfFeature), 1, fp) != 1 ) goto bailBadWrite;\n#endif\n        if( fwrite(  &(refDataSet->refPoint[i].pageNo),     sizeof(int), 1, fp) != 1 ) goto bailBadWrite;\n        if( fwrite(  &(refDataSet->refPoint[i].refImageNo), sizeof(int), 1, fp) != 1 ) goto bailBadWrite;\n    }\n\n    if( fwrite(&(refDataSet->pageNum), sizeof(int), 1, fp) != 1 ) goto bailBadWrite;\n\n    for( i = 0; i < refDataSet->pageNum; i++ ) {\n        if( fwrite( &(refDataSet->pageInfo[i].pageNo),   sizeof(int), 1, fp) != 1 ) goto bailBadWrite;\n        if( fwrite( &(refDataSet->pageInfo[i].imageNum), sizeof(int), 1, fp) != 1 ) goto bailBadWrite;\n        j = refDataSet->pageInfo[i].imageNum;\n        if( fwrite(  refDataSet->pageInfo[i].imageInfo,  sizeof(KpmImageInfo), j, fp) != j ) goto bailBadWrite;\n    }\n\n    fclose(fp);\n    return 0;\n\nbailBadWrite:\n    ARLOGe(\"Error saving KPM data: error writing data.\\n\");\n    fclose(fp);\n    return -1;\n}\n\nint kpmLoadRefDataSet( const char *filename, const char *ext, KpmRefDataSet **refDataSetPtr )\n{\n    KpmRefDataSet  *refDataSet;\n    FILE           *fp;\n    char            fmode[] = \"rb\";\n    int             i, j;\n\n    if (!filename || !refDataSetPtr) {\n        ARLOGe(\"kpmLoadRefDataSet(): NULL filename/refDataSetPtr.\\n\");\n        return (-1);\n    }\n\n    fp = kpmFopen(filename, ext, fmode);\n    if (!fp) {\n        ARLOGe(\"Error loading KPM data: unable to open file '%s%s%s' for reading.\\n\", filename, (ext ? \".\" : \"\"), (ext ? ext : \"\"));\n        return (-1);\n    }\n\n    arMallocClear(refDataSet, KpmRefDataSet, 1);\n\n    if( fread(&(refDataSet->num), sizeof(int), 1, fp) != 1 ) goto bailBadRead;\n    if( refDataSet->num <= 0 ) goto bailBadRead;\n    arMalloc(refDataSet->refPoint, KpmRefData, refDataSet->num); // each KpmRefData = 68 floats, 3 ints = 284 bytes.\n\n    for(i = 0; i < refDataSet->num; i++ ) {\n        if( fread(  &(refDataSet->refPoint[i].coord2D), sizeof(KpmCoord2D), 1, fp) != 1 ) goto bailBadRead;\n        if( fread(  &(refDataSet->refPoint[i].coord3D), sizeof(KpmCoord2D), 1, fp) != 1 ) goto bailBadRead;\n#if BINARY_FEATURE\n        if( fread(  &(refDataSet->refPoint[i].featureVec), sizeof(FreakFeature), 1, fp) != 1 ) goto bailBadRead;\n#else\n        if( fread(  &(refDataSet->refPoint[i].featureVec), sizeof(SurfFeature), 1, fp) != 1 ) goto bailBadRead;\n#endif\n\n        if( fread(  &(refDataSet->refPoint[i].pageNo),     sizeof(int), 1, fp) != 1 ) goto bailBadRead;\n        if( fread(  &(refDataSet->refPoint[i].refImageNo), sizeof(int), 1, fp) != 1 ) goto bailBadRead;\n    }\n\n    if( fread(&(refDataSet->pageNum), sizeof(int), 1, fp) != 1 ) goto bailBadRead;\n\n    if( refDataSet->pageNum <= 0 ) {\n        refDataSet->pageInfo = NULL;\n        goto bailBadRead;\n    }\n    arMalloc(refDataSet->pageInfo, KpmPageInfo, refDataSet->pageNum);\n\n    for( i = 0; i < refDataSet->pageNum; i++ ) {\n        if( fread( &(refDataSet->pageInfo[i].pageNo),   sizeof(int), 1, fp) != 1 ) goto bailBadRead;\n        if( fread( &(refDataSet->pageInfo[i].imageNum), sizeof(int), 1, fp) != 1 ) goto bailBadRead;\n        j = refDataSet->pageInfo[i].imageNum;\n        arMalloc(refDataSet->pageInfo[i].imageInfo, KpmImageInfo, j);\n        if( fread(  refDataSet->pageInfo[i].imageInfo,  sizeof(KpmImageInfo), j, fp) != j ) goto bailBadRead;\n    }\n\n    *refDataSetPtr = refDataSet;\n\n    fclose(fp);\n    return 0;\n\nbailBadRead:\n    ARLOGe(\"Error loading KPM data: error reading data.\\n\");\n    if (refDataSet->pageInfo) free(refDataSet->pageInfo);\n    if (refDataSet->refPoint) free(refDataSet->refPoint);\n    free(refDataSet);\n    fclose(fp);\n    return (-1);\n}\n\nint kpmLoadRefDataSetOld( const char *filename, const char *ext, KpmRefDataSet **refDataSetPtr )\n{\n#if !BINARY_FEATURE\n    KpmRefDataSet  *refDataSet;\n    FILE           *fp;\n    char            fmode[] = \"rb\";\n    uint32_t        dummy[2];\n    int             i, j;\n\n    if (!filename || !refDataSetPtr) {\n        ARLOGe(\"kpmLoadRefDataSetOld(): NULL filename/refDataSetPtr.\\n\");\n        return (-1);\n    }\n\n    fp = kpmFopen(filename, ext, fmode);\n    if( fp == NULL ) {\n        ARLOGe(\"Error loading KPM data: unable to open file '%s%s%s' for reading.\\n\", filename, (ext ? \".\" : \"\"), (ext ? ext : \"\"));\n        return -1;\n    }\n\n    arMallocClear(refDataSet, KpmRefDataSet, 1);\n\n    if( fread(&(refDataSet->num), sizeof(int), 1, fp) != 1 ) goto bailBadRead;\n    if( refDataSet->num <= 0 ) goto bailBadRead;\n    arMalloc(refDataSet->refPoint, KpmRefData, refDataSet->num);\n\n    if( fread(dummy, sizeof(uint32_t), 2, fp) != 2 ) goto bailBadRead; // Skip old (int)refDataSet->surfThresh and (int)refDataSet->coord3DFlag.\n\n    for(i = 0; i < refDataSet->num; i++ ) {\n        if( fread(  &(refDataSet->refPoint[i].coord2D), sizeof(KpmCoord2D), 1, fp) != 1 ) goto bailBadRead;\n        if( fread(  &(refDataSet->refPoint[i].coord3D), sizeof(KpmCoord2D), 1, fp) != 1 ) goto bailBadRead;\n        //if( fread(  &(refDataSet->refPoint[i].featureVec), sizeof(SurfFeature), 1, fp) != 1 ) {\n        //    goto bailBadRead;\n        //}\n        if( fread( &(refDataSet->refPoint[i].featureVec.v[0]), sizeof(float), SURF_SUB_DIMENSION, fp) != SURF_SUB_DIMENSION ) goto bailBadRead;\n        refDataSet->refPoint[i].featureVec.l = 2;\n        if( fread(  &(refDataSet->refPoint[i].pageNo),     sizeof(int), 1, fp) != 1 ) goto bailBadRead;\n        if( fread(  &(refDataSet->refPoint[i].refImageNo), sizeof(int), 1, fp) != 1 ) goto bailBadRead;\n        refDataSet->refPoint[i].pageNo     = 1;\n        refDataSet->refPoint[i].refImageNo = 1;\n    }\n\n    if( fread(&(refDataSet->pageNum), sizeof(int), 1, fp) != 1 ) goto bailBadRead;\n    if( refDataSet->pageNum <= 0 ) {\n        refDataSet->pageInfo = NULL;\n        goto bailBadRead;\n    }\n    arMalloc(refDataSet->pageInfo, KpmPageInfo, refDataSet->pageNum);\n\n    for( i = 0; i < refDataSet->pageNum; i++ ) {\n        if( fread( &(refDataSet->pageInfo[i].pageNo),   sizeof(int), 1, fp) != 1 ) goto bailBadRead;\n        //if( fread( &(refDataSet->pageInfo[i].imageNum), sizeof(int), 1, fp) != 1 ) goto bailBadRead;\n        refDataSet->pageInfo[i].imageNum = 1;\n        j = refDataSet->pageInfo[i].imageNum;\n        arMalloc(refDataSet->pageInfo[i].imageInfo, KpmImageInfo, j);\n        //if( fread(  refDataSet->pageInfo[i].imageInfo,  sizeof(KpmImageInfo), j, fp) != j ) goto bailBadRead;\n        refDataSet->pageInfo[i].imageInfo->width  = 1000;\n        refDataSet->pageInfo[i].imageInfo->height = 1000;\n        refDataSet->pageInfo[i].imageInfo->imageNo = 1;\n    }\n\n    *refDataSetPtr = refDataSet;\n\n    fclose(fp);\n    return 0;\n\nbailBadRead:\n    ARLOGe(\"Error loading KPM data: error reading data.\\n\");\n    if (refDataSet->pageInfo) free(refDataSet->pageInfo);\n    if (refDataSet->refPoint) free(refDataSet->refPoint);\n    free(refDataSet);\n    fclose(fp);\n    return (-1);\n#else\n    return 0;\n#endif\n\n}\n\nint kpmChangePageNoOfRefDataSet ( KpmRefDataSet *refDataSet, int oldPageNo, int newPageNo )\n{\n    if (!refDataSet) {\n        ARLOGe(\"kpmChangePageNoOfRefDataSet(): NULL refDataSet.\\n\");\n        return (-1);\n    }\n\n    ARLOGi(\"in changepagenoofrefdataset %d\\n\", refDataSet->num);\n\n    for(int i = 0; i < refDataSet->num; i++ ) {\n        if( refDataSet->refPoint[i].pageNo == oldPageNo || (oldPageNo == KpmChangePageNoAllPages && refDataSet->refPoint[i].pageNo >= 0) ) {\n            refDataSet->refPoint[i].pageNo = newPageNo;\n        }\n    }\n\n    for(int i = 0; i < refDataSet->pageNum; i++ ) {\n        if( refDataSet->pageInfo[i].pageNo == oldPageNo || (oldPageNo == KpmChangePageNoAllPages && refDataSet->pageInfo[i].pageNo >= 0) ) {\n            refDataSet->pageInfo[i].pageNo = newPageNo;\n        }\n    }\n\n    return 0;\n}\n","/*\n *  AR2/util.c\n *  ARToolKit5\n *\n *  This file is part of ARToolKit.\n *\n *  ARToolKit is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation, either version 3 of the License, or\n *  (at your option) any later version.\n *\n *  ARToolKit is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public License\n *  along with ARToolKit.  If not, see <http://www.gnu.org/licenses/>.\n *\n *  As a special exception, the copyright holders of this library give you\n *  permission to link this library with independent modules to produce an\n *  executable, regardless of the license terms of these independent modules, and to\n *  copy and distribute the resulting executable under terms of your choice,\n *  provided that you also meet, for each linked independent module, the terms and\n *  conditions of the license of that module. An independent module is a module\n *  which is neither derived from nor based on this library. If you modify this\n *  library, you may extend this exception to your version of the library, but you\n *  are not obligated to do so. If you do not wish to do so, delete this exception\n *  statement from your version.\n *\n *  Copyright 2015 Daqri, LLC.\n *  Copyright 2006-2015 ARToolworks, Inc.\n *\n *  Author(s): Hirokazu Kato, Philip Lamb\n *\n */\n\n#include <AR/ar.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <AR2/util.h>\n\nint ar2UtilReplaceExt( char *filename, int n, char *ext )\n{\n    return arUtilReplaceExt( filename, n, ext );\n}\n\nint ar2UtilRemoveExt( char *filename )\n{\n    return arUtilRemoveExt( filename );\n}\n\nint ar2UtilDivideExt( const char *filename, char *s1, char *s2 )\n{\n    return arUtilDivideExt( filename, s1, s2 );\n}\n","/*\n *  kpmHandle.cpp\n *  ARToolKit5\n *\n *  This file is part of ARToolKit.\n *\n *  ARToolKit is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation, either version 3 of the License, or\n *  (at your option) any later version.\n *\n *  ARToolKit is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public License\n *  along with ARToolKit.  If not, see <http://www.gnu.org/licenses/>.\n *\n *  As a special exception, the copyright holders of this library give you\n *  permission to link this library with independent modules to produce an\n *  executable, regardless of the license terms of these independent modules, and to\n *  copy and distribute the resulting executable under terms of your choice,\n *  provided that you also meet, for each linked independent module, the terms and\n *  conditions of the license of that module. An independent module is a module\n *  which is neither derived from nor based on this library. If you modify this\n *  library, you may extend this exception to your version of the library, but you\n *  are not obligated to do so. If you do not wish to do so, delete this exception\n *  statement from your version.\n *\n *  Copyright 2015 Daqri, LLC. All rights reserved.\n *  Copyright 2006-2015 ARToolworks, Inc. All rights reserved.\n *  Author(s): Hirokazu Kato, Philip Lamb\n *\n */\n\n#include <stdio.h>\n#include <AR/ar.h>\n#include <KPM/kpm.h>\n#include \"kpmPrivate.h\"\n#if !BINARY_FEATURE\n#include \"AnnMatch.h\"\n#include \"AnnMatch2.h\"\n#endif\n\nstatic KpmHandle *kpmCreateHandleCore( ARParamLT *cparamLT, int xsize, int ysize, int poseMode, AR_PIXEL_FORMAT pixFormat );\n\nKpmHandle *kpmCreateHandle( ARParamLT *cparamLT, AR_PIXEL_FORMAT pixFormat )\n{\n    return kpmCreateHandleCore( cparamLT, cparamLT->param.xsize, cparamLT->param.ysize, KpmPose6DOF, pixFormat);\n}\n\nKpmHandle *kpmCreateHandleHomography( int xsize, int ysize, AR_PIXEL_FORMAT pixFormat )\n{\n    return kpmCreateHandleCore( NULL, xsize, ysize, KpmPoseHomography, pixFormat );\n}\n\nKpmHandle *kpmCreateHandle2( int xsize, int ysize, AR_PIXEL_FORMAT pixFormat )\n{\n    return kpmCreateHandleCore( NULL, xsize, ysize, KpmPoseHomography, pixFormat );\n}\n\nstatic KpmHandle *kpmCreateHandleCore( ARParamLT *cparamLT, int xsize, int ysize, int poseMode, AR_PIXEL_FORMAT pixFormat )\n{\n    KpmHandle       *kpmHandle;\n#if !BINARY_FEATURE\n    int surfXSize, surfYSize;\n#endif\n    \n    if (pixFormat != AR_PIXEL_FORMAT_MONO && pixFormat != AR_PIXEL_FORMAT_420v && pixFormat != AR_PIXEL_FORMAT_420f && pixFormat != AR_PIXEL_FORMAT_NV21) {\n        ARLOGw(\"Performance warning: KPM processing is not using a mono pixel format.\\n\");\n    }\n\n    arMallocClear( kpmHandle, KpmHandle, 1 );\n\n#if BINARY_FEATURE\n    kpmHandle->freakMatcher             = new vision::VisualDatabaseFacade;\n#else\n    kpmHandle->ann2                     = NULL;\n#endif\n    \n    kpmHandle->cparamLT                = cparamLT;\n    kpmHandle->poseMode                = poseMode;\n    kpmHandle->xsize                   = xsize;\n    kpmHandle->ysize                   = ysize;\n    kpmHandle->pixFormat               = pixFormat;\n    kpmHandle->procMode                = KpmDefaultProcMode;\n    kpmHandle->detectedMaxFeature      = -1;\n#if !BINARY_FEATURE\n    kpmHandle->surfThreadNum           = -1;\n#endif\n    \n    kpmHandle->refDataSet.refPoint     = NULL;\n    kpmHandle->refDataSet.num          = 0;\n    kpmHandle->refDataSet.pageInfo     = NULL;\n    kpmHandle->refDataSet.pageNum      = 0;\n\n    kpmHandle->inDataSet.coord         = NULL;\n    kpmHandle->inDataSet.num           = 0;\n\n#if !BINARY_FEATURE\n    kpmHandle->preRANSAC.num           = 0;\n    kpmHandle->preRANSAC.match         = NULL;\n    kpmHandle->aftRANSAC.num           = 0;\n    kpmHandle->aftRANSAC.match         = NULL;\n\n    kpmHandle->skipRegion.regionMax    = 0;\n    kpmHandle->skipRegion.regionNum    = 0;\n    kpmHandle->skipRegion.region       = NULL;\n#endif\n\n    kpmHandle->result                  = NULL;\n    kpmHandle->resultNum               = 0;\n\n#if !BINARY_FEATURE\n    switch (kpmHandle->procMode) {\n        case KpmProcFullSize:     surfXSize = xsize;     surfYSize = ysize;     break;\n        case KpmProcHalfSize:     surfXSize = xsize/2;   surfYSize = ysize/2;   break;\n        case KpmProcQuatSize:     surfXSize = xsize/4;   surfYSize = ysize/4;   break;\n        case KpmProcOneThirdSize: surfXSize = xsize/3;   surfYSize = ysize/3;   break;\n        case KpmProcTwoThirdSize: surfXSize = xsize/3*2; surfYSize = ysize/3*2; break;\n        default: ARLOGe(\"Error: Unknown kpmProcMode %d.\\n\", kpmHandle->procMode); goto bail; break;\n    }\n\n    kpmHandle->surfHandle = surfSubCreateHandle(surfXSize, surfYSize, AR_PIXEL_FORMAT_MONO);\n    if (!kpmHandle->surfHandle) {\n        ARLOGe(\"Error: unable to initialise KPM feature matching.\\n\");\n        goto bail;\n    }\n    \n    surfSubSetMaxPointNum(kpmHandle->surfHandle, kpmHandle->detectedMaxFeature);\n#endif\n    \n    return kpmHandle;\n    \n#if !BINARY_FEATURE\nbail:\n    free(kpmHandle);\n    return (NULL);\n#endif\n}\n\nint kpmHandleGetXSize(const KpmHandle *kpmHandle)\n{\n    if (!kpmHandle) return 0;\n    return kpmHandle->xsize;\n}\n\nint kpmHandleGetYSize(const KpmHandle *kpmHandle)\n{\n    if (!kpmHandle) return 0;\n    return kpmHandle->ysize;\n}\n\nAR_PIXEL_FORMAT kpmHandleGetPixelFormat(const KpmHandle *kpmHandle)\n{\n    if (!kpmHandle) return AR_PIXEL_FORMAT_INVALID;\n    return kpmHandle->pixFormat;\n}\n\nint kpmSetProcMode( KpmHandle *kpmHandle,  KPM_PROC_MODE mode )\n{\n#if !BINARY_FEATURE\n   int    thresh;\n    int    maxPointNum;\n    int surfXSize, surfYSize;\n#endif\n    \n    if( kpmHandle == NULL ) return -1;\n    \n    if( kpmHandle->procMode == mode ) return 0;\n    kpmHandle->procMode = mode;\n\n#if !BINARY_FEATURE\n    surfSubGetThresh( kpmHandle->surfHandle, &thresh );\n    surfSubGetMaxPointNum( kpmHandle->surfHandle, &maxPointNum );\n    \n    surfSubDeleteHandle( &(kpmHandle->surfHandle) );\n\n    switch (kpmHandle->procMode) {\n        case KpmProcFullSize:     surfXSize = kpmHandle->xsize;     surfYSize = kpmHandle->ysize;     break;\n        case KpmProcHalfSize:     surfXSize = kpmHandle->xsize/2;   surfYSize = kpmHandle->ysize/2;   break;\n        case KpmProcQuatSize:     surfXSize = kpmHandle->xsize/4;   surfYSize = kpmHandle->ysize/4;   break;\n        case KpmProcOneThirdSize: surfXSize = kpmHandle->xsize/3;   surfYSize = kpmHandle->ysize/3;   break;\n        case KpmProcTwoThirdSize: surfXSize = kpmHandle->xsize/3*2; surfYSize = kpmHandle->ysize/3*2; break;\n        default: ARLOGe(\"Error: Unknown kpmProcMode %d.\\n\", kpmHandle->procMode); goto bail; break;\n    }\n    kpmHandle->surfHandle = surfSubCreateHandle(surfXSize, surfYSize, AR_PIXEL_FORMAT_MONO);\n    if (!kpmHandle->surfHandle) {\n        ARLOGe(\"Error: unable to initialise KPM feature matching.\\n\");\n        goto bail;\n    }\n\n    surfSubSetThresh( kpmHandle->surfHandle, thresh );\n    surfSubSetMaxPointNum( kpmHandle->surfHandle, maxPointNum );\n#endif\n    \n    return 0;\n    \n#if !BINARY_FEATURE\nbail:\n    return (-1);\n#endif\n}\n\nint kpmGetProcMode( KpmHandle *kpmHandle, KPM_PROC_MODE *mode )\n{\n    if( kpmHandle == NULL ) return -1;\n    *mode = kpmHandle->procMode;\n    return 0;\n}\n\nint kpmSetDetectedFeatureMax( KpmHandle *kpmHandle, int  detectedMaxFeature )\n{\n    kpmHandle->detectedMaxFeature = detectedMaxFeature;\n#if !BINARY_FEATURE\n    surfSubSetMaxPointNum(kpmHandle->surfHandle, kpmHandle->detectedMaxFeature);\n#endif\n    return 0;\n}\n\nint kpmGetDetectedFeatureMax( KpmHandle *kpmHandle, int *detectedMaxFeature )\n{\n    *detectedMaxFeature = kpmHandle->detectedMaxFeature;\n    return 0;\n}\n\nint kpmSetSurfThreadNum( KpmHandle *kpmHandle, int surfThreadNum )\n{\n#if !BINARY_FEATURE\n    kpmHandle->surfThreadNum = surfThreadNum;\n    surfSubSetThreadNum(kpmHandle->surfHandle, kpmHandle->surfThreadNum);\n#endif\n    return 0;\n}\n\n\n\nint kpmDeleteHandle( KpmHandle **kpmHandle )\n{\n    if( *kpmHandle == NULL ) return -1;\n\n#if BINARY_FEATURE\n    delete (*kpmHandle)->freakMatcher;\n#else\n    CAnnMatch2  *ann2 = (CAnnMatch2 *)((*kpmHandle)->ann2);\n    delete ann2;\n\n    surfSubDeleteHandle( &((*kpmHandle)->surfHandle) );\n    \n#endif\n    \n    if( (*kpmHandle)->refDataSet.refPoint != NULL ) {\n        free( (*kpmHandle)->refDataSet.refPoint );\n    }\n    if( (*kpmHandle)->refDataSet.pageInfo != NULL ) {\n        free( (*kpmHandle)->refDataSet.pageInfo );\n    }\n#if !BINARY_FEATURE\n    if( (*kpmHandle)->preRANSAC.match != NULL ) {\n        free( (*kpmHandle)->preRANSAC.match );\n    }\n    if( (*kpmHandle)->aftRANSAC.match != NULL ) {\n        free( (*kpmHandle)->aftRANSAC.match );\n    }\n\n    if( (*kpmHandle)->skipRegion.region != NULL ) {\n        free( (*kpmHandle)->skipRegion.region );\n    }\n#endif\n    if( (*kpmHandle)->result != NULL ) {\n        free( (*kpmHandle)->result );\n    }\n    if( (*kpmHandle)->inDataSet.coord != NULL ) {\n        free( (*kpmHandle)->inDataSet.coord );\n    }\n\n    free( *kpmHandle );\n    *kpmHandle = NULL;\n\n    return 0;\n}\n","/*\n *  icpCore.c\n *  ARToolKit5\n *\n *  This file is part of ARToolKit.\n *\n *  ARToolKit is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation, either version 3 of the License, or\n *  (at your option) any later version.\n *\n *  ARToolKit is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public License\n *  along with ARToolKit.  If not, see <http://www.gnu.org/licenses/>.\n *\n *  As a special exception, the copyright holders of this library give you\n *  permission to link this library with independent modules to produce an\n *  executable, regardless of the license terms of these independent modules, and to\n *  copy and distribute the resulting executable under terms of your choice,\n *  provided that you also meet, for each linked independent module, the terms and\n *  conditions of the license of that module. An independent module is a module\n *  which is neither derived from nor based on this library. If you modify this\n *  library, you may extend this exception to your version of the library, but you\n *  are not obligated to do so. If you do not wish to do so, delete this exception\n *  statement from your version.\n *\n *  Copyright 2015 Daqri, LLC.\n *  Copyright 2007-2015 ARToolworks, Inc.\n *\n *  Author(s): Hirokazu Kato\n *\n */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n#include <AR/ar.h>\n#include <AR/icpCore.h>\n\n#ifdef ARDOUBLE_IS_FLOAT\n#  define SQRT sqrtf\n#  define COS cosf\n#  define SIN sinf\n#  define ONE 1.0f\n#else\n#  define SQRT sqrt\n#  define COS cos\n#  define SIN sin\n#  define ONE 1.0\n#endif\n\n\nstatic int icpGetJ_U_Xc( ARdouble J_U_Xc[2][3], ARdouble matXc2U[3][4], ICP3DCoordT *cameraCoord );\nstatic int icpGetJ_Xc_S( ARdouble J_Xc_S[3][6], ICP3DCoordT *cameraCoord, ARdouble T0[3][4], ICP3DCoordT *worldCoord );\nstatic int icpGetJ_T_S( ARdouble J_T_S[12][6] );\nstatic int icpGetQ_from_S( ARdouble q[7], ARdouble s[6] );\nstatic int icpGetMat_from_Q( ARdouble mat[3][4], ARdouble q[7] );\n\nint icpGetXc_from_Xw_by_MatXw2Xc( ICP3DCoordT *Xc, ARdouble matXw2Xc[3][4], ICP3DCoordT *Xw )\n{\n    Xc->x = matXw2Xc[0][0] * Xw->x + matXw2Xc[0][1] * Xw->y + matXw2Xc[0][2] * Xw->z + matXw2Xc[0][3];\n    Xc->y = matXw2Xc[1][0] * Xw->x + matXw2Xc[1][1] * Xw->y + matXw2Xc[1][2] * Xw->z + matXw2Xc[1][3];\n    Xc->z = matXw2Xc[2][0] * Xw->x + matXw2Xc[2][1] * Xw->y + matXw2Xc[2][2] * Xw->z + matXw2Xc[2][3];\n\n    return 0;\n}\n\nint icpGetU_from_X_by_MatX2U( ICP2DCoordT *u, ARdouble matX2U[3][4], ICP3DCoordT *coord3d )\n{\n    ARdouble    hx, hy, h;\n\n    hx = matX2U[0][0] * coord3d->x + matX2U[0][1] * coord3d->y\n       + matX2U[0][2] * coord3d->z + matX2U[0][3];\n    hy = matX2U[1][0] * coord3d->x + matX2U[1][1] * coord3d->y\n       + matX2U[1][2] * coord3d->z + matX2U[1][3];\n    h  = matX2U[2][0] * coord3d->x + matX2U[2][1] * coord3d->y\n       + matX2U[2][2] * coord3d->z + matX2U[2][3];\n\n    if( h == 0.0 ) return -1;\n\n    u->x = hx / h;\n    u->y = hy / h;\n\n    return 0;\n}\n\nint icpGetJ_U_S( ARdouble J_U_S[2][6], ARdouble matXc2U[3][4], ARdouble matXw2Xc[3][4], ICP3DCoordT *worldCoord )\n{\n    ARdouble        J_Xc_S[3][6];\n    ARdouble        J_U_Xc[2][3];\n    ICP3DCoordT   Xc;\n    int           i, j, k;\n\n    if( icpGetJ_Xc_S( J_Xc_S, &Xc, matXw2Xc, worldCoord ) < 0 ) {\n        ARLOGe(\"Error: icpGetJ_Xc_S\\n\");\n        return -1;\n    }\n#if ICP_DEBUG\n    icpDispMat( \"J_Xc_S\", (ARdouble *)J_Xc_S, 3, 6 );\n#endif\n\n    if( icpGetJ_U_Xc( J_U_Xc, matXc2U, &Xc ) < 0 ) {\n        ARLOGe(\"Error: icpGetJ_U_Xc\");\n        return -1;\n    }\n#if ICP_DEBUG\n    icpDispMat( \"J_U_Xc\", (ARdouble *)J_U_Xc, 2, 3 );\n#endif\n\n    for( j = 0; j < 2; j++ ) {\n        for( i = 0; i < 6; i++ ) {\n            J_U_S[j][i] = 0.0;\n            for( k = 0; k < 3; k++ ) {\n                J_U_S[j][i] += J_U_Xc[j][k] * J_Xc_S[k][i];\n            }\n        }\n    }\n#if ICP_DEBUG\n    icpDispMat( \"J_U_S\", (ARdouble *)J_U_S, 2, 6 );\n#endif\n\n    return 0;\n}\n\nint icpGetDeltaS( ARdouble S[6], ARdouble dU[], ARdouble J_U_S[][6], int n )\n{\n    ARMat   matS, matU, matJ;\n    ARMat  *matJt, *matJtJ, *matJtU;\n\n    matS.row = 6;\n    matS.clm = 1;\n    matS.m   = S;\n\n    matU.row = n;\n    matU.clm = 1;\n    matU.m   = dU;\n\n    matJ.row = n;\n    matJ.clm = 6;\n    matJ.m   = &J_U_S[0][0];\n\n#if ICP_DEBUG\n    ARLOG(\"cc1 - matU\\n\");\n    arMatrixDisp( &matU );\n    ARLOG(\"cc1 - matJ\\n\");\n    arMatrixDisp( &matJ );\n#endif\n    matJt = arMatrixAllocTrans( &matJ );\n    if( matJt == NULL ) return -1;\n#if ICP_DEBUG\n    ARLOG(\"cc1 - matJt\\n\");\n    arMatrixDisp( matJt );\n#endif\n    matJtJ = arMatrixAllocMul( matJt, &matJ );\n    if( matJtJ == NULL ) {\n        arMatrixFree( matJt );\n        return -1;\n    }\n#if ICP_DEBUG\n    ARLOG(\"cc2 - matJtJ\\n\");\n    arMatrixDisp( matJtJ );\n#endif\n    matJtU = arMatrixAllocMul( matJt, &matU );\n    if( matJtU == NULL ) {\n        arMatrixFree( matJt );\n        arMatrixFree( matJtJ );\n        return -1;\n    }\n#if ICP_DEBUG\n    ARLOG(\"cc3 -- matJtU\\n\");\n    arMatrixDisp( matJtU );\n#endif\n    if( arMatrixSelfInv(matJtJ) < 0 ) {\n        arMatrixFree( matJt );\n        arMatrixFree( matJtJ );\n        arMatrixFree( matJtU );\n        return -1;\n    }\n\n#if ICP_DEBUG\n    ARLOG(\"cc4 -- matJtJ_Inv\\n\");\n    arMatrixDisp( matJtJ );\n#endif\n    arMatrixMul( &matS, matJtJ, matJtU );\n    arMatrixFree( matJt );\n    arMatrixFree( matJtJ );\n    arMatrixFree( matJtU );\n#if ICP_DEBUG\n    ARLOG(\"cc5 -- matS\\n\");\n    arMatrixDisp( &matS );\n#endif\n\n    return 0;\n}\n\nint icpUpdateMat( ARdouble matXw2Xc[3][4], ARdouble dS[6] )\n{\n    ARdouble   q[7];\n    ARdouble   mat[3][4], mat2[3][4];\n    int      i, j;\n\n    if( icpGetQ_from_S(q, dS) < 0 ) return -1;\n    if( icpGetMat_from_Q( mat, q ) < 0 ) return -1;\n\n    for( j = 0; j < 3; j++ ) {\n        for( i = 0; i < 4; i++ ) {\n            mat2[j][i] = matXw2Xc[j][0] * mat[0][i]\n                       + matXw2Xc[j][1] * mat[1][i]\n                       + matXw2Xc[j][2] * mat[2][i];\n        }\n        mat2[j][3] += matXw2Xc[j][3];\n    }\n\n    for( j = 0; j < 3; j++ ) {\n        for( i = 0; i < 4; i++ ) matXw2Xc[j][i] = mat2[j][i];\n    }\n\n    return 0;\n}\n\nvoid icpDispMat( char *title, ARdouble *mat, int row, int clm )\n{\n    int    i, j;\n\n    ARLOG(\"====== %s ========\\n\", title);\n    for( j = 0; j < row; j++ ) {\n        for( i = 0; i < clm; i++ ) {\n            ARLOG(\"%7.5f \", mat[j*clm+i]);\n        }\n        ARLOG(\"\\n\");\n    }\n    ARLOG(\"-------------------------\\n\");\n\n    return;\n}\n\n\nstatic int icpGetJ_U_Xc( ARdouble J_U_Xc[2][3], ARdouble matXc2U[3][4], ICP3DCoordT *cameraCoord )\n{\n    ARdouble   w1, w2, w3, w3_w3;\n\n    w1 = matXc2U[0][0] * cameraCoord->x + matXc2U[0][1] * cameraCoord->y + matXc2U[0][2] * cameraCoord->z + matXc2U[0][3];\n    w2 = matXc2U[1][0] * cameraCoord->x + matXc2U[1][1] * cameraCoord->y + matXc2U[1][2] * cameraCoord->z + matXc2U[1][3];\n    w3 = matXc2U[2][0] * cameraCoord->x + matXc2U[2][1] * cameraCoord->y + matXc2U[2][2] * cameraCoord->z + matXc2U[2][3];\n\n    if( w3 == 0.0 ) return -1;\n\n    w3_w3 = w3 * w3;\n    J_U_Xc[0][0] = (matXc2U[0][0] * w3 - matXc2U[2][0] * w1) / w3_w3;\n    J_U_Xc[0][1] = (matXc2U[0][1] * w3 - matXc2U[2][1] * w1) / w3_w3;\n    J_U_Xc[0][2] = (matXc2U[0][2] * w3 - matXc2U[2][2] * w1) / w3_w3;\n    J_U_Xc[1][0] = (matXc2U[1][0] * w3 - matXc2U[2][0] * w2) / w3_w3;\n    J_U_Xc[1][1] = (matXc2U[1][1] * w3 - matXc2U[2][1] * w2) / w3_w3;\n    J_U_Xc[1][2] = (matXc2U[1][2] * w3 - matXc2U[2][2] * w2) / w3_w3;\n\n    return 0;\n}\n\nstatic int icpGetJ_Xc_S( ARdouble J_Xc_S[3][6], ICP3DCoordT *cameraCoord, ARdouble T0[3][4], ICP3DCoordT *worldCoord )\n{\n    ARdouble   J_Xc_T[3][12];\n    ARdouble   J_T_S[12][6];\n    int      i, j, k;\n\n    cameraCoord->x = T0[0][0]*worldCoord->x + T0[0][1]*worldCoord->y + T0[0][2]*worldCoord->z + T0[0][3];\n    cameraCoord->y = T0[1][0]*worldCoord->x + T0[1][1]*worldCoord->y + T0[1][2]*worldCoord->z + T0[1][3];\n    cameraCoord->z = T0[2][0]*worldCoord->x + T0[2][1]*worldCoord->y + T0[2][2]*worldCoord->z + T0[2][3];\n\n    J_Xc_T[0][0] = T0[0][0] * worldCoord->x;\n    J_Xc_T[0][1] = T0[0][0] * worldCoord->y;\n    J_Xc_T[0][2] = T0[0][0] * worldCoord->z;\n    J_Xc_T[0][3] = T0[0][1] * worldCoord->x;\n    J_Xc_T[0][4] = T0[0][1] * worldCoord->y;\n    J_Xc_T[0][5] = T0[0][1] * worldCoord->z;\n    J_Xc_T[0][6] = T0[0][2] * worldCoord->x;\n    J_Xc_T[0][7] = T0[0][2] * worldCoord->y;\n    J_Xc_T[0][8] = T0[0][2] * worldCoord->z;\n    J_Xc_T[0][9] = T0[0][0];\n    J_Xc_T[0][10] = T0[0][1];\n    J_Xc_T[0][11] = T0[0][2];\n\n    J_Xc_T[1][0] = T0[1][0] * worldCoord->x;\n    J_Xc_T[1][1] = T0[1][0] * worldCoord->y;\n    J_Xc_T[1][2] = T0[1][0] * worldCoord->z;\n    J_Xc_T[1][3] = T0[1][1] * worldCoord->x;\n    J_Xc_T[1][4] = T0[1][1] * worldCoord->y;\n    J_Xc_T[1][5] = T0[1][1] * worldCoord->z;\n    J_Xc_T[1][6] = T0[1][2] * worldCoord->x;\n    J_Xc_T[1][7] = T0[1][2] * worldCoord->y;\n    J_Xc_T[1][8] = T0[1][2] * worldCoord->z;\n    J_Xc_T[1][9] = T0[1][0];\n    J_Xc_T[1][10] = T0[1][1];\n    J_Xc_T[1][11] = T0[1][2];\n\n    J_Xc_T[2][0] = T0[2][0] * worldCoord->x;\n    J_Xc_T[2][1] = T0[2][0] * worldCoord->y;\n    J_Xc_T[2][2] = T0[2][0] * worldCoord->z;\n    J_Xc_T[2][3] = T0[2][1] * worldCoord->x;\n    J_Xc_T[2][4] = T0[2][1] * worldCoord->y;\n    J_Xc_T[2][5] = T0[2][1] * worldCoord->z;\n    J_Xc_T[2][6] = T0[2][2] * worldCoord->x;\n    J_Xc_T[2][7] = T0[2][2] * worldCoord->y;\n    J_Xc_T[2][8] = T0[2][2] * worldCoord->z;\n    J_Xc_T[2][9] = T0[2][0];\n    J_Xc_T[2][10] = T0[2][1];\n    J_Xc_T[2][11] = T0[2][2];\n\n    if( icpGetJ_T_S( J_T_S ) < 0 ) return -1;\n\n    for( j = 0; j < 3; j++ ) {\n        for( i = 0; i < 6; i++ ) {\n            J_Xc_S[j][i] = 0.0;\n            for( k = 0; k < 12; k++ ) {\n                J_Xc_S[j][i] += J_Xc_T[j][k] * J_T_S[k][i];\n            }\n        }\n    }\n\n    return 0;\n}\n\nstatic int icpGetJ_T_S( ARdouble J_T_S[12][6] )\n{\n    J_T_S[0][0] = 0.0;\n    J_T_S[0][1] = 0.0;\n    J_T_S[0][2] = 0.0;\n    J_T_S[0][3] = 0.0;\n    J_T_S[0][4] = 0.0;\n    J_T_S[0][5] = 0.0;\n\n    J_T_S[1][0] = 0.0;\n    J_T_S[1][1] = 0.0;\n    J_T_S[1][2] = -1.0;\n    J_T_S[1][3] = 0.0;\n    J_T_S[1][4] = 0.0;\n    J_T_S[1][5] = 0.0;\n\n    J_T_S[2][0] = 0.0;\n    J_T_S[2][1] = 1.0;\n    J_T_S[2][2] = 0.0;\n    J_T_S[2][3] = 0.0;\n    J_T_S[2][4] = 0.0;\n    J_T_S[2][5] = 0.0;\n\n    J_T_S[3][0] = 0.0;\n    J_T_S[3][1] = 0.0;\n    J_T_S[3][2] = 1.0;\n    J_T_S[3][3] = 0.0;\n    J_T_S[3][4] = 0.0;\n    J_T_S[3][5] = 0.0;\n\n    J_T_S[4][0] = 0.0;\n    J_T_S[4][1] = 0.0;\n    J_T_S[4][2] = 0.0;\n    J_T_S[4][3] = 0.0;\n    J_T_S[4][4] = 0.0;\n    J_T_S[4][5] = 0.0;\n\n    J_T_S[5][0] = -1.0;\n    J_T_S[5][1] = 0.0;\n    J_T_S[5][2] = 0.0;\n    J_T_S[5][3] = 0.0;\n    J_T_S[5][4] = 0.0;\n    J_T_S[5][5] = 0.0;\n\n    J_T_S[6][0] = 0.0;\n    J_T_S[6][1] = -1.0;\n    J_T_S[6][2] = 0.0;\n    J_T_S[6][3] = 0.0;\n    J_T_S[6][4] = 0.0;\n    J_T_S[6][5] = 0.0;\n\n    J_T_S[7][0] = 1.0;\n    J_T_S[7][1] = 0.0;\n    J_T_S[7][2] = 0.0;\n    J_T_S[7][3] = 0.0;\n    J_T_S[7][4] = 0.0;\n    J_T_S[7][5] = 0.0;\n\n    J_T_S[8][0] = 0.0;\n    J_T_S[8][1] = 0.0;\n    J_T_S[8][2] = 0.0;\n    J_T_S[8][3] = 0.0;\n    J_T_S[8][4] = 0.0;\n    J_T_S[8][5] = 0.0;\n\n    J_T_S[9][0] = 0.0;\n    J_T_S[9][1] = 0.0;\n    J_T_S[9][2] = 0.0;\n    J_T_S[9][3] = 1.0;\n    J_T_S[9][4] = 0.0;\n    J_T_S[9][5] = 0.0;\n\n    J_T_S[10][0] = 0.0;\n    J_T_S[10][1] = 0.0;\n    J_T_S[10][2] = 0.0;\n    J_T_S[10][3] = 0.0;\n    J_T_S[10][4] = 1.0;\n    J_T_S[10][5] = 0.0;\n\n    J_T_S[11][0] = 0.0;\n    J_T_S[11][1] = 0.0;\n    J_T_S[11][2] = 0.0;\n    J_T_S[11][3] = 0.0;\n    J_T_S[11][4] = 0.0;\n    J_T_S[11][5] = 1.0;\n\n    return 0;\n}\n\nstatic int icpGetQ_from_S( ARdouble q[7], ARdouble s[6] )\n{\n    ARdouble    ra;\n\n    ra = s[0]*s[0] + s[1]*s[1] + s[2]*s[2];\n    if( ra == 0.0 ) {\n        q[0] = 1.0;\n        q[1] = 0.0;\n        q[2] = 0.0;\n        q[3] = 0.0;\n    }\n    else {\n        ra = SQRT(ra);\n        q[0] = s[0] / ra;\n        q[1] = s[1] / ra;\n        q[2] = s[2] / ra;\n        q[3] = ra;\n    }\n    q[4] = s[3];\n    q[5] = s[4];\n    q[6] = s[5];\n\n    return 0;\n}\n\nstatic int icpGetMat_from_Q( ARdouble mat[3][4], ARdouble q[7] )\n{\n    ARdouble    cra, one_cra, sra;\n\n    cra = COS(q[3]);\n    one_cra = ONE - cra;\n    sra = SIN(q[3]);\n\n    mat[0][0] = q[0]*q[0]*one_cra + cra;\n    mat[0][1] = q[0]*q[1]*one_cra - q[2]*sra;\n    mat[0][2] = q[0]*q[2]*one_cra + q[1]*sra;\n    mat[0][3] = q[4];\n    mat[1][0] = q[1]*q[0]*one_cra + q[2]*sra;\n    mat[1][1] = q[1]*q[1]*one_cra + cra;\n    mat[1][2] = q[1]*q[2]*one_cra - q[0]*sra;\n    mat[1][3] = q[5];\n    mat[2][0] = q[2]*q[0]*one_cra - q[1]*sra;\n    mat[2][1] = q[2]*q[1]*one_cra + q[0]*sra;\n    mat[2][2] = q[2]*q[2]*one_cra + cra;\n    mat[2][3] = q[6];\n\n    return 0;\n}\n","/*\n *  icpHandle.c\n *  ARToolKit5\n *\n *  This file is part of ARToolKit.\n *\n *  ARToolKit is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation, either version 3 of the License, or\n *  (at your option) any later version.\n *\n *  ARToolKit is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public License\n *  along with ARToolKit.  If not, see <http://www.gnu.org/licenses/>.\n *\n *  As a special exception, the copyright holders of this library give you\n *  permission to link this library with independent modules to produce an\n *  executable, regardless of the license terms of these independent modules, and to\n *  copy and distribute the resulting executable under terms of your choice,\n *  provided that you also meet, for each linked independent module, the terms and\n *  conditions of the license of that module. An independent module is a module\n *  which is neither derived from nor based on this library. If you modify this\n *  library, you may extend this exception to your version of the library, but you\n *  are not obligated to do so. If you do not wish to do so, delete this exception\n *  statement from your version.\n *\n *  Copyright 2015 Daqri, LLC.\n *  Copyright 2007-2015 ARToolworks, Inc.\n *\n *  Author(s): Hirokazu Kato\n *\n */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n#include <AR/ar.h>\n#include <AR/icp.h>\n\n\nICPHandleT  *icpCreateHandle( ARdouble matXc2U[3][4] )\n{\n    ICPHandleT *handle;\n    int         i, j;\n\n    handle = (ICPHandleT *)malloc(sizeof(ICPHandleT));\n    if( handle == NULL ) return NULL;\n\n    for( j = 0; j < 3; j++ ) {\n        for( i = 0; i < 4; i++ ) {\n            handle->matXc2U[j][i] = matXc2U[j][i];\n        }\n    }\n    handle->maxLoop = ICP_MAX_LOOP;\n    handle->breakLoopErrorThresh      = ICP_BREAK_LOOP_ERROR_THRESH;\n    handle->breakLoopErrorRatioThresh = ICP_BREAK_LOOP_ERROR_RATIO_THRESH;\n    handle->breakLoopErrorThresh2     = ICP_BREAK_LOOP_ERROR_THRESH2;\n    handle->inlierProb                = ICP_INLIER_PROBABILITY;\n\n    return handle;\n}\n\nint icpDeleteHandle( ICPHandleT **handle )\n{\n    if( *handle == NULL ) return -1;\n\n    free( *handle );\n    *handle = NULL;\n\n    return 0;\n}\n\nint icpSetMatXc2U( ICPHandleT *handle, ARdouble matXc2U[3][4] )\n{\n    int     i, j;\n\n    if( handle == NULL ) return -1;\n    for( j = 0; j < 3; j++ ) {\n        for( i = 0; i < 4; i++ ) {\n            handle->matXc2U[j][i] = matXc2U[j][i];\n        }\n    }\n    return 0;\n}\n\nint icpSetMaxLoop( ICPHandleT *handle, int maxLoop )\n{\n    if( handle == NULL ) return -1;\n\n    handle->maxLoop = maxLoop;\n    return 0;\n}\n\nint icpSetBreakLoopErrorThresh( ICPHandleT *handle, ARdouble breakLoopErrorThresh )\n{\n    if( handle == NULL ) return -1;\n\n    handle->breakLoopErrorThresh = breakLoopErrorThresh;\n    return 0;\n}\n\nint icpSetBreakLoopErrorRatioThresh( ICPHandleT *handle, ARdouble breakLoopErrorRatioThresh )\n{\n    if( handle == NULL ) return -1;\n\n    handle->breakLoopErrorRatioThresh = breakLoopErrorRatioThresh;\n    return 0;\n}\n\nint icpSetBreakLoopErrorThresh2( ICPHandleT *handle, ARdouble breakLoopErrorThresh2 )\n{\n    if( handle == NULL ) return -1;\n\n    handle->breakLoopErrorThresh2 = breakLoopErrorThresh2;\n    return 0;\n}\n\nint icpGetMatXc2U( ICPHandleT *handle, ARdouble matXc2U[3][4] )\n{\n    int     i, j;\n\n    if( handle == NULL ) return -1;\n    for( j = 0; j < 3; j++ ) {\n        for( i = 0; i < 4; i++ ) {\n            matXc2U[j][i] = handle->matXc2U[j][i];\n        }\n    }\n    return 0;\n}\n\nint icpGetMaxLoop( ICPHandleT *handle, int *maxLoop )\n{\n    if( handle == NULL ) return -1;\n\n    *maxLoop = handle->maxLoop;\n    return 0;\n}\n\nint icpGetBreakLoopErrorThresh( ICPHandleT *handle, ARdouble *breakLoopErrorThresh )\n{\n    if( handle == NULL ) return -1;\n\n    *breakLoopErrorThresh = handle->breakLoopErrorThresh;\n    return 0;\n}\n\nint icpGetBreakLoopErrorRatioThresh( ICPHandleT *handle, ARdouble *breakLoopErrorRatioThresh )\n{\n    if( handle == NULL ) return -1;\n\n    *breakLoopErrorRatioThresh = handle->breakLoopErrorRatioThresh;\n    return 0;\n}\n\nint icpGetBreakLoopErrorThresh2( ICPHandleT *handle, ARdouble *breakLoopErrorThresh2 )\n{\n    if( handle == NULL ) return -1;\n\n    *breakLoopErrorThresh2 = handle->breakLoopErrorThresh2;\n    return 0;\n}\n\nint icpSetInlierProbability( ICPHandleT *handle, ARdouble inlierProb )\n{\n    if( handle == NULL ) return -1;\n\n    handle->inlierProb = inlierProb;\n    return 0;\n}\n\nint icpGetInlierProbability( ICPHandleT *handle, ARdouble *inlierProb )\n{\n    if( handle == NULL ) return -1;\n\n    *inlierProb = handle->inlierProb;\n    return 0;\n}\n","/*\n *  vAlloc.c\n *  ARToolKit5\n *\n *  This file is part of ARToolKit.\n *\n *  ARToolKit is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation, either version 3 of the License, or\n *  (at your option) any later version.\n *\n *  ARToolKit is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public License\n *  along with ARToolKit.  If not, see <http://www.gnu.org/licenses/>.\n *\n *  As a special exception, the copyright holders of this library give you\n *  permission to link this library with independent modules to produce an\n *  executable, regardless of the license terms of these independent modules, and to\n *  copy and distribute the resulting executable under terms of your choice,\n *  provided that you also meet, for each linked independent module, the terms and\n *  conditions of the license of that module. An independent module is a module\n *  which is neither derived from nor based on this library. If you modify this\n *  library, you may extend this exception to your version of the library, but you\n *  are not obligated to do so. If you do not wish to do so, delete this exception\n *  statement from your version.\n *\n *  Copyright 2015 Daqri, LLC.\n *  Copyright 2002-2015 ARToolworks, Inc.\n *\n *  Author(s): Shinsaku Hiura, Hirokazu Kato\n *\n */\n/*******************************************************\n *\n * Author: Shinsaku Hiura, Hirokazu Kato\n *\n *         shinsaku@sys.es.osaka-u.ac.jp\n *         kato@sys.im.hiroshima-cu.ac.jp\n *\n * Revision: 2.1\n * Date: 99/07/16\n *\n *******************************************************/\n\n#include <stdio.h>\n#ifndef __APPLE__\n#include <malloc.h>\n#else\n#include <stdlib.h>\n#endif\n#include <math.h>\n#include <AR/ar.h>\n\nARVec *arVecAlloc( int clm )\n{\n    ARVec     *v;\n\n    v = (ARVec *)malloc(sizeof(ARVec));\n    if( v == NULL ) return NULL;\n\n    v->v = (ARdouble *)malloc(sizeof(ARdouble) * clm);\n    if( v->v == NULL ) {\n        free(v);\n        return NULL;\n    }\n\n    v->clm = clm;\n\n    return v;\n}\n","/*\n *  vFree.c\n *  ARToolKit5\n *\n *  This file is part of ARToolKit.\n *\n *  ARToolKit is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation, either version 3 of the License, or\n *  (at your option) any later version.\n *\n *  ARToolKit is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public License\n *  along with ARToolKit.  If not, see <http://www.gnu.org/licenses/>.\n *\n *  As a special exception, the copyright holders of this library give you\n *  permission to link this library with independent modules to produce an\n *  executable, regardless of the license terms of these independent modules, and to\n *  copy and distribute the resulting executable under terms of your choice,\n *  provided that you also meet, for each linked independent module, the terms and\n *  conditions of the license of that module. An independent module is a module\n *  which is neither derived from nor based on this library. If you modify this\n *  library, you may extend this exception to your version of the library, but you\n *  are not obligated to do so. If you do not wish to do so, delete this exception\n *  statement from your version.\n *\n *  Copyright 2015 Daqri, LLC.\n *  Copyright 2002-2015 ARToolworks, Inc.\n *\n *  Author(s): Shinsaku Hiura, Hirokazu Kato\n *\n */\n/*******************************************************\n *\n * Author: Shinsaku Hiura, Hirokazu Kato\n *\n *         shinsaku@sys.es.osaka-u.ac.jp\n *         kato@sys.im.hiroshima-cu.ac.jp\n *\n * Revision: 2.1\n * Date: 99/07/16\n *\n *******************************************************/\n\n#include <stdio.h>\n#include <math.h>\n#ifndef __APPLE__\n#include <malloc.h>\n#else\n#include <stdlib.h>\n#endif\n#include <AR/ar.h>\n\nint arVecFree( ARVec *v )\n{\n    free( v->v );\n    free( v );\n\n    return 0;\n}\n","/*\n *  vHouse.c\n *  ARToolKit5\n *\n *  This file is part of ARToolKit.\n *\n *  ARToolKit is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation, either version 3 of the License, or\n *  (at your option) any later version.\n *\n *  ARToolKit is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public License\n *  along with ARToolKit.  If not, see <http://www.gnu.org/licenses/>.\n *\n *  As a special exception, the copyright holders of this library give you\n *  permission to link this library with independent modules to produce an\n *  executable, regardless of the license terms of these independent modules, and to\n *  copy and distribute the resulting executable under terms of your choice,\n *  provided that you also meet, for each linked independent module, the terms and\n *  conditions of the license of that module. An independent module is a module\n *  which is neither derived from nor based on this library. If you modify this\n *  library, you may extend this exception to your version of the library, but you\n *  are not obligated to do so. If you do not wish to do so, delete this exception\n *  statement from your version.\n *\n *  Copyright 2015 Daqri, LLC.\n *  Copyright 2002-2015 ARToolworks, Inc.\n *\n *  Author(s): Shinsaku Hiura, Hirokazu Kato\n *\n */\n/*******************************************************\n *\n * Author: Shinsaku Hiura, Hirokazu Kato\n *\n *         shinsaku@sys.es.osaka-u.ac.jp\n *         kato@sys.im.hiroshima-cu.ac.jp\n *\n * Revision: 2.1\n * Date: 99/07/16\n *\n *******************************************************/\n\n#include <stdio.h>\n#include <math.h>\n#include <AR/ar.h>\n\n#ifdef ARDOUBLE_IS_FLOAT\n#  define SQRT sqrtf\n#else\n#  define SQRT sqrt\n#endif\n\nARdouble arVecHousehold( ARVec *x )\n{\n    ARdouble s, t;\n    int    i;\n\n    s = SQRT( arVecInnerproduct(x,x) );\n\n    if( s != 0.0 ) {\n        if(x->v[0] < 0) s = -s;\n        x->v[0] += s;\n        t = 1 / SQRT(x->v[0] * s);\n        for( i = 0; i < x->clm; i++ ) {\n            x->v[i] *= t;\n        }\n    }\n\n    return(-s);\n}\n","/*\n *  vInnerP.c\n *  ARToolKit5\n *\n *  This file is part of ARToolKit.\n *\n *  ARToolKit is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation, either version 3 of the License, or\n *  (at your option) any later version.\n *\n *  ARToolKit is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public License\n *  along with ARToolKit.  If not, see <http://www.gnu.org/licenses/>.\n *\n *  As a special exception, the copyright holders of this library give you\n *  permission to link this library with independent modules to produce an\n *  executable, regardless of the license terms of these independent modules, and to\n *  copy and distribute the resulting executable under terms of your choice,\n *  provided that you also meet, for each linked independent module, the terms and\n *  conditions of the license of that module. An independent module is a module\n *  which is neither derived from nor based on this library. If you modify this\n *  library, you may extend this exception to your version of the library, but you\n *  are not obligated to do so. If you do not wish to do so, delete this exception\n *  statement from your version.\n *\n *  Copyright 2015 Daqri, LLC.\n *  Copyright 2002-2015 ARToolworks, Inc.\n *\n *  Author(s): Shinsaku Hiura, Hirokazu Kato\n *\n */\n/*******************************************************\n *\n * Author: Shinsaku Hiura, Hirokazu Kato\n *\n *         shinsaku@sys.es.osaka-u.ac.jp\n *         kato@sys.im.hiroshima-cu.ac.jp\n *\n * Revision: 2.1\n * Date: 99/07/16\n *\n *******************************************************/\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <math.h>\n#include <AR/ar.h>\n\nARdouble arVecInnerproduct( ARVec *x, ARVec *y )\n{\n    ARdouble   result = 0.0;\n    int      i;\n\n    if( x->clm != y->clm ) exit(0);\n\n    for( i = 0; i < x->clm; i++ ) {\n        result += x->v[i] * y->v[i];\n    }\n\n    return( result );\n}\n","/*\n *  vTridiag.c\n *  ARToolKit5\n *\n *  This file is part of ARToolKit.\n *\n *  ARToolKit is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation, either version 3 of the License, or\n *  (at your option) any later version.\n *\n *  ARToolKit is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public License\n *  along with ARToolKit.  If not, see <http://www.gnu.org/licenses/>.\n *\n *  As a special exception, the copyright holders of this library give you\n *  permission to link this library with independent modules to produce an\n *  executable, regardless of the license terms of these independent modules, and to\n *  copy and distribute the resulting executable under terms of your choice,\n *  provided that you also meet, for each linked independent module, the terms and\n *  conditions of the license of that module. An independent module is a module\n *  which is neither derived from nor based on this library. If you modify this\n *  library, you may extend this exception to your version of the library, but you\n *  are not obligated to do so. If you do not wish to do so, delete this exception\n *  statement from your version.\n *\n *  Copyright 2015 Daqri, LLC.\n *  Copyright 2002-2015 ARToolworks, Inc.\n *\n *  Author(s): Shinsaku Hiura, Hirokazu Kato\n *\n */\n/*******************************************************\n *\n * Author: Shinsaku Hiura, Hirokazu Kato\n *\n *         shinsaku@sys.es.osaka-u.ac.jp\n *         kato@sys.im.hiroshima-cu.ac.jp\n *\n * Revision: 2.1\n * Date: 99/07/16\n *\n *******************************************************/\n\n#include <stdio.h>\n#include <math.h>\n#include <AR/ar.h>\n\nint arVecTridiagonalize( ARMat *a, ARVec *d, ARVec *e )\n{\n    ARVec     wv1, wv2;\n    ARdouble  *v;\n    ARdouble  s, t, p, q;\n    int     dim;\n    int     i, j, k;\n\n    if( a->clm != a->row )   return(-1);\n    if( a->clm != d->clm )   return(-1);\n    if( a->clm != e->clm+1 ) return(-1);\n    dim = a->clm;\n\n    for( k = 0; k < dim-2; k++ ) {\n        v = &(a->m[k*dim]);\n        d->v[k] = v[k];\n\n        wv1.clm = dim-k-1;\n        wv1.v = &(v[k+1]);\n        e->v[k] = arVecHousehold(&wv1);\n        if( e->v[k] == 0.0 ) continue;\n\n        for( i = k+1; i < dim; i++ ) {\n            s = 0.0;\n            for( j = k+1; j < i; j++ ) {\n                s += a->m[j*dim+i] * v[j];\n            }\n            for( j = i; j < dim; j++ ) {\n                s += a->m[i*dim+j] * v[j];\n            }\n            d->v[i] = s;\n        }\n\n        wv1.clm = wv2.clm = dim-k-1;\n        wv1.v = &(v[k+1]);\n        wv2.v = &(d->v[k+1]);\n        t = arVecInnerproduct( &wv1, &wv2 ) / 2;\n        for( i = dim-1; i > k; i-- ) {\n            p = v[i];\n            q = d->v[i] -= t*p;\n            for( j = i; j < dim; j++ ) {\n                a->m[i*dim+j] -= p*(d->v[j]) + q*v[j];\n            }\n        }\n    }\n\n    if( dim >= 2) {\n        d->v[dim-2] = a->m[(dim-2)*dim+(dim-2)];\n        e->v[dim-2] = a->m[(dim-2)*dim+(dim-1)];\n    }\n\n    if( dim >= 1 ) d->v[dim-1] = a->m[(dim-1)*dim+(dim-1)];\n\n    for( k = dim-1; k >= 0; k-- ) {\n        v = &(a->m[k*dim]);\n        if( k < dim-2 ) {\n            for( i = k+1; i < dim; i++ ) {\n                wv1.clm = wv2.clm = dim-k-1;\n                wv1.v = &(v[k+1]);\n                wv2.v = &(a->m[i*dim+k+1]);\n                t = arVecInnerproduct( &wv1, &wv2 );\n                for( j = k+1; j < dim; j++ ) a->m[i*dim+j] -= t * v[j];\n            }\n        }\n        for( i = 0; i < dim; i++ ) v[i] = 0.0;\n        v[k] = 1;\n    }\n\n    return(0);\n}\n","//\n//  point.h\n//  ARToolKit5\n//\n//  This file is part of ARToolKit.\n//\n//  ARToolKit is free software: you can redistribute it and/or modify\n//  it under the terms of the GNU Lesser General Public License as published by\n//  the Free Software Foundation, either version 3 of the License, or\n//  (at your option) any later version.\n//\n//  ARToolKit is distributed in the hope that it will be useful,\n//  but WITHOUT ANY WARRANTY; without even the implied warranty of\n//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n//  GNU Lesser General Public License for more details.\n//\n//  You should have received a copy of the GNU Lesser General Public License\n//  along with ARToolKit.  If not, see <http://www.gnu.org/licenses/>.\n//\n//  As a special exception, the copyright holders of this library give you\n//  permission to link this library with independent modules to produce an\n//  executable, regardless of the license terms of these independent modules, and to\n//  copy and distribute the resulting executable under terms of your choice,\n//  provided that you also meet, for each linked independent module, the terms and\n//  conditions of the license of that module. An independent module is a module\n//  which is neither derived from nor based on this library. If you modify this\n//  library, you may extend this exception to your version of the library, but you\n//  are not obligated to do so. If you do not wish to do so, delete this exception\n//  statement from your version.\n//\n//  Copyright 2013-2015 Daqri, LLC.\n//\n//  Author(s): Chris Broaddus\n//\n\n#pragma once\n\nnamespace vision {\n    \n    template<typename T>\n    class Point2d {\n    public:\n        \n        Point2d() : x(0), y(0) {}\n        Point2d(T _x, T _y) : x(_x), y(_y) {}\n        \n        T x;\n        T y;\n        \n    }; // Point\n    \n    template<typename T>\n    class Point3d {\n    public:\n        \n        Point3d() : x(0), y(0), z(0) {}\n        Point3d(T _x, T _y, T _z) : x(_x), y(_y), z(_z) {}\n        \n        T x;\n        T y;\n        T z;\n        \n    }; // Point\n    \n} // vision","/*\n *  arDetectMarker.c\n *  ARToolKit5\n *\n *  This file is part of ARToolKit.\n *\n *  ARToolKit is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation, either version 3 of the License, or\n *  (at your option) any later version.\n *\n *  ARToolKit is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public License\n *  along with ARToolKit.  If not, see <http://www.gnu.org/licenses/>.\n *\n *  As a special exception, the copyright holders of this library give you\n *  permission to link this library with independent modules to produce an\n *  executable, regardless of the license terms of these independent modules, and to\n *  copy and distribute the resulting executable under terms of your choice,\n *  provided that you also meet, for each linked independent module, the terms and\n *  conditions of the license of that module. An independent module is a module\n *  which is neither derived from nor based on this library. If you modify this\n *  library, you may extend this exception to your version of the library, but you\n *  are not obligated to do so. If you do not wish to do so, delete this exception\n *  statement from your version.\n *\n *  Copyright 2015 Daqri, LLC.\n *  Copyright 2002-2015 ARToolworks, Inc.\n *\n *  Author(s): Hirokazu Kato, Philip Lamb\n *\n */\n\n#include <stdio.h>\n#include <AR/ar.h>\n#include <AR/arImageProc.h>\n\n#if DEBUG_PATT_GETID\nextern int cnt;\n#endif\n\nconst char *arMarkerInfoCutoffPhaseDescriptions[AR_MARKER_INFO_CUTOFF_PHASE_DESCRIPTION_COUNT] = {\n    \"Marker OK.\",\n    \"Pattern extraction failed.\",\n    \"Generic error during matching phase.\",\n    \"Insufficient contrast during matching.\",\n    \"Barcode matching could not find correct barcode locator pattern.\",\n    \"Barcode matching error detection/correction found unrecoverable error.\",\n    \"Matching confidence cutoff value not reached.\",\n    \"Maximum allowable pose error exceeded.\",\n    \"Multi-marker pose error value exceeded.\",\n    \"Rejected frequently misrecognised matrix marker.\"\n};\n\nstatic void confidenceCutoff(ARHandle *arHandle);\n\nint arDetectMarker( ARHandle *arHandle, ARUint8 *dataPtr )\n{\n    ARdouble    rarea, rlen, rlenmin;\n    ARdouble    diff, diffmin;\n    int         cid, cdir;\n    int         i, j, k;\n    int         detectionIsDone = 0;\n    int         threshDiff;\n\n#if DEBUG_PATT_GETID\ncnt = 0;\n#endif\n\n    arHandle->marker_num = 0;\n    \n    if (arHandle->arLabelingThreshMode == AR_LABELING_THRESH_MODE_AUTO_BRACKETING) {\n        if (arHandle->arLabelingThreshAutoIntervalTTL > 0) {\n            arHandle->arLabelingThreshAutoIntervalTTL--;\n        } else {\n            int thresholds[3];\n            int marker_nums[3];\n            \n            thresholds[0] = arHandle->arLabelingThresh + arHandle->arLabelingThreshAutoBracketOver;\n            if (thresholds[0] > 255) thresholds[0] = 255;\n            thresholds[1] = arHandle->arLabelingThresh - arHandle->arLabelingThreshAutoBracketUnder;\n            if (thresholds[1] < 0) thresholds[1] = 0;\n            thresholds[2] = arHandle->arLabelingThresh;\n            \n            for (i = 0; i < 3; i++) {\n                if (arLabeling(dataPtr, arHandle->xsize, arHandle->ysize, arHandle->arPixelFormat, arHandle->arDebug, arHandle->arLabelingMode, thresholds[i], arHandle->arImageProcMode, &(arHandle->labelInfo), NULL) < 0) return -1;\n                if (arDetectMarker2(arHandle->xsize, arHandle->ysize, &(arHandle->labelInfo), arHandle->arImageProcMode, AR_AREA_MAX, AR_AREA_MIN, AR_SQUARE_FIT_THRESH, arHandle->markerInfo2, &(arHandle->marker2_num)) < 0) return -1;\n                if (arGetMarkerInfo(dataPtr, arHandle->xsize, arHandle->ysize, arHandle->arPixelFormat, arHandle->markerInfo2, arHandle->marker2_num, arHandle->pattHandle, arHandle->arImageProcMode, arHandle->arPatternDetectionMode, &(arHandle->arParamLT->paramLTf), arHandle->pattRatio, arHandle->markerInfo, &(arHandle->marker_num), arHandle->matrixCodeType) < 0) return -1;\n                marker_nums[i] = arHandle->marker_num;\n            }\n\n            if (arHandle->arDebug == AR_DEBUG_ENABLE) ARLOGe(\"Auto threshold (bracket) marker counts -[%3d: %3d] [%3d: %3d] [%3d: %3d]+.\\n\", thresholds[1], marker_nums[1], thresholds[2], marker_nums[2], thresholds[0], marker_nums[0]);\n        \n            // If neither of the bracketed values was superior, then change the size of the bracket.\n            if (marker_nums[0] <= marker_nums[2] && marker_nums[1] <= marker_nums[2]) {\n                if (arHandle->arLabelingThreshAutoBracketOver < arHandle->arLabelingThreshAutoBracketUnder) {\n                    arHandle->arLabelingThreshAutoBracketOver++;\n                } else if (arHandle->arLabelingThreshAutoBracketOver > arHandle->arLabelingThreshAutoBracketUnder) {\n                    arHandle->arLabelingThreshAutoBracketUnder++;\n                } else {\n                    arHandle->arLabelingThreshAutoBracketOver++;\n                    arHandle->arLabelingThreshAutoBracketUnder++;\n                }\n                if ((thresholds[2] + arHandle->arLabelingThreshAutoBracketOver) >= 255) arHandle->arLabelingThreshAutoBracketOver = 1; // If the bracket has hit the end of the range, reset it.\n                if ((thresholds[2] - arHandle->arLabelingThreshAutoBracketOver) <= 0) arHandle->arLabelingThreshAutoBracketUnder = 1; // If a bracket has hit the end of the range, reset it.\n                detectionIsDone = 1;\n            } else {\n                arHandle->arLabelingThresh = (marker_nums[0] >= marker_nums[1] ? thresholds[0] : thresholds[1]);\n                threshDiff = arHandle->arLabelingThresh - thresholds[2];\n                if (threshDiff > 0) {\n                    arHandle->arLabelingThreshAutoBracketOver = threshDiff;\n                    arHandle->arLabelingThreshAutoBracketUnder = 1;\n                } else {\n                    arHandle->arLabelingThreshAutoBracketOver = 1;\n                    arHandle->arLabelingThreshAutoBracketUnder = -threshDiff;\n                }\n                if (arHandle->arDebug == AR_DEBUG_ENABLE) ARLOGe(\"Auto threshold (bracket) adjusted threshold to %d.\\n\", arHandle->arLabelingThresh);\n            }\n            arHandle->arLabelingThreshAutoIntervalTTL = arHandle->arLabelingThreshAutoInterval;\n        }\n    }\n    \n    if (!detectionIsDone) {\n#if !AR_DISABLE_THRESH_MODE_AUTO_ADAPTIVE\n        if (arHandle->arLabelingThreshMode == AR_LABELING_THRESH_MODE_AUTO_ADAPTIVE) {\n            \n            int ret;\n            ret = arImageProcLumaHistAndBoxFilterWithBias(arHandle->arImageProcInfo, dataPtr,  AR_LABELING_THRESH_ADAPTIVE_KERNEL_SIZE_DEFAULT, AR_LABELING_THRESH_ADAPTIVE_BIAS_DEFAULT);\n            if (ret < 0) return (ret);\n            \n            ret = arLabeling(arHandle->arImageProcInfo->image, arHandle->arImageProcInfo->imageX, arHandle->arImageProcInfo->imageY,\n                             AR_PIXEL_FORMAT_MONO, arHandle->arDebug, arHandle->arLabelingMode,\n                             0, AR_IMAGE_PROC_FRAME_IMAGE,\n                             &(arHandle->labelInfo), arHandle->arImageProcInfo->image2);\n            if (ret < 0) return (ret);\n            \n        } else { // !adaptive\n#endif\n            \n            if (arHandle->arLabelingThreshMode == AR_LABELING_THRESH_MODE_AUTO_MEDIAN || arHandle->arLabelingThreshMode == AR_LABELING_THRESH_MODE_AUTO_OTSU) {\n                // Do an auto-threshold operation.\n                if (arHandle->arLabelingThreshAutoIntervalTTL > 0) {\n                    arHandle->arLabelingThreshAutoIntervalTTL--;\n                } else {\n                    int ret;\n                    unsigned char value;\n                    if (arHandle->arLabelingThreshMode == AR_LABELING_THRESH_MODE_AUTO_MEDIAN) ret = arImageProcLumaHistAndCDFAndMedian(arHandle->arImageProcInfo, dataPtr, &value);\n                    else ret = arImageProcLumaHistAndOtsu(arHandle->arImageProcInfo, dataPtr, &value);\n                    if (ret < 0) return (ret);\n                    if (arHandle->arDebug == AR_DEBUG_ENABLE && arHandle->arLabelingThresh != value) ARLOGe(\"Auto threshold (%s) adjusted threshold to %d.\\n\", (arHandle->arLabelingThreshMode == AR_LABELING_THRESH_MODE_AUTO_MEDIAN ? \"median\" : \"Otsu\"), value);\n                    arHandle->arLabelingThresh = value;\n                    arHandle->arLabelingThreshAutoIntervalTTL = arHandle->arLabelingThreshAutoInterval;\n                }\n            }\n            \n            if( arLabeling(dataPtr, arHandle->xsize, arHandle->ysize,\n                           arHandle->arPixelFormat, arHandle->arDebug, arHandle->arLabelingMode,\n                           arHandle->arLabelingThresh, arHandle->arImageProcMode,\n                           &(arHandle->labelInfo), NULL) < 0 ) {\n                return -1;\n            }\n            \n#if !AR_DISABLE_THRESH_MODE_AUTO_ADAPTIVE\n        }\n#endif\n        \n        if( arDetectMarker2( arHandle->xsize, arHandle->ysize,\n                            &(arHandle->labelInfo), arHandle->arImageProcMode,\n                            AR_AREA_MAX, AR_AREA_MIN, AR_SQUARE_FIT_THRESH,\n                            arHandle->markerInfo2, &(arHandle->marker2_num) ) < 0 ) {\n            return -1;\n        }\n        \n        if( arGetMarkerInfo(dataPtr, arHandle->xsize, arHandle->ysize, arHandle->arPixelFormat,\n                            arHandle->markerInfo2, arHandle->marker2_num,\n                            arHandle->pattHandle, arHandle->arImageProcMode,\n                            arHandle->arPatternDetectionMode, &(arHandle->arParamLT->paramLTf), arHandle->pattRatio,\n                            arHandle->markerInfo, &(arHandle->marker_num),\n                            arHandle->matrixCodeType ) < 0 ) {\n            return -1;\n        }\n    } // !detectionIsDone\n    \n    // If history mode is not enabled, just perform a basic confidence cutoff.\n    if (arHandle->arMarkerExtractionMode == AR_NOUSE_TRACKING_HISTORY) {\n        confidenceCutoff(arHandle);\n        return 0;\n    }\n\n/*------------------------------------------------------------*/\n\n    // For all history records, check every identified marker, to see if the position and size of the marker\n    // as recorded in the history record is very similar to one of the identified markers.\n    // If it is, and the history record has a higher confidence value, then use the  pattern matching\n    // information (marker ID, confidence, and direction) info from the history instead.\n    for( i = 0; i < arHandle->history_num; i++ ) {\n        rlenmin = 0.5;\n        cid = -1;\n        for( j = 0; j < arHandle->marker_num; j++ ) {\n            rarea = (ARdouble)arHandle->history[i].marker.area / (ARdouble)arHandle->markerInfo[j].area;\n            if( rarea < 0.7 || rarea > 1.43 ) continue;\n            rlen = ( (arHandle->markerInfo[j].pos[0] - arHandle->history[i].marker.pos[0])\n                   * (arHandle->markerInfo[j].pos[0] - arHandle->history[i].marker.pos[0])\n                   + (arHandle->markerInfo[j].pos[1] - arHandle->history[i].marker.pos[1])\n                   * (arHandle->markerInfo[j].pos[1] - arHandle->history[i].marker.pos[1]) )\n                   / arHandle->markerInfo[j].area;\n            if( rlen < rlenmin ) {\n                rlenmin = rlen;\n                cid = j;\n            }\n        }\n        if (cid >= 0) {\n            if (arHandle->arPatternDetectionMode == AR_TEMPLATE_MATCHING_COLOR || arHandle->arPatternDetectionMode == AR_TEMPLATE_MATCHING_MONO || arHandle->arPatternDetectionMode == AR_MATRIX_CODE_DETECTION) {\n                if (arHandle->markerInfo[cid].cf < arHandle->history[i].marker.cf) {\n                    arHandle->markerInfo[cid].cf = arHandle->history[i].marker.cf;\n                    arHandle->markerInfo[cid].id = arHandle->history[i].marker.id;\n                    diffmin = 10000.0 * 10000.0;\n                    cdir = -1;\n                    for( j = 0; j < 4; j++ ) {\n                        diff = 0;\n                        for( k = 0; k < 4; k++ ) {\n                            diff += (arHandle->history[i].marker.vertex[k][0] - arHandle->markerInfo[cid].vertex[(j+k)%4][0])\n                            * (arHandle->history[i].marker.vertex[k][0] - arHandle->markerInfo[cid].vertex[(j+k)%4][0])\n                            + (arHandle->history[i].marker.vertex[k][1] - arHandle->markerInfo[cid].vertex[(j+k)%4][1])\n                            * (arHandle->history[i].marker.vertex[k][1] - arHandle->markerInfo[cid].vertex[(j+k)%4][1]);\n                        }\n                        if( diff < diffmin ) {\n                            diffmin = diff;\n                            cdir = (arHandle->history[i].marker.dir - j + 4) % 4;\n                        }\n                    }\n                    arHandle->markerInfo[cid].dir = cdir;\n                    // Copy the id, cf, and dir back to the appropriate mode-dependent values too.\n                    if (arHandle->arPatternDetectionMode == AR_TEMPLATE_MATCHING_COLOR || arHandle->arPatternDetectionMode == AR_TEMPLATE_MATCHING_MONO) {\n                        arHandle->markerInfo[cid].idPatt  = arHandle->markerInfo[cid].id;\n                        arHandle->markerInfo[cid].cfPatt  = arHandle->markerInfo[cid].cf;\n                        arHandle->markerInfo[cid].dirPatt = arHandle->markerInfo[cid].dir;\n                    } else {\n                        arHandle->markerInfo[cid].idMatrix  = arHandle->markerInfo[cid].id;\n                        arHandle->markerInfo[cid].cfMatrix  = arHandle->markerInfo[cid].cf;\n                        arHandle->markerInfo[cid].dirMatrix = arHandle->markerInfo[cid].dir;\n                    }\n                }\n            } else if (arHandle->arPatternDetectionMode == AR_TEMPLATE_MATCHING_COLOR_AND_MATRIX || arHandle->arPatternDetectionMode == AR_TEMPLATE_MATCHING_MONO_AND_MATRIX) {\n                if (arHandle->markerInfo[cid].cfPatt < arHandle->history[i].marker.cfPatt || arHandle->markerInfo[cid].cfMatrix < arHandle->history[i].marker.cfMatrix) {\n                    arHandle->markerInfo[cid].cfPatt = arHandle->history[i].marker.cfPatt;\n                    arHandle->markerInfo[cid].idPatt = arHandle->history[i].marker.idPatt;\n                    arHandle->markerInfo[cid].cfMatrix = arHandle->history[i].marker.cfMatrix;\n                    arHandle->markerInfo[cid].idMatrix = arHandle->history[i].marker.idMatrix;\n                    diffmin = 10000.0 * 10000.0;\n                    cdir = -1;\n                    for( j = 0; j < 4; j++ ) {\n                        diff = 0;\n                        for( k = 0; k < 4; k++ ) {\n                            diff += (arHandle->history[i].marker.vertex[k][0] - arHandle->markerInfo[cid].vertex[(j+k)%4][0])\n                            * (arHandle->history[i].marker.vertex[k][0] - arHandle->markerInfo[cid].vertex[(j+k)%4][0])\n                            + (arHandle->history[i].marker.vertex[k][1] - arHandle->markerInfo[cid].vertex[(j+k)%4][1])\n                            * (arHandle->history[i].marker.vertex[k][1] - arHandle->markerInfo[cid].vertex[(j+k)%4][1]);\n                        }\n                        if( diff < diffmin ) {\n                            diffmin = diff;\n                            cdir = j;\n                        }\n                    }\n                    arHandle->markerInfo[cid].dirPatt   = (arHandle->history[i].marker.dirPatt   - cdir + 4) % 4;\n                    arHandle->markerInfo[cid].dirMatrix = (arHandle->history[i].marker.dirMatrix - cdir + 4) % 4;\n                }\n            }\n            else return -1; // Unsupported arPatternDetectionMode.\n        } // cid >= 0\n    }\n\n    confidenceCutoff(arHandle);\n\n    // Age all history records (and expire old records, i.e. where count >= 4).\n    for( i = j = 0; i < arHandle->history_num; i++ ) {\n        arHandle->history[i].count++;\n        if( arHandle->history[i].count < 4 ) {\n            if (i != j) arHandle->history[j] = arHandle->history[i];\n            j++;\n        }\n    }\n    arHandle->history_num = j;\n\n    // Save current marker info in history.\n    for( i = 0; i < arHandle->marker_num; i++ ) {\n        if( arHandle->markerInfo[i].id < 0 ) continue;\n\n        // Check if an ARTrackingHistory record already exists for this marker ID.\n        for( j = 0; j < arHandle->history_num; j++ ) {\n            if( arHandle->history[j].marker.id == arHandle->markerInfo[i].id ) break;\n        }\n        if( j == arHandle->history_num ) { // If a pre-existing ARTrackingHistory record was not found,\n            if( arHandle->history_num == AR_SQUARE_MAX ) break; // exit if we've filled all available history slots,\n            arHandle->history_num++; // Otherwise count the newly created record.\n        }\n        arHandle->history[j].marker = arHandle->markerInfo[i]; // Save the marker info.\n        arHandle->history[j].count  = 1; // Reset count to indicate info is fresh.\n    }\n\n    if( arHandle->arMarkerExtractionMode == AR_USE_TRACKING_HISTORY_V2 ) {\n        return 0;\n    }\n\n\n    for( i = 0; i < arHandle->history_num; i++ ) {\n        for( j = 0; j < arHandle->marker_num; j++ ) {\n            rarea = (ARdouble)arHandle->history[i].marker.area / (ARdouble)arHandle->markerInfo[j].area;\n            if( rarea < 0.7 || rarea > 1.43 ) continue;\n            rlen = ( (arHandle->markerInfo[j].pos[0] - arHandle->history[i].marker.pos[0])\n                   * (arHandle->markerInfo[j].pos[0] - arHandle->history[i].marker.pos[0])\n                   + (arHandle->markerInfo[j].pos[1] - arHandle->history[i].marker.pos[1])\n                   * (arHandle->markerInfo[j].pos[1] - arHandle->history[i].marker.pos[1]) )\n                   / arHandle->markerInfo[j].area;\n            if( rlen < 0.5 ) break;\n        }\n        if( j == arHandle->marker_num ) {\n            arHandle->markerInfo[arHandle->marker_num] = arHandle->history[i].marker;\n            arHandle->marker_num++;\n        }\n    }\n\n    return 0;\n}\n\nstatic void confidenceCutoff(ARHandle *arHandle)\n{\n    int i, cfOK;\n    \n    if (arHandle->arPatternDetectionMode == AR_TEMPLATE_MATCHING_COLOR || arHandle->arPatternDetectionMode == AR_TEMPLATE_MATCHING_MONO) {\n        for (i = 0; i < arHandle->marker_num; i++) {\n            if (arHandle->markerInfo[i].id >= 0 && arHandle->markerInfo[i].cf < AR_CONFIDENCE_CUTOFF_DEFAULT) {\n                arHandle->markerInfo[i].id = arHandle->markerInfo[i].idPatt = -1;\n                arHandle->markerInfo[i].cutoffPhase = AR_MARKER_INFO_CUTOFF_PHASE_MATCH_CONFIDENCE;\n            }\n        }\n    } else if (arHandle->arPatternDetectionMode == AR_MATRIX_CODE_DETECTION ) {\n        for (i = 0; i < arHandle->marker_num; i++) {\n            if (arHandle->markerInfo[i].id >= 0 && arHandle->markerInfo[i].cf < AR_CONFIDENCE_CUTOFF_DEFAULT) {\n                arHandle->markerInfo[i].id = arHandle->markerInfo[i].idMatrix = -1;\n                arHandle->markerInfo[i].cutoffPhase = AR_MARKER_INFO_CUTOFF_PHASE_MATCH_CONFIDENCE;\n            }\n        }\n    } else {\n        for (i = 0; i < arHandle->marker_num; i++) {\n            cfOK = 0;\n            if (arHandle->markerInfo[i].idPatt >= 0 && arHandle->markerInfo[i].cfPatt < AR_CONFIDENCE_CUTOFF_DEFAULT) {\n                arHandle->markerInfo[i].idPatt = -1;\n            } else cfOK = 1;\n            if (arHandle->markerInfo[i].idMatrix >= 0 && arHandle->markerInfo[i].cfMatrix < AR_CONFIDENCE_CUTOFF_DEFAULT) {\n                arHandle->markerInfo[i].idMatrix = -1;\n            } else cfOK = 1;\n            if (!cfOK) arHandle->markerInfo[i].cutoffPhase = AR_MARKER_INFO_CUTOFF_PHASE_MATCH_CONFIDENCE;\n        }\n    }\n}\n\n","//\n//  visual_database_facade.cpp\n//  ARToolKit5\n//\n//  This file is part of ARToolKit.\n//\n//  ARToolKit is free software: you can redistribute it and/or modify\n//  it under the terms of the GNU Lesser General Public License as published by\n//  the Free Software Foundation, either version 3 of the License, or\n//  (at your option) any later version.\n//\n//  ARToolKit is distributed in the hope that it will be useful,\n//  but WITHOUT ANY WARRANTY; without even the implied warranty of\n//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n//  GNU Lesser General Public License for more details.\n//\n//  You should have received a copy of the GNU Lesser General Public License\n//  along with ARToolKit.  If not, see <http://www.gnu.org/licenses/>.\n//\n//  As a special exception, the copyright holders of this library give you\n//  permission to link this library with independent modules to produce an\n//  executable, regardless of the license terms of these independent modules, and to\n//  copy and distribute the resulting executable under terms of your choice,\n//  provided that you also meet, for each linked independent module, the terms and\n//  conditions of the license of that module. An independent module is a module\n//  which is neither derived from nor based on this library. If you modify this\n//  library, you may extend this exception to your version of the library, but you\n//  are not obligated to do so. If you do not wish to do so, delete this exception\n//  statement from your version.\n//\n//  Copyright 2013-2015 Daqri, LLC.\n//\n//  Author(s): Chris Broaddus\n//\n#include <AR/ar.h>\n\n#include \"visual_database_facade.h\"\n#include <matchers/visual_database-inline.h>\n#include <matchers/freak.h>\n#include <matchers/keyframe.h>\n#include <framework/image.h>\n#include <matchers/visual_database-inline.h>\n\nnamespace vision {\n    typedef VisualDatabase<FREAKExtractor, BinaryFeatureStore, BinaryFeatureMatcher<96> > vdb_t;\n    typedef std::vector<vision::Point3d<float> > Point3dVector;\n    typedef std::unordered_map<int, Point3dVector> point3d_map_t;\n\n    class VisualDatabaseImpl{\n    public:\n        VisualDatabaseImpl(){\n            mVdb.reset(new vdb_t());\n        }\n        ~VisualDatabaseImpl(){\n        }\n\n        std::unique_ptr<vdb_t> mVdb;\n        point3d_map_t mPoint3d;\n    };\n\n    VisualDatabaseFacade::VisualDatabaseFacade(){\n        mVisualDbImpl.reset(new VisualDatabaseImpl());\n    }\n    VisualDatabaseFacade::~VisualDatabaseFacade(){\n\n    }\n\n    void VisualDatabaseFacade::addImage(unsigned char* grayImage,\n                                        size_t width,\n                                        size_t height,\n                                        int image_id) {\n        Image img;\n        img.deepCopy(Image(grayImage,IMAGE_UINT8,width,height,(int)width,1));\n        mVisualDbImpl->mVdb->addImage(img, image_id);\n    }\n\n    void VisualDatabaseFacade::addFreakFeaturesAndDescriptors(const std::vector<FeaturePoint>& featurePoints,\n                                                              const std::vector<unsigned char>& descriptors,\n                                                              const std::vector<vision::Point3d<float> >& points3D,\n                                                              size_t width,\n                                                              size_t height,\n                                                              int image_id){\n        std::shared_ptr<Keyframe<96> > keyframe(new Keyframe<96>());\n        keyframe->setWidth((int)width);\n        keyframe->setHeight((int)height);\n        keyframe->store().setNumBytesPerFeature(96);\n        keyframe->store().points().resize(featurePoints.size());\n        keyframe->store().points() = featurePoints;\n        keyframe->store().features().resize(descriptors.size());\n        keyframe->store().features() = descriptors;\n        keyframe->buildIndex();\n\n        mVisualDbImpl->mVdb->addKeyframe(keyframe, image_id);\n        mVisualDbImpl->mPoint3d[image_id] = points3D;\n    }\n\n    void VisualDatabaseFacade::computeFreakFeaturesAndDescriptors(unsigned char* grayImage,\n                                                                  size_t width,\n                                                                  size_t height,\n                                                                  std::vector<FeaturePoint>& featurePoints,\n                                                                  std::vector<unsigned char>& descriptors){\n        Image img = Image(grayImage,IMAGE_UINT8,width,height,(int)width,1);\n        std::unique_ptr<vdb_t> tmpDb(new vdb_t());\n        tmpDb->addImage(img, 1);\n        featurePoints = tmpDb->keyframe(1)->store().points();\n        descriptors = tmpDb->keyframe(1)->store().features();\n    }\n\n    bool VisualDatabaseFacade::query(unsigned char* grayImage,\n                                     size_t width,\n                                     size_t height){\n        Image img = Image(grayImage,IMAGE_UINT8,width,height,(int)width,1);\n        return mVisualDbImpl->mVdb->query(img);\n    }\n\n    bool VisualDatabaseFacade::erase(int image_id){\n        return mVisualDbImpl->mVdb->erase(image_id);\n    }\n\n    const size_t VisualDatabaseFacade::databaseCount(){\n        return mVisualDbImpl->mVdb->databaseCount();\n    }\n\n    int VisualDatabaseFacade::matchedId(){\n        return mVisualDbImpl->mVdb->matchedId();\n    }\n\n    const float* VisualDatabaseFacade::matchedGeometry(){\n        return mVisualDbImpl->mVdb->matchedGeometry();\n    }\n\n    const std::vector<FeaturePoint> &VisualDatabaseFacade::getFeaturePoints(int image_id) const{\n        return mVisualDbImpl->mVdb->keyframe(image_id)->store().points();\n    }\n\n    const std::vector<unsigned char> &VisualDatabaseFacade::getDescriptors(int image_id) const{\n        return mVisualDbImpl->mVdb->keyframe(image_id)->store().features();\n    }\n\n    const std::vector<vision::Point3d<float> >& VisualDatabaseFacade::get3DFeaturePoints(int image_id) const{\n        return mVisualDbImpl->mPoint3d[image_id];\n    }\n\n    const std::vector<FeaturePoint>&VisualDatabaseFacade::getQueryFeaturePoints() const{\n        return mVisualDbImpl->mVdb->queryKeyframe()->store().points();\n    }\n\n    const std::vector<unsigned char>&VisualDatabaseFacade::getQueryDescriptors() const{\n        return mVisualDbImpl->mVdb->queryKeyframe()->store().features();\n    }\n\n    const matches_t& VisualDatabaseFacade::inliers() const{\n        return mVisualDbImpl->mVdb->inliers();\n    }\n\n    int VisualDatabaseFacade::getWidth(int image_id) const{\n        return mVisualDbImpl->mVdb->keyframe(image_id)->width();\n    }\n    int VisualDatabaseFacade::getHeight(int image_id) const{\n        return mVisualDbImpl->mVdb->keyframe(image_id)->height();\n    }\n} // vision\n","//\n//  image.h\n//  ARToolKit5\n//\n//  This file is part of ARToolKit.\n//\n//  ARToolKit is free software: you can redistribute it and/or modify\n//  it under the terms of the GNU Lesser General Public License as published by\n//  the Free Software Foundation, either version 3 of the License, or\n//  (at your option) any later version.\n//\n//  ARToolKit is distributed in the hope that it will be useful,\n//  but WITHOUT ANY WARRANTY; without even the implied warranty of\n//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n//  GNU Lesser General Public License for more details.\n//\n//  You should have received a copy of the GNU Lesser General Public License\n//  along with ARToolKit.  If not, see <http://www.gnu.org/licenses/>.\n//\n//  As a special exception, the copyright holders of this library give you\n//  permission to link this library with independent modules to produce an\n//  executable, regardless of the license terms of these independent modules, and to\n//  copy and distribute the resulting executable under terms of your choice,\n//  provided that you also meet, for each linked independent module, the terms and\n//  conditions of the license of that module. An independent module is a module\n//  which is neither derived from nor based on this library. If you modify this\n//  library, you may extend this exception to your version of the library, but you\n//  are not obligated to do so. If you do not wish to do so, delete this exception\n//  statement from your version.\n//\n//  Copyright 2013-2015 Daqri, LLC.\n//\n//  Author(s): Chris Broaddus\n//\n\n#pragma once\n\n#include \"exception.h\"\n#include \"error.h\"\n#include <memory>\n\nnamespace vision {\n    \n    /**\n     * Enumeration for the different image types.\n     */\n    enum ImageType {\n        IMAGE_UNKNOWN = 0,\n        IMAGE_UINT8,\n        IMAGE_F32\n    };\n    \n    /**\n     * Type of image step.\n     */\n    enum StepType {\n        AUTO_STEP = -1\n    };\n    \n    /**\n     * Represents images that used in the framework.\n     */\n    class Image {\n    public:\n        \n        Image();\n        Image(Image& image);\n        Image(const Image& image);\n        Image(ImageType type,\n              size_t width,\n              size_t height,\n              int step,\n              size_t channels);\n        Image(unsigned char* data,\n              ImageType type,\n              size_t width,\n              size_t height,\n              int step,\n              size_t channels);\n        ~Image();\n        \n        /**\n         * Allocate the image data.\n         */\n        void alloc(ImageType type,\n                   size_t width,\n                   size_t height,\n                   int step,\n                   size_t channels) throw(Exception);\n        \n        /**\n         * Release the memory associated with the image.\n         */\n        void release();\n        \n        /**\n         * Get a pointer to the image data.\n         */\n        inline unsigned char* get() {\n            return mData.get();\n        }\n        inline const unsigned char* get() const {\n            return mData.get();\n        }\n        \n        /**\n         * Get a pointer to the image data via template functions.\n         */\n        template<typename T>\n        inline T* get() {\n            return (T*)(mData.get());\n        }\n        template<typename T>\n        inline const T* get() const {\n            return (const T*)(mData.get());\n        }\n        template<typename T>\n        inline T* get(size_t row) {\n            ASSERT(row < mHeight, \"row out of bounds\");\n            return (T*)(mData.get() + row*mStep);\n        }\n        template<typename T>\n        inline const T* get(size_t row) const {\n            ASSERT(row < mHeight, \"row out of bounds\");\n            return (const T*)(mData.get() + row*mStep);\n        }\n        \n        /**\n         * Get the image type.\n         */\n        inline ImageType type() const { return mType; }\n        \n        /**\n         * Set the dimensions of the image.\n         */\n        inline void setWidth(size_t width) { mWidth = width; }\n        inline void setHeight(size_t height) { mHeight = height; }\n        inline void setStep(size_t step) { mStep = step; }\n        inline void setChannels(size_t channels) { mChannels = channels; }\n        \n        /**\n         * Get the dimensions of the image.\n         */\n        inline size_t width() const { return mWidth; }\n        inline size_t height() const { return mHeight; }\n        inline size_t step() const { return mStep; }\n        inline size_t channels() const { return mChannels; }\n        inline size_t size() const { return mSize; }\n        \n        /**\n         * Copy functions.\n         */\n        void deepCopy(const Image& image);\n        void shallowCopy(const Image& image);\n        \n        /**\n         * Copy an image by doing a shallow copy.\n         */\n        Image& operator=(Image& image);\n        Image& operator=(const Image& image);\n        \n        /**\n         * Calculate the size of a single unit.\n         */\n        static size_t calculate_unit_size(ImageType type);\n        \n    private:\n        \n        // Image type\n        ImageType mType;\n        \n        // Dimensions\n        size_t mWidth;\n        size_t mHeight;\n        size_t mStep;\n        size_t mChannels;\n        \n        // Size of the allocated image\n        size_t mSize;\n        \n        // Image data\n        std::shared_ptr<unsigned char> mData;\n    };\n    \n} // vision\n","// -*- C++ -*-\n//===----------------------------------------------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP__HASH_TABLE\n#define _LIBCPP__HASH_TABLE\n\n#include <__config>\n#include <initializer_list>\n#include <memory>\n#include <iterator>\n#include <algorithm>\n#include <cmath>\n#include <utility>\n\n#include <__undef_min_max>\n\n#include <__debug>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\n\n#ifndef _LIBCPP_CXX03_LANG\ntemplate <class _Key, class _Tp>\nunion __hash_value_type;\n#else\ntemplate <class _Key, class _Tp>\nstruct __hash_value_type;\n#endif\n\n#ifndef _LIBCPP_CXX03_LANG\ntemplate <class _Tp>\nstruct __is_hash_value_type_imp : false_type {};\n\ntemplate <class _Key, class _Value>\nstruct __is_hash_value_type_imp<__hash_value_type<_Key, _Value>> : true_type {};\n\ntemplate <class ..._Args>\nstruct __is_hash_value_type : false_type {};\n\ntemplate <class _One>\nstruct __is_hash_value_type<_One> : __is_hash_value_type_imp<typename __uncvref<_One>::type> {};\n#endif\n\n_LIBCPP_FUNC_VIS\nsize_t __next_prime(size_t __n);\n\ntemplate <class _NodePtr>\nstruct __hash_node_base\n{\n    typedef typename pointer_traits<_NodePtr>::element_type __node_type;\n    typedef __hash_node_base __first_node;\n    typedef typename __rebind_pointer<_NodePtr, __first_node>::type __node_base_pointer;\n    typedef _NodePtr __node_pointer;\n\n#if defined(_LIBCPP_ABI_FIX_UNORDERED_NODE_POINTER_UB)\n  typedef __node_base_pointer __next_pointer;\n#else\n  typedef typename conditional<\n      is_pointer<__node_pointer>::value,\n      __node_base_pointer,\n      __node_pointer>::type   __next_pointer;\n#endif\n\n    __next_pointer    __next_;\n\n    _LIBCPP_INLINE_VISIBILITY\n    __next_pointer __ptr() _NOEXCEPT {\n        return static_cast<__next_pointer>(\n            pointer_traits<__node_base_pointer>::pointer_to(*this));\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    __node_pointer __upcast() _NOEXCEPT {\n        return static_cast<__node_pointer>(\n            pointer_traits<__node_base_pointer>::pointer_to(*this));\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_t __hash() const _NOEXCEPT {\n        return static_cast<__node_type const&>(*this).__hash_;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY __hash_node_base() _NOEXCEPT : __next_(nullptr) {}\n};\n\ntemplate <class _Tp, class _VoidPtr>\nstruct __hash_node\n    : public __hash_node_base\n             <\n                 typename __rebind_pointer<_VoidPtr, __hash_node<_Tp, _VoidPtr> >::type\n             >\n{\n    typedef _Tp __node_value_type;\n\n    size_t            __hash_;\n    __node_value_type __value_;\n};\n\ninline _LIBCPP_INLINE_VISIBILITY\nbool\n__is_hash_power2(size_t __bc)\n{\n    return __bc > 2 && !(__bc & (__bc - 1));\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nsize_t\n__constrain_hash(size_t __h, size_t __bc)\n{\n    return !(__bc & (__bc - 1)) ? __h & (__bc - 1) :\n        (__h < __bc ? __h : __h % __bc);\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nsize_t\n__next_hash_pow2(size_t __n)\n{\n    return size_t(1) << (std::numeric_limits<size_t>::digits - __clz(__n-1));\n}\n\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc> class __hash_table;\n\ntemplate <class _NodePtr>      class _LIBCPP_TEMPLATE_VIS __hash_iterator;\ntemplate <class _ConstNodePtr> class _LIBCPP_TEMPLATE_VIS __hash_const_iterator;\ntemplate <class _NodePtr>      class _LIBCPP_TEMPLATE_VIS __hash_local_iterator;\ntemplate <class _ConstNodePtr> class _LIBCPP_TEMPLATE_VIS __hash_const_local_iterator;\ntemplate <class _HashIterator> class _LIBCPP_TEMPLATE_VIS __hash_map_iterator;\ntemplate <class _HashIterator> class _LIBCPP_TEMPLATE_VIS __hash_map_const_iterator;\n\ntemplate <class _Tp>\nstruct __hash_key_value_types {\n  static_assert(!is_reference<_Tp>::value && !is_const<_Tp>::value, \"\");\n  typedef _Tp key_type;\n  typedef _Tp __node_value_type;\n  typedef _Tp __container_value_type;\n  static const bool __is_map = false;\n\n  _LIBCPP_INLINE_VISIBILITY\n  static key_type const& __get_key(_Tp const& __v) {\n    return __v;\n  }\n  _LIBCPP_INLINE_VISIBILITY\n  static __container_value_type const& __get_value(__node_value_type const& __v) {\n    return __v;\n  }\n  _LIBCPP_INLINE_VISIBILITY\n  static __container_value_type* __get_ptr(__node_value_type& __n) {\n    return _VSTD::addressof(__n);\n  }\n#ifndef _LIBCPP_CXX03_LANG\n  _LIBCPP_INLINE_VISIBILITY\n  static  __container_value_type&& __move(__node_value_type& __v) {\n    return _VSTD::move(__v);\n  }\n#endif\n};\n\ntemplate <class _Key, class _Tp>\nstruct __hash_key_value_types<__hash_value_type<_Key, _Tp> > {\n  typedef _Key                                         key_type;\n  typedef _Tp                                          mapped_type;\n  typedef __hash_value_type<_Key, _Tp>                 __node_value_type;\n  typedef pair<const _Key, _Tp>                        __container_value_type;\n  typedef pair<_Key, _Tp>                              __nc_value_type;\n  typedef __container_value_type                       __map_value_type;\n  static const bool __is_map = true;\n\n  _LIBCPP_INLINE_VISIBILITY\n  static key_type const& __get_key(__container_value_type const& __v) {\n    return __v.first;\n  }\n\n  template <class _Up>\n  _LIBCPP_INLINE_VISIBILITY\n  static typename enable_if<__is_same_uncvref<_Up, __node_value_type>::value,\n      __container_value_type const&>::type\n  __get_value(_Up& __t) {\n    return __t.__cc;\n  }\n\n  template <class _Up>\n  _LIBCPP_INLINE_VISIBILITY\n  static typename enable_if<__is_same_uncvref<_Up, __container_value_type>::value,\n      __container_value_type const&>::type\n  __get_value(_Up& __t) {\n    return __t;\n  }\n\n  _LIBCPP_INLINE_VISIBILITY\n  static __container_value_type* __get_ptr(__node_value_type& __n) {\n    return _VSTD::addressof(__n.__cc);\n  }\n#ifndef _LIBCPP_CXX03_LANG\n  _LIBCPP_INLINE_VISIBILITY\n  static __nc_value_type&& __move(__node_value_type& __v) {\n    return _VSTD::move(__v.__nc);\n  }\n#endif\n\n};\n\ntemplate <class _Tp, class _AllocPtr, class _KVTypes = __hash_key_value_types<_Tp>,\n          bool = _KVTypes::__is_map>\nstruct __hash_map_pointer_types {};\n\ntemplate <class _Tp, class _AllocPtr, class _KVTypes>\nstruct __hash_map_pointer_types<_Tp, _AllocPtr, _KVTypes, true> {\n  typedef typename _KVTypes::__map_value_type   _Mv;\n  typedef typename __rebind_pointer<_AllocPtr, _Mv>::type\n                                                       __map_value_type_pointer;\n  typedef typename __rebind_pointer<_AllocPtr, const _Mv>::type\n                                                 __const_map_value_type_pointer;\n};\n\ntemplate <class _NodePtr, class _NodeT = typename pointer_traits<_NodePtr>::element_type>\nstruct __hash_node_types;\n\ntemplate <class _NodePtr, class _Tp, class _VoidPtr>\nstruct __hash_node_types<_NodePtr, __hash_node<_Tp, _VoidPtr> >\n    : public __hash_key_value_types<_Tp>, __hash_map_pointer_types<_Tp, _VoidPtr>\n\n{\n  typedef __hash_key_value_types<_Tp>           __base;\n\npublic:\n  typedef ptrdiff_t difference_type;\n  typedef size_t size_type;\n\n  typedef typename __rebind_pointer<_NodePtr, void>::type       __void_pointer;\n\n  typedef typename pointer_traits<_NodePtr>::element_type       __node_type;\n  typedef _NodePtr                                              __node_pointer;\n\n  typedef __hash_node_base<__node_pointer>                      __node_base_type;\n  typedef typename __rebind_pointer<_NodePtr, __node_base_type>::type\n                                                             __node_base_pointer;\n\n  typedef typename __node_base_type::__next_pointer          __next_pointer;\n\n  typedef _Tp                                                 __node_value_type;\n  typedef typename __rebind_pointer<_VoidPtr, __node_value_type>::type\n                                                      __node_value_type_pointer;\n  typedef typename __rebind_pointer<_VoidPtr, const __node_value_type>::type\n                                                __const_node_value_type_pointer;\n\nprivate:\n    static_assert(!is_const<__node_type>::value,\n                \"_NodePtr should never be a pointer to const\");\n    static_assert((is_same<typename pointer_traits<_VoidPtr>::element_type, void>::value),\n                  \"_VoidPtr does not point to unqualified void type\");\n    static_assert((is_same<typename __rebind_pointer<_VoidPtr, __node_type>::type,\n                          _NodePtr>::value), \"_VoidPtr does not rebind to _NodePtr.\");\n};\n\ntemplate <class _HashIterator>\nstruct __hash_node_types_from_iterator;\ntemplate <class _NodePtr>\nstruct __hash_node_types_from_iterator<__hash_iterator<_NodePtr> > : __hash_node_types<_NodePtr> {};\ntemplate <class _NodePtr>\nstruct __hash_node_types_from_iterator<__hash_const_iterator<_NodePtr> > : __hash_node_types<_NodePtr> {};\ntemplate <class _NodePtr>\nstruct __hash_node_types_from_iterator<__hash_local_iterator<_NodePtr> > : __hash_node_types<_NodePtr> {};\ntemplate <class _NodePtr>\nstruct __hash_node_types_from_iterator<__hash_const_local_iterator<_NodePtr> > : __hash_node_types<_NodePtr> {};\n\n\ntemplate <class _NodeValueTp, class _VoidPtr>\nstruct __make_hash_node_types {\n  typedef __hash_node<_NodeValueTp, _VoidPtr> _NodeTp;\n  typedef typename __rebind_pointer<_VoidPtr, _NodeTp>::type _NodePtr;\n  typedef __hash_node_types<_NodePtr> type;\n};\n\ntemplate <class _NodePtr>\nclass _LIBCPP_TEMPLATE_VIS __hash_iterator\n{\n    typedef __hash_node_types<_NodePtr> _NodeTypes;\n    typedef _NodePtr                            __node_pointer;\n    typedef typename _NodeTypes::__next_pointer __next_pointer;\n\n    __next_pointer            __node_;\n\npublic:\n    typedef forward_iterator_tag                           iterator_category;\n    typedef typename _NodeTypes::__node_value_type         value_type;\n    typedef typename _NodeTypes::difference_type           difference_type;\n    typedef value_type&                                    reference;\n    typedef typename _NodeTypes::__node_value_type_pointer pointer;\n\n    _LIBCPP_INLINE_VISIBILITY __hash_iterator() _NOEXCEPT : __node_(nullptr) {\n        _LIBCPP_DEBUG_MODE(__get_db()->__insert_i(this));\n    }\n\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_INLINE_VISIBILITY\n    __hash_iterator(const __hash_iterator& __i)\n        : __node_(__i.__node_)\n    {\n        __get_db()->__iterator_copy(this, &__i);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    ~__hash_iterator()\n    {\n        __get_db()->__erase_i(this);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    __hash_iterator& operator=(const __hash_iterator& __i)\n    {\n        if (this != &__i)\n        {\n            __get_db()->__iterator_copy(this, &__i);\n            __node_ = __i.__node_;\n        }\n        return *this;\n    }\n#endif  // _LIBCPP_DEBUG_LEVEL >= 2\n\n    _LIBCPP_INLINE_VISIBILITY\n    reference operator*() const {\n        _LIBCPP_DEBUG_ASSERT(__get_const_db()->__dereferenceable(this),\n                             \"Attempted to dereference a non-dereferenceable unordered container iterator\");\n        return __node_->__upcast()->__value_;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    pointer operator->() const {\n        _LIBCPP_DEBUG_ASSERT(__get_const_db()->__dereferenceable(this),\n                           \"Attempted to dereference a non-dereferenceable unordered container iterator\");\n        return pointer_traits<pointer>::pointer_to(__node_->__upcast()->__value_);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    __hash_iterator& operator++() {\n        _LIBCPP_DEBUG_ASSERT(__get_const_db()->__dereferenceable(this),\n                       \"Attempted to increment non-incrementable unordered container iterator\");\n        __node_ = __node_->__next_;\n        return *this;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    __hash_iterator operator++(int)\n    {\n        __hash_iterator __t(*this);\n        ++(*this);\n        return __t;\n    }\n\n    friend _LIBCPP_INLINE_VISIBILITY\n    bool operator==(const __hash_iterator& __x, const __hash_iterator& __y)\n    {\n        return __x.__node_ == __y.__node_;\n    }\n    friend _LIBCPP_INLINE_VISIBILITY\n    bool operator!=(const __hash_iterator& __x, const __hash_iterator& __y)\n        {return !(__x == __y);}\n\nprivate:\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_INLINE_VISIBILITY\n    __hash_iterator(__next_pointer __node, const void* __c) _NOEXCEPT\n        : __node_(__node)\n        {\n            __get_db()->__insert_ic(this, __c);\n        }\n#else\n    _LIBCPP_INLINE_VISIBILITY\n    __hash_iterator(__next_pointer __node) _NOEXCEPT\n        : __node_(__node)\n        {}\n#endif\n    template <class, class, class, class> friend class __hash_table;\n    template <class> friend class _LIBCPP_TEMPLATE_VIS __hash_const_iterator;\n    template <class> friend class _LIBCPP_TEMPLATE_VIS __hash_map_iterator;\n    template <class, class, class, class, class> friend class _LIBCPP_TEMPLATE_VIS unordered_map;\n    template <class, class, class, class, class> friend class _LIBCPP_TEMPLATE_VIS unordered_multimap;\n};\n\ntemplate <class _NodePtr>\nclass _LIBCPP_TEMPLATE_VIS __hash_const_iterator\n{\n    static_assert(!is_const<typename pointer_traits<_NodePtr>::element_type>::value, \"\");\n    typedef __hash_node_types<_NodePtr> _NodeTypes;\n    typedef _NodePtr                            __node_pointer;\n    typedef typename _NodeTypes::__next_pointer __next_pointer;\n\n    __next_pointer __node_;\n\npublic:\n    typedef __hash_iterator<_NodePtr> __non_const_iterator;\n\n    typedef forward_iterator_tag                                 iterator_category;\n    typedef typename _NodeTypes::__node_value_type               value_type;\n    typedef typename _NodeTypes::difference_type                 difference_type;\n    typedef const value_type&                                    reference;\n    typedef typename _NodeTypes::__const_node_value_type_pointer pointer;\n\n\n    _LIBCPP_INLINE_VISIBILITY __hash_const_iterator() _NOEXCEPT : __node_(nullptr) {\n        _LIBCPP_DEBUG_MODE(__get_db()->__insert_i(this));\n    }\n\n    _LIBCPP_INLINE_VISIBILITY \n    __hash_const_iterator(const __non_const_iterator& __x) _NOEXCEPT\n        : __node_(__x.__node_)\n    {\n        _LIBCPP_DEBUG_MODE(__get_db()->__iterator_copy(this, &__x));\n    }\n\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_INLINE_VISIBILITY\n    __hash_const_iterator(const __hash_const_iterator& __i)\n        : __node_(__i.__node_)\n    {\n        __get_db()->__iterator_copy(this, &__i);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    ~__hash_const_iterator()\n    {\n        __get_db()->__erase_i(this);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    __hash_const_iterator& operator=(const __hash_const_iterator& __i)\n    {\n        if (this != &__i)\n        {\n            __get_db()->__iterator_copy(this, &__i);\n            __node_ = __i.__node_;\n        }\n        return *this;\n    }\n#endif  // _LIBCPP_DEBUG_LEVEL >= 2\n\n    _LIBCPP_INLINE_VISIBILITY\n    reference operator*() const {\n        _LIBCPP_DEBUG_ASSERT(__get_const_db()->__dereferenceable(this),\n                           \"Attempted to dereference a non-dereferenceable unordered container const_iterator\");\n        return __node_->__upcast()->__value_;\n    }\n    _LIBCPP_INLINE_VISIBILITY\n    pointer operator->() const {\n        _LIBCPP_DEBUG_ASSERT(__get_const_db()->__dereferenceable(this),\n                           \"Attempted to dereference a non-dereferenceable unordered container const_iterator\");\n        return pointer_traits<pointer>::pointer_to(__node_->__upcast()->__value_);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    __hash_const_iterator& operator++() {\n        _LIBCPP_DEBUG_ASSERT(__get_const_db()->__dereferenceable(this),\n                             \"Attempted to increment non-incrementable unordered container const_iterator\");\n        __node_ = __node_->__next_;\n        return *this;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    __hash_const_iterator operator++(int)\n    {\n        __hash_const_iterator __t(*this);\n        ++(*this);\n        return __t;\n    }\n\n    friend _LIBCPP_INLINE_VISIBILITY\n    bool operator==(const __hash_const_iterator& __x, const __hash_const_iterator& __y)\n    {\n        return __x.__node_ == __y.__node_;\n    }\n    friend _LIBCPP_INLINE_VISIBILITY\n    bool operator!=(const __hash_const_iterator& __x, const __hash_const_iterator& __y)\n        {return !(__x == __y);}\n\nprivate:\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_INLINE_VISIBILITY\n    __hash_const_iterator(__next_pointer __node, const void* __c) _NOEXCEPT\n        : __node_(__node)\n        {\n            __get_db()->__insert_ic(this, __c);\n        }\n#else\n    _LIBCPP_INLINE_VISIBILITY\n    __hash_const_iterator(__next_pointer __node) _NOEXCEPT\n        : __node_(__node)\n        {}\n#endif\n    template <class, class, class, class> friend class __hash_table;\n    template <class> friend class _LIBCPP_TEMPLATE_VIS __hash_map_const_iterator;\n    template <class, class, class, class, class> friend class _LIBCPP_TEMPLATE_VIS unordered_map;\n    template <class, class, class, class, class> friend class _LIBCPP_TEMPLATE_VIS unordered_multimap;\n};\n\ntemplate <class _NodePtr>\nclass _LIBCPP_TEMPLATE_VIS __hash_local_iterator\n{\n    typedef __hash_node_types<_NodePtr> _NodeTypes;\n    typedef _NodePtr                            __node_pointer;\n    typedef typename _NodeTypes::__next_pointer __next_pointer;\n\n    __next_pointer         __node_;\n    size_t                 __bucket_;\n    size_t                 __bucket_count_;\n\npublic:\n    typedef forward_iterator_tag                                iterator_category;\n    typedef typename _NodeTypes::__node_value_type              value_type;\n    typedef typename _NodeTypes::difference_type                difference_type;\n    typedef value_type&                                         reference;\n    typedef typename _NodeTypes::__node_value_type_pointer      pointer;\n\n    _LIBCPP_INLINE_VISIBILITY __hash_local_iterator() _NOEXCEPT : __node_(nullptr) {\n        _LIBCPP_DEBUG_MODE(__get_db()->__insert_i(this));\n    }\n\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_INLINE_VISIBILITY\n    __hash_local_iterator(const __hash_local_iterator& __i)\n        : __node_(__i.__node_),\n          __bucket_(__i.__bucket_),\n          __bucket_count_(__i.__bucket_count_)\n    {\n        __get_db()->__iterator_copy(this, &__i);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    ~__hash_local_iterator()\n    {\n        __get_db()->__erase_i(this);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    __hash_local_iterator& operator=(const __hash_local_iterator& __i)\n    {\n        if (this != &__i)\n        {\n            __get_db()->__iterator_copy(this, &__i);\n            __node_ = __i.__node_;\n            __bucket_ = __i.__bucket_;\n            __bucket_count_ = __i.__bucket_count_;\n        }\n        return *this;\n    }\n#endif  // _LIBCPP_DEBUG_LEVEL >= 2\n\n    _LIBCPP_INLINE_VISIBILITY\n    reference operator*() const {\n        _LIBCPP_DEBUG_ASSERT(__get_const_db()->__dereferenceable(this),\n                           \"Attempted to dereference a non-dereferenceable unordered container local_iterator\");\n        return __node_->__upcast()->__value_;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    pointer operator->() const {\n        _LIBCPP_DEBUG_ASSERT(__get_const_db()->__dereferenceable(this),\n                             \"Attempted to dereference a non-dereferenceable unordered container local_iterator\");\n        return pointer_traits<pointer>::pointer_to(__node_->__upcast()->__value_);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    __hash_local_iterator& operator++() {\n        _LIBCPP_DEBUG_ASSERT(__get_const_db()->__dereferenceable(this),\n                       \"Attempted to increment non-incrementable unordered container local_iterator\");\n        __node_ = __node_->__next_;\n        if (__node_ != nullptr && __constrain_hash(__node_->__hash(), __bucket_count_) != __bucket_)\n            __node_ = nullptr;\n        return *this;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    __hash_local_iterator operator++(int)\n    {\n        __hash_local_iterator __t(*this);\n        ++(*this);\n        return __t;\n    }\n\n    friend _LIBCPP_INLINE_VISIBILITY\n    bool operator==(const __hash_local_iterator& __x, const __hash_local_iterator& __y)\n    {\n        return __x.__node_ == __y.__node_;\n    }\n    friend _LIBCPP_INLINE_VISIBILITY\n    bool operator!=(const __hash_local_iterator& __x, const __hash_local_iterator& __y)\n        {return !(__x == __y);}\n\nprivate:\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_INLINE_VISIBILITY\n    __hash_local_iterator(__next_pointer __node, size_t __bucket,\n                          size_t __bucket_count, const void* __c) _NOEXCEPT\n        : __node_(__node),\n          __bucket_(__bucket),\n          __bucket_count_(__bucket_count)\n        {\n            __get_db()->__insert_ic(this, __c);\n            if (__node_ != nullptr)\n                __node_ = __node_->__next_;\n        }\n#else\n    _LIBCPP_INLINE_VISIBILITY\n    __hash_local_iterator(__next_pointer __node, size_t __bucket,\n                          size_t __bucket_count) _NOEXCEPT\n        : __node_(__node),\n          __bucket_(__bucket),\n          __bucket_count_(__bucket_count)\n        {\n            if (__node_ != nullptr)\n                __node_ = __node_->__next_;\n        }\n#endif\n    template <class, class, class, class> friend class __hash_table;\n    template <class> friend class _LIBCPP_TEMPLATE_VIS __hash_const_local_iterator;\n    template <class> friend class _LIBCPP_TEMPLATE_VIS __hash_map_iterator;\n};\n\ntemplate <class _ConstNodePtr>\nclass _LIBCPP_TEMPLATE_VIS __hash_const_local_iterator\n{\n    typedef __hash_node_types<_ConstNodePtr> _NodeTypes;\n    typedef _ConstNodePtr                       __node_pointer;\n    typedef typename _NodeTypes::__next_pointer __next_pointer;\n\n    __next_pointer         __node_;\n    size_t                 __bucket_;\n    size_t                 __bucket_count_;\n\n    typedef pointer_traits<__node_pointer>          __pointer_traits;\n    typedef typename __pointer_traits::element_type __node;\n    typedef typename remove_const<__node>::type     __non_const_node;\n    typedef typename __rebind_pointer<__node_pointer, __non_const_node>::type\n        __non_const_node_pointer;\npublic:\n    typedef __hash_local_iterator<__non_const_node_pointer>\n                                                    __non_const_iterator;\n\n    typedef forward_iterator_tag                                 iterator_category;\n    typedef typename _NodeTypes::__node_value_type               value_type;\n    typedef typename _NodeTypes::difference_type                 difference_type;\n    typedef const value_type&                                    reference;\n    typedef typename _NodeTypes::__const_node_value_type_pointer pointer;\n\n\n    _LIBCPP_INLINE_VISIBILITY __hash_const_local_iterator() _NOEXCEPT : __node_(nullptr) {\n        _LIBCPP_DEBUG_MODE(__get_db()->__insert_i(this));\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    __hash_const_local_iterator(const __non_const_iterator& __x) _NOEXCEPT\n        : __node_(__x.__node_),\n          __bucket_(__x.__bucket_),\n          __bucket_count_(__x.__bucket_count_)\n    {\n        _LIBCPP_DEBUG_MODE(__get_db()->__iterator_copy(this, &__x));\n    }\n\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_INLINE_VISIBILITY\n    __hash_const_local_iterator(const __hash_const_local_iterator& __i)\n        : __node_(__i.__node_),\n          __bucket_(__i.__bucket_),\n          __bucket_count_(__i.__bucket_count_)\n    {\n        __get_db()->__iterator_copy(this, &__i);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    ~__hash_const_local_iterator()\n    {\n        __get_db()->__erase_i(this);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    __hash_const_local_iterator& operator=(const __hash_const_local_iterator& __i)\n    {\n        if (this != &__i)\n        {\n            __get_db()->__iterator_copy(this, &__i);\n            __node_ = __i.__node_;\n            __bucket_ = __i.__bucket_;\n            __bucket_count_ = __i.__bucket_count_;\n        }\n        return *this;\n    }\n#endif  // _LIBCPP_DEBUG_LEVEL >= 2\n\n    _LIBCPP_INLINE_VISIBILITY\n    reference operator*() const {\n        _LIBCPP_DEBUG_ASSERT(__get_const_db()->__dereferenceable(this),\n                           \"Attempted to dereference a non-dereferenceable unordered container const_local_iterator\");\n        return __node_->__upcast()->__value_;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    pointer operator->() const {\n        _LIBCPP_DEBUG_ASSERT(__get_const_db()->__dereferenceable(this),\n                           \"Attempted to dereference a non-dereferenceable unordered container const_local_iterator\");\n        return pointer_traits<pointer>::pointer_to(__node_->__upcast()->__value_);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    __hash_const_local_iterator& operator++() {\n        _LIBCPP_DEBUG_ASSERT(__get_const_db()->__dereferenceable(this),\n                       \"Attempted to increment non-incrementable unordered container const_local_iterator\");\n        __node_ = __node_->__next_;\n        if (__node_ != nullptr && __constrain_hash(__node_->__hash(), __bucket_count_) != __bucket_)\n            __node_ = nullptr;\n        return *this;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    __hash_const_local_iterator operator++(int)\n    {\n        __hash_const_local_iterator __t(*this);\n        ++(*this);\n        return __t;\n    }\n\n    friend _LIBCPP_INLINE_VISIBILITY\n    bool operator==(const __hash_const_local_iterator& __x, const __hash_const_local_iterator& __y)\n    {\n        return __x.__node_ == __y.__node_;\n    }\n    friend _LIBCPP_INLINE_VISIBILITY\n    bool operator!=(const __hash_const_local_iterator& __x, const __hash_const_local_iterator& __y)\n        {return !(__x == __y);}\n\nprivate:\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_INLINE_VISIBILITY\n    __hash_const_local_iterator(__next_pointer __node, size_t __bucket,\n                                size_t __bucket_count, const void* __c) _NOEXCEPT\n        : __node_(__node),\n          __bucket_(__bucket),\n          __bucket_count_(__bucket_count)\n        {\n            __get_db()->__insert_ic(this, __c);\n            if (__node_ != nullptr)\n                __node_ = __node_->__next_;\n        }\n#else\n    _LIBCPP_INLINE_VISIBILITY\n    __hash_const_local_iterator(__next_pointer __node, size_t __bucket,\n                                size_t __bucket_count) _NOEXCEPT\n        : __node_(__node),\n          __bucket_(__bucket),\n          __bucket_count_(__bucket_count)\n        {\n            if (__node_ != nullptr)\n                __node_ = __node_->__next_;\n        }\n#endif\n    template <class, class, class, class> friend class __hash_table;\n    template <class> friend class _LIBCPP_TEMPLATE_VIS __hash_map_const_iterator;\n};\n\ntemplate <class _Alloc>\nclass __bucket_list_deallocator\n{\n    typedef _Alloc                                          allocator_type;\n    typedef allocator_traits<allocator_type>                __alloc_traits;\n    typedef typename __alloc_traits::size_type              size_type;\n\n    __compressed_pair<size_type, allocator_type> __data_;\npublic:\n    typedef typename __alloc_traits::pointer pointer;\n\n    _LIBCPP_INLINE_VISIBILITY\n    __bucket_list_deallocator()\n        _NOEXCEPT_(is_nothrow_default_constructible<allocator_type>::value)\n        : __data_(0) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __bucket_list_deallocator(const allocator_type& __a, size_type __size)\n        _NOEXCEPT_(is_nothrow_copy_constructible<allocator_type>::value)\n        : __data_(__size, __a) {}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    _LIBCPP_INLINE_VISIBILITY\n    __bucket_list_deallocator(__bucket_list_deallocator&& __x)\n        _NOEXCEPT_(is_nothrow_move_constructible<allocator_type>::value)\n        : __data_(_VSTD::move(__x.__data_))\n    {\n        __x.size() = 0;\n    }\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type& size() _NOEXCEPT {return __data_.first();}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type  size() const _NOEXCEPT {return __data_.first();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    allocator_type& __alloc() _NOEXCEPT {return __data_.second();}\n    _LIBCPP_INLINE_VISIBILITY\n    const allocator_type& __alloc() const _NOEXCEPT {return __data_.second();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void operator()(pointer __p) _NOEXCEPT\n    {\n        __alloc_traits::deallocate(__alloc(), __p, size());\n    }\n};\n\ntemplate <class _Alloc> class __hash_map_node_destructor;\n\ntemplate <class _Alloc>\nclass __hash_node_destructor\n{\n    typedef _Alloc                                          allocator_type;\n    typedef allocator_traits<allocator_type>                __alloc_traits;\n\npublic:\n    typedef typename __alloc_traits::pointer                pointer;\nprivate:\n    typedef __hash_node_types<pointer> _NodeTypes;\n\n    allocator_type& __na_;\n\n    __hash_node_destructor& operator=(const __hash_node_destructor&);\n\npublic:\n    bool __value_constructed;\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __hash_node_destructor(allocator_type& __na,\n                                    bool __constructed = false) _NOEXCEPT\n        : __na_(__na),\n          __value_constructed(__constructed)\n        {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void operator()(pointer __p) _NOEXCEPT\n    {\n        if (__value_constructed)\n            __alloc_traits::destroy(__na_, _NodeTypes::__get_ptr(__p->__value_));\n        if (__p)\n            __alloc_traits::deallocate(__na_, __p, 1);\n    }\n\n    template <class> friend class __hash_map_node_destructor;\n};\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\nclass __hash_table\n{\npublic:\n    typedef _Tp    value_type;\n    typedef _Hash  hasher;\n    typedef _Equal key_equal;\n    typedef _Alloc allocator_type;\n\nprivate:\n    typedef allocator_traits<allocator_type> __alloc_traits;\n    typedef typename\n      __make_hash_node_types<value_type, typename __alloc_traits::void_pointer>::type\n                                                                     _NodeTypes;\npublic:\n\n    typedef typename _NodeTypes::__node_value_type           __node_value_type;\n    typedef typename _NodeTypes::__container_value_type      __container_value_type;\n    typedef typename _NodeTypes::key_type                    key_type;\n    typedef value_type&                              reference;\n    typedef const value_type&                        const_reference;\n    typedef typename __alloc_traits::pointer         pointer;\n    typedef typename __alloc_traits::const_pointer   const_pointer;\n#ifndef _LIBCPP_ABI_FIX_UNORDERED_CONTAINER_SIZE_TYPE\n    typedef typename __alloc_traits::size_type       size_type;\n#else\n    typedef typename _NodeTypes::size_type           size_type;\n#endif\n    typedef typename _NodeTypes::difference_type     difference_type;\npublic:\n    // Create __node\n\n    typedef typename _NodeTypes::__node_type __node;\n    typedef typename __rebind_alloc_helper<__alloc_traits, __node>::type __node_allocator;\n    typedef allocator_traits<__node_allocator>       __node_traits;\n    typedef typename _NodeTypes::__void_pointer      __void_pointer;\n    typedef typename _NodeTypes::__node_pointer      __node_pointer;\n    typedef typename _NodeTypes::__node_pointer      __node_const_pointer;\n    typedef typename _NodeTypes::__node_base_type    __first_node;\n    typedef typename _NodeTypes::__node_base_pointer __node_base_pointer;\n    typedef typename _NodeTypes::__next_pointer      __next_pointer;\n\nprivate:\n    // check for sane allocator pointer rebinding semantics. Rebinding the\n    // allocator for a new pointer type should be exactly the same as rebinding\n    // the pointer using 'pointer_traits'.\n    static_assert((is_same<__node_pointer, typename __node_traits::pointer>::value),\n                  \"Allocator does not rebind pointers in a sane manner.\");\n    typedef typename __rebind_alloc_helper<__node_traits, __first_node>::type\n        __node_base_allocator;\n    typedef allocator_traits<__node_base_allocator> __node_base_traits;\n    static_assert((is_same<__node_base_pointer, typename __node_base_traits::pointer>::value),\n                 \"Allocator does not rebind pointers in a sane manner.\");\n\nprivate:\n\n    typedef typename __rebind_alloc_helper<__node_traits, __next_pointer>::type __pointer_allocator;\n    typedef __bucket_list_deallocator<__pointer_allocator> __bucket_list_deleter;\n    typedef unique_ptr<__next_pointer[], __bucket_list_deleter> __bucket_list;\n    typedef allocator_traits<__pointer_allocator>          __pointer_alloc_traits;\n    typedef typename __bucket_list_deleter::pointer       __node_pointer_pointer;\n\n    // --- Member data begin ---\n    __bucket_list                                         __bucket_list_;\n    __compressed_pair<__first_node, __node_allocator>     __p1_;\n    __compressed_pair<size_type, hasher>                  __p2_;\n    __compressed_pair<float, key_equal>                   __p3_;\n    // --- Member data end ---\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type& size() _NOEXCEPT {return __p2_.first();}\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    size_type  size() const _NOEXCEPT {return __p2_.first();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    hasher& hash_function() _NOEXCEPT {return __p2_.second();}\n    _LIBCPP_INLINE_VISIBILITY\n    const hasher& hash_function() const _NOEXCEPT {return __p2_.second();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    float& max_load_factor() _NOEXCEPT {return __p3_.first();}\n    _LIBCPP_INLINE_VISIBILITY\n    float  max_load_factor() const _NOEXCEPT {return __p3_.first();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    key_equal& key_eq() _NOEXCEPT {return __p3_.second();}\n    _LIBCPP_INLINE_VISIBILITY\n    const key_equal& key_eq() const _NOEXCEPT {return __p3_.second();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __node_allocator& __node_alloc() _NOEXCEPT {return __p1_.second();}\n    _LIBCPP_INLINE_VISIBILITY\n    const __node_allocator& __node_alloc() const _NOEXCEPT\n        {return __p1_.second();}\n\npublic:\n    typedef __hash_iterator<__node_pointer>                   iterator;\n    typedef __hash_const_iterator<__node_pointer>             const_iterator;\n    typedef __hash_local_iterator<__node_pointer>             local_iterator;\n    typedef __hash_const_local_iterator<__node_pointer>       const_local_iterator;\n\n    _LIBCPP_INLINE_VISIBILITY\n    __hash_table()\n        _NOEXCEPT_(\n            is_nothrow_default_constructible<__bucket_list>::value &&\n            is_nothrow_default_constructible<__first_node>::value &&\n            is_nothrow_default_constructible<__node_allocator>::value &&\n            is_nothrow_default_constructible<hasher>::value &&\n            is_nothrow_default_constructible<key_equal>::value);\n    _LIBCPP_INLINE_VISIBILITY\n    __hash_table(const hasher& __hf, const key_equal& __eql);\n    __hash_table(const hasher& __hf, const key_equal& __eql,\n                 const allocator_type& __a);\n    explicit __hash_table(const allocator_type& __a);\n    __hash_table(const __hash_table& __u);\n    __hash_table(const __hash_table& __u, const allocator_type& __a);\n#ifndef _LIBCPP_CXX03_LANG\n    __hash_table(__hash_table&& __u)\n        _NOEXCEPT_(\n            is_nothrow_move_constructible<__bucket_list>::value &&\n            is_nothrow_move_constructible<__first_node>::value &&\n            is_nothrow_move_constructible<__node_allocator>::value &&\n            is_nothrow_move_constructible<hasher>::value &&\n            is_nothrow_move_constructible<key_equal>::value);\n    __hash_table(__hash_table&& __u, const allocator_type& __a);\n#endif  // _LIBCPP_CXX03_LANG\n    ~__hash_table();\n\n    __hash_table& operator=(const __hash_table& __u);\n#ifndef _LIBCPP_CXX03_LANG\n    _LIBCPP_INLINE_VISIBILITY\n    __hash_table& operator=(__hash_table&& __u)\n        _NOEXCEPT_(\n            __node_traits::propagate_on_container_move_assignment::value &&\n            is_nothrow_move_assignable<__node_allocator>::value &&\n            is_nothrow_move_assignable<hasher>::value &&\n            is_nothrow_move_assignable<key_equal>::value);\n#endif\n    template <class _InputIterator>\n        void __assign_unique(_InputIterator __first, _InputIterator __last);\n    template <class _InputIterator>\n        void __assign_multi(_InputIterator __first, _InputIterator __last);\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type max_size() const _NOEXCEPT\n    {\n        return std::min<size_type>(\n            __node_traits::max_size(__node_alloc()),\n            numeric_limits<difference_type >::max()\n        );\n    }\n\n    pair<iterator, bool> __node_insert_unique(__node_pointer __nd);\n    iterator             __node_insert_multi(__node_pointer __nd);\n    iterator             __node_insert_multi(const_iterator __p,\n                                             __node_pointer __nd);\n\n#ifndef _LIBCPP_CXX03_LANG\n    template <class _Key, class ..._Args>\n    _LIBCPP_INLINE_VISIBILITY\n    pair<iterator, bool> __emplace_unique_key_args(_Key const& __k, _Args&&... __args);\n\n    template <class... _Args>\n    _LIBCPP_INLINE_VISIBILITY\n    pair<iterator, bool> __emplace_unique_impl(_Args&&... __args);\n\n    template <class _Pp>\n    _LIBCPP_INLINE_VISIBILITY\n    pair<iterator, bool> __emplace_unique(_Pp&& __x) {\n      return __emplace_unique_extract_key(_VSTD::forward<_Pp>(__x),\n                                          __can_extract_key<_Pp, key_type>());\n    }\n\n    template <class _First, class _Second>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<\n        __can_extract_map_key<_First, key_type, __container_value_type>::value,\n        pair<iterator, bool>\n    >::type __emplace_unique(_First&& __f, _Second&& __s) {\n        return __emplace_unique_key_args(__f, _VSTD::forward<_First>(__f),\n                                              _VSTD::forward<_Second>(__s));\n    }\n\n    template <class... _Args>\n    _LIBCPP_INLINE_VISIBILITY\n    pair<iterator, bool> __emplace_unique(_Args&&... __args) {\n      return __emplace_unique_impl(_VSTD::forward<_Args>(__args)...);\n    }\n\n    template <class _Pp>\n    _LIBCPP_INLINE_VISIBILITY\n    pair<iterator, bool>\n    __emplace_unique_extract_key(_Pp&& __x, __extract_key_fail_tag) {\n      return __emplace_unique_impl(_VSTD::forward<_Pp>(__x));\n    }\n    template <class _Pp>\n    _LIBCPP_INLINE_VISIBILITY\n    pair<iterator, bool>\n    __emplace_unique_extract_key(_Pp&& __x, __extract_key_self_tag) {\n      return __emplace_unique_key_args(__x, _VSTD::forward<_Pp>(__x));\n    }\n    template <class _Pp>\n    _LIBCPP_INLINE_VISIBILITY\n    pair<iterator, bool>\n    __emplace_unique_extract_key(_Pp&& __x, __extract_key_first_tag) {\n      return __emplace_unique_key_args(__x.first, _VSTD::forward<_Pp>(__x));\n    }\n\n    template <class... _Args>\n    _LIBCPP_INLINE_VISIBILITY\n    iterator __emplace_multi(_Args&&... __args);\n    template <class... _Args>\n    _LIBCPP_INLINE_VISIBILITY\n    iterator __emplace_hint_multi(const_iterator __p, _Args&&... __args);\n\n\n    _LIBCPP_INLINE_VISIBILITY\n    pair<iterator, bool>\n    __insert_unique(__container_value_type&& __x) {\n      return __emplace_unique_key_args(_NodeTypes::__get_key(__x), _VSTD::move(__x));\n    }\n\n    template <class _Pp, class = typename enable_if<\n            !__is_same_uncvref<_Pp, __container_value_type>::value\n        >::type>\n    _LIBCPP_INLINE_VISIBILITY\n    pair<iterator, bool> __insert_unique(_Pp&& __x) {\n      return __emplace_unique(_VSTD::forward<_Pp>(__x));\n    }\n\n    template <class _Pp>\n    _LIBCPP_INLINE_VISIBILITY\n    iterator __insert_multi(_Pp&& __x) {\n      return __emplace_multi(_VSTD::forward<_Pp>(__x));\n    }\n\n    template <class _Pp>\n    _LIBCPP_INLINE_VISIBILITY\n    iterator __insert_multi(const_iterator __p, _Pp&& __x) {\n        return __emplace_hint_multi(__p, _VSTD::forward<_Pp>(__x));\n    }\n\n#else  // !defined(_LIBCPP_CXX03_LANG)\n    template <class _Key, class _Args>\n    _LIBCPP_INLINE_VISIBILITY\n    pair<iterator, bool> __emplace_unique_key_args(_Key const&, _Args& __args);\n\n    iterator __insert_multi(const __container_value_type& __x);\n    iterator __insert_multi(const_iterator __p, const __container_value_type& __x);\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    pair<iterator, bool> __insert_unique(const __container_value_type& __x) {\n        return __emplace_unique_key_args(_NodeTypes::__get_key(__x), __x);\n    }\n\n    void clear() _NOEXCEPT;\n    void rehash(size_type __n);\n    _LIBCPP_INLINE_VISIBILITY void reserve(size_type __n)\n        {rehash(static_cast<size_type>(ceil(__n / max_load_factor())));}\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type bucket_count() const _NOEXCEPT\n    {\n        return __bucket_list_.get_deleter().size();\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator       begin() _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    iterator       end() _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator begin() const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator end() const _NOEXCEPT;\n\n    template <class _Key>\n        _LIBCPP_INLINE_VISIBILITY\n        size_type bucket(const _Key& __k) const\n        {\n            _LIBCPP_ASSERT(bucket_count() > 0,\n                \"unordered container::bucket(key) called when bucket_count() == 0\");\n            return __constrain_hash(hash_function()(__k), bucket_count());\n        }\n\n    template <class _Key>\n        iterator       find(const _Key& __x);\n    template <class _Key>\n        const_iterator find(const _Key& __x) const;\n\n    typedef __hash_node_destructor<__node_allocator> _Dp;\n    typedef unique_ptr<__node, _Dp> __node_holder;\n\n    iterator erase(const_iterator __p);\n    iterator erase(const_iterator __first, const_iterator __last);\n    template <class _Key>\n        size_type __erase_unique(const _Key& __k);\n    template <class _Key>\n        size_type __erase_multi(const _Key& __k);\n    __node_holder remove(const_iterator __p) _NOEXCEPT;\n\n    template <class _Key>\n        _LIBCPP_INLINE_VISIBILITY\n        size_type __count_unique(const _Key& __k) const;\n    template <class _Key>\n        size_type __count_multi(const _Key& __k) const;\n\n    template <class _Key>\n        pair<iterator, iterator>\n        __equal_range_unique(const _Key& __k);\n    template <class _Key>\n        pair<const_iterator, const_iterator>\n        __equal_range_unique(const _Key& __k) const;\n\n    template <class _Key>\n        pair<iterator, iterator>\n        __equal_range_multi(const _Key& __k);\n    template <class _Key>\n        pair<const_iterator, const_iterator>\n        __equal_range_multi(const _Key& __k) const;\n\n    void swap(__hash_table& __u)\n#if _LIBCPP_STD_VER <= 11\n        _NOEXCEPT_DEBUG_(\n            __is_nothrow_swappable<hasher>::value && __is_nothrow_swappable<key_equal>::value\n            && (!allocator_traits<__pointer_allocator>::propagate_on_container_swap::value\n                  || __is_nothrow_swappable<__pointer_allocator>::value)\n            && (!__node_traits::propagate_on_container_swap::value\n                  || __is_nothrow_swappable<__node_allocator>::value)\n            );\n#else\n     _NOEXCEPT_DEBUG_(__is_nothrow_swappable<hasher>::value && __is_nothrow_swappable<key_equal>::value);\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type max_bucket_count() const _NOEXCEPT\n        {return max_size(); }\n    size_type bucket_size(size_type __n) const;\n    _LIBCPP_INLINE_VISIBILITY float load_factor() const _NOEXCEPT\n    {\n        size_type __bc = bucket_count();\n        return __bc != 0 ? (float)size() / __bc : 0.f;\n    }\n    _LIBCPP_INLINE_VISIBILITY void max_load_factor(float __mlf) _NOEXCEPT\n    {\n        _LIBCPP_ASSERT(__mlf > 0,\n            \"unordered container::max_load_factor(lf) called with lf <= 0\");\n        max_load_factor() = _VSTD::max(__mlf, load_factor());\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    local_iterator\n    begin(size_type __n)\n    {\n        _LIBCPP_ASSERT(__n < bucket_count(),\n            \"unordered container::begin(n) called with n >= bucket_count()\");\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        return local_iterator(__bucket_list_[__n], __n, bucket_count(), this);\n#else\n        return local_iterator(__bucket_list_[__n], __n, bucket_count());\n#endif\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    local_iterator\n    end(size_type __n)\n    {\n        _LIBCPP_ASSERT(__n < bucket_count(),\n            \"unordered container::end(n) called with n >= bucket_count()\");\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        return local_iterator(nullptr, __n, bucket_count(), this);\n#else\n        return local_iterator(nullptr, __n, bucket_count());\n#endif\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    const_local_iterator\n    cbegin(size_type __n) const\n    {\n        _LIBCPP_ASSERT(__n < bucket_count(),\n            \"unordered container::cbegin(n) called with n >= bucket_count()\");\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        return const_local_iterator(__bucket_list_[__n], __n, bucket_count(), this);\n#else\n        return const_local_iterator(__bucket_list_[__n], __n, bucket_count());\n#endif\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    const_local_iterator\n    cend(size_type __n) const\n    {\n        _LIBCPP_ASSERT(__n < bucket_count(),\n            \"unordered container::cend(n) called with n >= bucket_count()\");\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        return const_local_iterator(nullptr, __n, bucket_count(), this);\n#else\n        return const_local_iterator(nullptr, __n, bucket_count());\n#endif\n    }\n\n#if _LIBCPP_DEBUG_LEVEL >= 2\n\n    bool __dereferenceable(const const_iterator* __i) const;\n    bool __decrementable(const const_iterator* __i) const;\n    bool __addable(const const_iterator* __i, ptrdiff_t __n) const;\n    bool __subscriptable(const const_iterator* __i, ptrdiff_t __n) const;\n\n#endif  // _LIBCPP_DEBUG_LEVEL >= 2\n\nprivate:\n    void __rehash(size_type __n);\n\n#ifndef _LIBCPP_CXX03_LANG\n    template <class ..._Args>\n    __node_holder __construct_node(_Args&& ...__args);\n\n    template <class _First, class ..._Rest>\n    __node_holder __construct_node_hash(size_t __hash, _First&& __f, _Rest&&... __rest);\n#else // _LIBCPP_CXX03_LANG\n    __node_holder __construct_node(const __container_value_type& __v);\n    __node_holder __construct_node_hash(size_t __hash, const __container_value_type& __v);\n#endif\n\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __copy_assign_alloc(const __hash_table& __u)\n        {__copy_assign_alloc(__u, integral_constant<bool,\n             __node_traits::propagate_on_container_copy_assignment::value>());}\n    void __copy_assign_alloc(const __hash_table& __u, true_type);\n    _LIBCPP_INLINE_VISIBILITY\n        void __copy_assign_alloc(const __hash_table&, false_type) {}\n\n#ifndef _LIBCPP_CXX03_LANG\n    void __move_assign(__hash_table& __u, false_type);\n    void __move_assign(__hash_table& __u, true_type)\n        _NOEXCEPT_(\n            is_nothrow_move_assignable<__node_allocator>::value &&\n            is_nothrow_move_assignable<hasher>::value &&\n            is_nothrow_move_assignable<key_equal>::value);\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign_alloc(__hash_table& __u)\n        _NOEXCEPT_(\n            !__node_traits::propagate_on_container_move_assignment::value ||\n            (is_nothrow_move_assignable<__pointer_allocator>::value &&\n             is_nothrow_move_assignable<__node_allocator>::value))\n        {__move_assign_alloc(__u, integral_constant<bool,\n             __node_traits::propagate_on_container_move_assignment::value>());}\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign_alloc(__hash_table& __u, true_type)\n        _NOEXCEPT_(\n            is_nothrow_move_assignable<__pointer_allocator>::value &&\n            is_nothrow_move_assignable<__node_allocator>::value)\n    {\n        __bucket_list_.get_deleter().__alloc() =\n                _VSTD::move(__u.__bucket_list_.get_deleter().__alloc());\n        __node_alloc() = _VSTD::move(__u.__node_alloc());\n    }\n    _LIBCPP_INLINE_VISIBILITY\n        void __move_assign_alloc(__hash_table&, false_type) _NOEXCEPT {}\n#endif // _LIBCPP_CXX03_LANG\n\n    void __deallocate_node(__next_pointer __np) _NOEXCEPT;\n    __next_pointer __detach() _NOEXCEPT;\n\n    template <class, class, class, class, class> friend class _LIBCPP_TEMPLATE_VIS unordered_map;\n    template <class, class, class, class, class> friend class _LIBCPP_TEMPLATE_VIS unordered_multimap;\n};\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\ninline\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::__hash_table()\n    _NOEXCEPT_(\n        is_nothrow_default_constructible<__bucket_list>::value &&\n        is_nothrow_default_constructible<__first_node>::value &&\n        is_nothrow_default_constructible<__node_allocator>::value &&\n        is_nothrow_default_constructible<hasher>::value &&\n        is_nothrow_default_constructible<key_equal>::value)\n    : __p2_(0),\n      __p3_(1.0f)\n{\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\ninline\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::__hash_table(const hasher& __hf,\n                                                       const key_equal& __eql)\n    : __bucket_list_(nullptr, __bucket_list_deleter()),\n      __p1_(),\n      __p2_(0, __hf),\n      __p3_(1.0f, __eql)\n{\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::__hash_table(const hasher& __hf,\n                                                       const key_equal& __eql,\n                                                       const allocator_type& __a)\n    : __bucket_list_(nullptr, __bucket_list_deleter(__pointer_allocator(__a), 0)),\n      __p1_(__node_allocator(__a)),\n      __p2_(0, __hf),\n      __p3_(1.0f, __eql)\n{\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::__hash_table(const allocator_type& __a)\n    : __bucket_list_(nullptr, __bucket_list_deleter(__pointer_allocator(__a), 0)),\n      __p1_(__node_allocator(__a)),\n      __p2_(0),\n      __p3_(1.0f)\n{\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::__hash_table(const __hash_table& __u)\n    : __bucket_list_(nullptr,\n          __bucket_list_deleter(allocator_traits<__pointer_allocator>::\n              select_on_container_copy_construction(\n                  __u.__bucket_list_.get_deleter().__alloc()), 0)),\n      __p1_(allocator_traits<__node_allocator>::\n          select_on_container_copy_construction(__u.__node_alloc())),\n      __p2_(0, __u.hash_function()),\n      __p3_(__u.__p3_)\n{\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::__hash_table(const __hash_table& __u,\n                                                       const allocator_type& __a)\n    : __bucket_list_(nullptr, __bucket_list_deleter(__pointer_allocator(__a), 0)),\n      __p1_(__node_allocator(__a)),\n      __p2_(0, __u.hash_function()),\n      __p3_(__u.__p3_)\n{\n}\n\n#ifndef _LIBCPP_CXX03_LANG\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::__hash_table(__hash_table&& __u)\n        _NOEXCEPT_(\n            is_nothrow_move_constructible<__bucket_list>::value &&\n            is_nothrow_move_constructible<__first_node>::value &&\n            is_nothrow_move_constructible<__node_allocator>::value &&\n            is_nothrow_move_constructible<hasher>::value &&\n            is_nothrow_move_constructible<key_equal>::value)\n    : __bucket_list_(_VSTD::move(__u.__bucket_list_)),\n      __p1_(_VSTD::move(__u.__p1_)),\n      __p2_(_VSTD::move(__u.__p2_)),\n      __p3_(_VSTD::move(__u.__p3_))\n{\n    if (size() > 0)\n    {\n        __bucket_list_[__constrain_hash(__p1_.first().__next_->__hash(), bucket_count())] =\n            __p1_.first().__ptr();\n        __u.__p1_.first().__next_ = nullptr;\n        __u.size() = 0;\n    }\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::__hash_table(__hash_table&& __u,\n                                                       const allocator_type& __a)\n    : __bucket_list_(nullptr, __bucket_list_deleter(__pointer_allocator(__a), 0)),\n      __p1_(__node_allocator(__a)),\n      __p2_(0, _VSTD::move(__u.hash_function())),\n      __p3_(_VSTD::move(__u.__p3_))\n{\n    if (__a == allocator_type(__u.__node_alloc()))\n    {\n        __bucket_list_.reset(__u.__bucket_list_.release());\n        __bucket_list_.get_deleter().size() = __u.__bucket_list_.get_deleter().size();\n        __u.__bucket_list_.get_deleter().size() = 0;\n        if (__u.size() > 0)\n        {\n            __p1_.first().__next_ = __u.__p1_.first().__next_;\n            __u.__p1_.first().__next_ = nullptr;\n            __bucket_list_[__constrain_hash(__p1_.first().__next_->__hash(), bucket_count())] =\n                __p1_.first().__ptr();\n            size() = __u.size();\n            __u.size() = 0;\n        }\n    }\n}\n\n#endif  // _LIBCPP_CXX03_LANG\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::~__hash_table()\n{\n    static_assert((is_copy_constructible<key_equal>::value),\n                 \"Predicate must be copy-constructible.\");\n    static_assert((is_copy_constructible<hasher>::value),\n                 \"Hasher must be copy-constructible.\");\n    __deallocate_node(__p1_.first().__next_);\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__erase_c(this);\n#endif\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\nvoid\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::__copy_assign_alloc(\n        const __hash_table& __u, true_type)\n{\n    if (__node_alloc() != __u.__node_alloc())\n    {\n        clear();\n        __bucket_list_.reset();\n        __bucket_list_.get_deleter().size() = 0;\n    }\n    __bucket_list_.get_deleter().__alloc() = __u.__bucket_list_.get_deleter().__alloc();\n    __node_alloc() = __u.__node_alloc();\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\n__hash_table<_Tp, _Hash, _Equal, _Alloc>&\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::operator=(const __hash_table& __u)\n{\n    if (this != &__u)\n    {\n        __copy_assign_alloc(__u);\n        hash_function() = __u.hash_function();\n        key_eq() = __u.key_eq();\n        max_load_factor() = __u.max_load_factor();\n        __assign_multi(__u.begin(), __u.end());\n    }\n    return *this;\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\nvoid\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::__deallocate_node(__next_pointer __np)\n    _NOEXCEPT\n{\n    __node_allocator& __na = __node_alloc();\n    while (__np != nullptr)\n    {\n        __next_pointer __next = __np->__next_;\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        __c_node* __c = __get_db()->__find_c_and_lock(this);\n        for (__i_node** __p = __c->end_; __p != __c->beg_; )\n        {\n            --__p;\n            iterator* __i = static_cast<iterator*>((*__p)->__i_);\n            if (__i->__node_ == __np)\n            {\n                (*__p)->__c_ = nullptr;\n                if (--__c->end_ != __p)\n                    memmove(__p, __p+1, (__c->end_ - __p)*sizeof(__i_node*));\n            }\n        }\n        __get_db()->unlock();\n#endif\n        __node_pointer __real_np = __np->__upcast();\n        __node_traits::destroy(__na, _NodeTypes::__get_ptr(__real_np->__value_));\n        __node_traits::deallocate(__na, __real_np, 1);\n        __np = __next;\n    }\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\ntypename __hash_table<_Tp, _Hash, _Equal, _Alloc>::__next_pointer\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::__detach() _NOEXCEPT\n{\n    size_type __bc = bucket_count();\n    for (size_type __i = 0; __i < __bc; ++__i)\n        __bucket_list_[__i] = nullptr;\n    size() = 0;\n    __next_pointer __cache = __p1_.first().__next_;\n    __p1_.first().__next_ = nullptr;\n    return __cache;\n}\n\n#ifndef _LIBCPP_CXX03_LANG\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\nvoid\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::__move_assign(\n        __hash_table& __u, true_type)\n    _NOEXCEPT_(\n        is_nothrow_move_assignable<__node_allocator>::value &&\n        is_nothrow_move_assignable<hasher>::value &&\n        is_nothrow_move_assignable<key_equal>::value)\n{\n    clear();\n    __bucket_list_.reset(__u.__bucket_list_.release());\n    __bucket_list_.get_deleter().size() = __u.__bucket_list_.get_deleter().size();\n    __u.__bucket_list_.get_deleter().size() = 0;\n    __move_assign_alloc(__u);\n    size() = __u.size();\n    hash_function() = _VSTD::move(__u.hash_function());\n    max_load_factor() = __u.max_load_factor();\n    key_eq() = _VSTD::move(__u.key_eq());\n    __p1_.first().__next_ = __u.__p1_.first().__next_;\n    if (size() > 0)\n    {\n        __bucket_list_[__constrain_hash(__p1_.first().__next_->__hash(), bucket_count())] =\n            __p1_.first().__ptr();\n        __u.__p1_.first().__next_ = nullptr;\n        __u.size() = 0;\n    }\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->swap(this, &__u);\n#endif\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\nvoid\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::__move_assign(\n        __hash_table& __u, false_type)\n{\n    if (__node_alloc() == __u.__node_alloc())\n        __move_assign(__u, true_type());\n    else\n    {\n        hash_function() = _VSTD::move(__u.hash_function());\n        key_eq() = _VSTD::move(__u.key_eq());\n        max_load_factor() = __u.max_load_factor();\n        if (bucket_count() != 0)\n        {\n            __next_pointer __cache = __detach();\n#ifndef _LIBCPP_NO_EXCEPTIONS\n            try\n            {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n                const_iterator __i = __u.begin();\n                while (__cache != nullptr && __u.size() != 0)\n                {\n                    __cache->__upcast()->__value_ =\n                        _VSTD::move(__u.remove(__i++)->__value_);\n                    __next_pointer __next = __cache->__next_;\n                    __node_insert_multi(__cache->__upcast());\n                    __cache = __next;\n                }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n            }\n            catch (...)\n            {\n                __deallocate_node(__cache);\n                throw;\n            }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n            __deallocate_node(__cache);\n        }\n        const_iterator __i = __u.begin();\n        while (__u.size() != 0)\n        {\n            __node_holder __h = __construct_node(_NodeTypes::__move(__u.remove(__i++)->__value_));\n            __node_insert_multi(__h.get());\n            __h.release();\n        }\n    }\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\ninline\n__hash_table<_Tp, _Hash, _Equal, _Alloc>&\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::operator=(__hash_table&& __u)\n    _NOEXCEPT_(\n        __node_traits::propagate_on_container_move_assignment::value &&\n        is_nothrow_move_assignable<__node_allocator>::value &&\n        is_nothrow_move_assignable<hasher>::value &&\n        is_nothrow_move_assignable<key_equal>::value)\n{\n    __move_assign(__u, integral_constant<bool,\n                  __node_traits::propagate_on_container_move_assignment::value>());\n    return *this;\n}\n\n#endif  // _LIBCPP_CXX03_LANG\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\ntemplate <class _InputIterator>\nvoid\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::__assign_unique(_InputIterator __first,\n                                                          _InputIterator __last)\n{\n    typedef iterator_traits<_InputIterator> _ITraits;\n    typedef typename _ITraits::value_type _ItValueType;\n    static_assert((is_same<_ItValueType, __container_value_type>::value),\n                  \"__assign_unique may only be called with the containers value type\");\n\n    if (bucket_count() != 0)\n    {\n        __next_pointer __cache = __detach();\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        try\n        {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n            for (; __cache != nullptr && __first != __last; ++__first)\n            {\n                __cache->__upcast()->__value_ = *__first;\n                __next_pointer __next = __cache->__next_;\n                __node_insert_unique(__cache->__upcast());\n                __cache = __next;\n            }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        }\n        catch (...)\n        {\n            __deallocate_node(__cache);\n            throw;\n        }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        __deallocate_node(__cache);\n    }\n    for (; __first != __last; ++__first)\n        __insert_unique(*__first);\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\ntemplate <class _InputIterator>\nvoid\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::__assign_multi(_InputIterator __first,\n                                                         _InputIterator __last)\n{\n    typedef iterator_traits<_InputIterator> _ITraits;\n    typedef typename _ITraits::value_type _ItValueType;\n    static_assert((is_same<_ItValueType, __container_value_type>::value ||\n                  is_same<_ItValueType, __node_value_type>::value),\n                  \"__assign_multi may only be called with the containers value type\"\n                  \" or the nodes value type\");\n    if (bucket_count() != 0)\n    {\n        __next_pointer __cache = __detach();\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        try\n        {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n            for (; __cache != nullptr && __first != __last; ++__first)\n            {\n                __cache->__upcast()->__value_ = *__first;\n                __next_pointer __next = __cache->__next_;\n                __node_insert_multi(__cache->__upcast());\n                __cache = __next;\n            }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        }\n        catch (...)\n        {\n            __deallocate_node(__cache);\n            throw;\n        }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        __deallocate_node(__cache);\n    }\n    for (; __first != __last; ++__first)\n        __insert_multi(_NodeTypes::__get_value(*__first));\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\ninline\ntypename __hash_table<_Tp, _Hash, _Equal, _Alloc>::iterator\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::begin() _NOEXCEPT\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    return iterator(__p1_.first().__next_, this);\n#else\n    return iterator(__p1_.first().__next_);\n#endif\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\ninline\ntypename __hash_table<_Tp, _Hash, _Equal, _Alloc>::iterator\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::end() _NOEXCEPT\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    return iterator(nullptr, this);\n#else\n    return iterator(nullptr);\n#endif\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\ninline\ntypename __hash_table<_Tp, _Hash, _Equal, _Alloc>::const_iterator\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::begin() const _NOEXCEPT\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    return const_iterator(__p1_.first().__next_, this);\n#else\n    return const_iterator(__p1_.first().__next_);\n#endif\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\ninline\ntypename __hash_table<_Tp, _Hash, _Equal, _Alloc>::const_iterator\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::end() const _NOEXCEPT\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    return const_iterator(nullptr, this);\n#else\n    return const_iterator(nullptr);\n#endif\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\nvoid\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::clear() _NOEXCEPT\n{\n    if (size() > 0)\n    {\n        __deallocate_node(__p1_.first().__next_);\n        __p1_.first().__next_ = nullptr;\n        size_type __bc = bucket_count();\n        for (size_type __i = 0; __i < __bc; ++__i)\n            __bucket_list_[__i] = nullptr;\n        size() = 0;\n    }\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\npair<typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::iterator, bool>\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::__node_insert_unique(__node_pointer __nd)\n{\n    __nd->__hash_ = hash_function()(__nd->__value_);\n    size_type __bc = bucket_count();\n    bool __inserted = false;\n    __next_pointer __ndptr;\n    size_t __chash;\n    if (__bc != 0)\n    {\n        __chash = __constrain_hash(__nd->__hash_, __bc);\n        __ndptr = __bucket_list_[__chash];\n        if (__ndptr != nullptr)\n        {\n            for (__ndptr = __ndptr->__next_; __ndptr != nullptr &&\n                                             __constrain_hash(__ndptr->__hash(), __bc) == __chash;\n                                                     __ndptr = __ndptr->__next_)\n            {\n                if (key_eq()(__ndptr->__upcast()->__value_, __nd->__value_))\n                    goto __done;\n            }\n        }\n    }\n    {\n        if (size()+1 > __bc * max_load_factor() || __bc == 0)\n        {\n            rehash(_VSTD::max<size_type>(2 * __bc + !__is_hash_power2(__bc),\n                           size_type(ceil(float(size() + 1) / max_load_factor()))));\n            __bc = bucket_count();\n            __chash = __constrain_hash(__nd->__hash_, __bc);\n        }\n        // insert_after __bucket_list_[__chash], or __first_node if bucket is null\n        __next_pointer __pn = __bucket_list_[__chash];\n        if (__pn == nullptr)\n        {\n            __pn =__p1_.first().__ptr();\n            __nd->__next_ = __pn->__next_;\n            __pn->__next_ = __nd->__ptr();\n            // fix up __bucket_list_\n            __bucket_list_[__chash] = __pn;\n            if (__nd->__next_ != nullptr)\n                __bucket_list_[__constrain_hash(__nd->__next_->__hash(), __bc)] = __nd->__ptr();\n        }\n        else\n        {\n            __nd->__next_ = __pn->__next_;\n            __pn->__next_ = __nd->__ptr();\n        }\n        __ndptr = __nd->__ptr();\n        // increment size\n        ++size();\n        __inserted = true;\n    }\n__done:\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    return pair<iterator, bool>(iterator(__ndptr, this), __inserted);\n#else\n    return pair<iterator, bool>(iterator(__ndptr), __inserted);\n#endif\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\ntypename __hash_table<_Tp, _Hash, _Equal, _Alloc>::iterator\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::__node_insert_multi(__node_pointer __cp)\n{\n    __cp->__hash_ = hash_function()(__cp->__value_);\n    size_type __bc = bucket_count();\n    if (size()+1 > __bc * max_load_factor() || __bc == 0)\n    {\n        rehash(_VSTD::max<size_type>(2 * __bc + !__is_hash_power2(__bc),\n                       size_type(ceil(float(size() + 1) / max_load_factor()))));\n        __bc = bucket_count();\n    }\n    size_t __chash = __constrain_hash(__cp->__hash_, __bc);\n    __next_pointer __pn = __bucket_list_[__chash];\n    if (__pn == nullptr)\n    {\n        __pn =__p1_.first().__ptr();\n        __cp->__next_ = __pn->__next_;\n        __pn->__next_ = __cp->__ptr();\n        // fix up __bucket_list_\n        __bucket_list_[__chash] = __pn;\n        if (__cp->__next_ != nullptr)\n            __bucket_list_[__constrain_hash(__cp->__next_->__hash(), __bc)]\n                = __cp->__ptr();\n    }\n    else\n    {\n        for (bool __found = false; __pn->__next_ != nullptr &&\n                                   __constrain_hash(__pn->__next_->__hash(), __bc) == __chash;\n                                                           __pn = __pn->__next_)\n        {\n            //      __found    key_eq()     action\n            //      false       false       loop\n            //      true        true        loop\n            //      false       true        set __found to true\n            //      true        false       break\n            if (__found != (__pn->__next_->__hash() == __cp->__hash_ &&\n                            key_eq()(__pn->__next_->__upcast()->__value_, __cp->__value_)))\n            {\n                if (!__found)\n                    __found = true;\n                else\n                    break;\n            }\n        }\n        __cp->__next_ = __pn->__next_;\n        __pn->__next_ = __cp->__ptr();\n        if (__cp->__next_ != nullptr)\n        {\n            size_t __nhash = __constrain_hash(__cp->__next_->__hash(), __bc);\n            if (__nhash != __chash)\n                __bucket_list_[__nhash] = __cp->__ptr();\n        }\n    }\n    ++size();\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    return iterator(__cp->__ptr(), this);\n#else\n    return iterator(__cp->__ptr());\n#endif\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\ntypename __hash_table<_Tp, _Hash, _Equal, _Alloc>::iterator\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::__node_insert_multi(\n        const_iterator __p, __node_pointer __cp)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__p) == this,\n        \"unordered container::emplace_hint(const_iterator, args...) called with an iterator not\"\n        \" referring to this unordered container\");\n#endif\n    if (__p != end() && key_eq()(*__p, __cp->__value_))\n    {\n        __next_pointer __np = __p.__node_;\n        __cp->__hash_ = __np->__hash();\n        size_type __bc = bucket_count();\n        if (size()+1 > __bc * max_load_factor() || __bc == 0)\n        {\n            rehash(_VSTD::max<size_type>(2 * __bc + !__is_hash_power2(__bc),\n                           size_type(ceil(float(size() + 1) / max_load_factor()))));\n            __bc = bucket_count();\n        }\n        size_t __chash = __constrain_hash(__cp->__hash_, __bc);\n        __next_pointer __pp = __bucket_list_[__chash];\n        while (__pp->__next_ != __np)\n            __pp = __pp->__next_;\n        __cp->__next_ = __np;\n        __pp->__next_ = static_cast<__next_pointer>(__cp);\n        ++size();\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        return iterator(static_cast<__next_pointer>(__cp), this);\n#else\n        return iterator(static_cast<__next_pointer>(__cp));\n#endif\n    }\n    return __node_insert_multi(__cp);\n}\n\n\n\n#ifndef _LIBCPP_CXX03_LANG\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\ntemplate <class _Key, class ..._Args>\npair<typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::iterator, bool>\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::__emplace_unique_key_args(_Key const& __k, _Args&&... __args)\n#else\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\ntemplate <class _Key, class _Args>\npair<typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::iterator, bool>\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::__emplace_unique_key_args(_Key const& __k, _Args& __args)\n#endif\n{\n\n    size_t __hash = hash_function()(__k);\n    size_type __bc = bucket_count();\n    bool __inserted = false;\n    __next_pointer __nd;\n    size_t __chash;\n    if (__bc != 0)\n    {\n        __chash = __constrain_hash(__hash, __bc);\n        __nd = __bucket_list_[__chash];\n        if (__nd != nullptr)\n        {\n            for (__nd = __nd->__next_; __nd != nullptr &&\n                (__nd->__hash() == __hash || __constrain_hash(__nd->__hash(), __bc) == __chash);\n                                                           __nd = __nd->__next_)\n            {\n                if (key_eq()(__nd->__upcast()->__value_, __k))\n                    goto __done;\n            }\n        }\n    }\n    {\n#ifndef _LIBCPP_CXX03_LANG\n        __node_holder __h = __construct_node_hash(__hash, _VSTD::forward<_Args>(__args)...);\n#else\n        __node_holder __h = __construct_node_hash(__hash, __args);\n#endif\n        if (size()+1 > __bc * max_load_factor() || __bc == 0)\n        {\n            rehash(_VSTD::max<size_type>(2 * __bc + !__is_hash_power2(__bc),\n                           size_type(ceil(float(size() + 1) / max_load_factor()))));\n            __bc = bucket_count();\n            __chash = __constrain_hash(__hash, __bc);\n        }\n        // insert_after __bucket_list_[__chash], or __first_node if bucket is null\n        __next_pointer __pn = __bucket_list_[__chash];\n        if (__pn == nullptr)\n        {\n            __pn = __p1_.first().__ptr();\n            __h->__next_ = __pn->__next_;\n            __pn->__next_ = __h.get()->__ptr();\n            // fix up __bucket_list_\n            __bucket_list_[__chash] = __pn;\n            if (__h->__next_ != nullptr)\n                __bucket_list_[__constrain_hash(__h->__next_->__hash(), __bc)]\n                    = __h.get()->__ptr();\n        }\n        else\n        {\n            __h->__next_ = __pn->__next_;\n            __pn->__next_ = static_cast<__next_pointer>(__h.get());\n        }\n        __nd = static_cast<__next_pointer>(__h.release());\n        // increment size\n        ++size();\n        __inserted = true;\n    }\n__done:\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    return pair<iterator, bool>(iterator(__nd, this), __inserted);\n#else\n    return pair<iterator, bool>(iterator(__nd), __inserted);\n#endif\n}\n\n#ifndef _LIBCPP_CXX03_LANG\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\ntemplate <class... _Args>\npair<typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::iterator, bool>\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::__emplace_unique_impl(_Args&&... __args)\n{\n    __node_holder __h = __construct_node(_VSTD::forward<_Args>(__args)...);\n    pair<iterator, bool> __r = __node_insert_unique(__h.get());\n    if (__r.second)\n        __h.release();\n    return __r;\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\ntemplate <class... _Args>\ntypename __hash_table<_Tp, _Hash, _Equal, _Alloc>::iterator\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::__emplace_multi(_Args&&... __args)\n{\n    __node_holder __h = __construct_node(_VSTD::forward<_Args>(__args)...);\n    iterator __r = __node_insert_multi(__h.get());\n    __h.release();\n    return __r;\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\ntemplate <class... _Args>\ntypename __hash_table<_Tp, _Hash, _Equal, _Alloc>::iterator\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::__emplace_hint_multi(\n        const_iterator __p, _Args&&... __args)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__p) == this,\n        \"unordered container::emplace_hint(const_iterator, args...) called with an iterator not\"\n        \" referring to this unordered container\");\n#endif\n    __node_holder __h = __construct_node(_VSTD::forward<_Args>(__args)...);\n    iterator __r = __node_insert_multi(__p, __h.get());\n    __h.release();\n    return __r;\n}\n\n#else // _LIBCPP_CXX03_LANG\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\ntypename __hash_table<_Tp, _Hash, _Equal, _Alloc>::iterator\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::__insert_multi(const __container_value_type& __x)\n{\n    __node_holder __h = __construct_node(__x);\n    iterator __r = __node_insert_multi(__h.get());\n    __h.release();\n    return __r;\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\ntypename __hash_table<_Tp, _Hash, _Equal, _Alloc>::iterator\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::__insert_multi(const_iterator __p,\n                                                         const __container_value_type& __x)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__p) == this,\n        \"unordered container::insert(const_iterator, lvalue) called with an iterator not\"\n        \" referring to this unordered container\");\n#endif\n    __node_holder __h = __construct_node(__x);\n    iterator __r = __node_insert_multi(__p, __h.get());\n    __h.release();\n    return __r;\n}\n\n#endif  // _LIBCPP_CXX03_LANG\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\nvoid\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::rehash(size_type __n)\n{\n    if (__n == 1)\n        __n = 2;\n    else if (__n & (__n - 1))\n        __n = __next_prime(__n);\n    size_type __bc = bucket_count();\n    if (__n > __bc)\n        __rehash(__n);\n    else if (__n < __bc)\n    {\n        __n = _VSTD::max<size_type>\n              (\n                  __n,\n                  __is_hash_power2(__bc) ? __next_hash_pow2(size_t(ceil(float(size()) / max_load_factor()))) :\n                                           __next_prime(size_t(ceil(float(size()) / max_load_factor())))\n              );\n        if (__n < __bc)\n            __rehash(__n);\n    }\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\nvoid\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::__rehash(size_type __nbc)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__invalidate_all(this);\n#endif  // _LIBCPP_DEBUG_LEVEL >= 2\n    __pointer_allocator& __npa = __bucket_list_.get_deleter().__alloc();\n    __bucket_list_.reset(__nbc > 0 ?\n                      __pointer_alloc_traits::allocate(__npa, __nbc) : nullptr);\n    __bucket_list_.get_deleter().size() = __nbc;\n    if (__nbc > 0)\n    {\n        for (size_type __i = 0; __i < __nbc; ++__i)\n            __bucket_list_[__i] = nullptr;\n        __next_pointer __pp = __p1_.first().__ptr();\n        __next_pointer __cp = __pp->__next_;\n        if (__cp != nullptr)\n        {\n            size_type __chash = __constrain_hash(__cp->__hash(), __nbc);\n            __bucket_list_[__chash] = __pp;\n            size_type __phash = __chash;\n            for (__pp = __cp, __cp = __cp->__next_; __cp != nullptr;\n                                                           __cp = __pp->__next_)\n            {\n                __chash = __constrain_hash(__cp->__hash(), __nbc);\n                if (__chash == __phash)\n                    __pp = __cp;\n                else\n                {\n                    if (__bucket_list_[__chash] == nullptr)\n                    {\n                        __bucket_list_[__chash] = __pp;\n                        __pp = __cp;\n                        __phash = __chash;\n                    }\n                    else\n                    {\n                        __next_pointer __np = __cp;\n                        for (; __np->__next_ != nullptr &&\n                               key_eq()(__cp->__upcast()->__value_,\n                                        __np->__next_->__upcast()->__value_);\n                                                           __np = __np->__next_)\n                            ;\n                        __pp->__next_ = __np->__next_;\n                        __np->__next_ = __bucket_list_[__chash]->__next_;\n                        __bucket_list_[__chash]->__next_ = __cp;\n\n                    }\n                }\n            }\n        }\n    }\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\ntemplate <class _Key>\ntypename __hash_table<_Tp, _Hash, _Equal, _Alloc>::iterator\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::find(const _Key& __k)\n{\n    size_t __hash = hash_function()(__k);\n    size_type __bc = bucket_count();\n    if (__bc != 0)\n    {\n        size_t __chash = __constrain_hash(__hash, __bc);\n        __next_pointer __nd = __bucket_list_[__chash];\n        if (__nd != nullptr)\n        {\n            for (__nd = __nd->__next_; __nd != nullptr &&\n                (__nd->__hash() == __hash\n                  || __constrain_hash(__nd->__hash(), __bc) == __chash);\n                                                           __nd = __nd->__next_)\n            {\n                if ((__nd->__hash() == __hash)\n                    && key_eq()(__nd->__upcast()->__value_, __k))\n#if _LIBCPP_DEBUG_LEVEL >= 2\n                    return iterator(__nd, this);\n#else\n                    return iterator(__nd);\n#endif\n            }\n        }\n    }\n    return end();\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\ntemplate <class _Key>\ntypename __hash_table<_Tp, _Hash, _Equal, _Alloc>::const_iterator\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::find(const _Key& __k) const\n{\n    size_t __hash = hash_function()(__k);\n    size_type __bc = bucket_count();\n    if (__bc != 0)\n    {\n        size_t __chash = __constrain_hash(__hash, __bc);\n        __next_pointer __nd = __bucket_list_[__chash];\n        if (__nd != nullptr)\n        {\n            for (__nd = __nd->__next_; __nd != nullptr &&\n                (__hash == __nd->__hash()\n                    || __constrain_hash(__nd->__hash(), __bc) == __chash);\n                                                           __nd = __nd->__next_)\n            {\n                if ((__nd->__hash() == __hash)\n                    && key_eq()(__nd->__upcast()->__value_, __k))\n#if _LIBCPP_DEBUG_LEVEL >= 2\n                    return const_iterator(__nd, this);\n#else\n                    return const_iterator(__nd);\n#endif\n            }\n        }\n\n    }\n    return end();\n}\n\n#ifndef _LIBCPP_CXX03_LANG\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\ntemplate <class ..._Args>\ntypename __hash_table<_Tp, _Hash, _Equal, _Alloc>::__node_holder\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::__construct_node(_Args&& ...__args)\n{\n    static_assert(!__is_hash_value_type<_Args...>::value,\n                  \"Construct cannot be called with a hash value type\");\n    __node_allocator& __na = __node_alloc();\n    __node_holder __h(__node_traits::allocate(__na, 1), _Dp(__na));\n    __node_traits::construct(__na, _NodeTypes::__get_ptr(__h->__value_), _VSTD::forward<_Args>(__args)...);\n    __h.get_deleter().__value_constructed = true;\n    __h->__hash_ = hash_function()(__h->__value_);\n    __h->__next_ = nullptr;\n    return __h;\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\ntemplate <class _First, class ..._Rest>\ntypename __hash_table<_Tp, _Hash, _Equal, _Alloc>::__node_holder\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::__construct_node_hash(\n    size_t __hash, _First&& __f, _Rest&& ...__rest)\n{\n    static_assert(!__is_hash_value_type<_First, _Rest...>::value,\n                  \"Construct cannot be called with a hash value type\");\n    __node_allocator& __na = __node_alloc();\n    __node_holder __h(__node_traits::allocate(__na, 1), _Dp(__na));\n    __node_traits::construct(__na, _NodeTypes::__get_ptr(__h->__value_),\n                             _VSTD::forward<_First>(__f),\n                             _VSTD::forward<_Rest>(__rest)...);\n    __h.get_deleter().__value_constructed = true;\n    __h->__hash_ = __hash;\n    __h->__next_ = nullptr;\n    return __h;\n}\n\n#else  // _LIBCPP_CXX03_LANG\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\ntypename __hash_table<_Tp, _Hash, _Equal, _Alloc>::__node_holder\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::__construct_node(const __container_value_type& __v)\n{\n    __node_allocator& __na = __node_alloc();\n    __node_holder __h(__node_traits::allocate(__na, 1), _Dp(__na));\n    __node_traits::construct(__na, _NodeTypes::__get_ptr(__h->__value_), __v);\n    __h.get_deleter().__value_constructed = true;\n    __h->__hash_ = hash_function()(__h->__value_);\n    __h->__next_ = nullptr;\n    return _LIBCPP_EXPLICIT_MOVE(__h);  // explicitly moved for C++03\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\ntypename __hash_table<_Tp, _Hash, _Equal, _Alloc>::__node_holder\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::__construct_node_hash(size_t __hash,\n                                                                const __container_value_type& __v)\n{\n    __node_allocator& __na = __node_alloc();\n    __node_holder __h(__node_traits::allocate(__na, 1), _Dp(__na));\n    __node_traits::construct(__na, _NodeTypes::__get_ptr(__h->__value_), __v);\n    __h.get_deleter().__value_constructed = true;\n    __h->__hash_ = __hash;\n    __h->__next_ = nullptr;\n    return _LIBCPP_EXPLICIT_MOVE(__h);  // explicitly moved for C++03\n}\n\n#endif  // _LIBCPP_CXX03_LANG\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\ntypename __hash_table<_Tp, _Hash, _Equal, _Alloc>::iterator\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::erase(const_iterator __p)\n{\n    __next_pointer __np = __p.__node_;\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__p) == this,\n        \"unordered container erase(iterator) called with an iterator not\"\n        \" referring to this container\");\n    _LIBCPP_ASSERT(__p != end(),\n        \"unordered container erase(iterator) called with a non-dereferenceable iterator\");\n    iterator __r(__np, this);\n#else\n    iterator __r(__np);\n#endif\n    ++__r;\n    remove(__p);\n    return __r;\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\ntypename __hash_table<_Tp, _Hash, _Equal, _Alloc>::iterator\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::erase(const_iterator __first,\n                                                const_iterator __last)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__first) == this,\n        \"unodered container::erase(iterator, iterator) called with an iterator not\"\n        \" referring to this unodered container\");\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__last) == this,\n        \"unodered container::erase(iterator, iterator) called with an iterator not\"\n        \" referring to this unodered container\");\n#endif\n    for (const_iterator __p = __first; __first != __last; __p = __first)\n    {\n        ++__first;\n        erase(__p);\n    }\n    __next_pointer __np = __last.__node_;\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    return iterator (__np, this);\n#else\n    return iterator (__np);\n#endif\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\ntemplate <class _Key>\ntypename __hash_table<_Tp, _Hash, _Equal, _Alloc>::size_type\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::__erase_unique(const _Key& __k)\n{\n    iterator __i = find(__k);\n    if (__i == end())\n        return 0;\n    erase(__i);\n    return 1;\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\ntemplate <class _Key>\ntypename __hash_table<_Tp, _Hash, _Equal, _Alloc>::size_type\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::__erase_multi(const _Key& __k)\n{\n    size_type __r = 0;\n    iterator __i = find(__k);\n    if (__i != end())\n    {\n        iterator __e = end();\n        do\n        {\n            erase(__i++);\n            ++__r;\n        } while (__i != __e && key_eq()(*__i, __k));\n    }\n    return __r;\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\ntypename __hash_table<_Tp, _Hash, _Equal, _Alloc>::__node_holder\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::remove(const_iterator __p) _NOEXCEPT\n{\n    // current node\n    __next_pointer __cn = __p.__node_;\n    size_type __bc = bucket_count();\n    size_t __chash = __constrain_hash(__cn->__hash(), __bc);\n    // find previous node\n    __next_pointer __pn = __bucket_list_[__chash];\n    for (; __pn->__next_ != __cn; __pn = __pn->__next_)\n        ;\n    // Fix up __bucket_list_\n        // if __pn is not in same bucket (before begin is not in same bucket) &&\n        //    if __cn->__next_ is not in same bucket (nullptr is not in same bucket)\n    if (__pn == __p1_.first().__ptr()\n            || __constrain_hash(__pn->__hash(), __bc) != __chash)\n    {\n        if (__cn->__next_ == nullptr\n            || __constrain_hash(__cn->__next_->__hash(), __bc) != __chash)\n            __bucket_list_[__chash] = nullptr;\n    }\n        // if __cn->__next_ is not in same bucket (nullptr is in same bucket)\n    if (__cn->__next_ != nullptr)\n    {\n        size_t __nhash = __constrain_hash(__cn->__next_->__hash(), __bc);\n        if (__nhash != __chash)\n            __bucket_list_[__nhash] = __pn;\n    }\n    // remove __cn\n    __pn->__next_ = __cn->__next_;\n    __cn->__next_ = nullptr;\n    --size();\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __c_node* __c = __get_db()->__find_c_and_lock(this);\n    for (__i_node** __dp = __c->end_; __dp != __c->beg_; )\n    {\n        --__dp;\n        iterator* __i = static_cast<iterator*>((*__dp)->__i_);\n        if (__i->__node_ == __cn)\n        {\n            (*__dp)->__c_ = nullptr;\n            if (--__c->end_ != __dp)\n                memmove(__dp, __dp+1, (__c->end_ - __dp)*sizeof(__i_node*));\n        }\n    }\n    __get_db()->unlock();\n#endif\n    return __node_holder(__cn->__upcast(), _Dp(__node_alloc(), true));\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\ntemplate <class _Key>\ninline\ntypename __hash_table<_Tp, _Hash, _Equal, _Alloc>::size_type\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::__count_unique(const _Key& __k) const\n{\n    return static_cast<size_type>(find(__k) != end());\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\ntemplate <class _Key>\ntypename __hash_table<_Tp, _Hash, _Equal, _Alloc>::size_type\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::__count_multi(const _Key& __k) const\n{\n    size_type __r = 0;\n    const_iterator __i = find(__k);\n    if (__i != end())\n    {\n        const_iterator __e = end();\n        do\n        {\n            ++__i;\n            ++__r;\n        } while (__i != __e && key_eq()(*__i, __k));\n    }\n    return __r;\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\ntemplate <class _Key>\npair<typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::iterator,\n     typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::iterator>\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::__equal_range_unique(\n        const _Key& __k)\n{\n    iterator __i = find(__k);\n    iterator __j = __i;\n    if (__i != end())\n        ++__j;\n    return pair<iterator, iterator>(__i, __j);\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\ntemplate <class _Key>\npair<typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::const_iterator,\n     typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::const_iterator>\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::__equal_range_unique(\n        const _Key& __k) const\n{\n    const_iterator __i = find(__k);\n    const_iterator __j = __i;\n    if (__i != end())\n        ++__j;\n    return pair<const_iterator, const_iterator>(__i, __j);\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\ntemplate <class _Key>\npair<typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::iterator,\n     typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::iterator>\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::__equal_range_multi(\n        const _Key& __k)\n{\n    iterator __i = find(__k);\n    iterator __j = __i;\n    if (__i != end())\n    {\n        iterator __e = end();\n        do\n        {\n            ++__j;\n        } while (__j != __e && key_eq()(*__j, __k));\n    }\n    return pair<iterator, iterator>(__i, __j);\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\ntemplate <class _Key>\npair<typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::const_iterator,\n     typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::const_iterator>\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::__equal_range_multi(\n        const _Key& __k) const\n{\n    const_iterator __i = find(__k);\n    const_iterator __j = __i;\n    if (__i != end())\n    {\n        const_iterator __e = end();\n        do\n        {\n            ++__j;\n        } while (__j != __e && key_eq()(*__j, __k));\n    }\n    return pair<const_iterator, const_iterator>(__i, __j);\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\nvoid\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::swap(__hash_table& __u)\n#if _LIBCPP_STD_VER <= 11\n    _NOEXCEPT_DEBUG_(\n        __is_nothrow_swappable<hasher>::value && __is_nothrow_swappable<key_equal>::value\n        && (!allocator_traits<__pointer_allocator>::propagate_on_container_swap::value\n              || __is_nothrow_swappable<__pointer_allocator>::value)\n        && (!__node_traits::propagate_on_container_swap::value\n              || __is_nothrow_swappable<__node_allocator>::value)\n            )\n#else\n  _NOEXCEPT_DEBUG_(__is_nothrow_swappable<hasher>::value && __is_nothrow_swappable<key_equal>::value)\n#endif\n{\n    _LIBCPP_ASSERT(__node_traits::propagate_on_container_swap::value ||\n                   this->__node_alloc() == __u.__node_alloc(),\n                   \"list::swap: Either propagate_on_container_swap must be true\"\n                   \" or the allocators must compare equal\");\n    {\n    __node_pointer_pointer __npp = __bucket_list_.release();\n    __bucket_list_.reset(__u.__bucket_list_.release());\n    __u.__bucket_list_.reset(__npp);\n    }\n    _VSTD::swap(__bucket_list_.get_deleter().size(), __u.__bucket_list_.get_deleter().size());\n    __swap_allocator(__bucket_list_.get_deleter().__alloc(),\n             __u.__bucket_list_.get_deleter().__alloc());\n    __swap_allocator(__node_alloc(), __u.__node_alloc());\n    _VSTD::swap(__p1_.first().__next_, __u.__p1_.first().__next_);\n    __p2_.swap(__u.__p2_);\n    __p3_.swap(__u.__p3_);\n    if (size() > 0)\n        __bucket_list_[__constrain_hash(__p1_.first().__next_->__hash(), bucket_count())] =\n            __p1_.first().__ptr();\n    if (__u.size() > 0)\n        __u.__bucket_list_[__constrain_hash(__u.__p1_.first().__next_->__hash(), __u.bucket_count())] =\n            __u.__p1_.first().__ptr();\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->swap(this, &__u);\n#endif\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\ntypename __hash_table<_Tp, _Hash, _Equal, _Alloc>::size_type\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::bucket_size(size_type __n) const\n{\n    _LIBCPP_ASSERT(__n < bucket_count(),\n        \"unordered container::bucket_size(n) called with n >= bucket_count()\");\n    __next_pointer __np = __bucket_list_[__n];\n    size_type __bc = bucket_count();\n    size_type __r = 0;\n    if (__np != nullptr)\n    {\n        for (__np = __np->__next_; __np != nullptr &&\n                                   __constrain_hash(__np->__hash(), __bc) == __n;\n                                                    __np = __np->__next_, ++__r)\n            ;\n    }\n    return __r;\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(__hash_table<_Tp, _Hash, _Equal, _Alloc>& __x,\n     __hash_table<_Tp, _Hash, _Equal, _Alloc>& __y)\n    _NOEXCEPT_(_NOEXCEPT_(__x.swap(__y)))\n{\n    __x.swap(__y);\n}\n\n#if _LIBCPP_DEBUG_LEVEL >= 2\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\nbool\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::__dereferenceable(const const_iterator* __i) const\n{\n    return __i->__node_ != nullptr;\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\nbool\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::__decrementable(const const_iterator*) const\n{\n    return false;\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\nbool\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::__addable(const const_iterator*, ptrdiff_t) const\n{\n    return false;\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\nbool\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::__subscriptable(const const_iterator*, ptrdiff_t) const\n{\n    return false;\n}\n\n#endif  // _LIBCPP_DEBUG_LEVEL >= 2\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP__HASH_TABLE\n","// -*- C++ -*-\n//===------------------------ functional ----------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_FUNCTIONAL\n#define _LIBCPP_FUNCTIONAL\n\n/*\n    functional synopsis\n\nnamespace std\n{\n\ntemplate <class Arg, class Result>\nstruct unary_function\n{\n    typedef Arg    argument_type;\n    typedef Result result_type;\n};\n\ntemplate <class Arg1, class Arg2, class Result>\nstruct binary_function\n{\n    typedef Arg1   first_argument_type;\n    typedef Arg2   second_argument_type;\n    typedef Result result_type;\n};\n\ntemplate <class T>\nclass reference_wrapper\n    : public unary_function<T1, R> // if wrapping a unary functor\n    : public binary_function<T1, T2, R> // if wraping a binary functor\n{\npublic:\n    // types\n    typedef T type;\n    typedef see below result_type; // Not always defined\n\n    // construct/copy/destroy\n    reference_wrapper(T&) noexcept;\n    reference_wrapper(T&&) = delete; // do not bind to temps\n    reference_wrapper(const reference_wrapper<T>& x) noexcept;\n\n    // assignment\n    reference_wrapper& operator=(const reference_wrapper<T>& x) noexcept;\n\n    // access\n    operator T& () const noexcept;\n    T& get() const noexcept;\n\n    // invoke\n    template <class... ArgTypes>\n      typename result_of<T&(ArgTypes&&...)>::type\n          operator() (ArgTypes&&...) const;\n};\n\ntemplate <class T> reference_wrapper<T> ref(T& t) noexcept;\ntemplate <class T> void ref(const T&& t) = delete;\ntemplate <class T> reference_wrapper<T> ref(reference_wrapper<T>t) noexcept;\n\ntemplate <class T> reference_wrapper<const T> cref(const T& t) noexcept;\ntemplate <class T> void cref(const T&& t) = delete;\ntemplate <class T> reference_wrapper<const T> cref(reference_wrapper<T> t) noexcept;\n\ntemplate <class T> // <class T=void> in C++14\nstruct plus : binary_function<T, T, T>\n{\n    T operator()(const T& x, const T& y) const;\n};\n\ntemplate <class T> // <class T=void> in C++14\nstruct minus : binary_function<T, T, T>\n{\n    T operator()(const T& x, const T& y) const;\n};\n\ntemplate <class T> // <class T=void> in C++14\nstruct multiplies : binary_function<T, T, T>\n{\n    T operator()(const T& x, const T& y) const;\n};\n\ntemplate <class T> // <class T=void> in C++14\nstruct divides : binary_function<T, T, T>\n{\n    T operator()(const T& x, const T& y) const;\n};\n\ntemplate <class T> // <class T=void> in C++14\nstruct modulus : binary_function<T, T, T>\n{\n    T operator()(const T& x, const T& y) const;\n};\n\ntemplate <class T> // <class T=void> in C++14\nstruct negate : unary_function<T, T>\n{\n    T operator()(const T& x) const;\n};\n\ntemplate <class T> // <class T=void> in C++14\nstruct equal_to : binary_function<T, T, bool>\n{\n    bool operator()(const T& x, const T& y) const;\n};\n\ntemplate <class T> // <class T=void> in C++14\nstruct not_equal_to : binary_function<T, T, bool>\n{\n    bool operator()(const T& x, const T& y) const;\n};\n\ntemplate <class T> // <class T=void> in C++14\nstruct greater : binary_function<T, T, bool>\n{\n    bool operator()(const T& x, const T& y) const;\n};\n\ntemplate <class T> // <class T=void> in C++14\nstruct less : binary_function<T, T, bool>\n{\n    bool operator()(const T& x, const T& y) const;\n};\n\ntemplate <class T> // <class T=void> in C++14\nstruct greater_equal : binary_function<T, T, bool>\n{\n    bool operator()(const T& x, const T& y) const;\n};\n\ntemplate <class T> // <class T=void> in C++14\nstruct less_equal : binary_function<T, T, bool>\n{\n    bool operator()(const T& x, const T& y) const;\n};\n\ntemplate <class T> // <class T=void> in C++14\nstruct logical_and : binary_function<T, T, bool>\n{\n    bool operator()(const T& x, const T& y) const;\n};\n\ntemplate <class T> // <class T=void> in C++14\nstruct logical_or : binary_function<T, T, bool>\n{\n    bool operator()(const T& x, const T& y) const;\n};\n\ntemplate <class T> // <class T=void> in C++14\nstruct logical_not : unary_function<T, bool>\n{\n    bool operator()(const T& x) const;\n};\n\ntemplate <class T> // <class T=void> in C++14\nstruct bit_and : unary_function<T, bool>\n{\n    bool operator()(const T& x, const T& y) const;\n};\n\ntemplate <class T> // <class T=void> in C++14\nstruct bit_or : unary_function<T, bool>\n{\n    bool operator()(const T& x, const T& y) const;\n};\n\ntemplate <class T> // <class T=void> in C++14\nstruct bit_xor : unary_function<T, bool>\n{\n    bool operator()(const T& x, const T& y) const;\n};\n\ntemplate <class T=void> // C++14\nstruct bit_xor : unary_function<T, bool>\n{\n    bool operator()(const T& x) const;\n};\n\ntemplate <class Predicate>\nclass unary_negate\n    : public unary_function<typename Predicate::argument_type, bool>\n{\npublic:\n    explicit unary_negate(const Predicate& pred);\n    bool operator()(const typename Predicate::argument_type& x) const;\n};\n\ntemplate <class Predicate> unary_negate<Predicate> not1(const Predicate& pred);\n\ntemplate <class Predicate>\nclass binary_negate\n    : public binary_function<typename Predicate::first_argument_type,\n                             typename Predicate::second_argument_type,\n                             bool>\n{\npublic:\n    explicit binary_negate(const Predicate& pred);\n    bool operator()(const typename Predicate::first_argument_type& x,\n                    const typename Predicate::second_argument_type& y) const;\n};\n\ntemplate <class Predicate> binary_negate<Predicate> not2(const Predicate& pred);\n\ntemplate <class F> unspecified not_fn(F&& f); // C++17\n\ntemplate<class T> struct is_bind_expression;\ntemplate<class T> struct is_placeholder;\n\n    // See C++14 20.9.9, Function object binders\ntemplate <class T> constexpr bool is_bind_expression_v\n  = is_bind_expression<T>::value; // C++17\ntemplate <class T> constexpr int is_placeholder_v\n  = is_placeholder<T>::value; // C++17\n\n\ntemplate<class Fn, class... BoundArgs>\n  unspecified bind(Fn&&, BoundArgs&&...);\ntemplate<class R, class Fn, class... BoundArgs>\n  unspecified bind(Fn&&, BoundArgs&&...);\n\nnamespace placeholders {\n  // M is the implementation-defined number of placeholders\n  extern unspecified _1;\n  extern unspecified _2;\n  .\n  .\n  .\n  extern unspecified _Mp;\n}\n\ntemplate <class Operation>\nclass binder1st\n    : public unary_function<typename Operation::second_argument_type,\n                            typename Operation::result_type>\n{\nprotected:\n    Operation                               op;\n    typename Operation::first_argument_type value;\npublic:\n    binder1st(const Operation& x, const typename Operation::first_argument_type y);\n    typename Operation::result_type operator()(      typename Operation::second_argument_type& x) const;\n    typename Operation::result_type operator()(const typename Operation::second_argument_type& x) const;\n};\n\ntemplate <class Operation, class T>\nbinder1st<Operation> bind1st(const Operation& op, const T& x);\n\ntemplate <class Operation>\nclass binder2nd\n    : public unary_function<typename Operation::first_argument_type,\n                            typename Operation::result_type>\n{\nprotected:\n    Operation                                op;\n    typename Operation::second_argument_type value;\npublic:\n    binder2nd(const Operation& x, const typename Operation::second_argument_type y);\n    typename Operation::result_type operator()(      typename Operation::first_argument_type& x) const;\n    typename Operation::result_type operator()(const typename Operation::first_argument_type& x) const;\n};\n\ntemplate <class Operation, class T>\nbinder2nd<Operation> bind2nd(const Operation& op, const T& x);\n\ntemplate <class Arg, class Result>\nclass pointer_to_unary_function : public unary_function<Arg, Result>\n{\npublic:\n    explicit pointer_to_unary_function(Result (*f)(Arg));\n    Result operator()(Arg x) const;\n};\n\ntemplate <class Arg, class Result>\npointer_to_unary_function<Arg,Result> ptr_fun(Result (*f)(Arg));\n\ntemplate <class Arg1, class Arg2, class Result>\nclass pointer_to_binary_function : public binary_function<Arg1, Arg2, Result>\n{\npublic:\n    explicit pointer_to_binary_function(Result (*f)(Arg1, Arg2));\n    Result operator()(Arg1 x, Arg2 y) const;\n};\n\ntemplate <class Arg1, class Arg2, class Result>\npointer_to_binary_function<Arg1,Arg2,Result> ptr_fun(Result (*f)(Arg1,Arg2));\n\ntemplate<class S, class T>\nclass mem_fun_t : public unary_function<T*, S>\n{\npublic:\n    explicit mem_fun_t(S (T::*p)());\n    S operator()(T* p) const;\n};\n\ntemplate<class S, class T, class A>\nclass mem_fun1_t : public binary_function<T*, A, S>\n{\npublic:\n    explicit mem_fun1_t(S (T::*p)(A));\n    S operator()(T* p, A x) const;\n};\n\ntemplate<class S, class T>          mem_fun_t<S,T>    mem_fun(S (T::*f)());\ntemplate<class S, class T, class A> mem_fun1_t<S,T,A> mem_fun(S (T::*f)(A));\n\ntemplate<class S, class T>\nclass mem_fun_ref_t : public unary_function<T, S>\n{\npublic:\n    explicit mem_fun_ref_t(S (T::*p)());\n    S operator()(T& p) const;\n};\n\ntemplate<class S, class T, class A>\nclass mem_fun1_ref_t : public binary_function<T, A, S>\n{\npublic:\n    explicit mem_fun1_ref_t(S (T::*p)(A));\n    S operator()(T& p, A x) const;\n};\n\ntemplate<class S, class T>          mem_fun_ref_t<S,T>    mem_fun_ref(S (T::*f)());\ntemplate<class S, class T, class A> mem_fun1_ref_t<S,T,A> mem_fun_ref(S (T::*f)(A));\n\ntemplate <class S, class T>\nclass const_mem_fun_t : public unary_function<const T*, S>\n{\npublic:\n    explicit const_mem_fun_t(S (T::*p)() const);\n    S operator()(const T* p) const;\n};\n\ntemplate <class S, class T, class A>\nclass const_mem_fun1_t : public binary_function<const T*, A, S>\n{\npublic:\n    explicit const_mem_fun1_t(S (T::*p)(A) const);\n    S operator()(const T* p, A x) const;\n};\n\ntemplate <class S, class T>          const_mem_fun_t<S,T>    mem_fun(S (T::*f)() const);\ntemplate <class S, class T, class A> const_mem_fun1_t<S,T,A> mem_fun(S (T::*f)(A) const);\n\ntemplate <class S, class T>\nclass const_mem_fun_ref_t : public unary_function<T, S>\n{\npublic:\n    explicit const_mem_fun_ref_t(S (T::*p)() const);\n    S operator()(const T& p) const;\n};\n\ntemplate <class S, class T, class A>\nclass const_mem_fun1_ref_t : public binary_function<T, A, S>\n{\npublic:\n    explicit const_mem_fun1_ref_t(S (T::*p)(A) const);\n    S operator()(const T& p, A x) const;\n};\n\ntemplate <class S, class T>          const_mem_fun_ref_t<S,T>    mem_fun_ref(S (T::*f)() const);\ntemplate <class S, class T, class A> const_mem_fun1_ref_t<S,T,A> mem_fun_ref(S (T::*f)(A) const);\n\ntemplate<class R, class T> unspecified mem_fn(R T::*);\n\nclass bad_function_call\n    : public exception\n{\n};\n\ntemplate<class> class function; // undefined\n\ntemplate<class R, class... ArgTypes>\nclass function<R(ArgTypes...)>\n  : public unary_function<T1, R>      // iff sizeof...(ArgTypes) == 1 and\n                                      // ArgTypes contains T1\n  : public binary_function<T1, T2, R> // iff sizeof...(ArgTypes) == 2 and\n                                      // ArgTypes contains T1 and T2\n{\npublic:\n    typedef R result_type;\n\n    // construct/copy/destroy:\n    function() noexcept;\n    function(nullptr_t) noexcept;\n    function(const function&);\n    function(function&&) noexcept;\n    template<class F>\n      function(F);\n    template<Allocator Alloc>\n      function(allocator_arg_t, const Alloc&) noexcept;            // removed in C++17\n    template<Allocator Alloc>\n      function(allocator_arg_t, const Alloc&, nullptr_t) noexcept; // removed in C++17\n    template<Allocator Alloc>\n      function(allocator_arg_t, const Alloc&, const function&);    // removed in C++17\n    template<Allocator Alloc>\n      function(allocator_arg_t, const Alloc&, function&&);         // removed in C++17\n    template<class F, Allocator Alloc>\n      function(allocator_arg_t, const Alloc&, F);                  // removed in C++17\n\n    function& operator=(const function&);\n    function& operator=(function&&) noexcept;\n    function& operator=(nullptr_t) noexcept;\n    template<class F>\n      function& operator=(F&&);\n    template<class F>\n      function& operator=(reference_wrapper<F>) noexcept;\n\n    ~function();\n\n    // function modifiers:\n    void swap(function&) noexcept;\n    template<class F, class Alloc>\n      void assign(F&&, const Alloc&);                 // Removed in C++17\n\n    // function capacity:\n    explicit operator bool() const noexcept;\n\n    // function invocation:\n    R operator()(ArgTypes...) const;\n\n    // function target access:\n    const std::type_info& target_type() const noexcept;\n    template <typename T>       T* target() noexcept;\n    template <typename T> const T* target() const noexcept;\n};\n\n// Null pointer comparisons:\ntemplate <class R, class ... ArgTypes>\n  bool operator==(const function<R(ArgTypes...)>&, nullptr_t) noexcept;\n\ntemplate <class R, class ... ArgTypes>\n  bool operator==(nullptr_t, const function<R(ArgTypes...)>&) noexcept;\n\ntemplate <class R, class ... ArgTypes>\n  bool operator!=(const function<R(ArgTypes...)>&, nullptr_t) noexcept;\n\ntemplate <class  R, class ... ArgTypes>\n  bool operator!=(nullptr_t, const function<R(ArgTypes...)>&) noexcept;\n\n// specialized algorithms:\ntemplate <class  R, class ... ArgTypes>\n  void swap(function<R(ArgTypes...)>&, function<R(ArgTypes...)>&) noexcept;\n\ntemplate <class T> struct hash;\n\ntemplate <> struct hash<bool>;\ntemplate <> struct hash<char>;\ntemplate <> struct hash<signed char>;\ntemplate <> struct hash<unsigned char>;\ntemplate <> struct hash<char16_t>;\ntemplate <> struct hash<char32_t>;\ntemplate <> struct hash<wchar_t>;\ntemplate <> struct hash<short>;\ntemplate <> struct hash<unsigned short>;\ntemplate <> struct hash<int>;\ntemplate <> struct hash<unsigned int>;\ntemplate <> struct hash<long>;\ntemplate <> struct hash<long long>;\ntemplate <> struct hash<unsigned long>;\ntemplate <> struct hash<unsigned long long>;\n\ntemplate <> struct hash<float>;\ntemplate <> struct hash<double>;\ntemplate <> struct hash<long double>;\n\ntemplate<class T> struct hash<T*>;\n\n}  // std\n\nPOLICY:  For non-variadic implementations, the number of arguments is limited\n         to 3.  It is hoped that the need for non-variadic implementations\n         will be minimal.\n\n*/\n\n#include <__config>\n#include <type_traits>\n#include <typeinfo>\n#include <exception>\n#include <memory>\n#include <tuple>\n\n#include <__functional_base>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp = void>\n#else\ntemplate <class _Tp>\n#endif\nstruct _LIBCPP_TEMPLATE_VIS plus : binary_function<_Tp, _Tp, _Tp>\n{\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    _Tp operator()(const _Tp& __x, const _Tp& __y) const\n        {return __x + __y;}\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <>\nstruct _LIBCPP_TEMPLATE_VIS plus<void>\n{\n    template <class _T1, class _T2>\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    auto operator()(_T1&& __t, _T2&& __u) const\n    _NOEXCEPT_(noexcept(_VSTD::forward<_T1>(__t) + _VSTD::forward<_T2>(__u)))\n    -> decltype        (_VSTD::forward<_T1>(__t) + _VSTD::forward<_T2>(__u))\n        { return        _VSTD::forward<_T1>(__t) + _VSTD::forward<_T2>(__u); }\n    typedef void is_transparent;\n};\n#endif\n\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp = void>\n#else\ntemplate <class _Tp>\n#endif\nstruct _LIBCPP_TEMPLATE_VIS minus : binary_function<_Tp, _Tp, _Tp>\n{\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    _Tp operator()(const _Tp& __x, const _Tp& __y) const\n        {return __x - __y;}\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <>\nstruct _LIBCPP_TEMPLATE_VIS minus<void>\n{\n    template <class _T1, class _T2>\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    auto operator()(_T1&& __t, _T2&& __u) const\n    _NOEXCEPT_(noexcept(_VSTD::forward<_T1>(__t) - _VSTD::forward<_T2>(__u)))\n    -> decltype        (_VSTD::forward<_T1>(__t) - _VSTD::forward<_T2>(__u))\n        { return        _VSTD::forward<_T1>(__t) - _VSTD::forward<_T2>(__u); }\n    typedef void is_transparent;\n};\n#endif\n\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp = void>\n#else\ntemplate <class _Tp>\n#endif\nstruct _LIBCPP_TEMPLATE_VIS multiplies : binary_function<_Tp, _Tp, _Tp>\n{\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    _Tp operator()(const _Tp& __x, const _Tp& __y) const\n        {return __x * __y;}\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <>\nstruct _LIBCPP_TEMPLATE_VIS multiplies<void>\n{\n    template <class _T1, class _T2>\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    auto operator()(_T1&& __t, _T2&& __u) const\n    _NOEXCEPT_(noexcept(_VSTD::forward<_T1>(__t) * _VSTD::forward<_T2>(__u)))\n    -> decltype        (_VSTD::forward<_T1>(__t) * _VSTD::forward<_T2>(__u))\n        { return        _VSTD::forward<_T1>(__t) * _VSTD::forward<_T2>(__u); }\n    typedef void is_transparent;\n};\n#endif\n\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp = void>\n#else\ntemplate <class _Tp>\n#endif\nstruct _LIBCPP_TEMPLATE_VIS divides : binary_function<_Tp, _Tp, _Tp>\n{\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    _Tp operator()(const _Tp& __x, const _Tp& __y) const\n        {return __x / __y;}\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <>\nstruct _LIBCPP_TEMPLATE_VIS divides<void>\n{\n    template <class _T1, class _T2>\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    auto operator()(_T1&& __t, _T2&& __u) const\n    _NOEXCEPT_(noexcept(_VSTD::forward<_T1>(__t) / _VSTD::forward<_T2>(__u)))\n    -> decltype        (_VSTD::forward<_T1>(__t) / _VSTD::forward<_T2>(__u))\n        { return        _VSTD::forward<_T1>(__t) / _VSTD::forward<_T2>(__u); }\n    typedef void is_transparent;\n};\n#endif\n\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp = void>\n#else\ntemplate <class _Tp>\n#endif\nstruct _LIBCPP_TEMPLATE_VIS modulus : binary_function<_Tp, _Tp, _Tp>\n{\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    _Tp operator()(const _Tp& __x, const _Tp& __y) const\n        {return __x % __y;}\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <>\nstruct _LIBCPP_TEMPLATE_VIS modulus<void>\n{\n    template <class _T1, class _T2>\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    auto operator()(_T1&& __t, _T2&& __u) const\n    _NOEXCEPT_(noexcept(_VSTD::forward<_T1>(__t) % _VSTD::forward<_T2>(__u)))\n    -> decltype        (_VSTD::forward<_T1>(__t) % _VSTD::forward<_T2>(__u))\n        { return        _VSTD::forward<_T1>(__t) % _VSTD::forward<_T2>(__u); }\n    typedef void is_transparent;\n};\n#endif\n\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp = void>\n#else\ntemplate <class _Tp>\n#endif\nstruct _LIBCPP_TEMPLATE_VIS negate : unary_function<_Tp, _Tp>\n{\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    _Tp operator()(const _Tp& __x) const\n        {return -__x;}\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <>\nstruct _LIBCPP_TEMPLATE_VIS negate<void>\n{\n    template <class _Tp>\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    auto operator()(_Tp&& __x) const\n    _NOEXCEPT_(noexcept(- _VSTD::forward<_Tp>(__x)))\n    -> decltype        (- _VSTD::forward<_Tp>(__x))\n        { return        - _VSTD::forward<_Tp>(__x); }\n    typedef void is_transparent;\n};\n#endif\n\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp = void>\n#else\ntemplate <class _Tp>\n#endif\nstruct _LIBCPP_TEMPLATE_VIS equal_to : binary_function<_Tp, _Tp, bool>\n{\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const _Tp& __x, const _Tp& __y) const\n        {return __x == __y;}\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <>\nstruct _LIBCPP_TEMPLATE_VIS equal_to<void>\n{\n    template <class _T1, class _T2>\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    auto operator()(_T1&& __t, _T2&& __u) const\n    _NOEXCEPT_(noexcept(_VSTD::forward<_T1>(__t) == _VSTD::forward<_T2>(__u)))\n    -> decltype        (_VSTD::forward<_T1>(__t) == _VSTD::forward<_T2>(__u))\n        { return        _VSTD::forward<_T1>(__t) == _VSTD::forward<_T2>(__u); }\n    typedef void is_transparent;\n};\n#endif\n\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp = void>\n#else\ntemplate <class _Tp>\n#endif\nstruct _LIBCPP_TEMPLATE_VIS not_equal_to : binary_function<_Tp, _Tp, bool>\n{\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const _Tp& __x, const _Tp& __y) const\n        {return __x != __y;}\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <>\nstruct _LIBCPP_TEMPLATE_VIS not_equal_to<void>\n{\n    template <class _T1, class _T2>\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    auto operator()(_T1&& __t, _T2&& __u) const\n    _NOEXCEPT_(noexcept(_VSTD::forward<_T1>(__t) != _VSTD::forward<_T2>(__u)))\n    -> decltype        (_VSTD::forward<_T1>(__t) != _VSTD::forward<_T2>(__u))\n        { return        _VSTD::forward<_T1>(__t) != _VSTD::forward<_T2>(__u); }\n    typedef void is_transparent;\n};\n#endif\n\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp = void>\n#else\ntemplate <class _Tp>\n#endif\nstruct _LIBCPP_TEMPLATE_VIS greater : binary_function<_Tp, _Tp, bool>\n{\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const _Tp& __x, const _Tp& __y) const\n        {return __x > __y;}\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <>\nstruct _LIBCPP_TEMPLATE_VIS greater<void>\n{\n    template <class _T1, class _T2>\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    auto operator()(_T1&& __t, _T2&& __u) const\n    _NOEXCEPT_(noexcept(_VSTD::forward<_T1>(__t) > _VSTD::forward<_T2>(__u)))\n    -> decltype        (_VSTD::forward<_T1>(__t) > _VSTD::forward<_T2>(__u))\n        { return        _VSTD::forward<_T1>(__t) > _VSTD::forward<_T2>(__u); }\n    typedef void is_transparent;\n};\n#endif\n\n\n// less in <__functional_base>\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp = void>\n#else\ntemplate <class _Tp>\n#endif\nstruct _LIBCPP_TEMPLATE_VIS greater_equal : binary_function<_Tp, _Tp, bool>\n{\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const _Tp& __x, const _Tp& __y) const\n        {return __x >= __y;}\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <>\nstruct _LIBCPP_TEMPLATE_VIS greater_equal<void>\n{\n    template <class _T1, class _T2>\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    auto operator()(_T1&& __t, _T2&& __u) const\n    _NOEXCEPT_(noexcept(_VSTD::forward<_T1>(__t) >= _VSTD::forward<_T2>(__u)))\n    -> decltype        (_VSTD::forward<_T1>(__t) >= _VSTD::forward<_T2>(__u))\n        { return        _VSTD::forward<_T1>(__t) >= _VSTD::forward<_T2>(__u); }\n    typedef void is_transparent;\n};\n#endif\n\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp = void>\n#else\ntemplate <class _Tp>\n#endif\nstruct _LIBCPP_TEMPLATE_VIS less_equal : binary_function<_Tp, _Tp, bool>\n{\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const _Tp& __x, const _Tp& __y) const\n        {return __x <= __y;}\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <>\nstruct _LIBCPP_TEMPLATE_VIS less_equal<void>\n{\n    template <class _T1, class _T2>\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    auto operator()(_T1&& __t, _T2&& __u) const\n    _NOEXCEPT_(noexcept(_VSTD::forward<_T1>(__t) <= _VSTD::forward<_T2>(__u)))\n    -> decltype        (_VSTD::forward<_T1>(__t) <= _VSTD::forward<_T2>(__u))\n        { return        _VSTD::forward<_T1>(__t) <= _VSTD::forward<_T2>(__u); }\n    typedef void is_transparent;\n};\n#endif\n\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp = void>\n#else\ntemplate <class _Tp>\n#endif\nstruct _LIBCPP_TEMPLATE_VIS logical_and : binary_function<_Tp, _Tp, bool>\n{\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const _Tp& __x, const _Tp& __y) const\n        {return __x && __y;}\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <>\nstruct _LIBCPP_TEMPLATE_VIS logical_and<void>\n{\n    template <class _T1, class _T2>\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    auto operator()(_T1&& __t, _T2&& __u) const\n    _NOEXCEPT_(noexcept(_VSTD::forward<_T1>(__t) && _VSTD::forward<_T2>(__u)))\n    -> decltype        (_VSTD::forward<_T1>(__t) && _VSTD::forward<_T2>(__u))\n        { return        _VSTD::forward<_T1>(__t) && _VSTD::forward<_T2>(__u); }\n    typedef void is_transparent;\n};\n#endif\n\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp = void>\n#else\ntemplate <class _Tp>\n#endif\nstruct _LIBCPP_TEMPLATE_VIS logical_or : binary_function<_Tp, _Tp, bool>\n{\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const _Tp& __x, const _Tp& __y) const\n        {return __x || __y;}\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <>\nstruct _LIBCPP_TEMPLATE_VIS logical_or<void>\n{\n    template <class _T1, class _T2>\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    auto operator()(_T1&& __t, _T2&& __u) const\n    _NOEXCEPT_(noexcept(_VSTD::forward<_T1>(__t) || _VSTD::forward<_T2>(__u)))\n    -> decltype        (_VSTD::forward<_T1>(__t) || _VSTD::forward<_T2>(__u))\n        { return        _VSTD::forward<_T1>(__t) || _VSTD::forward<_T2>(__u); }\n    typedef void is_transparent;\n};\n#endif\n\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp = void>\n#else\ntemplate <class _Tp>\n#endif\nstruct _LIBCPP_TEMPLATE_VIS logical_not : unary_function<_Tp, bool>\n{\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const _Tp& __x) const\n        {return !__x;}\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <>\nstruct _LIBCPP_TEMPLATE_VIS logical_not<void>\n{\n    template <class _Tp>\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    auto operator()(_Tp&& __x) const\n    _NOEXCEPT_(noexcept(!_VSTD::forward<_Tp>(__x)))\n    -> decltype        (!_VSTD::forward<_Tp>(__x))\n        { return        !_VSTD::forward<_Tp>(__x); }\n    typedef void is_transparent;\n};\n#endif\n\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp = void>\n#else\ntemplate <class _Tp>\n#endif\nstruct _LIBCPP_TEMPLATE_VIS bit_and : binary_function<_Tp, _Tp, _Tp>\n{\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    _Tp operator()(const _Tp& __x, const _Tp& __y) const\n        {return __x & __y;}\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <>\nstruct _LIBCPP_TEMPLATE_VIS bit_and<void>\n{\n    template <class _T1, class _T2>\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    auto operator()(_T1&& __t, _T2&& __u) const\n    _NOEXCEPT_(noexcept(_VSTD::forward<_T1>(__t) & _VSTD::forward<_T2>(__u)))\n    -> decltype        (_VSTD::forward<_T1>(__t) & _VSTD::forward<_T2>(__u))\n        { return        _VSTD::forward<_T1>(__t) & _VSTD::forward<_T2>(__u); }\n    typedef void is_transparent;\n};\n#endif\n\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp = void>\n#else\ntemplate <class _Tp>\n#endif\nstruct _LIBCPP_TEMPLATE_VIS bit_or : binary_function<_Tp, _Tp, _Tp>\n{\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    _Tp operator()(const _Tp& __x, const _Tp& __y) const\n        {return __x | __y;}\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <>\nstruct _LIBCPP_TEMPLATE_VIS bit_or<void>\n{\n    template <class _T1, class _T2>\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    auto operator()(_T1&& __t, _T2&& __u) const\n    _NOEXCEPT_(noexcept(_VSTD::forward<_T1>(__t) | _VSTD::forward<_T2>(__u)))\n    -> decltype        (_VSTD::forward<_T1>(__t) | _VSTD::forward<_T2>(__u))\n        { return        _VSTD::forward<_T1>(__t) | _VSTD::forward<_T2>(__u); }\n    typedef void is_transparent;\n};\n#endif\n\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp = void>\n#else\ntemplate <class _Tp>\n#endif\nstruct _LIBCPP_TEMPLATE_VIS bit_xor : binary_function<_Tp, _Tp, _Tp>\n{\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    _Tp operator()(const _Tp& __x, const _Tp& __y) const\n        {return __x ^ __y;}\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <>\nstruct _LIBCPP_TEMPLATE_VIS bit_xor<void>\n{\n    template <class _T1, class _T2>\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    auto operator()(_T1&& __t, _T2&& __u) const\n    _NOEXCEPT_(noexcept(_VSTD::forward<_T1>(__t) ^ _VSTD::forward<_T2>(__u)))\n    -> decltype        (_VSTD::forward<_T1>(__t) ^ _VSTD::forward<_T2>(__u))\n        { return        _VSTD::forward<_T1>(__t) ^ _VSTD::forward<_T2>(__u); }\n    typedef void is_transparent;\n};\n#endif\n\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp = void>\nstruct _LIBCPP_TEMPLATE_VIS bit_not : unary_function<_Tp, _Tp>\n{\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    _Tp operator()(const _Tp& __x) const\n        {return ~__x;}\n};\n\ntemplate <>\nstruct _LIBCPP_TEMPLATE_VIS bit_not<void>\n{\n    template <class _Tp>\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    auto operator()(_Tp&& __x) const\n    _NOEXCEPT_(noexcept(~_VSTD::forward<_Tp>(__x)))\n    -> decltype        (~_VSTD::forward<_Tp>(__x))\n        { return        ~_VSTD::forward<_Tp>(__x); }\n    typedef void is_transparent;\n};\n#endif\n\ntemplate <class _Predicate>\nclass _LIBCPP_TEMPLATE_VIS unary_negate\n    : public unary_function<typename _Predicate::argument_type, bool>\n{\n    _Predicate __pred_;\npublic:\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    explicit unary_negate(const _Predicate& __pred)\n        : __pred_(__pred) {}\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const typename _Predicate::argument_type& __x) const\n        {return !__pred_(__x);}\n};\n\ntemplate <class _Predicate>\ninline _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\nunary_negate<_Predicate>\nnot1(const _Predicate& __pred) {return unary_negate<_Predicate>(__pred);}\n\ntemplate <class _Predicate>\nclass _LIBCPP_TEMPLATE_VIS binary_negate\n    : public binary_function<typename _Predicate::first_argument_type,\n                             typename _Predicate::second_argument_type,\n                             bool>\n{\n    _Predicate __pred_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY explicit _LIBCPP_CONSTEXPR_AFTER_CXX11 \n    binary_negate(const _Predicate& __pred) : __pred_(__pred) {}\n\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const typename _Predicate::first_argument_type& __x,\n                    const typename _Predicate::second_argument_type& __y) const\n        {return !__pred_(__x, __y);}\n};\n\ntemplate <class _Predicate>\ninline _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\nbinary_negate<_Predicate>\nnot2(const _Predicate& __pred) {return binary_negate<_Predicate>(__pred);}\n\ntemplate <class __Operation>\nclass _LIBCPP_TEMPLATE_VIS binder1st\n    : public unary_function<typename __Operation::second_argument_type,\n                            typename __Operation::result_type>\n{\nprotected:\n    __Operation                               op;\n    typename __Operation::first_argument_type value;\npublic:\n    _LIBCPP_INLINE_VISIBILITY binder1st(const __Operation& __x,\n                               const typename __Operation::first_argument_type __y)\n        : op(__x), value(__y) {}\n    _LIBCPP_INLINE_VISIBILITY typename __Operation::result_type operator()\n        (typename __Operation::second_argument_type& __x) const\n            {return op(value, __x);}\n    _LIBCPP_INLINE_VISIBILITY typename __Operation::result_type operator()\n        (const typename __Operation::second_argument_type& __x) const\n            {return op(value, __x);}\n};\n\ntemplate <class __Operation, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbinder1st<__Operation>\nbind1st(const __Operation& __op, const _Tp& __x)\n    {return binder1st<__Operation>(__op, __x);}\n\ntemplate <class __Operation>\nclass _LIBCPP_TEMPLATE_VIS binder2nd\n    : public unary_function<typename __Operation::first_argument_type,\n                            typename __Operation::result_type>\n{\nprotected:\n    __Operation                                op;\n    typename __Operation::second_argument_type value;\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    binder2nd(const __Operation& __x, const typename __Operation::second_argument_type __y)\n        : op(__x), value(__y) {}\n    _LIBCPP_INLINE_VISIBILITY typename __Operation::result_type operator()\n        (      typename __Operation::first_argument_type& __x) const\n            {return op(__x, value);}\n    _LIBCPP_INLINE_VISIBILITY typename __Operation::result_type operator()\n        (const typename __Operation::first_argument_type& __x) const\n            {return op(__x, value);}\n};\n\ntemplate <class __Operation, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbinder2nd<__Operation>\nbind2nd(const __Operation& __op, const _Tp& __x)\n    {return binder2nd<__Operation>(__op, __x);}\n\ntemplate <class _Arg, class _Result>\nclass _LIBCPP_TEMPLATE_VIS pointer_to_unary_function\n    : public unary_function<_Arg, _Result>\n{\n    _Result (*__f_)(_Arg);\npublic:\n    _LIBCPP_INLINE_VISIBILITY explicit pointer_to_unary_function(_Result (*__f)(_Arg))\n        : __f_(__f) {}\n    _LIBCPP_INLINE_VISIBILITY _Result operator()(_Arg __x) const\n        {return __f_(__x);}\n};\n\ntemplate <class _Arg, class _Result>\ninline _LIBCPP_INLINE_VISIBILITY\npointer_to_unary_function<_Arg,_Result>\nptr_fun(_Result (*__f)(_Arg))\n    {return pointer_to_unary_function<_Arg,_Result>(__f);}\n\ntemplate <class _Arg1, class _Arg2, class _Result>\nclass _LIBCPP_TEMPLATE_VIS pointer_to_binary_function\n    : public binary_function<_Arg1, _Arg2, _Result>\n{\n    _Result (*__f_)(_Arg1, _Arg2);\npublic:\n    _LIBCPP_INLINE_VISIBILITY explicit pointer_to_binary_function(_Result (*__f)(_Arg1, _Arg2))\n        : __f_(__f) {}\n    _LIBCPP_INLINE_VISIBILITY _Result operator()(_Arg1 __x, _Arg2 __y) const\n        {return __f_(__x, __y);}\n};\n\ntemplate <class _Arg1, class _Arg2, class _Result>\ninline _LIBCPP_INLINE_VISIBILITY\npointer_to_binary_function<_Arg1,_Arg2,_Result>\nptr_fun(_Result (*__f)(_Arg1,_Arg2))\n    {return pointer_to_binary_function<_Arg1,_Arg2,_Result>(__f);}\n\ntemplate<class _Sp, class _Tp>\nclass _LIBCPP_TEMPLATE_VIS mem_fun_t : public unary_function<_Tp*, _Sp>\n{\n    _Sp (_Tp::*__p_)();\npublic:\n    _LIBCPP_INLINE_VISIBILITY explicit mem_fun_t(_Sp (_Tp::*__p)())\n        : __p_(__p) {}\n    _LIBCPP_INLINE_VISIBILITY _Sp operator()(_Tp* __p) const\n        {return (__p->*__p_)();}\n};\n\ntemplate<class _Sp, class _Tp, class _Ap>\nclass _LIBCPP_TEMPLATE_VIS mem_fun1_t : public binary_function<_Tp*, _Ap, _Sp>\n{\n    _Sp (_Tp::*__p_)(_Ap);\npublic:\n    _LIBCPP_INLINE_VISIBILITY explicit mem_fun1_t(_Sp (_Tp::*__p)(_Ap))\n        : __p_(__p) {}\n    _LIBCPP_INLINE_VISIBILITY _Sp operator()(_Tp* __p, _Ap __x) const\n        {return (__p->*__p_)(__x);}\n};\n\ntemplate<class _Sp, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nmem_fun_t<_Sp,_Tp>\nmem_fun(_Sp (_Tp::*__f)())\n    {return mem_fun_t<_Sp,_Tp>(__f);}\n\ntemplate<class _Sp, class _Tp, class _Ap>\ninline _LIBCPP_INLINE_VISIBILITY\nmem_fun1_t<_Sp,_Tp,_Ap>\nmem_fun(_Sp (_Tp::*__f)(_Ap))\n    {return mem_fun1_t<_Sp,_Tp,_Ap>(__f);}\n\ntemplate<class _Sp, class _Tp>\nclass _LIBCPP_TEMPLATE_VIS mem_fun_ref_t : public unary_function<_Tp, _Sp>\n{\n    _Sp (_Tp::*__p_)();\npublic:\n    _LIBCPP_INLINE_VISIBILITY explicit mem_fun_ref_t(_Sp (_Tp::*__p)())\n        : __p_(__p) {}\n    _LIBCPP_INLINE_VISIBILITY _Sp operator()(_Tp& __p) const\n        {return (__p.*__p_)();}\n};\n\ntemplate<class _Sp, class _Tp, class _Ap>\nclass _LIBCPP_TEMPLATE_VIS mem_fun1_ref_t : public binary_function<_Tp, _Ap, _Sp>\n{\n    _Sp (_Tp::*__p_)(_Ap);\npublic:\n    _LIBCPP_INLINE_VISIBILITY explicit mem_fun1_ref_t(_Sp (_Tp::*__p)(_Ap))\n        : __p_(__p) {}\n    _LIBCPP_INLINE_VISIBILITY _Sp operator()(_Tp& __p, _Ap __x) const\n        {return (__p.*__p_)(__x);}\n};\n\ntemplate<class _Sp, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nmem_fun_ref_t<_Sp,_Tp>\nmem_fun_ref(_Sp (_Tp::*__f)())\n    {return mem_fun_ref_t<_Sp,_Tp>(__f);}\n\ntemplate<class _Sp, class _Tp, class _Ap>\ninline _LIBCPP_INLINE_VISIBILITY\nmem_fun1_ref_t<_Sp,_Tp,_Ap>\nmem_fun_ref(_Sp (_Tp::*__f)(_Ap))\n    {return mem_fun1_ref_t<_Sp,_Tp,_Ap>(__f);}\n\ntemplate <class _Sp, class _Tp>\nclass _LIBCPP_TEMPLATE_VIS const_mem_fun_t : public unary_function<const _Tp*, _Sp>\n{\n    _Sp (_Tp::*__p_)() const;\npublic:\n    _LIBCPP_INLINE_VISIBILITY explicit const_mem_fun_t(_Sp (_Tp::*__p)() const)\n        : __p_(__p) {}\n    _LIBCPP_INLINE_VISIBILITY _Sp operator()(const _Tp* __p) const\n        {return (__p->*__p_)();}\n};\n\ntemplate <class _Sp, class _Tp, class _Ap>\nclass _LIBCPP_TEMPLATE_VIS const_mem_fun1_t : public binary_function<const _Tp*, _Ap, _Sp>\n{\n    _Sp (_Tp::*__p_)(_Ap) const;\npublic:\n    _LIBCPP_INLINE_VISIBILITY explicit const_mem_fun1_t(_Sp (_Tp::*__p)(_Ap) const)\n        : __p_(__p) {}\n    _LIBCPP_INLINE_VISIBILITY _Sp operator()(const _Tp* __p, _Ap __x) const\n        {return (__p->*__p_)(__x);}\n};\n\ntemplate <class _Sp, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nconst_mem_fun_t<_Sp,_Tp>\nmem_fun(_Sp (_Tp::*__f)() const)\n    {return const_mem_fun_t<_Sp,_Tp>(__f);}\n\ntemplate <class _Sp, class _Tp, class _Ap>\ninline _LIBCPP_INLINE_VISIBILITY\nconst_mem_fun1_t<_Sp,_Tp,_Ap>\nmem_fun(_Sp (_Tp::*__f)(_Ap) const)\n    {return const_mem_fun1_t<_Sp,_Tp,_Ap>(__f);}\n\ntemplate <class _Sp, class _Tp>\nclass _LIBCPP_TEMPLATE_VIS const_mem_fun_ref_t : public unary_function<_Tp, _Sp>\n{\n    _Sp (_Tp::*__p_)() const;\npublic:\n    _LIBCPP_INLINE_VISIBILITY explicit const_mem_fun_ref_t(_Sp (_Tp::*__p)() const)\n        : __p_(__p) {}\n    _LIBCPP_INLINE_VISIBILITY _Sp operator()(const _Tp& __p) const\n        {return (__p.*__p_)();}\n};\n\ntemplate <class _Sp, class _Tp, class _Ap>\nclass _LIBCPP_TEMPLATE_VIS const_mem_fun1_ref_t\n    : public binary_function<_Tp, _Ap, _Sp>\n{\n    _Sp (_Tp::*__p_)(_Ap) const;\npublic:\n    _LIBCPP_INLINE_VISIBILITY explicit const_mem_fun1_ref_t(_Sp (_Tp::*__p)(_Ap) const)\n        : __p_(__p) {}\n    _LIBCPP_INLINE_VISIBILITY _Sp operator()(const _Tp& __p, _Ap __x) const\n        {return (__p.*__p_)(__x);}\n};\n\ntemplate <class _Sp, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nconst_mem_fun_ref_t<_Sp,_Tp>\nmem_fun_ref(_Sp (_Tp::*__f)() const)\n    {return const_mem_fun_ref_t<_Sp,_Tp>(__f);}\n\ntemplate <class _Sp, class _Tp, class _Ap>\ninline _LIBCPP_INLINE_VISIBILITY\nconst_mem_fun1_ref_t<_Sp,_Tp,_Ap>\nmem_fun_ref(_Sp (_Tp::*__f)(_Ap) const)\n    {return const_mem_fun1_ref_t<_Sp,_Tp,_Ap>(__f);}\n\n////////////////////////////////////////////////////////////////////////////////\n//                                MEMFUN\n//==============================================================================\n\ntemplate <class _Tp>\nclass __mem_fn\n    : public __weak_result_type<_Tp>\n{\npublic:\n    // types\n    typedef _Tp type;\nprivate:\n    type __f_;\n\npublic:\n    _LIBCPP_INLINE_VISIBILITY __mem_fn(type __f) _NOEXCEPT : __f_(__f) {}\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n    // invoke\n    template <class... _ArgTypes>\n    _LIBCPP_INLINE_VISIBILITY\n    typename __invoke_return<type, _ArgTypes...>::type\n    operator() (_ArgTypes&&... __args) const {\n        return __invoke(__f_, _VSTD::forward<_ArgTypes>(__args)...);\n    }\n#else\n\n    template <class _A0>\n    _LIBCPP_INLINE_VISIBILITY\n    typename __invoke_return0<type, _A0>::type\n    operator() (_A0& __a0) const {\n        return __invoke(__f_, __a0);\n    }\n\n    template <class _A0>\n    _LIBCPP_INLINE_VISIBILITY\n    typename __invoke_return0<type, _A0 const>::type\n    operator() (_A0 const& __a0) const {\n        return __invoke(__f_, __a0);\n    }\n\n    template <class _A0, class _A1>\n    _LIBCPP_INLINE_VISIBILITY\n    typename __invoke_return1<type, _A0, _A1>::type\n    operator() (_A0& __a0, _A1& __a1) const {\n        return __invoke(__f_, __a0, __a1);\n    }\n\n    template <class _A0, class _A1>\n    _LIBCPP_INLINE_VISIBILITY\n    typename __invoke_return1<type, _A0 const, _A1>::type\n    operator() (_A0 const& __a0, _A1& __a1) const {\n        return __invoke(__f_, __a0, __a1);\n    }\n\n    template <class _A0, class _A1>\n    _LIBCPP_INLINE_VISIBILITY\n    typename __invoke_return1<type, _A0, _A1 const>::type\n    operator() (_A0& __a0, _A1 const& __a1) const {\n        return __invoke(__f_, __a0, __a1);\n    }\n\n    template <class _A0, class _A1>\n    _LIBCPP_INLINE_VISIBILITY\n    typename __invoke_return1<type, _A0 const, _A1 const>::type\n    operator() (_A0 const& __a0, _A1 const& __a1) const {\n        return __invoke(__f_, __a0, __a1);\n    }\n\n    template <class _A0, class _A1, class _A2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename __invoke_return2<type, _A0, _A1, _A2>::type\n    operator() (_A0& __a0, _A1& __a1, _A2& __a2) const {\n        return __invoke(__f_, __a0, __a1, __a2);\n    }\n\n    template <class _A0, class _A1, class _A2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename __invoke_return2<type, _A0 const, _A1, _A2>::type\n    operator() (_A0 const& __a0, _A1& __a1, _A2& __a2) const {\n        return __invoke(__f_, __a0, __a1, __a2);\n    }\n\n    template <class _A0, class _A1, class _A2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename __invoke_return2<type, _A0, _A1 const, _A2>::type\n    operator() (_A0& __a0, _A1 const& __a1, _A2& __a2) const {\n        return __invoke(__f_, __a0, __a1, __a2);\n    }\n\n    template <class _A0, class _A1, class _A2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename __invoke_return2<type, _A0, _A1, _A2 const>::type\n    operator() (_A0& __a0, _A1& __a1, _A2 const& __a2) const {\n        return __invoke(__f_, __a0, __a1, __a2);\n    }\n\n    template <class _A0, class _A1, class _A2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename __invoke_return2<type, _A0 const, _A1 const, _A2>::type\n    operator() (_A0 const& __a0, _A1 const& __a1, _A2& __a2) const {\n        return __invoke(__f_, __a0, __a1, __a2);\n    }\n\n    template <class _A0, class _A1, class _A2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename __invoke_return2<type, _A0 const, _A1, _A2 const>::type\n    operator() (_A0 const& __a0, _A1& __a1, _A2 const& __a2) const {\n        return __invoke(__f_, __a0, __a1, __a2);\n    }\n\n    template <class _A0, class _A1, class _A2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename __invoke_return2<type, _A0, _A1 const, _A2 const>::type\n    operator() (_A0& __a0, _A1 const& __a1, _A2 const& __a2) const {\n        return __invoke(__f_, __a0, __a1, __a2);\n    }\n\n    template <class _A0, class _A1, class _A2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename __invoke_return2<type, _A0 const, _A1 const, _A2 const>::type\n    operator() (_A0 const& __a0, _A1 const& __a1, _A2 const& __a2) const {\n        return __invoke(__f_, __a0, __a1, __a2);\n    }\n#endif\n};\n\ntemplate<class _Rp, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n__mem_fn<_Rp _Tp::*>\nmem_fn(_Rp _Tp::* __pm) _NOEXCEPT\n{\n    return __mem_fn<_Rp _Tp::*>(__pm);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n//                                FUNCTION\n//==============================================================================\n\n// bad_function_call\n\nclass _LIBCPP_EXCEPTION_ABI bad_function_call\n    : public exception\n{\n};\n\n_LIBCPP_NORETURN inline _LIBCPP_ALWAYS_INLINE\nvoid __throw_bad_function_call()\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    throw bad_function_call();\n#else\n\t_VSTD::abort();\n#endif\n}\n\ntemplate<class _Fp> class _LIBCPP_TEMPLATE_VIS function; // undefined\n\nnamespace __function\n{\n\ntemplate<class _Rp>\nstruct __maybe_derive_from_unary_function\n{\n};\n\ntemplate<class _Rp, class _A1>\nstruct __maybe_derive_from_unary_function<_Rp(_A1)>\n    : public unary_function<_A1, _Rp>\n{\n};\n\ntemplate<class _Rp>\nstruct __maybe_derive_from_binary_function\n{\n};\n\ntemplate<class _Rp, class _A1, class _A2>\nstruct __maybe_derive_from_binary_function<_Rp(_A1, _A2)>\n    : public binary_function<_A1, _A2, _Rp>\n{\n};\n\ntemplate <class _Fp>\n_LIBCPP_INLINE_VISIBILITY\nbool __not_null(_Fp const&) { return true; }\n\ntemplate <class _Fp>\n_LIBCPP_INLINE_VISIBILITY\nbool __not_null(_Fp* __ptr) { return __ptr; }\n\ntemplate <class _Ret, class _Class>\n_LIBCPP_INLINE_VISIBILITY\nbool __not_null(_Ret _Class::*__ptr) { return __ptr; }\n\ntemplate <class _Fp>\n_LIBCPP_INLINE_VISIBILITY\nbool __not_null(function<_Fp> const& __f) { return !!__f; }\n\n} // namespace __function\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\nnamespace __function {\n\ntemplate<class _Fp> class __base;\n\ntemplate<class _Rp, class ..._ArgTypes>\nclass __base<_Rp(_ArgTypes...)>\n{\n    __base(const __base&);\n    __base& operator=(const __base&);\npublic:\n    _LIBCPP_INLINE_VISIBILITY __base() {}\n    _LIBCPP_INLINE_VISIBILITY virtual ~__base() {}\n    virtual __base* __clone() const = 0;\n    virtual void __clone(__base*) const = 0;\n    virtual void destroy() _NOEXCEPT = 0;\n    virtual void destroy_deallocate() _NOEXCEPT = 0;\n    virtual _Rp operator()(_ArgTypes&& ...) = 0;\n#ifndef _LIBCPP_NO_RTTI\n    virtual const void* target(const type_info&) const _NOEXCEPT = 0;\n    virtual const std::type_info& target_type() const _NOEXCEPT = 0;\n#endif  // _LIBCPP_NO_RTTI\n};\n\ntemplate<class _FD, class _Alloc, class _FB> class __func;\n\ntemplate<class _Fp, class _Alloc, class _Rp, class ..._ArgTypes>\nclass __func<_Fp, _Alloc, _Rp(_ArgTypes...)>\n    : public  __base<_Rp(_ArgTypes...)>\n{\n    __compressed_pair<_Fp, _Alloc> __f_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __func(_Fp&& __f)\n        : __f_(piecewise_construct, _VSTD::forward_as_tuple(_VSTD::move(__f)),\n                                    _VSTD::forward_as_tuple()) {}\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __func(const _Fp& __f, const _Alloc& __a)\n        : __f_(piecewise_construct, _VSTD::forward_as_tuple(__f),\n                                    _VSTD::forward_as_tuple(__a)) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __func(const _Fp& __f, _Alloc&& __a)\n        : __f_(piecewise_construct, _VSTD::forward_as_tuple(__f),\n                                    _VSTD::forward_as_tuple(_VSTD::move(__a))) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __func(_Fp&& __f, _Alloc&& __a)\n        : __f_(piecewise_construct, _VSTD::forward_as_tuple(_VSTD::move(__f)),\n                                    _VSTD::forward_as_tuple(_VSTD::move(__a))) {}\n    virtual __base<_Rp(_ArgTypes...)>* __clone() const;\n    virtual void __clone(__base<_Rp(_ArgTypes...)>*) const;\n    virtual void destroy() _NOEXCEPT;\n    virtual void destroy_deallocate() _NOEXCEPT;\n    virtual _Rp operator()(_ArgTypes&& ... __arg);\n#ifndef _LIBCPP_NO_RTTI\n    virtual const void* target(const type_info&) const _NOEXCEPT;\n    virtual const std::type_info& target_type() const _NOEXCEPT;\n#endif  // _LIBCPP_NO_RTTI\n};\n\ntemplate<class _Fp, class _Alloc, class _Rp, class ..._ArgTypes>\n__base<_Rp(_ArgTypes...)>*\n__func<_Fp, _Alloc, _Rp(_ArgTypes...)>::__clone() const\n{\n    typedef allocator_traits<_Alloc> __alloc_traits;\n    typedef typename __rebind_alloc_helper<__alloc_traits, __func>::type _Ap;\n    _Ap __a(__f_.second());\n    typedef __allocator_destructor<_Ap> _Dp;\n    unique_ptr<__func, _Dp> __hold(__a.allocate(1), _Dp(__a, 1));\n    ::new (__hold.get()) __func(__f_.first(), _Alloc(__a));\n    return __hold.release();\n}\n\ntemplate<class _Fp, class _Alloc, class _Rp, class ..._ArgTypes>\nvoid\n__func<_Fp, _Alloc, _Rp(_ArgTypes...)>::__clone(__base<_Rp(_ArgTypes...)>* __p) const\n{\n    ::new (__p) __func(__f_.first(), __f_.second());\n}\n\ntemplate<class _Fp, class _Alloc, class _Rp, class ..._ArgTypes>\nvoid\n__func<_Fp, _Alloc, _Rp(_ArgTypes...)>::destroy() _NOEXCEPT\n{\n    __f_.~__compressed_pair<_Fp, _Alloc>();\n}\n\ntemplate<class _Fp, class _Alloc, class _Rp, class ..._ArgTypes>\nvoid\n__func<_Fp, _Alloc, _Rp(_ArgTypes...)>::destroy_deallocate() _NOEXCEPT\n{\n    typedef allocator_traits<_Alloc> __alloc_traits;\n    typedef typename __rebind_alloc_helper<__alloc_traits, __func>::type _Ap;\n    _Ap __a(__f_.second());\n    __f_.~__compressed_pair<_Fp, _Alloc>();\n    __a.deallocate(this, 1);\n}\n\ntemplate<class _Fp, class _Alloc, class _Rp, class ..._ArgTypes>\n_Rp\n__func<_Fp, _Alloc, _Rp(_ArgTypes...)>::operator()(_ArgTypes&& ... __arg)\n{\n    typedef __invoke_void_return_wrapper<_Rp> _Invoker;\n    return _Invoker::__call(__f_.first(), _VSTD::forward<_ArgTypes>(__arg)...);\n}\n\n#ifndef _LIBCPP_NO_RTTI\n\ntemplate<class _Fp, class _Alloc, class _Rp, class ..._ArgTypes>\nconst void*\n__func<_Fp, _Alloc, _Rp(_ArgTypes...)>::target(const type_info& __ti) const _NOEXCEPT\n{\n    if (__ti == typeid(_Fp))\n        return &__f_.first();\n    return (const void*)0;\n}\n\ntemplate<class _Fp, class _Alloc, class _Rp, class ..._ArgTypes>\nconst std::type_info&\n__func<_Fp, _Alloc, _Rp(_ArgTypes...)>::target_type() const _NOEXCEPT\n{\n    return typeid(_Fp);\n}\n\n#endif  // _LIBCPP_NO_RTTI\n\n}  // __function\n\ntemplate<class _Rp, class ..._ArgTypes>\nclass _LIBCPP_TEMPLATE_VIS function<_Rp(_ArgTypes...)>\n    : public __function::__maybe_derive_from_unary_function<_Rp(_ArgTypes...)>,\n      public __function::__maybe_derive_from_binary_function<_Rp(_ArgTypes...)>\n{\n    typedef __function::__base<_Rp(_ArgTypes...)> __base;\n    typename aligned_storage<3*sizeof(void*)>::type __buf_;\n    __base* __f_;\n\n    _LIBCPP_NO_CFI static __base *__as_base(void *p) {\n      return reinterpret_cast<__base*>(p);\n    }\n\n    template <class _Fp, bool = !is_same<_Fp, function>::value &&\n                                __invokable<_Fp&, _ArgTypes...>::value>\n        struct __callable;\n    template <class _Fp>\n        struct __callable<_Fp, true>\n        {\n            static const bool value = is_same<void, _Rp>::value ||\n                is_convertible<typename __invoke_of<_Fp&, _ArgTypes...>::type,\n                               _Rp>::value;\n        };\n    template <class _Fp>\n        struct __callable<_Fp, false>\n        {\n            static const bool value = false;\n        };\npublic:\n    typedef _Rp result_type;\n\n    // construct/copy/destroy:\n    _LIBCPP_INLINE_VISIBILITY\n    function() _NOEXCEPT : __f_(0) {}\n    _LIBCPP_INLINE_VISIBILITY\n    function(nullptr_t) _NOEXCEPT : __f_(0) {}\n    function(const function&);\n    function(function&&) _NOEXCEPT;\n    template<class _Fp, class = typename enable_if<\n        __callable<_Fp>::value && !is_same<_Fp, function>::value\n    >::type>\n    function(_Fp);\n\n#if _LIBCPP_STD_VER <= 14\n    template<class _Alloc>\n      _LIBCPP_INLINE_VISIBILITY\n      function(allocator_arg_t, const _Alloc&) _NOEXCEPT : __f_(0) {}\n    template<class _Alloc>\n      _LIBCPP_INLINE_VISIBILITY\n      function(allocator_arg_t, const _Alloc&, nullptr_t) _NOEXCEPT : __f_(0) {}\n    template<class _Alloc>\n      function(allocator_arg_t, const _Alloc&, const function&);\n    template<class _Alloc>\n      function(allocator_arg_t, const _Alloc&, function&&);\n    template<class _Fp, class _Alloc, class = typename enable_if<__callable<_Fp>::value>::type>\n      function(allocator_arg_t, const _Alloc& __a, _Fp __f);\n#endif\n\n    function& operator=(const function&);\n    function& operator=(function&&) _NOEXCEPT;\n    function& operator=(nullptr_t) _NOEXCEPT;\n    template<class _Fp>\n      typename enable_if\n      <\n        __callable<typename decay<_Fp>::type>::value &&\n        !is_same<typename remove_reference<_Fp>::type, function>::value,\n        function&\n      >::type\n      operator=(_Fp&&);\n\n    ~function();\n\n    // function modifiers:\n    void swap(function&) _NOEXCEPT;\n\n#if _LIBCPP_STD_VER <= 14\n    template<class _Fp, class _Alloc>\n      _LIBCPP_INLINE_VISIBILITY\n      void assign(_Fp&& __f, const _Alloc& __a)\n        {function(allocator_arg, __a, _VSTD::forward<_Fp>(__f)).swap(*this);}\n#endif\n\n    // function capacity:\n    _LIBCPP_INLINE_VISIBILITY\n        _LIBCPP_EXPLICIT operator bool() const _NOEXCEPT {return __f_;}\n\n    // deleted overloads close possible hole in the type system\n    template<class _R2, class... _ArgTypes2>\n      bool operator==(const function<_R2(_ArgTypes2...)>&) const = delete;\n    template<class _R2, class... _ArgTypes2>\n      bool operator!=(const function<_R2(_ArgTypes2...)>&) const = delete;\npublic:\n    // function invocation:\n    _Rp operator()(_ArgTypes...) const;\n\n#ifndef _LIBCPP_NO_RTTI\n    // function target access:\n    const std::type_info& target_type() const _NOEXCEPT;\n    template <typename _Tp> _Tp* target() _NOEXCEPT;\n    template <typename _Tp> const _Tp* target() const _NOEXCEPT;\n#endif  // _LIBCPP_NO_RTTI\n};\n\ntemplate<class _Rp, class ..._ArgTypes>\nfunction<_Rp(_ArgTypes...)>::function(const function& __f)\n{\n    if (__f.__f_ == 0)\n        __f_ = 0;\n    else if ((void *)__f.__f_ == &__f.__buf_)\n    {\n        __f_ = __as_base(&__buf_);\n        __f.__f_->__clone(__f_);\n    }\n    else\n        __f_ = __f.__f_->__clone();\n}\n\n#if _LIBCPP_STD_VER <= 14\ntemplate<class _Rp, class ..._ArgTypes>\ntemplate <class _Alloc>\nfunction<_Rp(_ArgTypes...)>::function(allocator_arg_t, const _Alloc&,\n                                     const function& __f)\n{\n    if (__f.__f_ == 0)\n        __f_ = 0;\n    else if ((void *)__f.__f_ == &__f.__buf_)\n    {\n        __f_ = __as_base(&__buf_);\n        __f.__f_->__clone(__f_);\n    }\n    else\n        __f_ = __f.__f_->__clone();\n}\n#endif\n\ntemplate<class _Rp, class ..._ArgTypes>\nfunction<_Rp(_ArgTypes...)>::function(function&& __f) _NOEXCEPT\n{\n    if (__f.__f_ == 0)\n        __f_ = 0;\n    else if ((void *)__f.__f_ == &__f.__buf_)\n    {\n        __f_ = __as_base(&__buf_);\n        __f.__f_->__clone(__f_);\n    }\n    else\n    {\n        __f_ = __f.__f_;\n        __f.__f_ = 0;\n    }\n}\n\n#if _LIBCPP_STD_VER <= 14\ntemplate<class _Rp, class ..._ArgTypes>\ntemplate <class _Alloc>\nfunction<_Rp(_ArgTypes...)>::function(allocator_arg_t, const _Alloc&,\n                                     function&& __f)\n{\n    if (__f.__f_ == 0)\n        __f_ = 0;\n    else if ((void *)__f.__f_ == &__f.__buf_)\n    {\n        __f_ = __as_base(&__buf_);\n        __f.__f_->__clone(__f_);\n    }\n    else\n    {\n        __f_ = __f.__f_;\n        __f.__f_ = 0;\n    }\n}\n#endif\n\ntemplate<class _Rp, class ..._ArgTypes>\ntemplate <class _Fp, class>\nfunction<_Rp(_ArgTypes...)>::function(_Fp __f)\n    : __f_(0)\n{\n    if (__function::__not_null(__f))\n    {\n        typedef __function::__func<_Fp, allocator<_Fp>, _Rp(_ArgTypes...)> _FF;\n        if (sizeof(_FF) <= sizeof(__buf_) && is_nothrow_copy_constructible<_Fp>::value)\n        {\n            __f_ = ::new((void*)&__buf_) _FF(_VSTD::move(__f));\n        }\n        else\n        {\n            typedef allocator<_FF> _Ap;\n            _Ap __a;\n            typedef __allocator_destructor<_Ap> _Dp;\n            unique_ptr<__base, _Dp> __hold(__a.allocate(1), _Dp(__a, 1));\n            ::new (__hold.get()) _FF(_VSTD::move(__f), allocator<_Fp>(__a));\n            __f_ = __hold.release();\n        }\n    }\n}\n\n#if _LIBCPP_STD_VER <= 14\ntemplate<class _Rp, class ..._ArgTypes>\ntemplate <class _Fp, class _Alloc, class>\nfunction<_Rp(_ArgTypes...)>::function(allocator_arg_t, const _Alloc& __a0, _Fp __f)\n    : __f_(0)\n{\n    typedef allocator_traits<_Alloc> __alloc_traits;\n    if (__function::__not_null(__f))\n    {\n        typedef __function::__func<_Fp, _Alloc, _Rp(_ArgTypes...)> _FF;\n        typedef typename __rebind_alloc_helper<__alloc_traits, _FF>::type _Ap;\n        _Ap __a(__a0);\n        if (sizeof(_FF) <= sizeof(__buf_) && \n            is_nothrow_copy_constructible<_Fp>::value && is_nothrow_copy_constructible<_Ap>::value)\n        {\n            __f_ = ::new((void*)&__buf_) _FF(_VSTD::move(__f), _Alloc(__a));\n        }\n        else\n        {\n            typedef __allocator_destructor<_Ap> _Dp;\n            unique_ptr<__base, _Dp> __hold(__a.allocate(1), _Dp(__a, 1));\n            ::new (__hold.get()) _FF(_VSTD::move(__f), _Alloc(__a));\n            __f_ = __hold.release();\n        }\n    }\n}\n#endif\n\ntemplate<class _Rp, class ..._ArgTypes>\nfunction<_Rp(_ArgTypes...)>&\nfunction<_Rp(_ArgTypes...)>::operator=(const function& __f)\n{\n    function(__f).swap(*this);\n    return *this;\n}\n\ntemplate<class _Rp, class ..._ArgTypes>\nfunction<_Rp(_ArgTypes...)>&\nfunction<_Rp(_ArgTypes...)>::operator=(function&& __f) _NOEXCEPT\n{\n    if ((void *)__f_ == &__buf_)\n        __f_->destroy();\n    else if (__f_)\n        __f_->destroy_deallocate();\n    __f_ = 0;\n    if (__f.__f_ == 0)\n        __f_ = 0;\n    else if ((void *)__f.__f_ == &__f.__buf_)\n    {\n        __f_ = __as_base(&__buf_);\n        __f.__f_->__clone(__f_);\n    }\n    else\n    {\n        __f_ = __f.__f_;\n        __f.__f_ = 0;\n    }\n    return *this;\n}\n\ntemplate<class _Rp, class ..._ArgTypes>\nfunction<_Rp(_ArgTypes...)>&\nfunction<_Rp(_ArgTypes...)>::operator=(nullptr_t) _NOEXCEPT\n{\n    if ((void *)__f_ == &__buf_)\n        __f_->destroy();\n    else if (__f_)\n        __f_->destroy_deallocate();\n    __f_ = 0;\n    return *this;\n}\n\ntemplate<class _Rp, class ..._ArgTypes>\ntemplate <class _Fp>\ntypename enable_if\n<\n    function<_Rp(_ArgTypes...)>::template __callable<typename decay<_Fp>::type>::value &&\n    !is_same<typename remove_reference<_Fp>::type, function<_Rp(_ArgTypes...)>>::value,\n    function<_Rp(_ArgTypes...)>&\n>::type\nfunction<_Rp(_ArgTypes...)>::operator=(_Fp&& __f)\n{\n    function(_VSTD::forward<_Fp>(__f)).swap(*this);\n    return *this;\n}\n\ntemplate<class _Rp, class ..._ArgTypes>\nfunction<_Rp(_ArgTypes...)>::~function()\n{\n    if ((void *)__f_ == &__buf_)\n        __f_->destroy();\n    else if (__f_)\n        __f_->destroy_deallocate();\n}\n\ntemplate<class _Rp, class ..._ArgTypes>\nvoid\nfunction<_Rp(_ArgTypes...)>::swap(function& __f) _NOEXCEPT\n{\n    if (_VSTD::addressof(__f) == this)\n      return;\n    if ((void *)__f_ == &__buf_ && (void *)__f.__f_ == &__f.__buf_)\n    {\n        typename aligned_storage<sizeof(__buf_)>::type __tempbuf;\n        __base* __t = __as_base(&__tempbuf);\n        __f_->__clone(__t);\n        __f_->destroy();\n        __f_ = 0;\n        __f.__f_->__clone(__as_base(&__buf_));\n        __f.__f_->destroy();\n        __f.__f_ = 0;\n        __f_ = __as_base(&__buf_);\n        __t->__clone(__as_base(&__f.__buf_));\n        __t->destroy();\n        __f.__f_ = __as_base(&__f.__buf_);\n    }\n    else if ((void *)__f_ == &__buf_)\n    {\n        __f_->__clone(__as_base(&__f.__buf_));\n        __f_->destroy();\n        __f_ = __f.__f_;\n        __f.__f_ = __as_base(&__f.__buf_);\n    }\n    else if ((void *)__f.__f_ == &__f.__buf_)\n    {\n        __f.__f_->__clone(__as_base(&__buf_));\n        __f.__f_->destroy();\n        __f.__f_ = __f_;\n        __f_ = __as_base(&__buf_);\n    }\n    else\n        _VSTD::swap(__f_, __f.__f_);\n}\n\ntemplate<class _Rp, class ..._ArgTypes>\n_Rp\nfunction<_Rp(_ArgTypes...)>::operator()(_ArgTypes... __arg) const\n{\n    if (__f_ == 0)\n        __throw_bad_function_call();\n    return (*__f_)(_VSTD::forward<_ArgTypes>(__arg)...);\n}\n\n#ifndef _LIBCPP_NO_RTTI\n\ntemplate<class _Rp, class ..._ArgTypes>\nconst std::type_info&\nfunction<_Rp(_ArgTypes...)>::target_type() const _NOEXCEPT\n{\n    if (__f_ == 0)\n        return typeid(void);\n    return __f_->target_type();\n}\n\ntemplate<class _Rp, class ..._ArgTypes>\ntemplate <typename _Tp>\n_Tp*\nfunction<_Rp(_ArgTypes...)>::target() _NOEXCEPT\n{\n    if (__f_ == 0)\n        return (_Tp*)0;\n    return (_Tp*)__f_->target(typeid(_Tp));\n}\n\ntemplate<class _Rp, class ..._ArgTypes>\ntemplate <typename _Tp>\nconst _Tp*\nfunction<_Rp(_ArgTypes...)>::target() const _NOEXCEPT\n{\n    if (__f_ == 0)\n        return (const _Tp*)0;\n    return (const _Tp*)__f_->target(typeid(_Tp));\n}\n\n#endif  // _LIBCPP_NO_RTTI\n\ntemplate <class _Rp, class... _ArgTypes>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const function<_Rp(_ArgTypes...)>& __f, nullptr_t) _NOEXCEPT {return !__f;}\n\ntemplate <class _Rp, class... _ArgTypes>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(nullptr_t, const function<_Rp(_ArgTypes...)>& __f) _NOEXCEPT {return !__f;}\n\ntemplate <class _Rp, class... _ArgTypes>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const function<_Rp(_ArgTypes...)>& __f, nullptr_t) _NOEXCEPT {return (bool)__f;}\n\ntemplate <class _Rp, class... _ArgTypes>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(nullptr_t, const function<_Rp(_ArgTypes...)>& __f) _NOEXCEPT {return (bool)__f;}\n\ntemplate <class _Rp, class... _ArgTypes>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(function<_Rp(_ArgTypes...)>& __x, function<_Rp(_ArgTypes...)>& __y) _NOEXCEPT\n{return __x.swap(__y);}\n\n#else // _LIBCPP_HAS_NO_VARIADICS\n\n#include <__functional_03>\n\n#endif\n\n////////////////////////////////////////////////////////////////////////////////\n//                                  BIND\n//==============================================================================\n\ntemplate<class _Tp> struct __is_bind_expression : public false_type {};\ntemplate<class _Tp> struct _LIBCPP_TEMPLATE_VIS is_bind_expression\n    : public __is_bind_expression<typename remove_cv<_Tp>::type> {};\n\n#if _LIBCPP_STD_VER > 14\ntemplate <class _Tp>\nconstexpr size_t is_bind_expression_v = is_bind_expression<_Tp>::value;\n#endif\n\ntemplate<class _Tp> struct __is_placeholder : public integral_constant<int, 0> {};\ntemplate<class _Tp> struct _LIBCPP_TEMPLATE_VIS is_placeholder\n    : public __is_placeholder<typename remove_cv<_Tp>::type> {};\n\n#if _LIBCPP_STD_VER > 14\ntemplate <class _Tp>\nconstexpr size_t is_placeholder_v = is_placeholder<_Tp>::value;\n#endif\n\nnamespace placeholders\n{\n\ntemplate <int _Np> struct __ph {};\n\n#if defined(_LIBCPP_CXX03_LANG) || defined(_LIBCPP_BUILDING_BIND)\n_LIBCPP_FUNC_VIS extern const __ph<1>   _1;\n_LIBCPP_FUNC_VIS extern const __ph<2>   _2;\n_LIBCPP_FUNC_VIS extern const __ph<3>   _3;\n_LIBCPP_FUNC_VIS extern const __ph<4>   _4;\n_LIBCPP_FUNC_VIS extern const __ph<5>   _5;\n_LIBCPP_FUNC_VIS extern const __ph<6>   _6;\n_LIBCPP_FUNC_VIS extern const __ph<7>   _7;\n_LIBCPP_FUNC_VIS extern const __ph<8>   _8;\n_LIBCPP_FUNC_VIS extern const __ph<9>   _9;\n_LIBCPP_FUNC_VIS extern const __ph<10> _10;\n#else\nconstexpr __ph<1>   _1{};\nconstexpr __ph<2>   _2{};\nconstexpr __ph<3>   _3{};\nconstexpr __ph<4>   _4{};\nconstexpr __ph<5>   _5{};\nconstexpr __ph<6>   _6{};\nconstexpr __ph<7>   _7{};\nconstexpr __ph<8>   _8{};\nconstexpr __ph<9>   _9{};\nconstexpr __ph<10> _10{};\n#endif // defined(_LIBCPP_CXX03_LANG) || defined(_LIBCPP_BUILDING_BIND)\n\n}  // placeholders\n\ntemplate<int _Np>\nstruct __is_placeholder<placeholders::__ph<_Np> >\n    : public integral_constant<int, _Np> {};\n\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Tp, class _Uj>\ninline _LIBCPP_INLINE_VISIBILITY\n_Tp&\n__mu(reference_wrapper<_Tp> __t, _Uj&)\n{\n    return __t.get();\n}\n\ntemplate <class _Ti, class ..._Uj, size_t ..._Indx>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename __invoke_of<_Ti&, _Uj...>::type\n__mu_expand(_Ti& __ti, tuple<_Uj...>& __uj, __tuple_indices<_Indx...>)\n{\n    return __ti(_VSTD::forward<_Uj>(_VSTD::get<_Indx>(__uj))...);\n}\n\ntemplate <class _Ti, class ..._Uj>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename __lazy_enable_if\n<\n    is_bind_expression<_Ti>::value,\n    __invoke_of<_Ti&, _Uj...>\n>::type\n__mu(_Ti& __ti, tuple<_Uj...>& __uj)\n{\n    typedef typename __make_tuple_indices<sizeof...(_Uj)>::type __indices;\n    return  __mu_expand(__ti, __uj, __indices());\n}\n\ntemplate <bool IsPh, class _Ti, class _Uj>\nstruct __mu_return2 {};\n\ntemplate <class _Ti, class _Uj>\nstruct __mu_return2<true, _Ti, _Uj>\n{\n    typedef typename tuple_element<is_placeholder<_Ti>::value - 1, _Uj>::type type;\n};\n\ntemplate <class _Ti, class _Uj>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    0 < is_placeholder<_Ti>::value,\n    typename __mu_return2<0 < is_placeholder<_Ti>::value, _Ti, _Uj>::type\n>::type\n__mu(_Ti&, _Uj& __uj)\n{\n    const size_t _Indx = is_placeholder<_Ti>::value - 1;\n    return _VSTD::forward<typename tuple_element<_Indx, _Uj>::type>(_VSTD::get<_Indx>(__uj));\n}\n\ntemplate <class _Ti, class _Uj>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    !is_bind_expression<_Ti>::value &&\n    is_placeholder<_Ti>::value == 0 &&\n    !__is_reference_wrapper<_Ti>::value,\n    _Ti&\n>::type\n__mu(_Ti& __ti, _Uj&)\n{\n    return __ti;\n}\n\ntemplate <class _Ti, bool IsReferenceWrapper, bool IsBindEx, bool IsPh,\n          class _TupleUj>\nstruct ____mu_return;\n\ntemplate <bool _Invokable, class _Ti, class ..._Uj>\nstruct ____mu_return_invokable  // false\n{\n    typedef __nat type;\n};\n\ntemplate <class _Ti, class ..._Uj>\nstruct ____mu_return_invokable<true, _Ti, _Uj...>\n{\n    typedef typename __invoke_of<_Ti&, _Uj...>::type type;\n};\n\ntemplate <class _Ti, class ..._Uj>\nstruct ____mu_return<_Ti, false, true, false, tuple<_Uj...> >\n    : public ____mu_return_invokable<__invokable<_Ti&, _Uj...>::value, _Ti, _Uj...>\n{\n};\n\ntemplate <class _Ti, class _TupleUj>\nstruct ____mu_return<_Ti, false, false, true, _TupleUj>\n{\n    typedef typename tuple_element<is_placeholder<_Ti>::value - 1,\n                                   _TupleUj>::type&& type;\n};\n\ntemplate <class _Ti, class _TupleUj>\nstruct ____mu_return<_Ti, true, false, false, _TupleUj>\n{\n    typedef typename _Ti::type& type;\n};\n\ntemplate <class _Ti, class _TupleUj>\nstruct ____mu_return<_Ti, false, false, false, _TupleUj>\n{\n    typedef _Ti& type;\n};\n\ntemplate <class _Ti, class _TupleUj>\nstruct __mu_return\n    : public ____mu_return<_Ti,\n                           __is_reference_wrapper<_Ti>::value,\n                           is_bind_expression<_Ti>::value,\n                           0 < is_placeholder<_Ti>::value &&\n                           is_placeholder<_Ti>::value <= tuple_size<_TupleUj>::value,\n                           _TupleUj>\n{\n};\n\ntemplate <class _Fp, class _BoundArgs, class _TupleUj>\nstruct __is_valid_bind_return\n{\n    static const bool value = false;\n};\n\ntemplate <class _Fp, class ..._BoundArgs, class _TupleUj>\nstruct __is_valid_bind_return<_Fp, tuple<_BoundArgs...>, _TupleUj>\n{\n    static const bool value = __invokable<_Fp,\n                    typename __mu_return<_BoundArgs, _TupleUj>::type...>::value;\n};\n\ntemplate <class _Fp, class ..._BoundArgs, class _TupleUj>\nstruct __is_valid_bind_return<_Fp, const tuple<_BoundArgs...>, _TupleUj>\n{\n    static const bool value = __invokable<_Fp,\n                    typename __mu_return<const _BoundArgs, _TupleUj>::type...>::value;\n};\n\ntemplate <class _Fp, class _BoundArgs, class _TupleUj,\n          bool = __is_valid_bind_return<_Fp, _BoundArgs, _TupleUj>::value>\nstruct __bind_return;\n\ntemplate <class _Fp, class ..._BoundArgs, class _TupleUj>\nstruct __bind_return<_Fp, tuple<_BoundArgs...>, _TupleUj, true>\n{\n    typedef typename __invoke_of\n    <\n        _Fp&,\n        typename __mu_return\n        <\n            _BoundArgs,\n            _TupleUj\n        >::type...\n    >::type type;\n};\n\ntemplate <class _Fp, class ..._BoundArgs, class _TupleUj>\nstruct __bind_return<_Fp, const tuple<_BoundArgs...>, _TupleUj, true>\n{\n    typedef typename __invoke_of\n    <\n        _Fp&,\n        typename __mu_return\n        <\n            const _BoundArgs,\n            _TupleUj\n        >::type...\n    >::type type;\n};\n\ntemplate <class _Fp, class _BoundArgs, size_t ..._Indx, class _Args>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename __bind_return<_Fp, _BoundArgs, _Args>::type\n__apply_functor(_Fp& __f, _BoundArgs& __bound_args, __tuple_indices<_Indx...>,\n                _Args&& __args)\n{\n    return __invoke(__f, __mu(_VSTD::get<_Indx>(__bound_args), __args)...);\n}\n\ntemplate<class _Fp, class ..._BoundArgs>\nclass __bind\n    : public __weak_result_type<typename decay<_Fp>::type>\n{\nprotected:\n    typedef typename decay<_Fp>::type _Fd;\n    typedef tuple<typename decay<_BoundArgs>::type...> _Td;\nprivate:\n    _Fd __f_;\n    _Td __bound_args_;\n\n    typedef typename __make_tuple_indices<sizeof...(_BoundArgs)>::type __indices;\npublic:\n    template <class _Gp, class ..._BA,\n              class = typename enable_if\n                               <\n                                  is_constructible<_Fd, _Gp>::value &&\n                                  !is_same<typename remove_reference<_Gp>::type,\n                                           __bind>::value\n                               >::type>\n      _LIBCPP_INLINE_VISIBILITY\n      explicit __bind(_Gp&& __f, _BA&& ...__bound_args)\n        : __f_(_VSTD::forward<_Gp>(__f)),\n          __bound_args_(_VSTD::forward<_BA>(__bound_args)...) {}\n\n    template <class ..._Args>\n        _LIBCPP_INLINE_VISIBILITY\n        typename __bind_return<_Fd, _Td, tuple<_Args&&...> >::type\n        operator()(_Args&& ...__args)\n        {\n            return __apply_functor(__f_, __bound_args_, __indices(),\n                                  tuple<_Args&&...>(_VSTD::forward<_Args>(__args)...));\n        }\n\n    template <class ..._Args>\n        _LIBCPP_INLINE_VISIBILITY\n        typename __bind_return<const _Fd, const _Td, tuple<_Args&&...> >::type\n        operator()(_Args&& ...__args) const\n        {\n            return __apply_functor(__f_, __bound_args_, __indices(),\n                                   tuple<_Args&&...>(_VSTD::forward<_Args>(__args)...));\n        }\n};\n\ntemplate<class _Fp, class ..._BoundArgs>\nstruct __is_bind_expression<__bind<_Fp, _BoundArgs...> > : public true_type {};\n\ntemplate<class _Rp, class _Fp, class ..._BoundArgs>\nclass __bind_r\n    : public __bind<_Fp, _BoundArgs...>\n{\n    typedef __bind<_Fp, _BoundArgs...> base;\n    typedef typename base::_Fd _Fd;\n    typedef typename base::_Td _Td;\npublic:\n    typedef _Rp result_type;\n\n\n    template <class _Gp, class ..._BA,\n              class = typename enable_if\n                               <\n                                  is_constructible<_Fd, _Gp>::value &&\n                                  !is_same<typename remove_reference<_Gp>::type,\n                                           __bind_r>::value\n                               >::type>\n      _LIBCPP_INLINE_VISIBILITY\n      explicit __bind_r(_Gp&& __f, _BA&& ...__bound_args)\n        : base(_VSTD::forward<_Gp>(__f),\n               _VSTD::forward<_BA>(__bound_args)...) {}\n\n    template <class ..._Args>\n        _LIBCPP_INLINE_VISIBILITY\n        typename enable_if\n        <\n            is_convertible<typename __bind_return<_Fd, _Td, tuple<_Args&&...> >::type,\n                           result_type>::value || is_void<_Rp>::value,\n            result_type\n        >::type\n        operator()(_Args&& ...__args)\n        {\n            typedef __invoke_void_return_wrapper<_Rp> _Invoker;\n            return _Invoker::__call(static_cast<base&>(*this), _VSTD::forward<_Args>(__args)...);\n        }\n\n    template <class ..._Args>\n        _LIBCPP_INLINE_VISIBILITY\n        typename enable_if\n        <\n            is_convertible<typename __bind_return<const _Fd, const _Td, tuple<_Args&&...> >::type,\n                           result_type>::value || is_void<_Rp>::value,\n            result_type\n        >::type\n        operator()(_Args&& ...__args) const\n        {\n            typedef __invoke_void_return_wrapper<_Rp> _Invoker;\n            return _Invoker::__call(static_cast<base const&>(*this), _VSTD::forward<_Args>(__args)...);\n        }\n};\n\ntemplate<class _Rp, class _Fp, class ..._BoundArgs>\nstruct __is_bind_expression<__bind_r<_Rp, _Fp, _BoundArgs...> > : public true_type {};\n\ntemplate<class _Fp, class ..._BoundArgs>\ninline _LIBCPP_INLINE_VISIBILITY\n__bind<_Fp, _BoundArgs...>\nbind(_Fp&& __f, _BoundArgs&&... __bound_args)\n{\n    typedef __bind<_Fp, _BoundArgs...> type;\n    return type(_VSTD::forward<_Fp>(__f), _VSTD::forward<_BoundArgs>(__bound_args)...);\n}\n\ntemplate<class _Rp, class _Fp, class ..._BoundArgs>\ninline _LIBCPP_INLINE_VISIBILITY\n__bind_r<_Rp, _Fp, _BoundArgs...>\nbind(_Fp&& __f, _BoundArgs&&... __bound_args)\n{\n    typedef __bind_r<_Rp, _Fp, _BoundArgs...> type;\n    return type(_VSTD::forward<_Fp>(__f), _VSTD::forward<_BoundArgs>(__bound_args)...);\n}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <>\nstruct _LIBCPP_TEMPLATE_VIS hash<bool>\n    : public unary_function<bool, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(bool __v) const _NOEXCEPT {return static_cast<size_t>(__v);}\n};\n\ntemplate <>\nstruct _LIBCPP_TEMPLATE_VIS hash<char>\n    : public unary_function<char, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(char __v) const _NOEXCEPT {return static_cast<size_t>(__v);}\n};\n\ntemplate <>\nstruct _LIBCPP_TEMPLATE_VIS hash<signed char>\n    : public unary_function<signed char, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(signed char __v) const _NOEXCEPT {return static_cast<size_t>(__v);}\n};\n\ntemplate <>\nstruct _LIBCPP_TEMPLATE_VIS hash<unsigned char>\n    : public unary_function<unsigned char, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(unsigned char __v) const _NOEXCEPT {return static_cast<size_t>(__v);}\n};\n\n#ifndef _LIBCPP_HAS_NO_UNICODE_CHARS\n\ntemplate <>\nstruct _LIBCPP_TEMPLATE_VIS hash<char16_t>\n    : public unary_function<char16_t, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(char16_t __v) const _NOEXCEPT {return static_cast<size_t>(__v);}\n};\n\ntemplate <>\nstruct _LIBCPP_TEMPLATE_VIS hash<char32_t>\n    : public unary_function<char32_t, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(char32_t __v) const _NOEXCEPT {return static_cast<size_t>(__v);}\n};\n\n#endif  // _LIBCPP_HAS_NO_UNICODE_CHARS\n\ntemplate <>\nstruct _LIBCPP_TEMPLATE_VIS hash<wchar_t>\n    : public unary_function<wchar_t, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(wchar_t __v) const _NOEXCEPT {return static_cast<size_t>(__v);}\n};\n\ntemplate <>\nstruct _LIBCPP_TEMPLATE_VIS hash<short>\n    : public unary_function<short, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(short __v) const _NOEXCEPT {return static_cast<size_t>(__v);}\n};\n\ntemplate <>\nstruct _LIBCPP_TEMPLATE_VIS hash<unsigned short>\n    : public unary_function<unsigned short, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(unsigned short __v) const _NOEXCEPT {return static_cast<size_t>(__v);}\n};\n\ntemplate <>\nstruct _LIBCPP_TEMPLATE_VIS hash<int>\n    : public unary_function<int, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(int __v) const _NOEXCEPT {return static_cast<size_t>(__v);}\n};\n\ntemplate <>\nstruct _LIBCPP_TEMPLATE_VIS hash<unsigned int>\n    : public unary_function<unsigned int, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(unsigned int __v) const _NOEXCEPT {return static_cast<size_t>(__v);}\n};\n\ntemplate <>\nstruct _LIBCPP_TEMPLATE_VIS hash<long>\n    : public unary_function<long, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(long __v) const _NOEXCEPT {return static_cast<size_t>(__v);}\n};\n\ntemplate <>\nstruct _LIBCPP_TEMPLATE_VIS hash<unsigned long>\n    : public unary_function<unsigned long, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(unsigned long __v) const _NOEXCEPT {return static_cast<size_t>(__v);}\n};\n\ntemplate <>\nstruct _LIBCPP_TEMPLATE_VIS hash<long long>\n    : public __scalar_hash<long long>\n{\n};\n\ntemplate <>\nstruct _LIBCPP_TEMPLATE_VIS hash<unsigned long long>\n    : public __scalar_hash<unsigned long long>\n{\n};\n\n#ifndef _LIBCPP_HAS_NO_INT128\n\ntemplate <>\nstruct _LIBCPP_TEMPLATE_VIS hash<__int128_t>\n    : public __scalar_hash<__int128_t>\n{\n};\n\ntemplate <>\nstruct _LIBCPP_TEMPLATE_VIS hash<__uint128_t>\n    : public __scalar_hash<__uint128_t>\n{\n};\n\n#endif\n\ntemplate <>\nstruct _LIBCPP_TEMPLATE_VIS hash<float>\n    : public __scalar_hash<float>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(float __v) const _NOEXCEPT\n    {\n        // -0.0 and 0.0 should return same hash\n       if (__v == 0)\n           return 0;\n        return __scalar_hash<float>::operator()(__v);\n    }\n};\n\ntemplate <>\nstruct _LIBCPP_TEMPLATE_VIS hash<double>\n    : public __scalar_hash<double>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(double __v) const _NOEXCEPT\n    {\n        // -0.0 and 0.0 should return same hash\n       if (__v == 0)\n           return 0;\n        return __scalar_hash<double>::operator()(__v);\n    }\n};\n\ntemplate <>\nstruct _LIBCPP_TEMPLATE_VIS hash<long double>\n    : public __scalar_hash<long double>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(long double __v) const _NOEXCEPT\n    {\n        // -0.0 and 0.0 should return same hash\n        if (__v == 0)\n            return 0;\n#if defined(__i386__)\n        // Zero out padding bits\n        union\n        {\n            long double __t;\n            struct\n            {\n                size_t __a;\n                size_t __b;\n                size_t __c;\n                size_t __d;\n            } __s;\n        } __u;\n        __u.__s.__a = 0;\n        __u.__s.__b = 0;\n        __u.__s.__c = 0;\n        __u.__s.__d = 0;\n        __u.__t = __v;\n        return __u.__s.__a ^ __u.__s.__b ^ __u.__s.__c ^ __u.__s.__d;\n#elif defined(__x86_64__)\n        // Zero out padding bits\n        union\n        {\n            long double __t;\n            struct\n            {\n                size_t __a;\n                size_t __b;\n            } __s;\n        } __u;\n        __u.__s.__a = 0;\n        __u.__s.__b = 0;\n        __u.__t = __v;\n        return __u.__s.__a ^ __u.__s.__b;\n#else\n        return __scalar_hash<long double>::operator()(__v);\n#endif\n    }\n};\n\n#if _LIBCPP_STD_VER > 11\n\ntemplate <class _Tp, bool = is_enum<_Tp>::value>\nstruct _LIBCPP_TEMPLATE_VIS __enum_hash\n    : public unary_function<_Tp, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(_Tp __v) const _NOEXCEPT\n    {\n        typedef typename underlying_type<_Tp>::type type;\n        return hash<type>{}(static_cast<type>(__v));\n    }\n};\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS __enum_hash<_Tp, false> {\n    __enum_hash() = delete;\n    __enum_hash(__enum_hash const&) = delete;\n    __enum_hash& operator=(__enum_hash const&) = delete;\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS hash : public __enum_hash<_Tp>\n{\n};\n#endif\n\n\n#if _LIBCPP_STD_VER > 14\n\n#define __cpp_lib_invoke 201411\n\ntemplate <class _Fn, class ..._Args>\nresult_of_t<_Fn&&(_Args&&...)>\ninvoke(_Fn&& __f, _Args&&... __args)\n    noexcept(noexcept(_VSTD::__invoke(_VSTD::forward<_Fn>(__f), _VSTD::forward<_Args>(__args)...)))\n{\n    return _VSTD::__invoke(_VSTD::forward<_Fn>(__f), _VSTD::forward<_Args>(__args)...);\n}\n\ntemplate <class _DecayFunc>\nclass _LIBCPP_TEMPLATE_VIS __not_fn_imp {\n  _DecayFunc __fd;\n\npublic:\n    __not_fn_imp() = delete;\n\n    template <class ..._Args>\n    _LIBCPP_INLINE_VISIBILITY\n    auto operator()(_Args&& ...__args) &\n            noexcept(noexcept(!_VSTD::invoke(__fd, _VSTD::forward<_Args>(__args)...)))\n        -> decltype(          !_VSTD::invoke(__fd, _VSTD::forward<_Args>(__args)...))\n        { return              !_VSTD::invoke(__fd, _VSTD::forward<_Args>(__args)...); }\n\n    template <class ..._Args>\n    _LIBCPP_INLINE_VISIBILITY\n    auto operator()(_Args&& ...__args) &&\n            noexcept(noexcept(!_VSTD::invoke(_VSTD::move(__fd), _VSTD::forward<_Args>(__args)...)))\n        -> decltype(          !_VSTD::invoke(_VSTD::move(__fd), _VSTD::forward<_Args>(__args)...))\n        { return              !_VSTD::invoke(_VSTD::move(__fd), _VSTD::forward<_Args>(__args)...); }\n\n    template <class ..._Args>\n    _LIBCPP_INLINE_VISIBILITY\n    auto operator()(_Args&& ...__args) const&\n            noexcept(noexcept(!_VSTD::invoke(__fd, _VSTD::forward<_Args>(__args)...)))\n        -> decltype(          !_VSTD::invoke(__fd, _VSTD::forward<_Args>(__args)...))\n        { return              !_VSTD::invoke(__fd, _VSTD::forward<_Args>(__args)...); }\n\n\n    template <class ..._Args>\n    _LIBCPP_INLINE_VISIBILITY\n    auto operator()(_Args&& ...__args) const&&\n            noexcept(noexcept(!_VSTD::invoke(_VSTD::move(__fd), _VSTD::forward<_Args>(__args)...)))\n        -> decltype(          !_VSTD::invoke(_VSTD::move(__fd), _VSTD::forward<_Args>(__args)...))\n        { return              !_VSTD::invoke(_VSTD::move(__fd), _VSTD::forward<_Args>(__args)...); }\n\nprivate:\n    template <class _RawFunc,\n              class = enable_if_t<!is_same<decay_t<_RawFunc>, __not_fn_imp>::value>>\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __not_fn_imp(_RawFunc&& __rf)\n        : __fd(_VSTD::forward<_RawFunc>(__rf)) {}\n\n    template <class _RawFunc>\n    friend inline _LIBCPP_INLINE_VISIBILITY\n    __not_fn_imp<decay_t<_RawFunc>> not_fn(_RawFunc&&);\n};\n\ntemplate <class _RawFunc>\ninline _LIBCPP_INLINE_VISIBILITY\n__not_fn_imp<decay_t<_RawFunc>> not_fn(_RawFunc&& __fn) {\n    return __not_fn_imp<decay_t<_RawFunc>>(_VSTD::forward<_RawFunc>(__fn));\n}\n\n#endif\n\n// struct hash<T*> in <memory>\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_FUNCTIONAL\n","//\n//  polynomial.h\n//  ARToolKit5\n//\n//  This file is part of ARToolKit.\n//\n//  ARToolKit is free software: you can redistribute it and/or modify\n//  it under the terms of the GNU Lesser General Public License as published by\n//  the Free Software Foundation, either version 3 of the License, or\n//  (at your option) any later version.\n//\n//  ARToolKit is distributed in the hope that it will be useful,\n//  but WITHOUT ANY WARRANTY; without even the implied warranty of\n//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n//  GNU Lesser General Public License for more details.\n//\n//  You should have received a copy of the GNU Lesser General Public License\n//  along with ARToolKit.  If not, see <http://www.gnu.org/licenses/>.\n//\n//  As a special exception, the copyright holders of this library give you\n//  permission to link this library with independent modules to produce an\n//  executable, regardless of the license terms of these independent modules, and to\n//  copy and distribute the resulting executable under terms of your choice,\n//  provided that you also meet, for each linked independent module, the terms and\n//  conditions of the license of that module. An independent module is a module\n//  which is neither derived from nor based on this library. If you modify this\n//  library, you may extend this exception to your version of the library, but you\n//  are not obligated to do so. If you do not wish to do so, delete this exception\n//  statement from your version.\n//\n//  Copyright 2013-2015 Daqri, LLC.\n//\n//  Author(s): Chris Broaddus\n//\n\n#pragma once\n\nnamespace vision {\n\n    /**\n     * Fit a quatratic to 3 points. The system of equations is:\n     *\n     * y0 = A*x0^2 + B*x0 + C\n     * y1 = A*x1^2 + B*x1 + C\n     * y2 = A*x2^2 + B*x2 + C\n     *\n     * This system of equations is solved for A,B,C.\n     *\n     * @param[out] A\n     * @param[out] B\n     * @param[out] C\n     * @param[in] p1 2D point 1\n     * @param[in] p2 2D point 2\n     * @param[in] p3 2D point 3\n     * @return True if the quatratic could be fit, otherwise false.\n     */\n    template<typename T>\n\tinline bool Quadratic3Points(T& A,\n                                 T& B,\n                                 T& C,\n                                 const T p1[2],\n                                 const T p2[2],\n                                 const T p3[2]) {\n\t\tT d1 = (p3[0]-p2[0])*(p3[0]-p1[0]);\n        T d2 = (p1[0]-p2[0])*(p3[0]-p1[0]);\n\t\tT d3 = p1[0]-p2[0];\n\t\t\n        // If any of the denominators are zero then return FALSE.\n\t\tif(d1 == 0 ||\n           d2 == 0 ||\n           d3 == 0) {\n\t\t\tA = 0;\n\t\t\tB = 0;\n\t\t\tC = 0;\n\t\t\treturn false;\n\t\t}\n\t\telse {\n\t\t\tT a = p1[0]*p1[0];\n\t\t\tT b = p2[0]*p2[0];\n\t\t\t\n            // Solve for the coefficients A,B,C\n\t\t\tA = ((p3[1]-p2[1])/d1)-((p1[1]-p2[1])/d2);\n\t\t\tB = ((p1[1]-p2[1])+(A*(b-a)))/d3;\n\t\t\tC = p1[1]-(A*a)-(B*p1[0]);\n\t\t\treturn true;\n\t\t}\n\t}\n    \n    /**\n     * Evaluate a quatratic function.\n     */\n    template<typename T>\n    inline T QuadraticEval(T A, T B, T C, const T x) {\n        return A*x*x + B*x + C;\n    }\n    \n    /**\n\t * Find the critical point of a quadratic.\n     *\n     * y = A*x^2 + B*x + C\n     *\n     * This function finds where \"x\" where dy/dx = 0.\n\t *\n     * @param[out] x Parameter of the critical point.\n     * @param[in] A\n     * @param[in] B\n     * @param[in] C\n\t * @return True on success.\n\t */\n\ttemplate<typename T>\n\tinline bool QuadraticCriticalPoint(T& x, T A, T B, T C) {\n\t\tif(A == 0) {\n\t\t\treturn false;\n\t\t}\n\t\tx = -B/(2*A);\n\t\treturn true;\n\t}\n    \n    /**\n     * Find the derivate of the quadratic at a point.\n     */\n    template<typename T>\n    inline T QuadraticDerivative(T x, T A, T B) {\n        return 2*A*x + B;\n    }\n    \n} // vision","//\n//  binary_hierarchical_clustering.h\n//  ARToolKit5\n//\n//  This file is part of ARToolKit.\n//\n//  ARToolKit is free software: you can redistribute it and/or modify\n//  it under the terms of the GNU Lesser General Public License as published by\n//  the Free Software Foundation, either version 3 of the License, or\n//  (at your option) any later version.\n//\n//  ARToolKit is distributed in the hope that it will be useful,\n//  but WITHOUT ANY WARRANTY; without even the implied warranty of\n//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n//  GNU Lesser General Public License for more details.\n//\n//  You should have received a copy of the GNU Lesser General Public License\n//  along with ARToolKit.  If not, see <http://www.gnu.org/licenses/>.\n//\n//  As a special exception, the copyright holders of this library give you\n//  permission to link this library with independent modules to produce an\n//  executable, regardless of the license terms of these independent modules, and to\n//  copy and distribute the resulting executable under terms of your choice,\n//  provided that you also meet, for each linked independent module, the terms and\n//  conditions of the license of that module. An independent module is a module\n//  which is neither derived from nor based on this library. If you modify this\n//  library, you may extend this exception to your version of the library, but you\n//  are not obligated to do so. If you do not wish to do so, delete this exception\n//  statement from your version.\n//\n//  Copyright 2013-2015 Daqri, LLC.\n//\n//  Author(s): Chris Broaddus\n//\n\n#pragma once\n\n#include \"kmedoids.h\"\n\n#include <unordered_map>\n#include <queue>\n\nnamespace vision {\n    \n    // Forward declartion\n    template<int NUM_BYTES_PER_FEATURE>\n    class Node;\n    \n    /**\n     * The nodes in the tree are sorted as they are visited when a QUERY is done. This class\n     * represents an entry in a priority queue to revisit certains nodes in a back-trace.\n     */\n    template<int NUM_BYTES_PER_FEATURE>\n    class PriorityQueueItem {\n    public:\n        \n        typedef Node<NUM_BYTES_PER_FEATURE> node_t;\n        \n        PriorityQueueItem()\n        : mNode(NULL)\n        , mDistance(0) {}\n        PriorityQueueItem(const node_t* node, unsigned int dist)\n        : mNode(node), mDistance(dist) {}\n        ~PriorityQueueItem() {}\n    \n        /**\n         * Get pointer to node.\n         */\n        inline const node_t* node() const { return mNode; }\n        \n        /**\n         * Distance to cluster center.\n         */\n        inline unsigned int dist() const { return mDistance; }\n        \n        /**\n         * Operator for sorting the queue. Smallest item is always the first.\n         */\n        bool operator<(const PriorityQueueItem& item) const {\n            return mDistance > item.mDistance;\n        }\n        \n    private:\n    \n        // Pointer to the node\n        const node_t* mNode;\n    \n        // Distance from cluster center\n        unsigned int mDistance;\n    \n    }; // PriorityQueueItem\n    \n    /**\n     * Represents a node in the tree.\n     */\n    template<int NUM_BYTES_PER_FEATURE>\n    class Node {\n    public:\n        \n        typedef int node_id_t;\n        typedef Node<NUM_BYTES_PER_FEATURE> node_t;\n        typedef PriorityQueueItem<NUM_BYTES_PER_FEATURE> queue_item_t;\n        typedef std::priority_queue<queue_item_t> queue_t;\n        \n        Node(node_id_t id);\n        Node(node_id_t id, const unsigned char* center);\n        ~Node() {\n            for(size_t i = 0; i < mChildren.size(); i++) {\n                delete mChildren[i];\n            }\n        }\n        \n        /**\n         * @return Node id\n         */\n        inline node_id_t id() const { return mId; }\n        \n        /**\n         * Set/Get leaf flag\n         */\n        inline void leaf(bool b) { mLeaf = b; }\n        inline bool leaf() const { return mLeaf; }\n        \n        /**\n         * @return Get children\n         */\n        inline std::vector<node_t*>& children() { return mChildren; }\n        inline const std::vector<node_t*>& children() const { return mChildren; }\n        \n        /**\n         * @return Get the reverse index\n         */\n        inline std::vector<int>& reverseIndex() { return mReverseIndex; }\n        inline const std::vector<int>& reverseIndex() const { return mReverseIndex; }\n        \n        /**\n         * Get a queue of all the children nodes sorted by distance from node center.\n         */\n        inline void nearest(std::vector<const node_t*>& nodes,\n                            queue_t& queue,\n                            const unsigned char* feature) const {\n            unsigned int mind = std::numeric_limits<unsigned int>::max();\n            int mini = -1;\n            \n            // Compute the distance to each cluster center\n            std::vector<queue_item_t> v(mChildren.size());\n            for(size_t i = 0; i < v.size(); i++) {\n                unsigned int d = HammingDistance<NUM_BYTES_PER_FEATURE>(mChildren[i]->mCenter, feature);\n                v[i] = queue_item_t(mChildren[i], d);\n                if(d < mind) {\n                    mind = d;\n                    mini = (int)i;\n                }\n            }\n            ASSERT(mini != -1, \"Minimum index not set\");\n            \n            // Store the closest child\n            nodes.push_back(mChildren[mini]);\n            \n            // Any nodes that are the SAME distance as the minimum node are added\n            // to the output vector, otherwise it's pushed onto the queue.\n            for(size_t i = 0; i < v.size(); i++) {\n                if(i == mini) {\n                    continue;\n                } else if(v[i].dist() == v[mini].dist()) {\n                    nodes.push_back(mChildren[i]);\n                } else {\n                    queue.push(v[i]);\n                }\n            }\n        }\n        \n    private:\n        \n        // ID of the node\n        node_id_t mId;\n        \n        // Feature center\n        unsigned char mCenter[NUM_BYTES_PER_FEATURE];\n        \n        // True if a leaf node\n        bool mLeaf;\n        \n        // Child nodes\n        std::vector<node_t*> mChildren;\n        \n        // Index of the features at this node\n        std::vector<int> mReverseIndex;\n        \n    }; // Node\n\n    template<int NUM_BYTES_PER_FEATURE>\n    Node<NUM_BYTES_PER_FEATURE>::Node(node_id_t id)\n    : mId(id)\n    , mLeaf(true) {\n        ZeroVector(mCenter, NUM_BYTES_PER_FEATURE);\n    }\n            \n    template<int NUM_BYTES_PER_FEATURE>\n    Node<NUM_BYTES_PER_FEATURE>::Node(node_id_t id, const unsigned char* center)\n    : mId(id)\n    , mLeaf(true) {\n        CopyVector(mCenter, center, NUM_BYTES_PER_FEATURE);\n    }\n    \n    /**\n     * Implements hierarchical clustering for binary features. This can\n     * be used for fast nearest neighbor search.\n     */\n    template<int NUM_BYTES_PER_FEATURE>\n    class BinaryHierarchicalClustering {\n    public:\n        \n        typedef Node<NUM_BYTES_PER_FEATURE> node_t;\n        typedef std::unique_ptr<node_t> node_ptr_t;\n        typedef BinarykMedoids<NUM_BYTES_PER_FEATURE> kmedoids_t;\n        typedef std::unordered_map<int, std::vector<int> > cluster_map_t;\n        \n        typedef PriorityQueueItem<NUM_BYTES_PER_FEATURE> queue_item_t;\n        typedef std::priority_queue<queue_item_t> queue_t;\n        \n        BinaryHierarchicalClustering();\n        ~BinaryHierarchicalClustering() {}\n        \n        /**\n         * Build the tree.\n         */\n        void build(const unsigned char* features, int num_features);\n        \n        /**\n         * Query the tree for a reverse index.\n         */\n        int query(const unsigned char* feature) const;\n        \n        /**\n         * @return Reverse index after a QUERY.\n         */\n        inline const std::vector<int>& reverseIndex() const { return mQueryReverseIndex; }\n\n        /**\n         * Set/Get number of hypotheses\n         */\n        inline void setNumHypotheses(int n) { mBinarykMedoids.setNumHypotheses(n); }\n        inline int numHypotheses() const { return mBinarykMedoids.numHypotheses(); }\n        \n        /**\n         * Set/Get number of center.\n         */\n        inline void setNumCenters(int k) { mBinarykMedoids.setk(k); }\n        inline int numCenters() const { return mBinarykMedoids.k(); }\n        \n        /**\n         * Set/Get max nodes to pop from queue.\n         */\n        inline void setMaxNodesToPop(int n) { mMaxNodesToPop = n; }\n        inline int maxNodesPerPop() const { return mMaxNodesToPop; }\n        \n        /**\n         * Set/Get minimum number of features per node.\n         */\n        inline void setMinFeaturesPerNode(int n) { mMinFeaturePerNode = n; }\n        inline int minFeaturesPerNode() const { return mMinFeaturePerNode; }\n        \n    private:\n        \n        // Random number seed\n        int mRandSeed;\n        \n        // Counter for node id's\n        int mNextNodeId;\n        \n        // Root node\n        node_ptr_t mRoot;\n        \n        // Clustering algorithm\n        kmedoids_t mBinarykMedoids;\n        \n        // Reverse index for query\n        mutable std::vector<int> mQueryReverseIndex;\n        \n        // Node queue\n        mutable queue_t mQueue;\n        \n        // Number of nodes popped off the priority queue\n        mutable int mNumNodesPopped;\n        \n        // Maximum nodes to pop off the priority queue\n        int mMaxNodesToPop;\n        \n        // Minimum number of feature at a node\n        int mMinFeaturePerNode;\n        \n        /**\n         * Get the next node id\n         */\n        inline int nextNodeId() {\n            return mNextNodeId++;\n        }\n        \n        /**\n         * Private build function with a set of indices.\n         */\n        void build(const unsigned char* features, int num_features, const int* indices, int num_indices);\n        \n        /**\n         * Recursive function to build the tree.\n         */\n        void build(node_t* node, const unsigned char* features, int num_features, const int* indices, int num_indices);\n        \n        /**\n         * Recursive function query function.\n         */\n        void query(queue_t& queue, const node_t* node, const unsigned char* feature) const;\n        \n    }; // BinaryHierarchicalClustering\n\n    template<int NUM_BYTES_PER_FEATURE>\n    BinaryHierarchicalClustering<NUM_BYTES_PER_FEATURE>::BinaryHierarchicalClustering()\n    : mRandSeed(1234)\n    , mNextNodeId(0)\n    , mBinarykMedoids(mRandSeed)\n    , mNumNodesPopped(0)\n    , mMaxNodesToPop(0)\n    , mMinFeaturePerNode(16) {\n        mBinarykMedoids.setk(8);\n        mBinarykMedoids.setNumHypotheses(1);\n    }\n    \n    template<int NUM_BYTES_PER_FEATURE>\n    void BinaryHierarchicalClustering<NUM_BYTES_PER_FEATURE>::build(const unsigned char* features, int num_features) {\n        std::vector<int> indices(num_features);\n        for(size_t i = 0; i < indices.size(); i++) {\n            indices[i] = (int)i;\n        }\n        build(features, num_features, &indices[0], (int)indices.size());\n    }\n    \n    template<int NUM_BYTES_PER_FEATURE>\n    void BinaryHierarchicalClustering<NUM_BYTES_PER_FEATURE>::build(const unsigned char* features, int num_features, const int* indices, int num_indices) {\n        mRoot.reset(new node_t(nextNodeId()));\n        mRoot->leaf(false);\n        build(mRoot.get(), features, num_features, indices, num_indices);\n    }\n    \n    template<int NUM_BYTES_PER_FEATURE>\n    void BinaryHierarchicalClustering<NUM_BYTES_PER_FEATURE>::build(node_t* node, const unsigned char* features, int num_features, const int* indices, int num_indices) {\n        // Check if there are enough features to cluster.\n        // If not, then assign all features to the same cluster.\n        if(num_indices <= max2(mBinarykMedoids.k(), mMinFeaturePerNode)) {\n            node->leaf(true);\n            node->reverseIndex().resize(num_indices);\n            for(int i = 0; i < num_indices; i++) {\n                node->reverseIndex()[i] = indices[i];\n            }\n        } else {\n            cluster_map_t cluster_map;\n            \n            // Perform clustering\n            mBinarykMedoids.assign(features, num_features, indices, num_indices);\n            \n            // Get a list of features for each cluster center\n            const std::vector<int>& assignment = mBinarykMedoids.assignment();\n            ASSERT(assignment.size() == num_indices, \"Assignment size wrong\");\n            for(size_t i = 0; i < assignment.size(); i++) {\n                ASSERT(assignment[i] != -1, \"Assignment is invalid\");\n                ASSERT(assignment[i] < num_indices, \"Assignment out of range\");\n                ASSERT(indices[assignment[i]] < num_features, \"Assignment out of range\");\n                \n                cluster_map[indices[assignment[i]]].push_back(indices[i]);\n            }\n\n            // If there is only 1 cluster then make this node a leaf\n            if(cluster_map.size() == 1) {\n                node->leaf(true);\n                node->reverseIndex().resize(num_indices);\n                for(int i = 0; i < num_indices; i++) {\n                    node->reverseIndex()[i] = indices[i];\n                }\n                return;\n            }\n            \n            // Create a new node for each cluster center\n            node->children().reserve(cluster_map.size());\n            for(cluster_map_t::const_iterator it = cluster_map.begin();\n                it != cluster_map.end();\n                it++) {\n                ASSERT(it->second.size() != 0, \"Cluster must have atleaset 1 feature\");\n                \n                node_t* new_node = new node_t(nextNodeId(),\n                                              &features[it->first*NUM_BYTES_PER_FEATURE]);\n                new_node->leaf(false);\n                \n                // Make the new node a child of the input node\n                node->children().push_back(new_node);\n                \n                // Recursively build the tree\n                const std::vector<int>& v = it->second;\n                build(new_node, features, num_features, &v[0], (int)v.size());\n            }\n        }\n    }\n    \n    template<int NUM_BYTES_PER_FEATURE>\n    int BinaryHierarchicalClustering<NUM_BYTES_PER_FEATURE>::query(const unsigned char* feature) const {\n        ASSERT(mRoot.get(), \"Root cannot be NULL\");\n        \n        mNumNodesPopped = 0;\n        mQueryReverseIndex.clear();\n        \n        while(!mQueue.empty()) {\n            mQueue.pop();\n        }\n        \n        query(mQueue, mRoot.get(), feature);\n        \n        return (int)mQueryReverseIndex.size();\n    }\n    \n    template<int NUM_BYTES_PER_FEATURE>\n    void BinaryHierarchicalClustering<NUM_BYTES_PER_FEATURE>::query(queue_t& queue,\n                                                                    const node_t* node,\n                                                                    const unsigned char* feature) const {\n        if(node->leaf()) {\n            // Insert all the leaf indices into the query index\n            mQueryReverseIndex.insert(mQueryReverseIndex.end(),\n                                      node->reverseIndex().begin(),\n                                      node->reverseIndex().end());\n            return;\n        } else {\n            std::vector<const node_t*> nodes;\n            node->nearest(nodes, queue, feature);\n            for(size_t i = 0; i < nodes.size(); i++) {\n                query(queue, nodes[i], feature);\n            }\n            \n            // Pop a node from the queue\n            if(mNumNodesPopped < mMaxNodesToPop && !queue.empty()) {\n                const node_t* q = queue.top().node();\n                queue.pop();\n                mNumNodesPopped++;\n                query(queue, q, feature);\n            }\n        }\n    }\n    \n} // vision","// -*- C++ -*-\n//===-------------------------- unordered_map -----------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_UNORDERED_MAP\n#define _LIBCPP_UNORDERED_MAP\n\n/*\n\n    unordered_map synopsis\n\n#include <initializer_list>\n\nnamespace std\n{\n\ntemplate <class Key, class T, class Hash = hash<Key>, class Pred = equal_to<Key>,\n          class Alloc = allocator<pair<const Key, T>>>\nclass unordered_map\n{\npublic:\n    // types\n    typedef Key                                                        key_type;\n    typedef T                                                          mapped_type;\n    typedef Hash                                                       hasher;\n    typedef Pred                                                       key_equal;\n    typedef Alloc                                                      allocator_type;\n    typedef pair<const key_type, mapped_type>                          value_type;\n    typedef value_type&                                                reference;\n    typedef const value_type&                                          const_reference;\n    typedef typename allocator_traits<allocator_type>::pointer         pointer;\n    typedef typename allocator_traits<allocator_type>::const_pointer   const_pointer;\n    typedef typename allocator_traits<allocator_type>::size_type       size_type;\n    typedef typename allocator_traits<allocator_type>::difference_type difference_type;\n\n    typedef /unspecified/ iterator;\n    typedef /unspecified/ const_iterator;\n    typedef /unspecified/ local_iterator;\n    typedef /unspecified/ const_local_iterator;\n\n    unordered_map()\n        noexcept(\n            is_nothrow_default_constructible<hasher>::value &&\n            is_nothrow_default_constructible<key_equal>::value &&\n            is_nothrow_default_constructible<allocator_type>::value);\n    explicit unordered_map(size_type n, const hasher& hf = hasher(),\n                           const key_equal& eql = key_equal(),\n                           const allocator_type& a = allocator_type());\n    template <class InputIterator>\n        unordered_map(InputIterator f, InputIterator l,\n                      size_type n = 0, const hasher& hf = hasher(),\n                      const key_equal& eql = key_equal(),\n                      const allocator_type& a = allocator_type());\n    explicit unordered_map(const allocator_type&);\n    unordered_map(const unordered_map&);\n    unordered_map(const unordered_map&, const Allocator&);\n    unordered_map(unordered_map&&)\n        noexcept(\n            is_nothrow_move_constructible<hasher>::value &&\n            is_nothrow_move_constructible<key_equal>::value &&\n            is_nothrow_move_constructible<allocator_type>::value);\n    unordered_map(unordered_map&&, const Allocator&);\n    unordered_map(initializer_list<value_type>, size_type n = 0,\n                  const hasher& hf = hasher(), const key_equal& eql = key_equal(),\n                  const allocator_type& a = allocator_type());\n    unordered_map(size_type n, const allocator_type& a)\n      : unordered_map(n, hasher(), key_equal(), a) {}  // C++14\n    unordered_map(size_type n, const hasher& hf, const allocator_type& a)\n      : unordered_map(n, hf, key_equal(), a) {}  // C++14\n    template <class InputIterator>\n      unordered_map(InputIterator f, InputIterator l, size_type n, const allocator_type& a)\n      : unordered_map(f, l, n, hasher(), key_equal(), a) {}  // C++14\n    template <class InputIterator>\n      unordered_map(InputIterator f, InputIterator l, size_type n, const hasher& hf, \n        const allocator_type& a)\n      : unordered_map(f, l, n, hf, key_equal(), a) {}  // C++14\n    unordered_map(initializer_list<value_type> il, size_type n, const allocator_type& a)\n      : unordered_map(il, n, hasher(), key_equal(), a) {}  // C++14\n    unordered_map(initializer_list<value_type> il, size_type n, const hasher& hf, \n      const allocator_type& a)\n      : unordered_map(il, n, hf, key_equal(), a) {}  // C++14\n    ~unordered_map();\n    unordered_map& operator=(const unordered_map&);\n    unordered_map& operator=(unordered_map&&)\n        noexcept(\n            allocator_type::propagate_on_container_move_assignment::value &&\n            is_nothrow_move_assignable<allocator_type>::value &&\n            is_nothrow_move_assignable<hasher>::value &&\n            is_nothrow_move_assignable<key_equal>::value);\n    unordered_map& operator=(initializer_list<value_type>);\n\n    allocator_type get_allocator() const noexcept;\n\n    bool      empty() const noexcept;\n    size_type size() const noexcept;\n    size_type max_size() const noexcept;\n\n    iterator       begin() noexcept;\n    iterator       end() noexcept;\n    const_iterator begin()  const noexcept;\n    const_iterator end()    const noexcept;\n    const_iterator cbegin() const noexcept;\n    const_iterator cend()   const noexcept;\n\n    template <class... Args>\n        pair<iterator, bool> emplace(Args&&... args);\n    template <class... Args>\n        iterator emplace_hint(const_iterator position, Args&&... args);\n    pair<iterator, bool> insert(const value_type& obj);\n    template <class P>\n        pair<iterator, bool> insert(P&& obj);\n    iterator insert(const_iterator hint, const value_type& obj);\n    template <class P>\n        iterator insert(const_iterator hint, P&& obj);\n    template <class InputIterator>\n        void insert(InputIterator first, InputIterator last);\n    void insert(initializer_list<value_type>);\n\n    template <class... Args>\n        pair<iterator, bool> try_emplace(const key_type& k, Args&&... args);          // C++17\n    template <class... Args>\n        pair<iterator, bool> try_emplace(key_type&& k, Args&&... args);               // C++17\n    template <class... Args>\n        iterator try_emplace(const_iterator hint, const key_type& k, Args&&... args); // C++17\n    template <class... Args>\n        iterator try_emplace(const_iterator hint, key_type&& k, Args&&... args);      // C++17\n    template <class M>\n        pair<iterator, bool> insert_or_assign(const key_type& k, M&& obj);            // C++17\n    template <class M>\n        pair<iterator, bool> insert_or_assign(key_type&& k, M&& obj);                 // C++17\n    template <class M>\n        iterator insert_or_assign(const_iterator hint, const key_type& k, M&& obj);   // C++17\n    template <class M>\n        iterator insert_or_assign(const_iterator hint, key_type&& k, M&& obj);        // C++17\n\n    iterator erase(const_iterator position);\n    iterator erase(iterator position);  // C++14\n    size_type erase(const key_type& k);\n    iterator erase(const_iterator first, const_iterator last);\n    void clear() noexcept;\n\n    void swap(unordered_map&)\n        noexcept(\n            (!allocator_type::propagate_on_container_swap::value ||\n             __is_nothrow_swappable<allocator_type>::value) &&\n            __is_nothrow_swappable<hasher>::value &&\n            __is_nothrow_swappable<key_equal>::value);\n\n    hasher hash_function() const;\n    key_equal key_eq() const;\n\n    iterator       find(const key_type& k);\n    const_iterator find(const key_type& k) const;\n    size_type count(const key_type& k) const;\n    pair<iterator, iterator>             equal_range(const key_type& k);\n    pair<const_iterator, const_iterator> equal_range(const key_type& k) const;\n\n    mapped_type& operator[](const key_type& k);\n    mapped_type& operator[](key_type&& k);\n\n    mapped_type&       at(const key_type& k);\n    const mapped_type& at(const key_type& k) const;\n\n    size_type bucket_count() const noexcept;\n    size_type max_bucket_count() const noexcept;\n\n    size_type bucket_size(size_type n) const;\n    size_type bucket(const key_type& k) const;\n\n    local_iterator       begin(size_type n);\n    local_iterator       end(size_type n);\n    const_local_iterator begin(size_type n) const;\n    const_local_iterator end(size_type n) const;\n    const_local_iterator cbegin(size_type n) const;\n    const_local_iterator cend(size_type n) const;\n\n    float load_factor() const noexcept;\n    float max_load_factor() const noexcept;\n    void max_load_factor(float z);\n    void rehash(size_type n);\n    void reserve(size_type n);\n};\n\ntemplate <class Key, class T, class Hash, class Pred, class Alloc>\n    void swap(unordered_map<Key, T, Hash, Pred, Alloc>& x,\n              unordered_map<Key, T, Hash, Pred, Alloc>& y)\n              noexcept(noexcept(x.swap(y)));\n\ntemplate <class Key, class T, class Hash, class Pred, class Alloc>\n    bool\n    operator==(const unordered_map<Key, T, Hash, Pred, Alloc>& x,\n               const unordered_map<Key, T, Hash, Pred, Alloc>& y);\n\ntemplate <class Key, class T, class Hash, class Pred, class Alloc>\n    bool\n    operator!=(const unordered_map<Key, T, Hash, Pred, Alloc>& x,\n               const unordered_map<Key, T, Hash, Pred, Alloc>& y);\n\ntemplate <class Key, class T, class Hash = hash<Key>, class Pred = equal_to<Key>,\n          class Alloc = allocator<pair<const Key, T>>>\nclass unordered_multimap\n{\npublic:\n    // types\n    typedef Key                                                        key_type;\n    typedef T                                                          mapped_type;\n    typedef Hash                                                       hasher;\n    typedef Pred                                                       key_equal;\n    typedef Alloc                                                      allocator_type;\n    typedef pair<const key_type, mapped_type>                          value_type;\n    typedef value_type&                                                reference;\n    typedef const value_type&                                          const_reference;\n    typedef typename allocator_traits<allocator_type>::pointer         pointer;\n    typedef typename allocator_traits<allocator_type>::const_pointer   const_pointer;\n    typedef typename allocator_traits<allocator_type>::size_type       size_type;\n    typedef typename allocator_traits<allocator_type>::difference_type difference_type;\n\n    typedef /unspecified/ iterator;\n    typedef /unspecified/ const_iterator;\n    typedef /unspecified/ local_iterator;\n    typedef /unspecified/ const_local_iterator;\n\n    unordered_multimap()\n        noexcept(\n            is_nothrow_default_constructible<hasher>::value &&\n            is_nothrow_default_constructible<key_equal>::value &&\n            is_nothrow_default_constructible<allocator_type>::value);\n    explicit unordered_multimap(size_type n, const hasher& hf = hasher(),\n                           const key_equal& eql = key_equal(),\n                           const allocator_type& a = allocator_type());\n    template <class InputIterator>\n        unordered_multimap(InputIterator f, InputIterator l,\n                      size_type n = 0, const hasher& hf = hasher(),\n                      const key_equal& eql = key_equal(),\n                      const allocator_type& a = allocator_type());\n    explicit unordered_multimap(const allocator_type&);\n    unordered_multimap(const unordered_multimap&);\n    unordered_multimap(const unordered_multimap&, const Allocator&);\n    unordered_multimap(unordered_multimap&&)\n        noexcept(\n            is_nothrow_move_constructible<hasher>::value &&\n            is_nothrow_move_constructible<key_equal>::value &&\n            is_nothrow_move_constructible<allocator_type>::value);\n    unordered_multimap(unordered_multimap&&, const Allocator&);\n    unordered_multimap(initializer_list<value_type>, size_type n = 0,\n                  const hasher& hf = hasher(), const key_equal& eql = key_equal(),\n                  const allocator_type& a = allocator_type());\n    unordered_multimap(size_type n, const allocator_type& a)\n      : unordered_multimap(n, hasher(), key_equal(), a) {}  // C++14\n    unordered_multimap(size_type n, const hasher& hf, const allocator_type& a)\n      : unordered_multimap(n, hf, key_equal(), a) {}  // C++14\n    template <class InputIterator>\n      unordered_multimap(InputIterator f, InputIterator l, size_type n, const allocator_type& a)\n      : unordered_multimap(f, l, n, hasher(), key_equal(), a) {}  // C++14\n    template <class InputIterator>\n      unordered_multimap(InputIterator f, InputIterator l, size_type n, const hasher& hf, \n        const allocator_type& a)\n      : unordered_multimap(f, l, n, hf, key_equal(), a) {}  // C++14\n    unordered_multimap(initializer_list<value_type> il, size_type n, const allocator_type& a)\n      : unordered_multimap(il, n, hasher(), key_equal(), a) {}  // C++14\n    unordered_multimap(initializer_list<value_type> il, size_type n, const hasher& hf, \n      const allocator_type& a)\n      : unordered_multimap(il, n, hf, key_equal(), a) {}  // C++14\n    ~unordered_multimap();\n    unordered_multimap& operator=(const unordered_multimap&);\n    unordered_multimap& operator=(unordered_multimap&&)\n        noexcept(\n            allocator_type::propagate_on_container_move_assignment::value &&\n            is_nothrow_move_assignable<allocator_type>::value &&\n            is_nothrow_move_assignable<hasher>::value &&\n            is_nothrow_move_assignable<key_equal>::value);\n    unordered_multimap& operator=(initializer_list<value_type>);\n\n    allocator_type get_allocator() const noexcept;\n\n    bool      empty() const noexcept;\n    size_type size() const noexcept;\n    size_type max_size() const noexcept;\n\n    iterator       begin() noexcept;\n    iterator       end() noexcept;\n    const_iterator begin()  const noexcept;\n    const_iterator end()    const noexcept;\n    const_iterator cbegin() const noexcept;\n    const_iterator cend()   const noexcept;\n\n    template <class... Args>\n        iterator emplace(Args&&... args);\n    template <class... Args>\n        iterator emplace_hint(const_iterator position, Args&&... args);\n    iterator insert(const value_type& obj);\n    template <class P>\n        iterator insert(P&& obj);\n    iterator insert(const_iterator hint, const value_type& obj);\n    template <class P>\n        iterator insert(const_iterator hint, P&& obj);\n    template <class InputIterator>\n        void insert(InputIterator first, InputIterator last);\n    void insert(initializer_list<value_type>);\n\n    iterator erase(const_iterator position);\n    iterator erase(iterator position);  // C++14\n    size_type erase(const key_type& k);\n    iterator erase(const_iterator first, const_iterator last);\n    void clear() noexcept;\n\n    void swap(unordered_multimap&)\n        noexcept(\n            (!allocator_type::propagate_on_container_swap::value ||\n             __is_nothrow_swappable<allocator_type>::value) &&\n            __is_nothrow_swappable<hasher>::value &&\n            __is_nothrow_swappable<key_equal>::value);\n\n    hasher hash_function() const;\n    key_equal key_eq() const;\n\n    iterator       find(const key_type& k);\n    const_iterator find(const key_type& k) const;\n    size_type count(const key_type& k) const;\n    pair<iterator, iterator>             equal_range(const key_type& k);\n    pair<const_iterator, const_iterator> equal_range(const key_type& k) const;\n\n    size_type bucket_count() const noexcept;\n    size_type max_bucket_count() const noexcept;\n\n    size_type bucket_size(size_type n) const;\n    size_type bucket(const key_type& k) const;\n\n    local_iterator       begin(size_type n);\n    local_iterator       end(size_type n);\n    const_local_iterator begin(size_type n) const;\n    const_local_iterator end(size_type n) const;\n    const_local_iterator cbegin(size_type n) const;\n    const_local_iterator cend(size_type n) const;\n\n    float load_factor() const noexcept;\n    float max_load_factor() const noexcept;\n    void max_load_factor(float z);\n    void rehash(size_type n);\n    void reserve(size_type n);\n};\n\ntemplate <class Key, class T, class Hash, class Pred, class Alloc>\n    void swap(unordered_multimap<Key, T, Hash, Pred, Alloc>& x,\n              unordered_multimap<Key, T, Hash, Pred, Alloc>& y)\n              noexcept(noexcept(x.swap(y)));\n\ntemplate <class Key, class T, class Hash, class Pred, class Alloc>\n    bool\n    operator==(const unordered_multimap<Key, T, Hash, Pred, Alloc>& x,\n               const unordered_multimap<Key, T, Hash, Pred, Alloc>& y);\n\ntemplate <class Key, class T, class Hash, class Pred, class Alloc>\n    bool\n    operator!=(const unordered_multimap<Key, T, Hash, Pred, Alloc>& x,\n               const unordered_multimap<Key, T, Hash, Pred, Alloc>& y);\n\n}  // std\n\n*/\n\n#include <__config>\n#include <__hash_table>\n#include <functional>\n#include <stdexcept>\n#include <tuple>\n\n#include <__debug>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\ntemplate <class _Key, class _Cp, class _Hash,\n          bool = is_empty<_Hash>::value && !__libcpp_is_final<_Hash>::value\n         >\nclass __unordered_map_hasher\n    : private _Hash\n{\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    __unordered_map_hasher()\n        _NOEXCEPT_(is_nothrow_default_constructible<_Hash>::value)\n        : _Hash() {}\n    _LIBCPP_INLINE_VISIBILITY\n    __unordered_map_hasher(const _Hash& __h)\n        _NOEXCEPT_(is_nothrow_copy_constructible<_Hash>::value)\n        : _Hash(__h) {}\n    _LIBCPP_INLINE_VISIBILITY\n    const _Hash& hash_function() const _NOEXCEPT {return *this;}\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(const _Cp& __x) const\n        {return static_cast<const _Hash&>(*this)(__x.__cc.first);}\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(const _Key& __x) const\n        {return static_cast<const _Hash&>(*this)(__x);}\n    void swap(__unordered_map_hasher&__y)\n        _NOEXCEPT_(__is_nothrow_swappable<_Hash>::value)\n    {\n        using _VSTD::swap;\n        swap(static_cast<const _Hash&>(*this), static_cast<const _Hash&>(__y));\n    }\n};\n\ntemplate <class _Key, class _Cp, class _Hash>\nclass __unordered_map_hasher<_Key, _Cp, _Hash, false>\n{\n    _Hash __hash_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    __unordered_map_hasher()\n        _NOEXCEPT_(is_nothrow_default_constructible<_Hash>::value)\n        : __hash_() {}\n    _LIBCPP_INLINE_VISIBILITY\n    __unordered_map_hasher(const _Hash& __h)\n        _NOEXCEPT_(is_nothrow_copy_constructible<_Hash>::value)\n        : __hash_(__h) {}\n    _LIBCPP_INLINE_VISIBILITY\n    const _Hash& hash_function() const _NOEXCEPT {return __hash_;}\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(const _Cp& __x) const\n        {return __hash_(__x.__cc.first);}\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(const _Key& __x) const\n        {return __hash_(__x);}\n    void swap(__unordered_map_hasher&__y)\n        _NOEXCEPT_(__is_nothrow_swappable<_Hash>::value)\n    {\n        using _VSTD::swap;\n        swap(__hash_, __y.__hash_);\n    }\n};\n\ntemplate <class _Key, class _Cp, class _Hash, bool __b>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(__unordered_map_hasher<_Key, _Cp, _Hash, __b>& __x,\n     __unordered_map_hasher<_Key, _Cp, _Hash, __b>& __y)\n    _NOEXCEPT_(_NOEXCEPT_(__x.swap(__y)))\n{\n    __x.swap(__y);\n}\n\ntemplate <class _Key, class _Cp, class _Pred,\n          bool = is_empty<_Pred>::value && !__libcpp_is_final<_Pred>::value\n         >\nclass __unordered_map_equal\n    : private _Pred\n{\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    __unordered_map_equal()\n        _NOEXCEPT_(is_nothrow_default_constructible<_Pred>::value)\n        : _Pred() {}\n    _LIBCPP_INLINE_VISIBILITY\n    __unordered_map_equal(const _Pred& __p)\n        _NOEXCEPT_(is_nothrow_copy_constructible<_Pred>::value)\n        : _Pred(__p) {}\n    _LIBCPP_INLINE_VISIBILITY\n    const _Pred& key_eq() const _NOEXCEPT {return *this;}\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const _Cp& __x, const _Cp& __y) const\n        {return static_cast<const _Pred&>(*this)(__x.__cc.first, __y.__cc.first);}\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const _Cp& __x, const _Key& __y) const\n        {return static_cast<const _Pred&>(*this)(__x.__cc.first, __y);}\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const _Key& __x, const _Cp& __y) const\n        {return static_cast<const _Pred&>(*this)(__x, __y.__cc.first);}\n    void swap(__unordered_map_equal&__y)\n        _NOEXCEPT_(__is_nothrow_swappable<_Pred>::value)\n    {\n        using _VSTD::swap;\n        swap(static_cast<const _Pred&>(*this), static_cast<const _Pred&>(__y));\n    }\n};\n\ntemplate <class _Key, class _Cp, class _Pred>\nclass __unordered_map_equal<_Key, _Cp, _Pred, false>\n{\n    _Pred __pred_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    __unordered_map_equal()\n        _NOEXCEPT_(is_nothrow_default_constructible<_Pred>::value)\n        : __pred_() {}\n    _LIBCPP_INLINE_VISIBILITY\n    __unordered_map_equal(const _Pred& __p)\n        _NOEXCEPT_(is_nothrow_copy_constructible<_Pred>::value)\n        : __pred_(__p) {}\n    _LIBCPP_INLINE_VISIBILITY\n    const _Pred& key_eq() const _NOEXCEPT {return __pred_;}\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const _Cp& __x, const _Cp& __y) const\n        {return __pred_(__x.__cc.first, __y.__cc.first);}\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const _Cp& __x, const _Key& __y) const\n        {return __pred_(__x.__cc.first, __y);}\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const _Key& __x, const _Cp& __y) const\n        {return __pred_(__x, __y.__cc.first);}\n    void swap(__unordered_map_equal&__y)\n        _NOEXCEPT_(__is_nothrow_swappable<_Pred>::value)\n    {\n        using _VSTD::swap;\n        swap(__pred_, __y.__pred_);\n    }\n};\n\ntemplate <class _Key, class _Cp, class _Pred, bool __b>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(__unordered_map_equal<_Key, _Cp, _Pred, __b>& __x,\n     __unordered_map_equal<_Key, _Cp, _Pred, __b>& __y)\n    _NOEXCEPT_(_NOEXCEPT_(__x.swap(__y)))\n{\n    __x.swap(__y);\n}\n\ntemplate <class _Alloc>\nclass __hash_map_node_destructor\n{\n    typedef _Alloc                              allocator_type;\n    typedef allocator_traits<allocator_type>    __alloc_traits;\n\npublic:\n\n    typedef typename __alloc_traits::pointer       pointer;\nprivate:\n\n    allocator_type& __na_;\n\n    __hash_map_node_destructor& operator=(const __hash_map_node_destructor&);\n\npublic:\n    bool __first_constructed;\n    bool __second_constructed;\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __hash_map_node_destructor(allocator_type& __na) _NOEXCEPT\n        : __na_(__na),\n          __first_constructed(false),\n          __second_constructed(false)\n        {}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    __hash_map_node_destructor(__hash_node_destructor<allocator_type>&& __x)\n        _NOEXCEPT\n        : __na_(__x.__na_),\n          __first_constructed(__x.__value_constructed),\n          __second_constructed(__x.__value_constructed)\n        {\n            __x.__value_constructed = false;\n        }\n#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    __hash_map_node_destructor(const __hash_node_destructor<allocator_type>& __x)\n        : __na_(__x.__na_),\n          __first_constructed(__x.__value_constructed),\n          __second_constructed(__x.__value_constructed)\n        {\n            const_cast<bool&>(__x.__value_constructed) = false;\n        }\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    _LIBCPP_INLINE_VISIBILITY\n    void operator()(pointer __p) _NOEXCEPT\n    {\n        if (__second_constructed)\n            __alloc_traits::destroy(__na_, _VSTD::addressof(__p->__value_.__cc.second));\n        if (__first_constructed)\n            __alloc_traits::destroy(__na_, _VSTD::addressof(__p->__value_.__cc.first));\n        if (__p)\n            __alloc_traits::deallocate(__na_, __p, 1);\n    }\n};\n\n#ifndef _LIBCPP_CXX03_LANG\ntemplate <class _Key, class _Tp>\nunion __hash_value_type\n{\n    typedef _Key                                     key_type;\n    typedef _Tp                                      mapped_type;\n    typedef pair<const key_type, mapped_type>        value_type;\n    typedef pair<key_type, mapped_type>              __nc_value_type;\n\n    value_type __cc;\n    __nc_value_type __nc;\n\n    _LIBCPP_INLINE_VISIBILITY\n    __hash_value_type& operator=(const __hash_value_type& __v)\n        {__nc = __v.__cc; return *this;}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __hash_value_type& operator=(__hash_value_type&& __v)\n        {__nc = _VSTD::move(__v.__nc); return *this;}\n\n    template <class _ValueTp,\n              class = typename enable_if<\n                    __is_same_uncvref<_ValueTp, value_type>::value\n                 >::type\n             >\n    _LIBCPP_INLINE_VISIBILITY\n    __hash_value_type& operator=(_ValueTp&& __v) {\n        __nc = _VSTD::forward<_ValueTp>(__v); return *this;\n    }\n\nprivate:\n    __hash_value_type(const __hash_value_type& __v) = delete;\n    __hash_value_type(__hash_value_type&& __v) = delete;\n    template <class ..._Args>\n    explicit __hash_value_type(_Args&& ...__args) = delete;\n\n    ~__hash_value_type() = delete;\n};\n\n#else\n\ntemplate <class _Key, class _Tp>\nstruct __hash_value_type\n{\n    typedef _Key                                     key_type;\n    typedef _Tp                                      mapped_type;\n    typedef pair<const key_type, mapped_type>        value_type;\n\n    value_type __cc;\n\nprivate:\n   ~__hash_value_type();\n};\n\n#endif\n\ntemplate <class _HashIterator>\nclass _LIBCPP_TEMPLATE_VIS __hash_map_iterator\n{\n    _HashIterator __i_;\n\n    typedef  __hash_node_types_from_iterator<_HashIterator> _NodeTypes;\n\npublic:\n    typedef forward_iterator_tag                                 iterator_category;\n    typedef typename _NodeTypes::__map_value_type                value_type;\n    typedef typename _NodeTypes::difference_type                 difference_type;\n    typedef value_type&                                          reference;\n    typedef typename _NodeTypes::__map_value_type_pointer       pointer;\n\n    _LIBCPP_INLINE_VISIBILITY\n    __hash_map_iterator() _NOEXCEPT {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __hash_map_iterator(_HashIterator __i) _NOEXCEPT : __i_(__i) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    reference operator*() const {return __i_->__cc;}\n    _LIBCPP_INLINE_VISIBILITY\n    pointer operator->() const {return pointer_traits<pointer>::pointer_to(__i_->__cc);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __hash_map_iterator& operator++() {++__i_; return *this;}\n    _LIBCPP_INLINE_VISIBILITY\n    __hash_map_iterator operator++(int)\n    {\n        __hash_map_iterator __t(*this);\n        ++(*this);\n        return __t;\n    }\n\n    friend _LIBCPP_INLINE_VISIBILITY\n        bool operator==(const __hash_map_iterator& __x, const __hash_map_iterator& __y)\n        {return __x.__i_ == __y.__i_;}\n    friend _LIBCPP_INLINE_VISIBILITY\n        bool operator!=(const __hash_map_iterator& __x, const __hash_map_iterator& __y)\n        {return __x.__i_ != __y.__i_;}\n\n    template <class, class, class, class, class> friend class _LIBCPP_TEMPLATE_VIS unordered_map;\n    template <class, class, class, class, class> friend class _LIBCPP_TEMPLATE_VIS unordered_multimap;\n    template <class> friend class _LIBCPP_TEMPLATE_VIS __hash_const_iterator;\n    template <class> friend class _LIBCPP_TEMPLATE_VIS __hash_const_local_iterator;\n    template <class> friend class _LIBCPP_TEMPLATE_VIS __hash_map_const_iterator;\n};\n\ntemplate <class _HashIterator>\nclass _LIBCPP_TEMPLATE_VIS __hash_map_const_iterator\n{\n    _HashIterator __i_;\n\n    typedef  __hash_node_types_from_iterator<_HashIterator> _NodeTypes;\n\npublic:\n    typedef forward_iterator_tag                                 iterator_category;\n    typedef typename _NodeTypes::__map_value_type                value_type;\n    typedef typename _NodeTypes::difference_type                 difference_type;\n    typedef const value_type&                                    reference;\n    typedef typename _NodeTypes::__const_map_value_type_pointer  pointer;\n\n    _LIBCPP_INLINE_VISIBILITY\n    __hash_map_const_iterator() _NOEXCEPT {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __hash_map_const_iterator(_HashIterator __i) _NOEXCEPT : __i_(__i) {}\n    _LIBCPP_INLINE_VISIBILITY\n    __hash_map_const_iterator(\n            __hash_map_iterator<typename _HashIterator::__non_const_iterator> __i)\n                 _NOEXCEPT\n                : __i_(__i.__i_) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    reference operator*() const {return __i_->__cc;}\n    _LIBCPP_INLINE_VISIBILITY\n    pointer operator->() const {return pointer_traits<pointer>::pointer_to(__i_->__cc);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __hash_map_const_iterator& operator++() {++__i_; return *this;}\n    _LIBCPP_INLINE_VISIBILITY\n    __hash_map_const_iterator operator++(int)\n    {\n        __hash_map_const_iterator __t(*this);\n        ++(*this);\n        return __t;\n    }\n\n    friend _LIBCPP_INLINE_VISIBILITY\n        bool operator==(const __hash_map_const_iterator& __x, const __hash_map_const_iterator& __y)\n        {return __x.__i_ == __y.__i_;}\n    friend _LIBCPP_INLINE_VISIBILITY\n        bool operator!=(const __hash_map_const_iterator& __x, const __hash_map_const_iterator& __y)\n        {return __x.__i_ != __y.__i_;}\n\n    template <class, class, class, class, class> friend class _LIBCPP_TEMPLATE_VIS unordered_map;\n    template <class, class, class, class, class> friend class _LIBCPP_TEMPLATE_VIS unordered_multimap;\n    template <class> friend class _LIBCPP_TEMPLATE_VIS __hash_const_iterator;\n    template <class> friend class _LIBCPP_TEMPLATE_VIS __hash_const_local_iterator;\n};\n\ntemplate <class _Key, class _Tp, class _Hash = hash<_Key>, class _Pred = equal_to<_Key>,\n          class _Alloc = allocator<pair<const _Key, _Tp> > >\nclass _LIBCPP_TEMPLATE_VIS unordered_map\n{\npublic:\n    // types\n    typedef _Key                                           key_type;\n    typedef _Tp                                            mapped_type;\n    typedef _Hash                                          hasher;\n    typedef _Pred                                          key_equal;\n    typedef _Alloc                                         allocator_type;\n    typedef pair<const key_type, mapped_type>              value_type;\n    typedef pair<key_type, mapped_type>                    __nc_value_type;\n    typedef value_type&                                    reference;\n    typedef const value_type&                              const_reference;\n    static_assert((is_same<value_type, typename allocator_type::value_type>::value),\n                  \"Invalid allocator::value_type\");\n\nprivate:\n    typedef __hash_value_type<key_type, mapped_type>                 __value_type;\n    typedef __unordered_map_hasher<key_type, __value_type, hasher>   __hasher;\n    typedef __unordered_map_equal<key_type, __value_type, key_equal> __key_equal;\n    typedef typename __rebind_alloc_helper<allocator_traits<allocator_type>,\n                                                 __value_type>::type __allocator_type;\n\n    typedef __hash_table<__value_type, __hasher,\n                         __key_equal,  __allocator_type>   __table;\n\n    __table __table_;\n\n    typedef typename __table::_NodeTypes                   _NodeTypes;\n    typedef typename __table::__node_pointer               __node_pointer;\n    typedef typename __table::__node_const_pointer         __node_const_pointer;\n    typedef typename __table::__node_traits                __node_traits;\n    typedef typename __table::__node_allocator             __node_allocator;\n    typedef typename __table::__node                       __node;\n    typedef __hash_map_node_destructor<__node_allocator>   _Dp;\n    typedef unique_ptr<__node, _Dp>                         __node_holder;\n    typedef allocator_traits<allocator_type>               __alloc_traits;\n\n    static_assert((is_same<typename __table::__container_value_type, value_type>::value), \"\");\n    static_assert((is_same<typename __table::__node_value_type, __value_type>::value), \"\");\npublic:\n    typedef typename __alloc_traits::pointer         pointer;\n    typedef typename __alloc_traits::const_pointer   const_pointer;\n    typedef typename __table::size_type              size_type;\n    typedef typename __table::difference_type        difference_type;\n\n    typedef __hash_map_iterator<typename __table::iterator>       iterator;\n    typedef __hash_map_const_iterator<typename __table::const_iterator> const_iterator;\n    typedef __hash_map_iterator<typename __table::local_iterator> local_iterator;\n    typedef __hash_map_const_iterator<typename __table::const_local_iterator> const_local_iterator;\n\n    _LIBCPP_INLINE_VISIBILITY\n    unordered_map()\n        _NOEXCEPT_(is_nothrow_default_constructible<__table>::value)\n        {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n            __get_db()->__insert_c(this);\n#endif\n        }\n    explicit unordered_map(size_type __n, const hasher& __hf = hasher(),\n                           const key_equal& __eql = key_equal());\n    unordered_map(size_type __n, const hasher& __hf,\n                  const key_equal& __eql,\n                  const allocator_type& __a);\n    template <class _InputIterator>\n        unordered_map(_InputIterator __first, _InputIterator __last);\n    template <class _InputIterator>\n        unordered_map(_InputIterator __first, _InputIterator __last,\n                      size_type __n, const hasher& __hf = hasher(),\n                      const key_equal& __eql = key_equal());\n    template <class _InputIterator>\n        unordered_map(_InputIterator __first, _InputIterator __last,\n                      size_type __n, const hasher& __hf,\n                      const key_equal& __eql,\n                      const allocator_type& __a);\n    _LIBCPP_INLINE_VISIBILITY\n    explicit unordered_map(const allocator_type& __a);\n    unordered_map(const unordered_map& __u);\n    unordered_map(const unordered_map& __u, const allocator_type& __a);\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    unordered_map(unordered_map&& __u)\n        _NOEXCEPT_(is_nothrow_move_constructible<__table>::value);\n    unordered_map(unordered_map&& __u, const allocator_type& __a);\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    unordered_map(initializer_list<value_type> __il);\n    unordered_map(initializer_list<value_type> __il, size_type __n,\n                  const hasher& __hf = hasher(), const key_equal& __eql = key_equal());\n    unordered_map(initializer_list<value_type> __il, size_type __n,\n                  const hasher& __hf, const key_equal& __eql,\n                  const allocator_type& __a);\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n#if _LIBCPP_STD_VER > 11\n    _LIBCPP_INLINE_VISIBILITY\n    unordered_map(size_type __n, const allocator_type& __a)\n      : unordered_map(__n, hasher(), key_equal(), __a) {}\n    _LIBCPP_INLINE_VISIBILITY\n    unordered_map(size_type __n, const hasher& __hf, const allocator_type& __a)\n      : unordered_map(__n, __hf, key_equal(), __a) {}\n    template <class _InputIterator>\n    _LIBCPP_INLINE_VISIBILITY\n      unordered_map(_InputIterator __first, _InputIterator __last, size_type __n, const allocator_type& __a)\n      : unordered_map(__first, __last, __n, hasher(), key_equal(), __a) {}\n    template <class _InputIterator>\n    _LIBCPP_INLINE_VISIBILITY\n      unordered_map(_InputIterator __first, _InputIterator __last, size_type __n, const hasher& __hf, \n        const allocator_type& __a)\n      : unordered_map(__first, __last, __n, __hf, key_equal(), __a) {}\n    _LIBCPP_INLINE_VISIBILITY\n    unordered_map(initializer_list<value_type> __il, size_type __n, const allocator_type& __a)\n      : unordered_map(__il, __n, hasher(), key_equal(), __a) {}\n    _LIBCPP_INLINE_VISIBILITY\n    unordered_map(initializer_list<value_type> __il, size_type __n, const hasher& __hf, \n      const allocator_type& __a)\n      : unordered_map(__il, __n, __hf, key_equal(), __a) {}\n#endif\n    // ~unordered_map() = default;\n    _LIBCPP_INLINE_VISIBILITY\n    unordered_map& operator=(const unordered_map& __u)\n    {\n#ifndef _LIBCPP_CXX03_LANG\n        __table_ = __u.__table_;\n#else\n        if (this != &__u) {\n            __table_.clear();\n            __table_.hash_function() = __u.__table_.hash_function();\n            __table_.key_eq() = __u.__table_.key_eq();\n            __table_.max_load_factor() = __u.__table_.max_load_factor();\n            __table_.__copy_assign_alloc(__u.__table_);\n            insert(__u.begin(), __u.end());\n        }\n#endif\n        return *this;\n    }\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    unordered_map& operator=(unordered_map&& __u)\n        _NOEXCEPT_(is_nothrow_move_assignable<__table>::value);\n#endif\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    unordered_map& operator=(initializer_list<value_type> __il);\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    _LIBCPP_INLINE_VISIBILITY\n    allocator_type get_allocator() const _NOEXCEPT\n        {return allocator_type(__table_.__node_alloc());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    bool      empty() const _NOEXCEPT {return __table_.size() == 0;}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type size() const _NOEXCEPT  {return __table_.size();}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type max_size() const _NOEXCEPT {return __table_.max_size();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator       begin() _NOEXCEPT        {return __table_.begin();}\n    _LIBCPP_INLINE_VISIBILITY\n    iterator       end() _NOEXCEPT          {return __table_.end();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator begin()  const _NOEXCEPT {return __table_.begin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator end()    const _NOEXCEPT {return __table_.end();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator cbegin() const _NOEXCEPT {return __table_.begin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator cend()   const _NOEXCEPT {return __table_.end();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    pair<iterator, bool> insert(const value_type& __x)\n        {return __table_.__insert_unique(__x);}\n\n    iterator insert(const_iterator __p, const value_type& __x) {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__p) == this,\n            \"unordered_map::insert(const_iterator, const value_type&) called with an iterator not\"\n            \" referring to this unordered_map\");\n#else\n        ((void)__p);\n#endif\n        return insert(__x).first;\n    }\n\n    template <class _InputIterator>\n        _LIBCPP_INLINE_VISIBILITY\n        void insert(_InputIterator __first, _InputIterator __last);\n\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    void insert(initializer_list<value_type> __il)\n        {insert(__il.begin(), __il.end());}\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n#ifndef _LIBCPP_CXX03_LANG\n    _LIBCPP_INLINE_VISIBILITY\n    pair<iterator, bool> insert(value_type&& __x)\n        {return __table_.__insert_unique(_VSTD::move(__x));}\n\n    iterator insert(const_iterator __p, value_type&& __x) {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__p) == this,\n            \"unordered_map::insert(const_iterator, const value_type&) called with an iterator not\"\n            \" referring to this unordered_map\");\n#else\n        ((void)__p);\n#endif\n        return __table_.__insert_unique(_VSTD::move(__x)).first;\n    }\n\n    template <class _Pp,\n              class = typename enable_if<is_constructible<value_type, _Pp>::value>::type>\n        _LIBCPP_INLINE_VISIBILITY\n        pair<iterator, bool> insert(_Pp&& __x)\n            {return __table_.__insert_unique(_VSTD::forward<_Pp>(__x));}\n\n    template <class _Pp,\n              class = typename enable_if<is_constructible<value_type, _Pp>::value>::type>\n        _LIBCPP_INLINE_VISIBILITY\n        iterator insert(const_iterator __p, _Pp&& __x)\n        {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n            _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__p) == this,\n                \"unordered_map::insert(const_iterator, value_type&&) called with an iterator not\"\n                \" referring to this unordered_map\");\n#else\n          ((void)__p);\n#endif\n            return insert(_VSTD::forward<_Pp>(__x)).first;\n        }\n\n    template <class... _Args>\n    _LIBCPP_INLINE_VISIBILITY\n    pair<iterator, bool> emplace(_Args&&... __args) {\n        return __table_.__emplace_unique(_VSTD::forward<_Args>(__args)...);\n    }\n\n    template <class... _Args>\n    _LIBCPP_INLINE_VISIBILITY\n    iterator emplace_hint(const_iterator __p, _Args&&... __args) {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__p) == this,\n            \"unordered_map::emplace_hint(const_iterator, args...) called with an iterator not\"\n            \" referring to this unordered_map\");\n#else\n          ((void)__p);\n#endif\n        return __table_.__emplace_unique(_VSTD::forward<_Args>(__args)...).first;\n    }\n\n#endif  // _LIBCPP_CXX03_LANG\n\n#if _LIBCPP_STD_VER > 14\n    template <class... _Args>\n        _LIBCPP_INLINE_VISIBILITY\n        pair<iterator, bool> try_emplace(const key_type& __k, _Args&&... __args)\n    {\n        return __table_.__emplace_unique_key_args(__k, _VSTD::piecewise_construct,\n            _VSTD::forward_as_tuple(__k),\n            _VSTD::forward_as_tuple(_VSTD::forward<_Args>(__args)...));\n    }\n\n    template <class... _Args>\n        _LIBCPP_INLINE_VISIBILITY\n        pair<iterator, bool> try_emplace(key_type&& __k, _Args&&... __args)\n    {\n        return __table_.__emplace_unique_key_args(__k, _VSTD::piecewise_construct,\n            _VSTD::forward_as_tuple(_VSTD::move(__k)),\n            _VSTD::forward_as_tuple(_VSTD::forward<_Args>(__args)...));\n    }\n\n    template <class... _Args>\n        _LIBCPP_INLINE_VISIBILITY\n        iterator try_emplace(const_iterator __h, const key_type& __k, _Args&&... __args)\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__h) == this,\n            \"unordered_map::try_emplace(const_iterator, key, args...) called with an iterator not\"\n            \" referring to this unordered_map\");\n#else\n        ((void)__h);\n#endif\n        return try_emplace(__k, _VSTD::forward<_Args>(__args)...).first;\n    }\n\n    template <class... _Args>\n        _LIBCPP_INLINE_VISIBILITY\n        iterator try_emplace(const_iterator __h, key_type&& __k, _Args&&... __args)\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__h) == this,\n            \"unordered_map::try_emplace(const_iterator, key, args...) called with an iterator not\"\n            \" referring to this unordered_map\");\n#else\n        ((void)__h);\n#endif\n        return try_emplace(_VSTD::move(__k), _VSTD::forward<_Args>(__args)...).first;\n    }\n\n    template <class _Vp>\n        _LIBCPP_INLINE_VISIBILITY\n        pair<iterator, bool> insert_or_assign(const key_type& __k, _Vp&& __v)\n    {\n        pair<iterator, bool> __res = __table_.__emplace_unique_key_args(__k,\n            __k, _VSTD::forward<_Vp>(__v));\n        if (!__res.second) {\n            __res.first->second = _VSTD::forward<_Vp>(__v);\n        }\n        return __res;\n    }\n\n    template <class _Vp>\n        _LIBCPP_INLINE_VISIBILITY\n        pair<iterator, bool> insert_or_assign(key_type&& __k, _Vp&& __v)\n    {\n        pair<iterator, bool> __res = __table_.__emplace_unique_key_args(__k,\n            _VSTD::move(__k), _VSTD::forward<_Vp>(__v));\n        if (!__res.second) {\n            __res.first->second = _VSTD::forward<_Vp>(__v);\n        }\n        return __res;\n    }\n\n    template <class _Vp>\n        _LIBCPP_INLINE_VISIBILITY\n        iterator insert_or_assign(const_iterator, const key_type& __k, _Vp&& __v)\n     {\n          // FIXME: Add debug mode checking for the iterator input\n          return insert_or_assign(__k, _VSTD::forward<_Vp>(__v)).first;\n     }\n\n    template <class _Vp>\n        _LIBCPP_INLINE_VISIBILITY\n        iterator insert_or_assign(const_iterator, key_type&& __k, _Vp&& __v)\n     {\n        // FIXME: Add debug mode checking for the iterator input\n        return insert_or_assign(_VSTD::move(__k), _VSTD::forward<_Vp>(__v)).first;\n     }\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator erase(const_iterator __p) {return __table_.erase(__p.__i_);}\n    _LIBCPP_INLINE_VISIBILITY\n    iterator erase(iterator __p)       {return __table_.erase(__p.__i_);}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type erase(const key_type& __k) {return __table_.__erase_unique(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    iterator erase(const_iterator __first, const_iterator __last)\n        {return __table_.erase(__first.__i_, __last.__i_);}\n    _LIBCPP_INLINE_VISIBILITY\n    void clear() _NOEXCEPT {__table_.clear();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void swap(unordered_map& __u)\n        _NOEXCEPT_(__is_nothrow_swappable<__table>::value)\n        { __table_.swap(__u.__table_);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    hasher hash_function() const\n        {return __table_.hash_function().hash_function();}\n    _LIBCPP_INLINE_VISIBILITY\n    key_equal key_eq() const\n        {return __table_.key_eq().key_eq();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator       find(const key_type& __k)       {return __table_.find(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator find(const key_type& __k) const {return __table_.find(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type count(const key_type& __k) const {return __table_.__count_unique(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    pair<iterator, iterator>             equal_range(const key_type& __k)\n        {return __table_.__equal_range_unique(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    pair<const_iterator, const_iterator> equal_range(const key_type& __k) const\n        {return __table_.__equal_range_unique(__k);}\n\n    mapped_type& operator[](const key_type& __k);\n#ifndef _LIBCPP_CXX03_LANG\n    mapped_type& operator[](key_type&& __k);\n#endif\n\n    mapped_type&       at(const key_type& __k);\n    const mapped_type& at(const key_type& __k) const;\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type bucket_count() const _NOEXCEPT {return __table_.bucket_count();}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type max_bucket_count() const _NOEXCEPT {return __table_.max_bucket_count();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type bucket_size(size_type __n) const\n        {return __table_.bucket_size(__n);}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type bucket(const key_type& __k) const {return __table_.bucket(__k);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    local_iterator       begin(size_type __n)        {return __table_.begin(__n);}\n    _LIBCPP_INLINE_VISIBILITY\n    local_iterator       end(size_type __n)          {return __table_.end(__n);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_local_iterator begin(size_type __n) const  {return __table_.cbegin(__n);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_local_iterator end(size_type __n) const    {return __table_.cend(__n);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_local_iterator cbegin(size_type __n) const {return __table_.cbegin(__n);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_local_iterator cend(size_type __n) const   {return __table_.cend(__n);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    float load_factor() const _NOEXCEPT {return __table_.load_factor();}\n    _LIBCPP_INLINE_VISIBILITY\n    float max_load_factor() const _NOEXCEPT {return __table_.max_load_factor();}\n    _LIBCPP_INLINE_VISIBILITY\n    void max_load_factor(float __mlf) {__table_.max_load_factor(__mlf);}\n    _LIBCPP_INLINE_VISIBILITY\n    void rehash(size_type __n) {__table_.rehash(__n);}\n    _LIBCPP_INLINE_VISIBILITY\n    void reserve(size_type __n) {__table_.reserve(__n);}\n\n#if _LIBCPP_DEBUG_LEVEL >= 2\n\n    bool __dereferenceable(const const_iterator* __i) const\n        {return __table_.__dereferenceable(&__i->__i_);}\n    bool __decrementable(const const_iterator* __i) const\n        {return __table_.__decrementable(&__i->__i_);}\n    bool __addable(const const_iterator* __i, ptrdiff_t __n) const\n        {return __table_.__addable(&__i->__i_, __n);}\n    bool __subscriptable(const const_iterator* __i, ptrdiff_t __n) const\n        {return __table_.__addable(&__i->__i_, __n);}\n\n#endif  // _LIBCPP_DEBUG_LEVEL >= 2\n\nprivate:\n\n#ifdef _LIBCPP_CXX03_LANG\n    __node_holder __construct_node_with_key(const key_type& __k);\n#endif\n};\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\nunordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_map(\n        size_type __n, const hasher& __hf, const key_equal& __eql)\n    : __table_(__hf, __eql)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    __table_.rehash(__n);\n}\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\nunordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_map(\n        size_type __n, const hasher& __hf, const key_equal& __eql,\n        const allocator_type& __a)\n    : __table_(__hf, __eql, typename __table::allocator_type(__a))\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    __table_.rehash(__n);\n}\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\ninline\nunordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_map(\n        const allocator_type& __a)\n    : __table_(typename __table::allocator_type(__a))\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\ntemplate <class _InputIterator>\nunordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_map(\n        _InputIterator __first, _InputIterator __last)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    insert(__first, __last);\n}\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\ntemplate <class _InputIterator>\nunordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_map(\n        _InputIterator __first, _InputIterator __last, size_type __n,\n        const hasher& __hf, const key_equal& __eql)\n    : __table_(__hf, __eql)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    __table_.rehash(__n);\n    insert(__first, __last);\n}\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\ntemplate <class _InputIterator>\nunordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_map(\n        _InputIterator __first, _InputIterator __last, size_type __n,\n        const hasher& __hf, const key_equal& __eql, const allocator_type& __a)\n    : __table_(__hf, __eql, typename __table::allocator_type(__a))\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    __table_.rehash(__n);\n    insert(__first, __last);\n}\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\nunordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_map(\n        const unordered_map& __u)\n    : __table_(__u.__table_)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    __table_.rehash(__u.bucket_count());\n    insert(__u.begin(), __u.end());\n}\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\nunordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_map(\n        const unordered_map& __u, const allocator_type& __a)\n    : __table_(__u.__table_, typename __table::allocator_type(__a))\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    __table_.rehash(__u.bucket_count());\n    insert(__u.begin(), __u.end());\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\ninline\nunordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_map(\n        unordered_map&& __u)\n    _NOEXCEPT_(is_nothrow_move_constructible<__table>::value)\n    : __table_(_VSTD::move(__u.__table_))\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n    __get_db()->swap(this, &__u);\n#endif\n}\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\nunordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_map(\n        unordered_map&& __u, const allocator_type& __a)\n    : __table_(_VSTD::move(__u.__table_), typename __table::allocator_type(__a))\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    if (__a != __u.get_allocator())\n    {\n        iterator __i = __u.begin();\n        while (__u.size() != 0) {\n            __table_.__emplace_unique(_VSTD::move(\n                __u.__table_.remove((__i++).__i_)->__value_.__nc));\n        }\n    }\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    else\n        __get_db()->swap(this, &__u);\n#endif\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\nunordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_map(\n        initializer_list<value_type> __il)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    insert(__il.begin(), __il.end());\n}\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\nunordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_map(\n        initializer_list<value_type> __il, size_type __n, const hasher& __hf,\n        const key_equal& __eql)\n    : __table_(__hf, __eql)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    __table_.rehash(__n);\n    insert(__il.begin(), __il.end());\n}\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\nunordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_map(\n        initializer_list<value_type> __il, size_type __n, const hasher& __hf,\n        const key_equal& __eql, const allocator_type& __a)\n    : __table_(__hf, __eql, typename __table::allocator_type(__a))\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    __table_.rehash(__n);\n    insert(__il.begin(), __il.end());\n}\n\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\ninline\nunordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&\nunordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::operator=(unordered_map&& __u)\n    _NOEXCEPT_(is_nothrow_move_assignable<__table>::value)\n{\n    __table_ = _VSTD::move(__u.__table_);\n    return *this;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\ninline\nunordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&\nunordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::operator=(\n        initializer_list<value_type> __il)\n{\n    __table_.__assign_unique(__il.begin(), __il.end());\n    return *this;\n}\n\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n#ifdef _LIBCPP_CXX03_LANG\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\ntypename unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::__node_holder\nunordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::__construct_node_with_key(const key_type& __k)\n{\n    __node_allocator& __na = __table_.__node_alloc();\n    __node_holder __h(__node_traits::allocate(__na, 1), _Dp(__na));\n    __node_traits::construct(__na, _VSTD::addressof(__h->__value_.__cc.first), __k);\n    __h.get_deleter().__first_constructed = true;\n    __node_traits::construct(__na, _VSTD::addressof(__h->__value_.__cc.second));\n    __h.get_deleter().__second_constructed = true;\n    return _LIBCPP_EXPLICIT_MOVE(__h);  // explicitly moved for C++03\n}\n#endif\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\ntemplate <class _InputIterator>\ninline\nvoid\nunordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::insert(_InputIterator __first,\n                                                       _InputIterator __last)\n{\n    for (; __first != __last; ++__first)\n        __table_.__insert_unique(*__first);\n}\n\n#ifdef _LIBCPP_CXX03_LANG\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\n_Tp&\nunordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::operator[](const key_type& __k)\n{\n    iterator __i = find(__k);\n    if (__i != end())\n        return __i->second;\n    __node_holder __h = __construct_node_with_key(__k);\n    pair<iterator, bool> __r = __table_.__node_insert_unique(__h.get());\n    __h.release();\n    return __r.first->second;\n}\n#else\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\n_Tp&\nunordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::operator[](const key_type& __k)\n{\n    return __table_.__emplace_unique_key_args(__k,\n        std::piecewise_construct, std::forward_as_tuple(__k),\n                                  std::forward_as_tuple()).first->__cc.second;\n}\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\n_Tp&\nunordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::operator[](key_type&& __k)\n{\n    return __table_.__emplace_unique_key_args(__k,\n        std::piecewise_construct, std::forward_as_tuple(std::move(__k)),\n                                  std::forward_as_tuple()).first->__cc.second;\n}\n\n#endif  // !_LIBCPP_CXX03_MODE\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\n_Tp&\nunordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::at(const key_type& __k)\n{\n    iterator __i = find(__k);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    if (__i == end())\n        throw out_of_range(\"unordered_map::at: key not found\");\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return __i->second;\n}\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\nconst _Tp&\nunordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::at(const key_type& __k) const\n{\n    const_iterator __i = find(__k);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    if (__i == end())\n        throw out_of_range(\"unordered_map::at: key not found\");\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return __i->second;\n}\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,\n     unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __y)\n    _NOEXCEPT_(_NOEXCEPT_(__x.swap(__y)))\n{\n    __x.swap(__y);\n}\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\nbool\noperator==(const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,\n           const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __y)\n{\n    if (__x.size() != __y.size())\n        return false;\n    typedef typename unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::const_iterator\n                                                                 const_iterator;\n    for (const_iterator __i = __x.begin(), __ex = __x.end(), __ey = __y.end();\n            __i != __ex; ++__i)\n    {\n        const_iterator __j = __y.find(__i->first);\n        if (__j == __ey || !(*__i == *__j))\n            return false;\n    }\n    return true;\n}\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,\n           const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __y)\n{\n    return !(__x == __y);\n}\n\ntemplate <class _Key, class _Tp, class _Hash = hash<_Key>, class _Pred = equal_to<_Key>,\n          class _Alloc = allocator<pair<const _Key, _Tp> > >\nclass _LIBCPP_TEMPLATE_VIS unordered_multimap\n{\npublic:\n    // types\n    typedef _Key                                           key_type;\n    typedef _Tp                                            mapped_type;\n    typedef _Hash                                          hasher;\n    typedef _Pred                                          key_equal;\n    typedef _Alloc                                         allocator_type;\n    typedef pair<const key_type, mapped_type>              value_type;\n    typedef pair<key_type, mapped_type>                    __nc_value_type;\n    typedef value_type&                                    reference;\n    typedef const value_type&                              const_reference;\n    static_assert((is_same<value_type, typename allocator_type::value_type>::value),\n                  \"Invalid allocator::value_type\");\n\nprivate:\n    typedef __hash_value_type<key_type, mapped_type>                 __value_type;\n    typedef __unordered_map_hasher<key_type, __value_type, hasher>   __hasher;\n    typedef __unordered_map_equal<key_type, __value_type, key_equal> __key_equal;\n    typedef typename __rebind_alloc_helper<allocator_traits<allocator_type>,\n                                                 __value_type>::type __allocator_type;\n\n    typedef __hash_table<__value_type, __hasher,\n                         __key_equal,  __allocator_type>   __table;\n\n    __table __table_;\n\n    typedef typename __table::_NodeTypes                   _NodeTypes;\n    typedef typename __table::__node_traits                __node_traits;\n    typedef typename __table::__node_allocator             __node_allocator;\n    typedef typename __table::__node                       __node;\n    typedef __hash_map_node_destructor<__node_allocator>   _Dp;\n    typedef unique_ptr<__node, _Dp>                         __node_holder;\n    typedef allocator_traits<allocator_type>               __alloc_traits;\n    static_assert((is_same<typename __node_traits::size_type,\n                          typename __alloc_traits::size_type>::value),\n                 \"Allocator uses different size_type for different types\");\npublic:\n    typedef typename __alloc_traits::pointer         pointer;\n    typedef typename __alloc_traits::const_pointer   const_pointer;\n    typedef typename __table::size_type              size_type;\n    typedef typename __table::difference_type        difference_type;\n\n    typedef __hash_map_iterator<typename __table::iterator>       iterator;\n    typedef __hash_map_const_iterator<typename __table::const_iterator> const_iterator;\n    typedef __hash_map_iterator<typename __table::local_iterator> local_iterator;\n    typedef __hash_map_const_iterator<typename __table::const_local_iterator> const_local_iterator;\n\n    _LIBCPP_INLINE_VISIBILITY\n    unordered_multimap()\n        _NOEXCEPT_(is_nothrow_default_constructible<__table>::value)\n        {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n            __get_db()->__insert_c(this);\n#endif\n        }\n    explicit unordered_multimap(size_type __n, const hasher& __hf = hasher(),\n                                const key_equal& __eql = key_equal());\n    unordered_multimap(size_type __n, const hasher& __hf,\n                                const key_equal& __eql,\n                                const allocator_type& __a);\n    template <class _InputIterator>\n        unordered_multimap(_InputIterator __first, _InputIterator __last);\n    template <class _InputIterator>\n        unordered_multimap(_InputIterator __first, _InputIterator __last,\n                      size_type __n, const hasher& __hf = hasher(),\n                      const key_equal& __eql = key_equal());\n    template <class _InputIterator>\n        unordered_multimap(_InputIterator __first, _InputIterator __last,\n                      size_type __n, const hasher& __hf,\n                      const key_equal& __eql,\n                      const allocator_type& __a);\n    _LIBCPP_INLINE_VISIBILITY\n    explicit unordered_multimap(const allocator_type& __a);\n    unordered_multimap(const unordered_multimap& __u);\n    unordered_multimap(const unordered_multimap& __u, const allocator_type& __a);\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    unordered_multimap(unordered_multimap&& __u)\n        _NOEXCEPT_(is_nothrow_move_constructible<__table>::value);\n    unordered_multimap(unordered_multimap&& __u, const allocator_type& __a);\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    unordered_multimap(initializer_list<value_type> __il);\n    unordered_multimap(initializer_list<value_type> __il, size_type __n,\n                       const hasher& __hf = hasher(),\n                       const key_equal& __eql = key_equal());\n    unordered_multimap(initializer_list<value_type> __il, size_type __n,\n                       const hasher& __hf, const key_equal& __eql,\n                       const allocator_type& __a);\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n#if _LIBCPP_STD_VER > 11\n    _LIBCPP_INLINE_VISIBILITY\n    unordered_multimap(size_type __n, const allocator_type& __a)\n      : unordered_multimap(__n, hasher(), key_equal(), __a) {}\n    _LIBCPP_INLINE_VISIBILITY\n    unordered_multimap(size_type __n, const hasher& __hf, const allocator_type& __a)\n      : unordered_multimap(__n, __hf, key_equal(), __a) {}\n    template <class _InputIterator>\n    _LIBCPP_INLINE_VISIBILITY\n      unordered_multimap(_InputIterator __first, _InputIterator __last, size_type __n, const allocator_type& __a)\n      : unordered_multimap(__first, __last, __n, hasher(), key_equal(), __a) {}\n    template <class _InputIterator>\n    _LIBCPP_INLINE_VISIBILITY\n      unordered_multimap(_InputIterator __first, _InputIterator __last, size_type __n, const hasher& __hf, \n        const allocator_type& __a)\n      : unordered_multimap(__first, __last, __n, __hf, key_equal(), __a) {}\n    _LIBCPP_INLINE_VISIBILITY\n    unordered_multimap(initializer_list<value_type> __il, size_type __n, const allocator_type& __a)\n      : unordered_multimap(__il, __n, hasher(), key_equal(), __a) {}\n    _LIBCPP_INLINE_VISIBILITY\n    unordered_multimap(initializer_list<value_type> __il, size_type __n, const hasher& __hf, \n      const allocator_type& __a)\n      : unordered_multimap(__il, __n, __hf, key_equal(), __a) {}\n#endif\n    // ~unordered_multimap() = default;\n    _LIBCPP_INLINE_VISIBILITY\n    unordered_multimap& operator=(const unordered_multimap& __u)\n    {\n#ifndef _LIBCPP_CXX03_LANG\n        __table_ = __u.__table_;\n#else\n        if (this != &__u) {\n            __table_.clear();\n            __table_.hash_function() = __u.__table_.hash_function();\n            __table_.key_eq() = __u.__table_.key_eq();\n            __table_.max_load_factor() = __u.__table_.max_load_factor();\n            __table_.__copy_assign_alloc(__u.__table_);\n            insert(__u.begin(), __u.end());\n        }\n#endif\n        return *this;\n    }\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    unordered_multimap& operator=(unordered_multimap&& __u)\n        _NOEXCEPT_(is_nothrow_move_assignable<__table>::value);\n#endif\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    unordered_multimap& operator=(initializer_list<value_type> __il);\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    _LIBCPP_INLINE_VISIBILITY\n    allocator_type get_allocator() const _NOEXCEPT\n        {return allocator_type(__table_.__node_alloc());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    bool      empty() const _NOEXCEPT {return __table_.size() == 0;}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type size() const _NOEXCEPT  {return __table_.size();}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type max_size() const _NOEXCEPT {return __table_.max_size();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator       begin() _NOEXCEPT        {return __table_.begin();}\n    _LIBCPP_INLINE_VISIBILITY\n    iterator       end() _NOEXCEPT          {return __table_.end();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator begin()  const _NOEXCEPT {return __table_.begin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator end()    const _NOEXCEPT {return __table_.end();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator cbegin() const _NOEXCEPT {return __table_.begin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator cend()   const _NOEXCEPT {return __table_.end();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator insert(const value_type& __x) {return __table_.__insert_multi(__x);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator insert(const_iterator __p, const value_type& __x)\n        {return __table_.__insert_multi(__p.__i_, __x);}\n\n    template <class _InputIterator>\n    _LIBCPP_INLINE_VISIBILITY\n    void insert(_InputIterator __first, _InputIterator __last);\n\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    void insert(initializer_list<value_type> __il)\n        {insert(__il.begin(), __il.end());}\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n#ifndef _LIBCPP_CXX03_LANG\n    _LIBCPP_INLINE_VISIBILITY\n    iterator insert(value_type&& __x) {return __table_.__insert_multi(_VSTD::move(__x));}\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator insert(const_iterator __p, value_type&& __x)\n        {return __table_.__insert_multi(__p.__i_, _VSTD::move(__x));}\n\n    template <class _Pp,\n              class = typename enable_if<is_constructible<value_type, _Pp>::value>::type>\n    _LIBCPP_INLINE_VISIBILITY\n    iterator insert(_Pp&& __x)\n        {return __table_.__insert_multi(_VSTD::forward<_Pp>(__x));}\n\n    template <class _Pp,\n              class = typename enable_if<is_constructible<value_type, _Pp>::value>::type>\n    _LIBCPP_INLINE_VISIBILITY\n    iterator insert(const_iterator __p, _Pp&& __x)\n        {return __table_.__insert_multi(__p.__i_, _VSTD::forward<_Pp>(__x));}\n\n    template <class... _Args>\n    iterator emplace(_Args&&... __args) {\n        return __table_.__emplace_multi(_VSTD::forward<_Args>(__args)...);\n    }\n\n    template <class... _Args>\n    iterator emplace_hint(const_iterator __p, _Args&&... __args) {\n        return __table_.__emplace_hint_multi(__p.__i_, _VSTD::forward<_Args>(__args)...);\n    }\n#endif  // _LIBCPP_CXX03_LANG\n\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator erase(const_iterator __p) {return __table_.erase(__p.__i_);}\n    _LIBCPP_INLINE_VISIBILITY\n    iterator erase(iterator __p)       {return __table_.erase(__p.__i_);}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type erase(const key_type& __k) {return __table_.__erase_multi(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    iterator erase(const_iterator __first, const_iterator __last)\n        {return __table_.erase(__first.__i_, __last.__i_);}\n    _LIBCPP_INLINE_VISIBILITY\n    void clear() _NOEXCEPT {__table_.clear();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void swap(unordered_multimap& __u)\n        _NOEXCEPT_(__is_nothrow_swappable<__table>::value)\n        {__table_.swap(__u.__table_);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    hasher hash_function() const\n        {return __table_.hash_function().hash_function();}\n    _LIBCPP_INLINE_VISIBILITY\n    key_equal key_eq() const\n        {return __table_.key_eq().key_eq();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator       find(const key_type& __k)       {return __table_.find(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator find(const key_type& __k) const {return __table_.find(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type count(const key_type& __k) const {return __table_.__count_multi(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    pair<iterator, iterator>             equal_range(const key_type& __k)\n        {return __table_.__equal_range_multi(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    pair<const_iterator, const_iterator> equal_range(const key_type& __k) const\n        {return __table_.__equal_range_multi(__k);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type bucket_count() const _NOEXCEPT {return __table_.bucket_count();}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type max_bucket_count() const _NOEXCEPT\n        {return __table_.max_bucket_count();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type bucket_size(size_type __n) const\n        {return __table_.bucket_size(__n);}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type bucket(const key_type& __k) const {return __table_.bucket(__k);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    local_iterator       begin(size_type __n)        {return __table_.begin(__n);}\n    _LIBCPP_INLINE_VISIBILITY\n    local_iterator       end(size_type __n)          {return __table_.end(__n);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_local_iterator begin(size_type __n) const  {return __table_.cbegin(__n);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_local_iterator end(size_type __n) const    {return __table_.cend(__n);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_local_iterator cbegin(size_type __n) const {return __table_.cbegin(__n);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_local_iterator cend(size_type __n) const   {return __table_.cend(__n);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    float load_factor() const _NOEXCEPT {return __table_.load_factor();}\n    _LIBCPP_INLINE_VISIBILITY\n    float max_load_factor() const _NOEXCEPT {return __table_.max_load_factor();}\n    _LIBCPP_INLINE_VISIBILITY\n    void max_load_factor(float __mlf) {__table_.max_load_factor(__mlf);}\n    _LIBCPP_INLINE_VISIBILITY\n    void rehash(size_type __n) {__table_.rehash(__n);}\n    _LIBCPP_INLINE_VISIBILITY\n    void reserve(size_type __n) {__table_.reserve(__n);}\n\n#if _LIBCPP_DEBUG_LEVEL >= 2\n\n    bool __dereferenceable(const const_iterator* __i) const\n        {return __table_.__dereferenceable(&__i->__i_);}\n    bool __decrementable(const const_iterator* __i) const\n        {return __table_.__decrementable(&__i->__i_);}\n    bool __addable(const const_iterator* __i, ptrdiff_t __n) const\n        {return __table_.__addable(&__i->__i_, __n);}\n    bool __subscriptable(const const_iterator* __i, ptrdiff_t __n) const\n        {return __table_.__addable(&__i->__i_, __n);}\n\n#endif  // _LIBCPP_DEBUG_LEVEL >= 2\n\n\n};\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\nunordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_multimap(\n        size_type __n, const hasher& __hf, const key_equal& __eql)\n    : __table_(__hf, __eql)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    __table_.rehash(__n);\n}\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\nunordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_multimap(\n        size_type __n, const hasher& __hf, const key_equal& __eql,\n        const allocator_type& __a)\n    : __table_(__hf, __eql, typename __table::allocator_type(__a))\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    __table_.rehash(__n);\n}\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\ntemplate <class _InputIterator>\nunordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_multimap(\n        _InputIterator __first, _InputIterator __last)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    insert(__first, __last);\n}\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\ntemplate <class _InputIterator>\nunordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_multimap(\n        _InputIterator __first, _InputIterator __last, size_type __n,\n        const hasher& __hf, const key_equal& __eql)\n    : __table_(__hf, __eql)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    __table_.rehash(__n);\n    insert(__first, __last);\n}\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\ntemplate <class _InputIterator>\nunordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_multimap(\n        _InputIterator __first, _InputIterator __last, size_type __n,\n        const hasher& __hf, const key_equal& __eql, const allocator_type& __a)\n    : __table_(__hf, __eql, typename __table::allocator_type(__a))\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    __table_.rehash(__n);\n    insert(__first, __last);\n}\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\ninline\nunordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_multimap(\n        const allocator_type& __a)\n    : __table_(typename __table::allocator_type(__a))\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\nunordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_multimap(\n        const unordered_multimap& __u)\n    : __table_(__u.__table_)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    __table_.rehash(__u.bucket_count());\n    insert(__u.begin(), __u.end());\n}\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\nunordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_multimap(\n        const unordered_multimap& __u, const allocator_type& __a)\n    : __table_(__u.__table_, typename __table::allocator_type(__a))\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    __table_.rehash(__u.bucket_count());\n    insert(__u.begin(), __u.end());\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\ninline\nunordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_multimap(\n        unordered_multimap&& __u)\n    _NOEXCEPT_(is_nothrow_move_constructible<__table>::value)\n    : __table_(_VSTD::move(__u.__table_))\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n    __get_db()->swap(this, &__u);\n#endif\n}\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\nunordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_multimap(\n        unordered_multimap&& __u, const allocator_type& __a)\n    : __table_(_VSTD::move(__u.__table_), typename __table::allocator_type(__a))\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    if (__a != __u.get_allocator())\n    {\n        iterator __i = __u.begin();\n        while (__u.size() != 0)\n        {\n            __table_.__insert_multi(\n                      _VSTD::move(__u.__table_.remove((__i++).__i_)->__value_.__nc)\n                                   );\n        }\n    }\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    else\n        __get_db()->swap(this, &__u);\n#endif\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\nunordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_multimap(\n        initializer_list<value_type> __il)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    insert(__il.begin(), __il.end());\n}\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\nunordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_multimap(\n        initializer_list<value_type> __il, size_type __n, const hasher& __hf,\n        const key_equal& __eql)\n    : __table_(__hf, __eql)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    __table_.rehash(__n);\n    insert(__il.begin(), __il.end());\n}\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\nunordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_multimap(\n        initializer_list<value_type> __il, size_type __n, const hasher& __hf,\n        const key_equal& __eql, const allocator_type& __a)\n    : __table_(__hf, __eql, typename __table::allocator_type(__a))\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    __table_.rehash(__n);\n    insert(__il.begin(), __il.end());\n}\n\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\ninline\nunordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&\nunordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::operator=(unordered_multimap&& __u)\n    _NOEXCEPT_(is_nothrow_move_assignable<__table>::value)\n{\n    __table_ = _VSTD::move(__u.__table_);\n    return *this;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\ninline\nunordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&\nunordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::operator=(\n        initializer_list<value_type> __il)\n{\n    __table_.__assign_multi(__il.begin(), __il.end());\n    return *this;\n}\n\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\ntemplate <class _InputIterator>\ninline\nvoid\nunordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::insert(_InputIterator __first,\n                                                            _InputIterator __last)\n{\n    for (; __first != __last; ++__first)\n        __table_.__insert_multi(*__first);\n}\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,\n     unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __y)\n    _NOEXCEPT_(_NOEXCEPT_(__x.swap(__y)))\n{\n    __x.swap(__y);\n}\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\nbool\noperator==(const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,\n           const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __y)\n{\n    if (__x.size() != __y.size())\n        return false;\n    typedef typename unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::const_iterator\n                                                                 const_iterator;\n    typedef pair<const_iterator, const_iterator> _EqRng;\n    for (const_iterator __i = __x.begin(), __ex = __x.end(); __i != __ex;)\n    {\n        _EqRng __xeq = __x.equal_range(__i->first);\n        _EqRng __yeq = __y.equal_range(__i->first);\n        if (_VSTD::distance(__xeq.first, __xeq.second) !=\n            _VSTD::distance(__yeq.first, __yeq.second) ||\n                  !_VSTD::is_permutation(__xeq.first, __xeq.second, __yeq.first))\n            return false;\n        __i = __xeq.second;\n    }\n    return true;\n}\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,\n           const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __y)\n{\n    return !(__x == __y);\n}\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_UNORDERED_MAP\n","/*\n *  kpmResult.cpp\n *  ARToolKit5\n *\n *  This file is part of ARToolKit.\n *\n *  ARToolKit is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation, either version 3 of the License, or\n *  (at your option) any later version.\n *\n *  ARToolKit is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public License\n *  along with ARToolKit.  If not, see <http://www.gnu.org/licenses/>.\n *\n *  As a special exception, the copyright holders of this library give you\n *  permission to link this library with independent modules to produce an\n *  executable, regardless of the license terms of these independent modules, and to\n *  copy and distribute the resulting executable under terms of your choice,\n *  provided that you also meet, for each linked independent module, the terms and\n *  conditions of the license of that module. An independent module is a module\n *  which is neither derived from nor based on this library. If you modify this\n *  library, you may extend this exception to your version of the library, but you\n *  are not obligated to do so. If you do not wish to do so, delete this exception\n *  statement from your version.\n *\n *  Copyright 2015 Daqri, LLC. All rights reserved.\n *  Copyright 2006-2015 ARToolworks, Inc. All rights reserved.\n *  Author(s): Hirokazu Kato, Philip Lamb\n *\n */\n\n#include <stdio.h>\n#include <AR/ar.h>\n#include <KPM/kpm.h>\n#include \"kpmPrivate.h\"\n\nint kpmGetRefDataSet( KpmHandle *kpmHandle, KpmRefDataSet **refDataSet )\n{\n    if( kpmHandle == NULL ) return -1;\n    if( refDataSet == NULL ) return -1;\n\n    *refDataSet = &(kpmHandle->refDataSet);\n\n    return 0;\n}\n\nint kpmGetInDataSet( KpmHandle *kpmHandle, KpmInputDataSet **inDataSet )\n{\n    if( kpmHandle == NULL ) return -1;\n    if( inDataSet == NULL ) return -1;\n\n    *inDataSet = &(kpmHandle->inDataSet);\n    return 0;\n}\n\n#if !BINARY_FEATURE\nint kpmGetMatchingResult( KpmHandle *kpmHandle, KpmMatchResult **preRANSAC, KpmMatchResult **aftRANSAC )\n{\n    if( kpmHandle == NULL ) return -1;\n    if( preRANSAC != NULL ) {\n        *preRANSAC = &(kpmHandle->preRANSAC);\n    }\n    if( aftRANSAC != NULL ) {\n        *aftRANSAC = &(kpmHandle->aftRANSAC);\n    }\n\n    return 0;\n}\n#endif\n\nint kpmGetPose( KpmHandle *kpmHandle, float pose[3][4], int *pageNo, float *error )\n{\n    int     i, j;\n\n    if( kpmHandle == NULL ) return -1;\n    if( kpmHandle->refDataSet.pageNum == 0 ) return -1;\n\n    for(int pageLoop= 0; pageLoop < kpmHandle->resultNum; pageLoop++) {\n        if( kpmHandle->result[pageLoop].camPoseF == 0 ) {\n            for(j=0;j<3;j++) for(i=0;i<4;i++) pose[j][i] = kpmHandle->result[pageLoop].camPose[j][i];\n            *pageNo = kpmHandle->result[pageLoop].pageNo;\n            *error = kpmHandle->result[pageLoop].error;\n            return 0;\n        }\n    }\n\n    return -1;\n}\n\nint kpmGetResult( KpmHandle *kpmHandle, KpmResult **result, int *resultNum )\n{\n    if( kpmHandle == NULL ) return -1;\n\n    *result = kpmHandle->result;\n    *resultNum = kpmHandle->resultNum;\n\n    return 0;\n}\n","//\n//  logger.h\n//  ARToolKit5\n//\n//  This file is part of ARToolKit.\n//\n//  ARToolKit is free software: you can redistribute it and/or modify\n//  it under the terms of the GNU Lesser General Public License as published by\n//  the Free Software Foundation, either version 3 of the License, or\n//  (at your option) any later version.\n//\n//  ARToolKit is distributed in the hope that it will be useful,\n//  but WITHOUT ANY WARRANTY; without even the implied warranty of\n//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n//  GNU Lesser General Public License for more details.\n//\n//  You should have received a copy of the GNU Lesser General Public License\n//  along with ARToolKit.  If not, see <http://www.gnu.org/licenses/>.\n//\n//  As a special exception, the copyright holders of this library give you\n//  permission to link this library with independent modules to produce an\n//  executable, regardless of the license terms of these independent modules, and to\n//  copy and distribute the resulting executable under terms of your choice,\n//  provided that you also meet, for each linked independent module, the terms and\n//  conditions of the license of that module. An independent module is a module\n//  which is neither derived from nor based on this library. If you modify this\n//  library, you may extend this exception to your version of the library, but you\n//  are not obligated to do so. If you do not wish to do so, delete this exception\n//  statement from your version.\n//\n//  Copyright 2013-2015 Daqri, LLC.\n//\n//  Author(s): Chris Broaddus\n//\n\n#pragma once\n\n#include <string>\n#include <vector>\n#include <memory>\n#include \"error.h\"\n#include \"date_time.h\"\n#include <fstream>\n\n#ifdef _WIN32\n#define __PRETTY_FUNCTION__ __FUNCSIG__\n#endif\n\n// DEFINES to enable/disable specific logger priorities\n#define ENABLE_LOGGER\n#define ENABLE_FATAL\n#define ENABLE_ERROR\n#define ENABLE_WARNING\n#define ENABLE_INFO\n#define ENABLE_DEBUG\n#define ENABLE_TRACE\n\n// STRING name of the logger priority\n#define LOGGER_FATAL_MESSAGE    \" FATAL \"\n#define LOGGER_ERROR_MESSAGE    \" ERROR \"\n#define LOGGER_WARNING_MESSAGE  \"WARNING\"\n#define LOGGER_INFO_MESSAGE     \" INFO  \"\n#define LOGGER_DEBUG_MESSAGE    \" DEBUG \"\n#define LOGGER_TRACE_MESSAGE    \" TRACE \"\n\n// Format of the log message\n#define LOGGER_FORMAT_SHORT(FMT, PRIORITY) \"[%s] [%s] : \" FMT, PRIORITY, vision::get_pretty_time().c_str()\n#define LOGGER_FORMAT_LONG(FMT, PRIORITY) \"[%s] [%s] [%s] : \" FMT, PRIORITY, vision::get_pretty_time().c_str(), __PRETTY_FUNCTION__\n#define LOGGER_FORMAT(FMT, PRIORITY) LOGGER_FORMAT_LONG(FMT, PRIORITY)\n\nnamespace vision {\n    \n    namespace detail {\n        \n        /**\n         * Converts a C-style function formatted argument list into a C++ STRING.\n         */\n        inline std::string create_formatted_string(const std::string& fmt, va_list arg_list) {\n            const size_t MAX_BUFFER_SIZE = 2048;\n            char buffer[MAX_BUFFER_SIZE];\n            vsnprintf(buffer, MAX_BUFFER_SIZE, fmt.c_str(), arg_list);\n            return std::string(buffer);\n        }\n        \n    } // detail\n    \n    enum LoggerPriorityLevel {\n        LOGGER_DISABLE     = 0,\n        LOGGER_FATAL       = 1,\n        LOGGER_ERROR       = 2,\n        LOGGER_WARNING     = 4,\n        LOGGER_INFO        = 8,\n        LOGGER_DEBUG       = 16,\n        LOGGER_TRACE       = 32\n    }; // Levels\n    \n    /**\n     * Back-end filters are the filters that log messages to the console, file or network. The default\n     * back-end filter logs to the standard error stream.\n     */\n    class BackendSinkFilter {\n    public:\n        \n        BackendSinkFilter();\n        virtual ~BackendSinkFilter();\n    \n        /**\n         * Write a message to the sink filter.\n         */\n        virtual void write(const std::string& str);\n    };\n    \n    typedef std::shared_ptr<BackendSinkFilter> BackendSinkFilterPtr;\n\n    /**\n     * The front-end filter \"filters\" messages based on the priority mask before forwarding to the \n     * corresponding back-end filter.\n     */\n    class FrontendSinkFilter {\n    public:\n        \n        FrontendSinkFilter(BackendSinkFilterPtr& backendFilter);\n        virtual ~FrontendSinkFilter();\n        \n        /**\n         * Set the priority mask of the logger.\n         */\n        void setPriority(int mask) {\n            mPriorityMask = mask;\n        }\n        \n        /**\n         * Get the priority mask of the logger.\n         */\n        int priority() const {\n            return mPriorityMask;\n        }\n        \n        /**\n         * Write a message to the sink filter.\n         */\n        virtual void write(LoggerPriorityLevel level, const std::string& str);\n        \n        /**\n         * Check if the message with LEVEL should be logged.\n         */\n        bool allow(LoggerPriorityLevel level) const {\n            return (mPriorityMask & (int)level) != 0;\n        }\n        \n    private:\n        \n        // Logger priority mask\n        int mPriorityMask;\n        \n        // Back-end sink filter\n        BackendSinkFilterPtr mBackendSinkFilter;\n    };\n\n    typedef std::shared_ptr<FrontendSinkFilter> FrontendSinkFilterPtr;\n    \n    class Logger {\n    public:\n    \n        /**\n         * Get an instance of the logger.\n         */\n        static Logger& getInstance() {\n            static Logger logger;\n            return logger;\n        }\n        \n        /**\n         * Write a message to the logger.\n         */\n        void write(LoggerPriorityLevel level, const std::string& str);\n        void write(LoggerPriorityLevel level, const char* fmt, ...);\n    \n        /**\n         * Add a front-end sink filter.\n         */\n        void addSinkFilter(FrontendSinkFilterPtr& f);\n        \n    private:\n        \n        // Vector of front-end sink filters\n        std::vector<FrontendSinkFilterPtr> mFrontendSinkFilters;\n        \n        Logger();\n        ~Logger();\n        \n    }; // Logger\n\n\n} // vision\n\n#if defined(ENABLE_LOGGER) && defined(ENABLE_FATAL)\n#define LOG_FATAL(FMT, ...) \\\nvision::Logger::getInstance().write(vision::LOGGER_FATAL, LOGGER_FORMAT(FMT, LOGGER_FATAL_MESSAGE), ##__VA_ARGS__);\n#else\n#define LOG_FATAL(FMT, ...)\n#endif\n\n#if defined(ENABLE_LOGGER) && defined(ENABLE_ERROR)\n#define LOG_ERROR(FMT, ...) \\\nvision::Logger::getInstance().write(vision::LOGGER_ERROR, LOGGER_FORMAT(FMT, LOGGER_ERROR_MESSAGE), ##__VA_ARGS__);\n#else\n#define LOG_ERROR(FMT, ...)\n#endif\n\n#if defined(ENABLE_LOGGER) && defined(ENABLE_WARNING)\n#define LOG_WARNING(FMT, ...) \\\nvision::Logger::getInstance().write(vision::LOGGER_WARNING, LOGGER_FORMAT(FMT, LOGGER_WARNING_MESSAGE), ##__VA_ARGS__);\n#else\n#define LOG_WARNING(FMT, ...)\n#endif\n\n#if defined(ENABLE_LOGGER) && defined(ENABLE_INFO)\n#define LOG_INFO(FMT, ...) \\\nvision::Logger::getInstance().write(vision::LOGGER_INFO, LOGGER_FORMAT(FMT, LOGGER_INFO_MESSAGE), ##__VA_ARGS__);\n#else\n#define LOG_INFO(FMT, ...)\n#endif\n\n#if defined(ENABLE_LOGGER) && defined(ENABLE_DEBUG)\n#define LOG_DEBUG(FMT, ...) \\\nvision::Logger::getInstance().write(vision::LOGGER_DEBUG, LOGGER_FORMAT(FMT, LOGGER_DEBUG_MESSAGE), ##__VA_ARGS__);\n#else\n#define LOG_DEBUG(FMT, ...)\n#endif\n\n#if defined(ENABLE_LOGGER) && defined(ENABLE_TRACE)\n#define LOG_TRACE(FMT, ...) \\\nvision::Logger::getInstance().write(vision::LOGGER_TRACE, LOGGER_FORMAT(FMT, LOGGER_TRACE_MESSAGE), ##__VA_ARGS__);\n#else\n#define LOG_TRACE(FMT, ...)\n#endif","/*\n *  arPattLoad.c\n *  ARToolKit5\n *\n *  This file is part of ARToolKit.\n *\n *  ARToolKit is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation, either version 3 of the License, or\n *  (at your option) any later version.\n *\n *  ARToolKit is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public License\n *  along with ARToolKit.  If not, see <http://www.gnu.org/licenses/>.\n *\n *  As a special exception, the copyright holders of this library give you\n *  permission to link this library with independent modules to produce an\n *  executable, regardless of the license terms of these independent modules, and to\n *  copy and distribute the resulting executable under terms of your choice,\n *  provided that you also meet, for each linked independent module, the terms and\n *  conditions of the license of that module. An independent module is a module\n *  which is neither derived from nor based on this library. If you modify this\n *  library, you may extend this exception to your version of the library, but you\n *  are not obligated to do so. If you do not wish to do so, delete this exception\n *  statement from your version.\n *\n *  Copyright 2015 Daqri, LLC.\n *  Copyright 2003-2015 ARToolworks, Inc.\n *\n *  Author(s): Hirokazu Kato, Philip Lamb\n *\n */\n/*******************************************************\n *\n * Author: Hirokazu Kato\n *\n *         kato@sys.im.hiroshima-cu.ac.jp\n *\n * Revision: 3.0\n * Date: 03/08/13\n *\n *******************************************************/\n\n#include <stdio.h>\n#include <math.h>\n#include <AR/ar.h>\n#include <string.h>\n\nint arPattLoadFromBuffer(ARPattHandle *pattHandle, const char *buffer) {\n    \n\tchar   *bufCopy;\n    int     patno;\n    int     h, i1, i2, i3;\n    int     i, j, l, m;\n\tchar   *buffPtr;\n\tconst char *delims = \" \\t\\n\\r\";\n    \n    if (!pattHandle) {\n        ARLOGe(\"Error: NULL pattHandle.\\n\");\n        return (-1);\n    }\n    if (!buffer) {\n        ARLOGe(\"Error: can't load pattern from NULL buffer.\\n\");\n        return (-1);\n    }\n\n    for( i = 0; i < pattHandle->patt_num_max; i++ ) {\n        if(pattHandle->pattf[i] == 0) break;\n    }\n    if( i == pattHandle->patt_num_max ) return -1;\n    patno = i;\n\n    if (!(bufCopy = strdup(buffer))) { // Make a mutable copy.\n        ARLOGe(\"Error: out of memory.\\n\");\n        return (-1);\n    }\n\tbuffPtr = strtok(bufCopy, delims);\n\n    for( h=0; h<4; h++ ) {\n        l = 0;\n        for( i3 = 0; i3 < 3; i3++ ) { // Three colours B G R\n            for( i2 = 0; i2 < pattHandle->pattSize; i2++ ) { // Rows\n                for( i1 = 0; i1 < pattHandle->pattSize; i1++ ) { // Columns\n\n\t\t\t\t\t/* Switch file scanning to buffer reading */\n\n                    /* if( fscanf(fp, \"%d\", &j) != 1 ) {\n                        ARLOGe(\"Pattern Data read error!!\\n\");\n                        return -1;\n                    }\n\t\t\t\t\t*/\n\n\t\t\t\t\tif (buffPtr == NULL) {\n\t\t\t\t\t\tARLOGe(\"Pattern Data read error!!\\n\");\n                        free(bufCopy);\n                        return -1;\n\t\t\t\t\t}\n\n\t\t\t\t\tj = atoi(buffPtr);\n\t\t\t\t\tbuffPtr = strtok(NULL, delims);\n\n                    j = 255-j;\n                    pattHandle->patt[patno*4 + h][(i2*pattHandle->pattSize+i1)*3+i3] = j;\n                    if( i3 == 0 ) pattHandle->pattBW[patno*4 + h][i2*pattHandle->pattSize+i1]  = j;\n                    else          pattHandle->pattBW[patno*4 + h][i2*pattHandle->pattSize+i1] += j;\n                    if( i3 == 2 ) pattHandle->pattBW[patno*4 + h][i2*pattHandle->pattSize+i1] /= 3;\n                    l += j;\n                }\n            }\n        }\n        l /= (pattHandle->pattSize*pattHandle->pattSize*3);\n\n        m = 0;\n        for( i = 0; i < pattHandle->pattSize*pattHandle->pattSize*3; i++ ) {\n            pattHandle->patt[patno*4 + h][i] -= l;\n            m += (pattHandle->patt[patno*4 + h][i]*pattHandle->patt[patno*4 + h][i]);\n        }\n        pattHandle->pattpow[patno*4 + h] = sqrt((ARdouble)m);\n        if( pattHandle->pattpow[patno*4 + h] == 0.0 ) pattHandle->pattpow[patno*4 + h] = 0.0000001;\n\n        m = 0;\n        for( i = 0; i < pattHandle->pattSize*pattHandle->pattSize; i++ ) {\n            pattHandle->pattBW[patno*4 + h][i] -= l;\n            m += (pattHandle->pattBW[patno*4 + h][i]*pattHandle->pattBW[patno*4 + h][i]);\n        }\n        pattHandle->pattpowBW[patno*4 + h] = sqrt((ARdouble)m);\n        if( pattHandle->pattpowBW[patno*4 + h] == 0.0 ) pattHandle->pattpowBW[patno*4 + h] = 0.0000001;\n    }\n\n    free(bufCopy);\n\n    pattHandle->pattf[patno] = 1;\n    pattHandle->patt_num++;\n\n    return( patno );\n}\n\n/* Old behaviour: load pattern data by loading the specified file and reading its contents.\n * New behaviour: load file contents and pass to arPattLoadFromBuffer.\n */\n\nint arPattLoad( ARPattHandle *pattHandle, const char *filename )\n{\n    FILE   *fp;\n\tint     patno;\n    size_t  ret;\n\n\t/* Old variables */\n    /*\t\n    int     h, i1, i2, i3;\n    int     i, j, l, m;\n\t*/\n\n\t/* New variables */\n\tlong pos = 0;\n\tchar* bytes = NULL;\n\n\t/* Open file */\n\tfp = fopen(filename, \"rb\");\n\tif (fp == NULL) {\n\t\tARLOGe(\"Error opening pattern file '%s' for reading.\\n\", filename);\n        return (-1);\n\t}\n\n\t/* Determine number of bytes in file */\n\tfseek(fp, 0L, SEEK_END);\n\tpos = ftell(fp);\n\tfseek(fp, 0L, SEEK_SET);\n\n\t//ARLOGd(\"Pattern file is %ld bytes\\n\", pos);\n    \n\t/* Allocate buffer */\n\tbytes = (char *)malloc(pos + 1);\n\tif (!bytes) {\n\t\tARLOGe(\"Out of memory!!\\n\");\n        fclose(fp);\n\t\treturn (-1);\n\t}\n\n\t/* Read pattern into buffer and close file */\n\tret = fread(bytes, pos, 1, fp);\n\tfclose(fp);\n    if (ret < 1) {\n        ARLOGe(\"Error reading pattern file '%s'.\\n\", filename);\n        free(bytes);\n        return (-1);\n    }\n\n\t/* Terminate string */\n\tbytes[pos] = '\\0';\n\n\t/* Load pattern from buffer */\n\tpatno = arPattLoadFromBuffer(pattHandle, bytes);\n\n\t/* Free allocated buffer */\n\tfree(bytes);\n\t\n\treturn( patno );\n}\n\nint arPattFree( ARPattHandle *pattHandle, int patno )\n{\n    if( pattHandle->pattf[patno] == 0 ) return -1;\n\n    pattHandle->pattf[patno] = 0;\n    pattHandle->patt_num--;\n\n    return 1;\n}\n\nint arPattActivate( ARPattHandle *pattHandle, int patno )\n{\n    if( pattHandle->pattf[patno] == 0 ) return -1;\n\n    pattHandle->pattf[patno] = 1;\n\n    return 1;\n}\n\nint arPattDeactivate( ARPattHandle *pattHandle, int patno )\n{\n    if( pattHandle->pattf[patno] == 0 ) return -1;\n\n    pattHandle->pattf[patno] = 2;\n\n    return 1;\n}\n","/*\n *  arPattCreateHandle.c\n *  ARToolKit5\n *\n *  This file is part of ARToolKit.\n *\n *  ARToolKit is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation, either version 3 of the License, or\n *  (at your option) any later version.\n *\n *  ARToolKit is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public License\n *  along with ARToolKit.  If not, see <http://www.gnu.org/licenses/>.\n *\n *  As a special exception, the copyright holders of this library give you\n *  permission to link this library with independent modules to produce an\n *  executable, regardless of the license terms of these independent modules, and to\n *  copy and distribute the resulting executable under terms of your choice,\n *  provided that you also meet, for each linked independent module, the terms and\n *  conditions of the license of that module. An independent module is a module\n *  which is neither derived from nor based on this library. If you modify this\n *  library, you may extend this exception to your version of the library, but you\n *  are not obligated to do so. If you do not wish to do so, delete this exception\n *  statement from your version.\n *\n *  Copyright 2015 Daqri, LLC.\n *  Copyright 2003-2015 ARToolworks, Inc.\n *\n *  Author(s): Hirokazu Kato\n *\n */\n/*******************************************************\n *\n * Author: Hirokazu Kato\n *\n *         kato@sys.im.hiroshima-cu.ac.jp\n *\n * Revision: 5.1\n * Date: 03/08/13\n *\n *******************************************************/\n\n#include <AR/ar.h>\n#include <stdio.h>\n#include <math.h>\n\nARPattHandle *arPattCreateHandle(void)\n{\n    return (arPattCreateHandle2(AR_PATT_SIZE1, AR_PATT_NUM_MAX));\n}\n\nARPattHandle *arPattCreateHandle2(const int pattSize, const int patternCountMax)\n{\n    ARPattHandle  *pattHandle;\n    int            i, j;\n    \n    if (pattSize < 16 || pattSize > AR_PATT_SIZE1_MAX || patternCountMax <= 0) return NULL;\n\n    arMalloc( pattHandle, ARPattHandle, 1 );\n\n    pattHandle->patt_num = 0;\n    pattHandle->patt_num_max = patternCountMax;\n    //pattHandle->pattRatio = AR_PATT_RATIO;\n    pattHandle->pattSize = pattSize;\n    \n    arMalloc(pattHandle->pattf, int, patternCountMax);\n    arMalloc(pattHandle->patt, int *, patternCountMax*4)\n    arMalloc(pattHandle->pattBW, int *, patternCountMax*4)\n    arMalloc(pattHandle->pattpow, ARdouble, patternCountMax*4)\n    arMalloc(pattHandle->pattpowBW, ARdouble, patternCountMax*4)\n    for (i = 0; i < patternCountMax; i++) {\n        pattHandle->pattf[i] = 0;\n        for (j = 0; j < 4; j++) {\n            arMalloc(pattHandle->patt[i*4 + j], int, pattSize*pattSize*3);\n            arMalloc(pattHandle->pattBW[i*4 + j], int, pattSize*pattSize);\n        }\n    }\n\n    return pattHandle;\n}\n\nint arPattDeleteHandle(ARPattHandle *pattHandle)\n{\n\tint i, j;\n\t\n\tif (pattHandle == NULL) return (-1);\n\t\n    for (i = 0; i < pattHandle->patt_num_max; i++) {\n\t\tif (pattHandle->pattf[i] != 0) arPattFree(pattHandle, i);\n        for (j = 0; j < 4; j++) {\n            free(pattHandle->patt[i*4 + j]);\n            free(pattHandle->pattBW[i*4 + j]);\n        }\n\t}\n\tfree(pattHandle);\n\tpattHandle = NULL;\n\t\n\treturn (0);\n}\n\n/*\nint arPattGetPattRatio( ARPattHandle *pattHandle, float *ratio )\n{\n    if( pattHandle == NULL ) return -1;\n    *ratio = pattHandle->pattRatio;\n    return 0;\n}\n\nint arPattSetPattRatio( ARPattHandle *pattHandle, float  ratio )\n{\n    if( pattHandle == NULL ) return -1;\n    if( ratio <= 0.0 || ratio >= 1.0 ) return -1;\n    pattHandle->pattRatio = ratio;\n    return 0;\n}\n*/","/*\n *  mSelfInv.c\n *  ARToolKit5\n *\n *  This file is part of ARToolKit.\n *\n *  ARToolKit is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation, either version 3 of the License, or\n *  (at your option) any later version.\n *\n *  ARToolKit is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public License\n *  along with ARToolKit.  If not, see <http://www.gnu.org/licenses/>.\n *\n *  As a special exception, the copyright holders of this library give you\n *  permission to link this library with independent modules to produce an\n *  executable, regardless of the license terms of these independent modules, and to\n *  copy and distribute the resulting executable under terms of your choice,\n *  provided that you also meet, for each linked independent module, the terms and\n *  conditions of the license of that module. An independent module is a module\n *  which is neither derived from nor based on this library. If you modify this\n *  library, you may extend this exception to your version of the library, but you\n *  are not obligated to do so. If you do not wish to do so, delete this exception\n *  statement from your version.\n *\n *  Copyright 2015 Daqri, LLC.\n *  Copyright 2002-2015 ARToolworks, Inc.\n *\n *  Author(s): Shinsaku Hiura, Hirokazu Kato, Philip Lamb\n *\n */\n/*******************************************************\n *\n * Author: Shinsaku Hiura, Hirokazu Kato\n *\n *         shinsaku@sys.es.osaka-u.ac.jp\n *         kato@sys.im.hiroshima-cu.ac.jp\n *\n * Revision: 2.1\n * Date: 99/07/16\n *\n *******************************************************/\n\n#include <stdio.h>\n#include <math.h>\n#include <AR/ar.h>\n#ifdef ARDOUBLE_IS_FLOAT\n#  define ZERO 0.0f\n#  define ONE 1.0f\n#  define FABS fabsf\n#  define EPS 1.0e-10f\n#else\n#  define ZERO 0.0\n#  define ONE 1.0\n#  define FABS fabs\n#  define EPS 1.0e-10\n#endif\n\nstatic ARdouble *minv( ARdouble *ap, int dimen, int rowa );\n\nint arMatrixSelfInv(ARMat *m)\n{\n\tif(minv(m->m, m->row, m->row) == NULL) return -1;\n\n\treturn 0;\n}\n\n\t\n/********************************/\n/*                              */\n/*    MATRIX inverse function   */\n/*                              */\n/********************************/\nstatic ARdouble *minv( ARdouble *ap, int dimen, int rowa )\n{\n        ARdouble *wap, *wcp, *wbp;/* work pointer                 */\n        int i,j,n,ip,nwork;\n        int nos[500];\n        ARdouble epsl;\n        ARdouble p,pbuf,work;\n\n        if( dimen > 500 ) return NULL;\n\n        epsl = EPS;         /* Threshold value      */\n\n        switch (dimen) {\n                case (0): return(NULL);                 /* check size */\n                case (1): *ap = ONE / (*ap);\n                          return(ap);                   /* 1 dimension */\n        }\n\n        for(n = 0; n < dimen ; n++)\n                nos[n] = n;\n\n        for(n = 0; n < dimen ; n++) {\n                wcp = ap + n * rowa;\n\n                for(i = n, wap = wcp, p = ZERO; i < dimen ; i++, wap += rowa)\n                        if( p < ( pbuf = FABS(*wap)) ) {\n                                p = pbuf;\n                                ip = i;\n                        }\n                if (p <= epsl)\n                        return(NULL);\n\n                nwork = nos[ip];\n                nos[ip] = nos[n];\n                nos[n] = nwork;\n\n                for(j = 0, wap = ap + ip * rowa, wbp = wcp; j < dimen ; j++) {\n                        work = *wap;\n                        *wap++ = *wbp;\n                        *wbp++ = work;\n                }\n\n                for(j = 1, wap = wcp, work = *wcp; j < dimen ; j++, wap++)\n                        *wap = *(wap + 1) / work;\n                *wap = ONE / work;\n\n                for(i = 0; i < dimen ; i++) {\n                        if(i != n) {\n                                wap = ap + i * rowa;\n                                for(j = 1, wbp = wcp, work = *wap;\n                                                j < dimen ; j++, wap++, wbp++)\n                                        *wap = *(wap + 1) - work * (*wbp);\n                                *wap = -work * (*wbp);\n                        }\n                }\n        }\n\n        for(n = 0; n < dimen ; n++) {\n                for(j = n; j < dimen ; j++)\n                        if( nos[j] == n) break;\n                nos[j] = nos[n];\n                for(i = 0, wap = ap + j, wbp = ap + n; i < dimen ;\n                                        i++, wap += rowa, wbp += rowa) {\n                        work = *wap;\n                        *wap = *wbp;\n                        *wbp = work;\n                }\n        }\n        return(ap);\n}\n\n#ifndef ARDOUBLE_IS_FLOAT\nstatic float *minvf( float *ap, int dimen, int rowa );\n\nint arMatrixSelfInvf(ARMatf *m)\n{\n\tif(minvf(m->m, m->row, m->row) == NULL) return -1;\n    \n\treturn 0;\n}\n\nstatic float *minvf( float *ap, int dimen, int rowa )\n{\n    float *wap, *wcp, *wbp;/* work pointer                 */\n    int i,j,n,ip,nwork;\n    int nos[500];\n    float epsl;\n    float p,pbuf,work;\n    \n    if( dimen > 500 ) return NULL;\n    \n    epsl = 1.0e-10f;         /* Threshold value      */\n    \n    switch (dimen) {\n        case (0): return(NULL);                 /* check size */\n        case (1): *ap = 1.0f / (*ap);\n            return(ap);                   /* 1 dimension */\n    }\n    \n    for(n = 0; n < dimen ; n++)\n        nos[n] = n;\n    \n    for(n = 0; n < dimen ; n++) {\n        wcp = ap + n * rowa;\n        \n        for(i = n, wap = wcp, p = 0.0; i < dimen ; i++, wap += rowa)\n            if( p < ( pbuf = fabsf(*wap)) ) {\n                p = pbuf;\n                ip = i;\n            }\n        if (p <= epsl)\n            return(NULL);\n        \n        nwork = nos[ip];\n        nos[ip] = nos[n];\n        nos[n] = nwork;\n        \n        for(j = 0, wap = ap + ip * rowa, wbp = wcp; j < dimen ; j++) {\n            work = *wap;\n            *wap++ = *wbp;\n            *wbp++ = work;\n        }\n        \n        for(j = 1, wap = wcp, work = *wcp; j < dimen ; j++, wap++)\n            *wap = *(wap + 1) / work;\n        *wap = 1.0f / work;\n        \n        for(i = 0; i < dimen ; i++) {\n            if(i != n) {\n                wap = ap + i * rowa;\n                for(j = 1, wbp = wcp, work = *wap;\n                    j < dimen ; j++, wap++, wbp++)\n                    *wap = *(wap + 1) - work * (*wbp);\n                *wap = -work * (*wbp);\n            }\n        }\n    }\n    \n    for(n = 0; n < dimen ; n++) {\n        for(j = n; j < dimen ; j++)\n            if( nos[j] == n) break;\n        nos[j] = nos[n];\n        for(i = 0, wap = ap + j, wbp = ap + n; i < dimen ;\n            i++, wap += rowa, wbp += rowa) {\n            work = *wap;\n            *wap = *wbp;\n            *wbp = work;\n        }\n    }\n    return(ap);\n}\n#endif\n","//\n//  timers.h\n//  ARToolKit5\n//\n//  This file is part of ARToolKit.\n//\n//  ARToolKit is free software: you can redistribute it and/or modify\n//  it under the terms of the GNU Lesser General Public License as published by\n//  the Free Software Foundation, either version 3 of the License, or\n//  (at your option) any later version.\n//\n//  ARToolKit is distributed in the hope that it will be useful,\n//  but WITHOUT ANY WARRANTY; without even the implied warranty of\n//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n//  GNU Lesser General Public License for more details.\n//\n//  You should have received a copy of the GNU Lesser General Public License\n//  along with ARToolKit.  If not, see <http://www.gnu.org/licenses/>.\n//\n//  As a special exception, the copyright holders of this library give you\n//  permission to link this library with independent modules to produce an\n//  executable, regardless of the license terms of these independent modules, and to\n//  copy and distribute the resulting executable under terms of your choice,\n//  provided that you also meet, for each linked independent module, the terms and\n//  conditions of the license of that module. An independent module is a module\n//  which is neither derived from nor based on this library. If you modify this\n//  library, you may extend this exception to your version of the library, but you\n//  are not obligated to do so. If you do not wish to do so, delete this exception\n//  statement from your version.\n//\n//  Copyright 2013-2015 Daqri, LLC.\n//\n//  Author(s): Chris Broaddus\n//\n\n#pragma once\n\n#include <string>\n\nnamespace vision {\n\n    /**\n     * Implements a simple start/stop timer.\n     */\n    class Timer {\n    public:\n        \n        Timer();\n        ~Timer();\n        \n        /**\n         * Start the timer.\n         */\n        void start();\n        \n        /**\n         * Stop the timer.\n         */\n        void stop();\n        \n        /**\n         * Get the timer in seconds.\n         */\n        double duration_in_seconds() const;\n        \n        /**\n         * Get the timer in milliseconds.\n         */\n        double duration_in_milliseconds() const;\n        \n    private:\n        \n        // Start/Stop time\n        double mStartTime;\n        double mStopTime;\n    }; // Timer\n    \n    /**\n     * Implements a scoped timer.\n     */\n    class ScopedTimer {\n    public:\n        \n        ScopedTimer(const char* str);\n        ~ScopedTimer();\n        \n        operator bool() {\n            return true;\n        }\n        \n    private:\n        \n        // The actual timer\n        Timer mTimer;\n        // Description\n        std::string mStr;\n        \n    }; // ScopedTimer\n    \n#define TIMED(X) if(ScopedTimer _ScopedTimer = X)\n    \n} // vision","/*\n *  arPattAttach.c\n *  ARToolKit5\n *\n *  This file is part of ARToolKit.\n *\n *  ARToolKit is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation, either version 3 of the License, or\n *  (at your option) any later version.\n *\n *  ARToolKit is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public License\n *  along with ARToolKit.  If not, see <http://www.gnu.org/licenses/>.\n *\n *  As a special exception, the copyright holders of this library give you\n *  permission to link this library with independent modules to produce an\n *  executable, regardless of the license terms of these independent modules, and to\n *  copy and distribute the resulting executable under terms of your choice,\n *  provided that you also meet, for each linked independent module, the terms and\n *  conditions of the license of that module. An independent module is a module\n *  which is neither derived from nor based on this library. If you modify this\n *  library, you may extend this exception to your version of the library, but you\n *  are not obligated to do so. If you do not wish to do so, delete this exception\n *  statement from your version.\n *\n *  Copyright 2015 Daqri, LLC.\n *  Copyright 2003-2015 ARToolworks, Inc.\n *\n *  Author(s): Hirokazu Kato\n *\n */\n/*******************************************************\n *\n * Author: Hirokazu Kato\n *\n *         kato@sys.im.hiroshima-cu.ac.jp\n *\n * Revision: 5.1\n * Date: 03/08/13\n *\n *******************************************************/\n\n#include <AR/ar.h>\n\nint arPattAttach( ARHandle *arHandle, ARPattHandle *arPattHandle )\n{\n    if (!arHandle) return (-1);\n    if (arHandle->pattHandle) return (-1);\n\n    arHandle->pattHandle = arPattHandle;\n\n    return (0);\n}\n\nint arPattDetach(ARHandle *arHandle)\n{\n    if (!arHandle) return (-1);\n    if (!arHandle->pattHandle) return (-1);\n\t\n    arHandle->pattHandle = NULL;\n\t\n    return (0);\n}","//\n//  feature_store.h\n//  ARToolKit5\n//\n//  This file is part of ARToolKit.\n//\n//  ARToolKit is free software: you can redistribute it and/or modify\n//  it under the terms of the GNU Lesser General Public License as published by\n//  the Free Software Foundation, either version 3 of the License, or\n//  (at your option) any later version.\n//\n//  ARToolKit is distributed in the hope that it will be useful,\n//  but WITHOUT ANY WARRANTY; without even the implied warranty of\n//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n//  GNU Lesser General Public License for more details.\n//\n//  You should have received a copy of the GNU Lesser General Public License\n//  along with ARToolKit.  If not, see <http://www.gnu.org/licenses/>.\n//\n//  As a special exception, the copyright holders of this library give you\n//  permission to link this library with independent modules to produce an\n//  executable, regardless of the license terms of these independent modules, and to\n//  copy and distribute the resulting executable under terms of your choice,\n//  provided that you also meet, for each linked independent module, the terms and\n//  conditions of the license of that module. An independent module is a module\n//  which is neither derived from nor based on this library. If you modify this\n//  library, you may extend this exception to your version of the library, but you\n//  are not obligated to do so. If you do not wish to do so, delete this exception\n//  statement from your version.\n//\n//  Copyright 2013-2015 Daqri, LLC.\n//\n//  Author(s): Chris Broaddus\n//\n\n#pragma once\n\n#include <vector>\n#include \"feature_point.h\"\n\n//#include <boost/serialization/serialization.hpp>\n//#include <boost/serialization/vector.hpp>\n\nnamespace vision {\n\n    /**\n     * Represents a container for features and point information.\n     */\n    class BinaryFeatureStore {\n    public:\n        \n        BinaryFeatureStore(int bytesPerFeature)\n        : mNumBytesPerFeature(bytesPerFeature) {}\n        BinaryFeatureStore()\n        : mNumBytesPerFeature(0) {}\n        ~BinaryFeatureStore() {}\n    \n        /**\n         * Resize the feature store to hold NUMFEATURES.\n         */\n        inline void resize(size_t numFeatures) {\n            mFeatures.resize(mNumBytesPerFeature*numFeatures, 0);\n            mPoints.resize(numFeatures);\n        }\n        \n        /**\n         * @return Number of features.\n         */\n        inline size_t size() const {\n            return mPoints.size();\n        }\n        \n        /**\n         * Set number of bytes per feature.\n         */\n        inline void setNumBytesPerFeature(int bytesPerFeature) { mNumBytesPerFeature = bytesPerFeature; }\n        \n        /**\n         * @return Number of bytes per feature\n         */\n        inline int numBytesPerFeature() const { return mNumBytesPerFeature; }\n        \n        /**\n         * @return Vector of features\n         */\n        inline std::vector<unsigned char>& features() { return mFeatures; }\n        inline const std::vector<unsigned char>& features() const { return mFeatures; }\n        \n        /**\n         * @return Specific feature with an index\n         */\n        inline unsigned char* feature(size_t i) { return &mFeatures[i*mNumBytesPerFeature]; }\n        inline const unsigned char* feature(size_t i) const { return &mFeatures[i*mNumBytesPerFeature]; }\n        \n        /**\n         * @return Vector of feature points\n         */\n        inline std::vector<FeaturePoint>& points() { return mPoints; }\n        inline const std::vector<FeaturePoint>& points() const { return mPoints; }\n        \n        /**\n         * @return Specific point with an index\n         */\n        inline FeaturePoint& point(size_t i) { return mPoints[i]; }\n        inline const FeaturePoint& point(size_t i) const { return mPoints[i]; }\n    \n        /**\n         * Copy a feature store.\n         */\n        void copy(const BinaryFeatureStore& store) {\n            mNumBytesPerFeature = store.mNumBytesPerFeature;\n            mFeatures = store.mFeatures;\n            mPoints = store.mPoints;\n        }\n        \n        //\n        // Serialization\n        //\n        \n        /*template<class Archive>\n        void serialize(Archive & ar, const unsigned int version) {\n            ar & mNumBytesPerFeature;\n            ar & mFeatures;\n            ar & mPoints;\n        }*/\n        \n    private:\n    \n        // Number of bytes per feature\n        int mNumBytesPerFeature;\n        \n        // Vector of features\n        std::vector<unsigned char> mFeatures;\n    \n        // Vector of feature points\n        std::vector<FeaturePoint> mPoints;\n    };\n\n} // vision","//\n//  rand.h\n//  ARToolKit5\n//\n//  This file is part of ARToolKit.\n//\n//  ARToolKit is free software: you can redistribute it and/or modify\n//  it under the terms of the GNU Lesser General Public License as published by\n//  the Free Software Foundation, either version 3 of the License, or\n//  (at your option) any later version.\n//\n//  ARToolKit is distributed in the hope that it will be useful,\n//  but WITHOUT ANY WARRANTY; without even the implied warranty of\n//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n//  GNU Lesser General Public License for more details.\n//\n//  You should have received a copy of the GNU Lesser General Public License\n//  along with ARToolKit.  If not, see <http://www.gnu.org/licenses/>.\n//\n//  As a special exception, the copyright holders of this library give you\n//  permission to link this library with independent modules to produce an\n//  executable, regardless of the license terms of these independent modules, and to\n//  copy and distribute the resulting executable under terms of your choice,\n//  provided that you also meet, for each linked independent module, the terms and\n//  conditions of the license of that module. An independent module is a module\n//  which is neither derived from nor based on this library. If you modify this\n//  library, you may extend this exception to your version of the library, but you\n//  are not obligated to do so. If you do not wish to do so, delete this exception\n//  statement from your version.\n//\n//  Copyright 2013-2015 Daqri, LLC.\n//\n//  Author(s): Chris Broaddus\n//\n\n#pragma once\n\n#include <algorithm>\n\nnamespace vision {\n    \n#define FAST_RAND_MAX 32767\n    \n    /**\n     * Implements a fast random number generator. \n     *\n     * http://software.intel.com/en-us/articles/fast-random-number-generator-on-the-intel-pentiumr-4-processor/\n     */\n    inline int FastRandom(int& seed) {\n        seed = (214013*seed+2531011);\n        return (seed>>16)&0x7FFF;\n    }\n    \n    /**\n     * Get a float between [0,1].\n     */\n    template<typename T>\n    inline T FastRandomFloat(int& seed) {\n        return FastRandom(seed)/(T)FAST_RAND_MAX;\n    }\n    \n    /**\n     * Shuffle the elements of an array.\n     *\n     * @param[in/out] v Array of elements\n     * @param[in] pop_size Population size, or size of the array v\n     * @param[in] sample_size The first SAMPLE_SIZE samples of v will be shuffled\n     * @param[in] seed Seed for random number generator\n     */\n    template<typename T>\n    inline void ArrayShuffle(T* v, int pop_size, int sample_size, int& seed) {\n        for(int i = 0; i < sample_size; i++) {\n            int k = FastRandom(seed)%pop_size;\n            std::swap(v[i], v[k]);\n        }\n    }\n    \n} // vision","//\n//  hamming.h\n//  ARToolKit5\n//\n//  This file is part of ARToolKit.\n//\n//  ARToolKit is free software: you can redistribute it and/or modify\n//  it under the terms of the GNU Lesser General Public License as published by\n//  the Free Software Foundation, either version 3 of the License, or\n//  (at your option) any later version.\n//\n//  ARToolKit is distributed in the hope that it will be useful,\n//  but WITHOUT ANY WARRANTY; without even the implied warranty of\n//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n//  GNU Lesser General Public License for more details.\n//\n//  You should have received a copy of the GNU Lesser General Public License\n//  along with ARToolKit.  If not, see <http://www.gnu.org/licenses/>.\n//\n//  As a special exception, the copyright holders of this library give you\n//  permission to link this library with independent modules to produce an\n//  executable, regardless of the license terms of these independent modules, and to\n//  copy and distribute the resulting executable under terms of your choice,\n//  provided that you also meet, for each linked independent module, the terms and\n//  conditions of the license of that module. An independent module is a module\n//  which is neither derived from nor based on this library. If you modify this\n//  library, you may extend this exception to your version of the library, but you\n//  are not obligated to do so. If you do not wish to do so, delete this exception\n//  statement from your version.\n//\n//  Copyright 2013-2015 Daqri, LLC.\n//\n//  Author(s): Chris Broaddus\n//\n\n#pragma once\n\nnamespace vision {\n    \n    /**\n     * Hamming distance for 32 bits.\n     */\n    inline unsigned int HammingDistance32(unsigned int a, unsigned int b) {\n        const unsigned int m1  = 0x55555555; // 0101...\n        const unsigned int m2  = 0x33333333; // 00110011..\n        const unsigned int m4  = 0x0f0f0f0f; // 4 zeros,  4 ones\n        const unsigned int h01 = 0x01010101; // the sum of 256 to the power of 0,1,2,...\n        \n        unsigned int x;\n        \n        x = a^b;\n        x -= (x >> 1) & m1;             // put count of each 2 bits into those 2 bits\n        x = (x & m2) + ((x >> 2) & m2); // put count of each 4 bits into those 4 bits\n        x = (x + (x >> 4)) & m4;        // put count of each 8 bits into those 8 bits\n        \n        return (x * h01) >> 24;         // returns left 8 bits of x + (x<<8) + (x<<16) + (x<<24) + ...\n    }\n    \n    /**\n     * Hamming distance for 768 bits (96 bytes)\n     */\n    inline unsigned int HammingDistance768(const unsigned int a[24], const unsigned int b[24]) {\n        return  HammingDistance32(a[0],  b[0]) +\n                HammingDistance32(a[1],  b[1]) +\n                HammingDistance32(a[2],  b[2]) +\n                HammingDistance32(a[3],  b[3]) +\n                HammingDistance32(a[4],  b[4]) +\n                HammingDistance32(a[5],  b[5]) +\n                HammingDistance32(a[6],  b[6]) +\n                HammingDistance32(a[7],  b[7]) +\n                HammingDistance32(a[8],  b[8]) +\n                HammingDistance32(a[9],  b[9]) +\n                HammingDistance32(a[10], b[10]) +\n                HammingDistance32(a[11], b[11]) +\n                HammingDistance32(a[12], b[12]) +\n                HammingDistance32(a[13], b[13]) +\n                HammingDistance32(a[14], b[14]) +\n                HammingDistance32(a[15], b[15]) +\n                HammingDistance32(a[16], b[16]) +\n                HammingDistance32(a[17], b[17]) +\n                HammingDistance32(a[18], b[18]) +\n                HammingDistance32(a[19], b[19]) +\n                HammingDistance32(a[20], b[20]) +\n                HammingDistance32(a[21], b[21]) +\n                HammingDistance32(a[22], b[22]) +\n                HammingDistance32(a[23], b[23]);\n    }\n    \n    template<int NUM_BYTES>\n    inline unsigned int HammingDistance(const unsigned char a[NUM_BYTES], const unsigned char b[NUM_BYTES]) {\n        switch(NUM_BYTES) {\n            case 96:\n                return HammingDistance768((unsigned int*)a, (unsigned int*)b);\n                break;\n        };\n        return std::numeric_limits<unsigned int>::max();\n    }\n\n} // vision\n","// -*- C++ -*-\n//===--------------------------- queue ------------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_QUEUE\n#define _LIBCPP_QUEUE\n\n/*\n    queue synopsis\n\nnamespace std\n{\n\ntemplate <class T, class Container = deque<T>>\nclass queue\n{\npublic:\n    typedef Container                                container_type;\n    typedef typename container_type::value_type      value_type;\n    typedef typename container_type::reference       reference;\n    typedef typename container_type::const_reference const_reference;\n    typedef typename container_type::size_type       size_type;\n\nprotected:\n    container_type c;\n\npublic:\n    queue() = default;\n    ~queue() = default;\n\n    queue(const queue& q) = default;\n    queue(queue&& q) = default;\n\n    queue& operator=(const queue& q) = default;\n    queue& operator=(queue&& q) = default;\n\n    explicit queue(const container_type& c);\n    explicit queue(container_type&& c)\n    template <class Alloc>\n        explicit queue(const Alloc& a);\n    template <class Alloc>\n        queue(const container_type& c, const Alloc& a);\n    template <class Alloc>\n        queue(container_type&& c, const Alloc& a);\n    template <class Alloc>\n        queue(const queue& q, const Alloc& a);\n    template <class Alloc>\n        queue(queue&& q, const Alloc& a);\n\n    bool      empty() const;\n    size_type size() const;\n\n    reference       front();\n    const_reference front() const;\n    reference       back();\n    const_reference back() const;\n\n    void push(const value_type& v);\n    void push(value_type&& v);\n    template <class... Args> reference emplace(Args&&... args); // reference in C++17\n    void pop();\n\n    void swap(queue& q) noexcept(is_nothrow_swappable_v<Container>)\n};\n\ntemplate <class T, class Container>\n  bool operator==(const queue<T, Container>& x,const queue<T, Container>& y);\n\ntemplate <class T, class Container>\n  bool operator< (const queue<T, Container>& x,const queue<T, Container>& y);\n\ntemplate <class T, class Container>\n  bool operator!=(const queue<T, Container>& x,const queue<T, Container>& y);\n\ntemplate <class T, class Container>\n  bool operator> (const queue<T, Container>& x,const queue<T, Container>& y);\n\ntemplate <class T, class Container>\n  bool operator>=(const queue<T, Container>& x,const queue<T, Container>& y);\n\ntemplate <class T, class Container>\n  bool operator<=(const queue<T, Container>& x,const queue<T, Container>& y);\n\ntemplate <class T, class Container>\n  void swap(queue<T, Container>& x, queue<T, Container>& y)\n  noexcept(noexcept(x.swap(y)));\n\ntemplate <class T, class Container = vector<T>,\n          class Compare = less<typename Container::value_type>>\nclass priority_queue\n{\npublic:\n    typedef Container                                container_type;\n    typedef typename container_type::value_type      value_type;\n    typedef typename container_type::reference       reference;\n    typedef typename container_type::const_reference const_reference;\n    typedef typename container_type::size_type       size_type;\n\nprotected:\n    container_type c;\n    Compare comp;\n\npublic:\n    priority_queue() = default;\n    ~priority_queue() = default;\n\n    priority_queue(const priority_queue& q) = default;\n    priority_queue(priority_queue&& q) = default;\n\n    priority_queue& operator=(const priority_queue& q) = default;\n    priority_queue& operator=(priority_queue&& q) = default;\n\n    explicit priority_queue(const Compare& comp);\n    priority_queue(const Compare& comp, const container_type& c);\n    explicit priority_queue(const Compare& comp, container_type&& c);\n    template <class InputIterator>\n        priority_queue(InputIterator first, InputIterator last,\n                       const Compare& comp = Compare());\n    template <class InputIterator>\n        priority_queue(InputIterator first, InputIterator last,\n                       const Compare& comp, const container_type& c);\n    template <class InputIterator>\n        priority_queue(InputIterator first, InputIterator last,\n                       const Compare& comp, container_type&& c);\n    template <class Alloc>\n        explicit priority_queue(const Alloc& a);\n    template <class Alloc>\n        priority_queue(const Compare& comp, const Alloc& a);\n    template <class Alloc>\n        priority_queue(const Compare& comp, const container_type& c,\n                       const Alloc& a);\n    template <class Alloc>\n        priority_queue(const Compare& comp, container_type&& c,\n                       const Alloc& a);\n    template <class Alloc>\n        priority_queue(const priority_queue& q, const Alloc& a);\n    template <class Alloc>\n        priority_queue(priority_queue&& q, const Alloc& a);\n\n    bool            empty() const;\n    size_type       size() const;\n    const_reference top() const;\n\n    void push(const value_type& v);\n    void push(value_type&& v);\n    template <class... Args> void emplace(Args&&... args);\n    void pop();\n\n    void swap(priority_queue& q)\n        noexcept(is_nothrow_swappable_v<Container> &&\n                 is_nothrow_swappable_v<Comp>)\n};\n\ntemplate <class T, class Container, class Compare>\n  void swap(priority_queue<T, Container, Compare>& x,\n            priority_queue<T, Container, Compare>& y)\n            noexcept(noexcept(x.swap(y)));\n\n}  // std\n\n*/\n\n#include <__config>\n#include <deque>\n#include <vector>\n#include <functional>\n#include <algorithm>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\ntemplate <class _Tp, class _Container = deque<_Tp> > class _LIBCPP_TEMPLATE_VIS queue;\n\ntemplate <class _Tp, class _Container>\n_LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const queue<_Tp, _Container>& __x,const queue<_Tp, _Container>& __y);\n\ntemplate <class _Tp, class _Container>\n_LIBCPP_INLINE_VISIBILITY\nbool\noperator< (const queue<_Tp, _Container>& __x,const queue<_Tp, _Container>& __y);\n\ntemplate <class _Tp, class _Container /*= deque<_Tp>*/>\nclass _LIBCPP_TEMPLATE_VIS queue\n{\npublic:\n    typedef _Container                               container_type;\n    typedef typename container_type::value_type      value_type;\n    typedef typename container_type::reference       reference;\n    typedef typename container_type::const_reference const_reference;\n    typedef typename container_type::size_type       size_type;\n    static_assert((is_same<_Tp, value_type>::value), \"\" );\n\nprotected:\n    container_type c;\n\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    queue()\n        _NOEXCEPT_(is_nothrow_default_constructible<container_type>::value)\n        : c() {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    queue(const queue& __q) : c(__q.c) {}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    queue(queue&& __q)\n        _NOEXCEPT_(is_nothrow_move_constructible<container_type>::value)\n        : c(_VSTD::move(__q.c)) {}\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    _LIBCPP_INLINE_VISIBILITY\n    queue& operator=(const queue& __q) {c = __q.c; return *this;}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    queue& operator=(queue&& __q)\n        _NOEXCEPT_(is_nothrow_move_assignable<container_type>::value)\n        {c = _VSTD::move(__q.c); return *this;}\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit queue(const container_type& __c)  : c(__c) {}\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    explicit queue(container_type&& __c) : c(_VSTD::move(__c)) {}\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    template <class _Alloc>\n        _LIBCPP_INLINE_VISIBILITY\n        explicit queue(const _Alloc& __a,\n                       typename enable_if<uses_allocator<container_type,\n                                                         _Alloc>::value>::type* = 0)\n            : c(__a) {}\n    template <class _Alloc>\n        _LIBCPP_INLINE_VISIBILITY\n        queue(const queue& __q, const _Alloc& __a,\n                       typename enable_if<uses_allocator<container_type,\n                                                         _Alloc>::value>::type* = 0)\n            : c(__q.c, __a) {}\n    template <class _Alloc>\n        _LIBCPP_INLINE_VISIBILITY\n        queue(const container_type& __c, const _Alloc& __a,\n                       typename enable_if<uses_allocator<container_type,\n                                                         _Alloc>::value>::type* = 0)\n            : c(__c, __a) {}\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    template <class _Alloc>\n        _LIBCPP_INLINE_VISIBILITY\n        queue(container_type&& __c, const _Alloc& __a,\n                       typename enable_if<uses_allocator<container_type,\n                                                         _Alloc>::value>::type* = 0)\n            : c(_VSTD::move(__c), __a) {}\n    template <class _Alloc>\n        _LIBCPP_INLINE_VISIBILITY\n        queue(queue&& __q, const _Alloc& __a,\n                       typename enable_if<uses_allocator<container_type,\n                                                         _Alloc>::value>::type* = 0)\n            : c(_VSTD::move(__q.c), __a) {}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    _LIBCPP_INLINE_VISIBILITY\n    bool      empty() const {return c.empty();}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type size() const  {return c.size();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    reference       front()       {return c.front();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reference front() const {return c.front();}\n    _LIBCPP_INLINE_VISIBILITY\n    reference       back()        {return c.back();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reference back() const  {return c.back();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void push(const value_type& __v) {c.push_back(__v);}\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    void push(value_type&& __v)      {c.push_back(_VSTD::move(__v));}\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n    template <class... _Args>\n        _LIBCPP_INLINE_VISIBILITY\n#if _LIBCPP_STD_VER > 14\n        reference emplace(_Args&&... __args)\n            { return c.emplace_back(_VSTD::forward<_Args>(__args)...);}\n#else\n        void     emplace(_Args&&... __args)\n            {        c.emplace_back(_VSTD::forward<_Args>(__args)...);}\n#endif\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    void pop() {c.pop_front();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void swap(queue& __q)\n        _NOEXCEPT_(__is_nothrow_swappable<container_type>::value)\n    {\n        using _VSTD::swap;\n        swap(c, __q.c);\n    }\n\n    template <class _T1, class _C1>\n    friend\n    _LIBCPP_INLINE_VISIBILITY\n    bool\n    operator==(const queue<_T1, _C1>& __x,const queue<_T1, _C1>& __y);\n\n    template <class _T1, class _C1>\n    friend\n    _LIBCPP_INLINE_VISIBILITY\n    bool\n    operator< (const queue<_T1, _C1>& __x,const queue<_T1, _C1>& __y);\n};\n\ntemplate <class _Tp, class _Container>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const queue<_Tp, _Container>& __x,const queue<_Tp, _Container>& __y)\n{\n    return __x.c == __y.c;\n}\n\ntemplate <class _Tp, class _Container>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator< (const queue<_Tp, _Container>& __x,const queue<_Tp, _Container>& __y)\n{\n    return __x.c < __y.c;\n}\n\ntemplate <class _Tp, class _Container>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const queue<_Tp, _Container>& __x,const queue<_Tp, _Container>& __y)\n{\n    return !(__x == __y);\n}\n\ntemplate <class _Tp, class _Container>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator> (const queue<_Tp, _Container>& __x,const queue<_Tp, _Container>& __y)\n{\n    return __y < __x;\n}\n\ntemplate <class _Tp, class _Container>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const queue<_Tp, _Container>& __x,const queue<_Tp, _Container>& __y)\n{\n    return !(__x < __y);\n}\n\ntemplate <class _Tp, class _Container>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const queue<_Tp, _Container>& __x,const queue<_Tp, _Container>& __y)\n{\n    return !(__y < __x);\n}\n\ntemplate <class _Tp, class _Container>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<\n    __is_swappable<_Container>::value,\n    void\n>::type\nswap(queue<_Tp, _Container>& __x, queue<_Tp, _Container>& __y)\n    _NOEXCEPT_(_NOEXCEPT_(__x.swap(__y)))\n{\n    __x.swap(__y);\n}\n\ntemplate <class _Tp, class _Container, class _Alloc>\nstruct _LIBCPP_TEMPLATE_VIS uses_allocator<queue<_Tp, _Container>, _Alloc>\n    : public uses_allocator<_Container, _Alloc>\n{\n};\n\ntemplate <class _Tp, class _Container = vector<_Tp>,\n          class _Compare = less<typename _Container::value_type> >\nclass _LIBCPP_TEMPLATE_VIS priority_queue\n{\npublic:\n    typedef _Container                               container_type;\n    typedef _Compare                                 value_compare;\n    typedef typename container_type::value_type      value_type;\n    typedef typename container_type::reference       reference;\n    typedef typename container_type::const_reference const_reference;\n    typedef typename container_type::size_type       size_type;\n    static_assert((is_same<_Tp, value_type>::value), \"\" );\n\nprotected:\n    container_type c;\n    value_compare comp;\n\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    priority_queue()\n        _NOEXCEPT_(is_nothrow_default_constructible<container_type>::value &&\n                   is_nothrow_default_constructible<value_compare>::value)\n        : c(), comp() {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    priority_queue(const priority_queue& __q) : c(__q.c), comp(__q.comp) {}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    priority_queue(priority_queue&& __q)\n        _NOEXCEPT_(is_nothrow_move_constructible<container_type>::value &&\n                   is_nothrow_move_constructible<value_compare>::value)\n        : c(_VSTD::move(__q.c)), comp(_VSTD::move(__q.comp)) {}\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    _LIBCPP_INLINE_VISIBILITY\n    priority_queue& operator=(const priority_queue& __q)\n        {c = __q.c; comp = __q.comp; return *this;}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    priority_queue& operator=(priority_queue&& __q)\n        _NOEXCEPT_(is_nothrow_move_assignable<container_type>::value &&\n                   is_nothrow_move_assignable<value_compare>::value)\n        {c = _VSTD::move(__q.c); comp = _VSTD::move(__q.comp); return *this;}\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit priority_queue(const value_compare& __comp)\n        : c(), comp(__comp) {}\n    _LIBCPP_INLINE_VISIBILITY\n    priority_queue(const value_compare& __comp, const container_type& __c);\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    explicit priority_queue(const value_compare& __comp, container_type&& __c);\n#endif\n    template <class _InputIter>\n        _LIBCPP_INLINE_VISIBILITY\n        priority_queue(_InputIter __f, _InputIter __l,\n                       const value_compare& __comp = value_compare());\n    template <class _InputIter>\n        _LIBCPP_INLINE_VISIBILITY\n        priority_queue(_InputIter __f, _InputIter __l,\n                       const value_compare& __comp, const container_type& __c);\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    template <class _InputIter>\n        _LIBCPP_INLINE_VISIBILITY\n        priority_queue(_InputIter __f, _InputIter __l,\n                       const value_compare& __comp, container_type&& __c);\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    template <class _Alloc>\n        _LIBCPP_INLINE_VISIBILITY\n        explicit priority_queue(const _Alloc& __a,\n                       typename enable_if<uses_allocator<container_type,\n                                                         _Alloc>::value>::type* = 0);\n    template <class _Alloc>\n        _LIBCPP_INLINE_VISIBILITY\n        priority_queue(const value_compare& __comp, const _Alloc& __a,\n                       typename enable_if<uses_allocator<container_type,\n                                                         _Alloc>::value>::type* = 0);\n    template <class _Alloc>\n        _LIBCPP_INLINE_VISIBILITY\n        priority_queue(const value_compare& __comp, const container_type& __c,\n                       const _Alloc& __a,\n                       typename enable_if<uses_allocator<container_type,\n                                                         _Alloc>::value>::type* = 0);\n    template <class _Alloc>\n        _LIBCPP_INLINE_VISIBILITY\n        priority_queue(const priority_queue& __q, const _Alloc& __a,\n                       typename enable_if<uses_allocator<container_type,\n                                                         _Alloc>::value>::type* = 0);\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    template <class _Alloc>\n        _LIBCPP_INLINE_VISIBILITY\n        priority_queue(const value_compare& __comp, container_type&& __c,\n                       const _Alloc& __a,\n                       typename enable_if<uses_allocator<container_type,\n                                                         _Alloc>::value>::type* = 0);\n    template <class _Alloc>\n        _LIBCPP_INLINE_VISIBILITY\n        priority_queue(priority_queue&& __q, const _Alloc& __a,\n                       typename enable_if<uses_allocator<container_type,\n                                                         _Alloc>::value>::type* = 0);\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    _LIBCPP_INLINE_VISIBILITY\n    bool            empty() const {return c.empty();}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type       size() const  {return c.size();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reference top() const   {return c.front();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void push(const value_type& __v);\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    void push(value_type&& __v);\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n    template <class... _Args> _LIBCPP_INLINE_VISIBILITY void emplace(_Args&&... __args);\n#endif\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    void pop();\n\n    _LIBCPP_INLINE_VISIBILITY\n    void swap(priority_queue& __q)\n        _NOEXCEPT_(__is_nothrow_swappable<container_type>::value &&\n                   __is_nothrow_swappable<value_compare>::value);\n};\n\ntemplate <class _Tp, class _Container, class _Compare>\ninline\npriority_queue<_Tp, _Container, _Compare>::priority_queue(const _Compare& __comp,\n                                                          const container_type& __c)\n    : c(__c),\n      comp(__comp)\n{\n    _VSTD::make_heap(c.begin(), c.end(), comp);\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Container, class _Compare>\ninline\npriority_queue<_Tp, _Container, _Compare>::priority_queue(const value_compare& __comp,\n                                                          container_type&& __c)\n    : c(_VSTD::move(__c)),\n      comp(__comp)\n{\n    _VSTD::make_heap(c.begin(), c.end(), comp);\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Container, class _Compare>\ntemplate <class _InputIter>\ninline\npriority_queue<_Tp, _Container, _Compare>::priority_queue(_InputIter __f, _InputIter __l,\n                                                          const value_compare& __comp)\n    : c(__f, __l),\n      comp(__comp)\n{\n    _VSTD::make_heap(c.begin(), c.end(), comp);\n}\n\ntemplate <class _Tp, class _Container, class _Compare>\ntemplate <class _InputIter>\ninline\npriority_queue<_Tp, _Container, _Compare>::priority_queue(_InputIter __f, _InputIter __l,\n                                                          const value_compare& __comp,\n                                                          const container_type& __c)\n    : c(__c),\n      comp(__comp)\n{\n    c.insert(c.end(), __f, __l);\n    _VSTD::make_heap(c.begin(), c.end(), comp);\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Container, class _Compare>\ntemplate <class _InputIter>\ninline\npriority_queue<_Tp, _Container, _Compare>::priority_queue(_InputIter __f, _InputIter __l,\n                                                          const value_compare& __comp,\n                                                          container_type&& __c)\n    : c(_VSTD::move(__c)),\n      comp(__comp)\n{\n    c.insert(c.end(), __f, __l);\n    _VSTD::make_heap(c.begin(), c.end(), comp);\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Container, class _Compare>\ntemplate <class _Alloc>\ninline\npriority_queue<_Tp, _Container, _Compare>::priority_queue(const _Alloc& __a,\n                       typename enable_if<uses_allocator<container_type,\n                                                         _Alloc>::value>::type*)\n    : c(__a)\n{\n}\n\ntemplate <class _Tp, class _Container, class _Compare>\ntemplate <class _Alloc>\ninline\npriority_queue<_Tp, _Container, _Compare>::priority_queue(const value_compare& __comp,\n                                                          const _Alloc& __a,\n                       typename enable_if<uses_allocator<container_type,\n                                                         _Alloc>::value>::type*)\n    : c(__a),\n      comp(__comp)\n{\n}\n\ntemplate <class _Tp, class _Container, class _Compare>\ntemplate <class _Alloc>\ninline\npriority_queue<_Tp, _Container, _Compare>::priority_queue(const value_compare& __comp,\n                                                          const container_type& __c,\n                                                          const _Alloc& __a,\n                       typename enable_if<uses_allocator<container_type,\n                                                         _Alloc>::value>::type*)\n    : c(__c, __a),\n      comp(__comp)\n{\n    _VSTD::make_heap(c.begin(), c.end(), comp);\n}\n\ntemplate <class _Tp, class _Container, class _Compare>\ntemplate <class _Alloc>\ninline\npriority_queue<_Tp, _Container, _Compare>::priority_queue(const priority_queue& __q,\n                                                          const _Alloc& __a,\n                       typename enable_if<uses_allocator<container_type,\n                                                         _Alloc>::value>::type*)\n    : c(__q.c, __a),\n      comp(__q.comp)\n{\n    _VSTD::make_heap(c.begin(), c.end(), comp);\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Container, class _Compare>\ntemplate <class _Alloc>\ninline\npriority_queue<_Tp, _Container, _Compare>::priority_queue(const value_compare& __comp,\n                                                          container_type&& __c,\n                                                          const _Alloc& __a,\n                       typename enable_if<uses_allocator<container_type,\n                                                         _Alloc>::value>::type*)\n    : c(_VSTD::move(__c), __a),\n      comp(__comp)\n{\n    _VSTD::make_heap(c.begin(), c.end(), comp);\n}\n\ntemplate <class _Tp, class _Container, class _Compare>\ntemplate <class _Alloc>\ninline\npriority_queue<_Tp, _Container, _Compare>::priority_queue(priority_queue&& __q,\n                                                          const _Alloc& __a,\n                       typename enable_if<uses_allocator<container_type,\n                                                         _Alloc>::value>::type*)\n    : c(_VSTD::move(__q.c), __a),\n      comp(_VSTD::move(__q.comp))\n{\n    _VSTD::make_heap(c.begin(), c.end(), comp);\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Container, class _Compare>\ninline\nvoid\npriority_queue<_Tp, _Container, _Compare>::push(const value_type& __v)\n{\n    c.push_back(__v);\n    _VSTD::push_heap(c.begin(), c.end(), comp);\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Container, class _Compare>\ninline\nvoid\npriority_queue<_Tp, _Container, _Compare>::push(value_type&& __v)\n{\n    c.push_back(_VSTD::move(__v));\n    _VSTD::push_heap(c.begin(), c.end(), comp);\n}\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Tp, class _Container, class _Compare>\ntemplate <class... _Args>\ninline\nvoid\npriority_queue<_Tp, _Container, _Compare>::emplace(_Args&&... __args)\n{\n    c.emplace_back(_VSTD::forward<_Args>(__args)...);\n    _VSTD::push_heap(c.begin(), c.end(), comp);\n}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Container, class _Compare>\ninline\nvoid\npriority_queue<_Tp, _Container, _Compare>::pop()\n{\n    _VSTD::pop_heap(c.begin(), c.end(), comp);\n    c.pop_back();\n}\n\ntemplate <class _Tp, class _Container, class _Compare>\ninline\nvoid\npriority_queue<_Tp, _Container, _Compare>::swap(priority_queue& __q)\n        _NOEXCEPT_(__is_nothrow_swappable<container_type>::value &&\n                   __is_nothrow_swappable<value_compare>::value)\n{\n    using _VSTD::swap;\n    swap(c, __q.c);\n    swap(comp, __q.comp);\n}\n\ntemplate <class _Tp, class _Container, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<\n    __is_swappable<_Container>::value\n    && __is_swappable<_Compare>::value,\n    void\n>::type\nswap(priority_queue<_Tp, _Container, _Compare>& __x,\n     priority_queue<_Tp, _Container, _Compare>& __y)\n    _NOEXCEPT_(_NOEXCEPT_(__x.swap(__y)))\n{\n    __x.swap(__y);\n}\n\ntemplate <class _Tp, class _Container, class _Compare, class _Alloc>\nstruct _LIBCPP_TEMPLATE_VIS uses_allocator<priority_queue<_Tp, _Container, _Compare>, _Alloc>\n    : public uses_allocator<_Container, _Alloc>\n{\n};\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_QUEUE\n","// -*- C++ -*-\n//===-------------------------- typeinfo ----------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef __LIBCPP_TYPEINFO\n#define __LIBCPP_TYPEINFO\n\n/*\n\n    typeinfo synopsis\n\nnamespace std {\n\nclass type_info\n{\npublic:\n    virtual ~type_info();\n\n    bool operator==(const type_info& rhs) const noexcept;\n    bool operator!=(const type_info& rhs) const noexcept;\n\n    bool before(const type_info& rhs) const noexcept;\n    size_t hash_code() const noexcept;\n    const char* name() const noexcept;\n\n    type_info(const type_info& rhs) = delete;\n    type_info& operator=(const type_info& rhs) = delete;\n};\n\nclass bad_cast\n    : public exception\n{\npublic:\n    bad_cast() noexcept;\n    bad_cast(const bad_cast&) noexcept;\n    bad_cast& operator=(const bad_cast&) noexcept;\n    virtual const char* what() const noexcept;\n};\n\nclass bad_typeid\n    : public exception\n{\npublic:\n    bad_typeid() noexcept;\n    bad_typeid(const bad_typeid&) noexcept;\n    bad_typeid& operator=(const bad_typeid&) noexcept;\n    virtual const char* what() const noexcept;\n};\n\n}  // std\n\n*/\n\n#include <__config>\n#include <exception>\n#include <cstddef>\n#include <cstdint>\n#ifdef _LIBCPP_NO_EXCEPTIONS\n#include <cstdlib>\n#endif\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n#if defined(_LIBCPP_NONUNIQUE_RTTI_BIT)\n#define _LIBCPP_HAS_NONUNIQUE_TYPEINFO\n#else\n#define _LIBCPP_HAS_UNIQUE_TYPEINFO\n#endif\n\nnamespace std  // purposefully not using versioning namespace\n{\n\nclass _LIBCPP_EXCEPTION_ABI type_info\n{\n    type_info& operator=(const type_info&);\n    type_info(const type_info&);\n\n#if defined(_LIBCPP_HAS_NONUNIQUE_TYPEINFO)\n    _LIBCPP_INLINE_VISIBILITY\n    int __compare_nonunique_names(const type_info &__arg) const _NOEXCEPT\n    { return __builtin_strcmp(name(), __arg.name()); }\n#endif\n\nprotected:\n#if defined(_LIBCPP_HAS_NONUNIQUE_TYPEINFO)\n    // A const char* with the non-unique RTTI bit possibly set.\n    uintptr_t __type_name;\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit type_info(const char* __n)\n      : __type_name(reinterpret_cast<uintptr_t>(__n)) {}\n#else\n    const char *__type_name;\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit type_info(const char* __n) : __type_name(__n) {}\n#endif\n\npublic:\n    virtual ~type_info();\n\n#if defined(_LIBCPP_HAS_NONUNIQUE_TYPEINFO)\n    _LIBCPP_INLINE_VISIBILITY\n    const char* name() const _NOEXCEPT\n    {\n      return reinterpret_cast<const char*>(__type_name &\n                                           ~_LIBCPP_NONUNIQUE_RTTI_BIT);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    bool before(const type_info& __arg) const _NOEXCEPT\n    {\n      if (!((__type_name & __arg.__type_name) & _LIBCPP_NONUNIQUE_RTTI_BIT))\n        return __type_name < __arg.__type_name;\n      return __compare_nonunique_names(__arg) < 0;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_t hash_code() const _NOEXCEPT\n    {\n      if (!(__type_name & _LIBCPP_NONUNIQUE_RTTI_BIT))\n        return __type_name;\n\n      const char* __ptr = name();\n      size_t __hash = 5381;\n      while (unsigned char __c = static_cast<unsigned char>(*__ptr++))\n        __hash = (__hash * 33) ^ __c;\n      return __hash;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator==(const type_info& __arg) const _NOEXCEPT\n    {\n      if (__type_name == __arg.__type_name)\n        return true;\n\n      if (!((__type_name & __arg.__type_name) & _LIBCPP_NONUNIQUE_RTTI_BIT))\n        return false;\n      return __compare_nonunique_names(__arg) == 0;\n    }\n#else\n    _LIBCPP_INLINE_VISIBILITY\n    const char* name() const _NOEXCEPT\n    { return __type_name; }\n\n    _LIBCPP_INLINE_VISIBILITY\n    bool before(const type_info& __arg) const _NOEXCEPT\n    { return __type_name < __arg.__type_name; }\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_t hash_code() const _NOEXCEPT\n    { return reinterpret_cast<size_t>(__type_name); }\n\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator==(const type_info& __arg) const _NOEXCEPT\n    { return __type_name == __arg.__type_name; }\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator!=(const type_info& __arg) const _NOEXCEPT\n    { return !operator==(__arg); }\n};\n\nclass _LIBCPP_EXCEPTION_ABI bad_cast\n    : public exception\n{\npublic:\n    bad_cast() _NOEXCEPT;\n    virtual ~bad_cast() _NOEXCEPT;\n    virtual const char* what() const _NOEXCEPT;\n};\n\nclass _LIBCPP_EXCEPTION_ABI bad_typeid\n    : public exception\n{\npublic:\n    bad_typeid() _NOEXCEPT;\n    virtual ~bad_typeid() _NOEXCEPT;\n    virtual const char* what() const _NOEXCEPT;\n};\n\n}  // std\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n_LIBCPP_NORETURN inline _LIBCPP_ALWAYS_INLINE\nvoid __throw_bad_cast()\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    throw bad_cast();\n#else\n\t_VSTD::abort();\n#endif\n}\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // __LIBCPP_TYPEINFO\n"]}